\> 本文由 \[简悦 SimpRead\](http://ksria.com/simpread/) 转码， 原文地址 \[blog.riskivy.com\](https://blog.riskivy.com/shiro-%e6%9d%83%e9%99%90%e7%bb%95%e8%bf%87%e6%bc%8f%e6%b4%9e%e5%88%86%e6%9e%90%ef%bc%88cve-2020-1957%ef%bc%89/)

1## 前言

2020 年 3 月 23 号，Shiro 开发者 Brian Demers 在[用户社区](http://shiro-user.582556.n2.nabble.com/Re-ANNOUNCE-CVE-2020-1957-Apache-Shiro-1-5-2-released-td7582136.html)发表帖子，提醒 shiro 用户进行安全更新，本次更新进行了三个修复，其中就包括了对编号为 CVE-2020-1957 的 Shrio 授权绕过漏洞的修复。漏洞影响 shiro 1.5.2 版本以下。

![](https://blog.riskivy.com/wp-content/uploads/2020/03/2c9219a094bd692b48bbb5d373b1d544.png)

分析过程
----

### SHIRO-682

根据 Shiro 开发者在 1.5.2 版本中提交的 [commit](https://github.com/apache/shiro/commit/3708d7907016bf2fa12691dff6ff0def1249b8ce) 中关于 PathMatchingFilter 类的测试用例，可以直接关联到 JIRA issue [SHIRO-682](https://issues.apache.org/jira/browse/SHIRO-682)，该 issue 在 1.5.0 版本中进行了修复。而 1.5.2 版本中更新则是对其绕过的修复。

![](https://blog.riskivy.com/wp-content/uploads/2020/03/f768f9960ecd9065cd2dafa12fd41d9c.png)

SHIRO-682 的修复了 spring 框架下 uri = uri + ‘/’ 绕过 Shiro 防护的问题。然后下面的描述则清晰得描述了造成改错误的原因。

在 Spring web 项目中，请求 URI `/resource/menus` 和`/resource/menus/` 都可以访问到服务器的资源。

但在 Shiro 中的 URL 路径表达式 pathPattern 可以正确匹配`/resource/menus`，但不能正确匹配`/resource/menus/`，导致过滤链无法正确匹配，从而绕 Shiro 的防护机制。

![](https://blog.riskivy.com/wp-content/uploads/2020/03/0f19d3eaf7284711794dea804d54ee7e.png)

### Shiro 拦截器

Shiro 框架通过拦截器功能来实现对用户访问权限的控制和拦截。Shiro 中常见的拦截器有 anon,authc 等拦截器。

1.anon 为匿名拦截器，不需要登录就能访问，一般用于静态资源, 或者移动端接口  
2.authc 为登录拦截器，需要登录认证才能访问的资源。

用户可以在 Shiro.ini 编写匹配 URL 配置，将会拦截匹配的 URL，并执行响应的拦截器。从而实现对 URL 的访问控制，URL 路径表达式通常为 ANT 格式。如下配置，访问 /index.html 主页的时候，Shiro 将不会对其进行登录判断，anon 拦截器不需要登录就能进行访问。而对于 / user/xiaoming 等 /user/xiaogang 等接口，authc 拦截器将会对其进行登录判断，有登录认证才能访问资源。

```
\[urls\]
/index.html = anon
/user/\*\* = authc


```

Shiro 的 URL 路径表达式为 Ant 格式，路径通配符支持 `?` `*` `**` 。

```
?：匹配一个字符
\*：匹配零个或多个字符串
\*\*：匹配路径中的零个或多个路径


```

其中`*`表示匹配零个或多个字符串，`/*`可以匹配`/hello`，但匹配不到`/hello/`因为 \* 通配符无法匹配路径。假设`/hello`接口设置了 authc 拦截器，访问`/hello`将会被进行权限判断，如果请求的 URI 为`/hello/`呢，`/*`URL 路径表达式将无法正确匹配，放行。然后进入到 spring(Servlet) 拦截器，spring 中`/hello` 形式和`/hello/`形式的 URL 访问的资源是一样的。

### 漏洞复现

明白上文的内容，漏洞复现就很容易了，复现环境代码主要参考网上的开源 [demo](https://github.com/lenve/javaboy-code-samples/tree/master/shiro/shiro-basic)。

1\. 下载 demo 代码 [shiro-basic](https://github.com/lenve/javaboy-code-samples/tree/master/shiro/shiro-basic)。  
2\. 导入 idea  
3.Shiro 版本 1.4.2

```
    <dependency>
        <groupId>org.apache.shiro</groupId>
        <artifactId>shiro-web</artifactId>
        <version>1.4.2</version>
    </dependency>
    <dependency>
        <groupId>org.apache.shiro</groupId>
        <artifactId>shiro-spring</artifactId>
        <version>1.4.2</version>
    </dependency>


```

4\. 修改 ShiroConfig 配置文件，添加 authc 拦截器的拦截正则

```
    @Bean
    ShiroFilterFactoryBean shiroFilterFactoryBean() {
        ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean();
        ...
        ...
        //map.put("/\*", "authc");
        map.put("/hello/\*", "authc"); 
        bean.setFilterChainDefinitionMap(map);
        return bean;
    }


```

5\. 修改路由控制器方法

```
@GetMapping("/hello/{currentPage}")
    public String hello(@PathVariable Integer currentPage) {
        return "hello";
}


```

6\. 启动应用

访问`/hello/1`接口，可以看到被 authc 拦截器拦截了，将会跳转到登录接口进行登录。

![](https://blog.riskivy.com/wp-content/uploads/2020/03/a75ce73673c513d96504f15a3ea2eeaa.png)

访问 / hello/1/，成功绕过 authc 拦截器，获取到了资源。

![](https://blog.riskivy.com/wp-content/uploads/2020/03/0a694248aebe4cac7453ce8090dab469.png)

### 漏洞成因

漏洞初始成因可以定位到 PathMatchingFilterChainResolver 的 getChain 函数下，该函数作用根据 URL 路径匹配中配置的 url 路径表达式来匹配输入的 URL，判断是否匹配拦截器，匹配成功将会返回响应的拦截器执行链，让 ShiroFither 执行权限操作的。

其对于 URL 路径表达式和输入 URL 的匹配主要通过 pathMathches 函数进行匹配。

![](https://blog.riskivy.com/wp-content/uploads/2020/03/4f29c6bf1f947d6d96b2a0e1d54c4751.png)

pathMatches 函数其最终会调用 shiro.util.AntPathMatcher 类中 doMatch 的对于 ant 格式的 pathPattern 和 requestURI 进行匹配。

```
//pathMatches:135, PathMatchingFilterChainResolver (org.apache.shiro.web.filter.mgt)
protected boolean pathMatches(String pattern, String path) {
        PatternMatcher pathMatcher = this.getPathMatcher();
        return pathMatcher.matches(pattern, path);
}


```

doMatch:109, AntPathMatcher (org.apache.shiro.util)，当 Shiro 的 Ant 格式的 pathPattern 中的的`*`通配符是不支持匹配路径的，所以`/hello/*` 不能成功匹配`/hello/1/` ，也就不会触发 authc 拦截器进行权限拦截。从而成功绕过了 Shiro 拦截器，而后再进入到 spring 拦截器中，/hello/1 / 与`/hello/1`能获取到相同的资源。

![](https://blog.riskivy.com/wp-content/uploads/2020/03/8cc2b378dcfc4e0f473dd0ae782b624d.png)

### 漏洞修复

该漏洞是由中国开发者在 2019 年 3 月 25 日在 ShiroGitHub 项目上提交的 [issue](https://github.com/apache/shiro/pull/127)，并 PR 了分支代码 [589f10](https://github.com/apache/shiro/commit/589f10d40414a815dbcaf1f1500a51f41258ef70) 添加漏洞修复代码，最终分支代码在 1.5.0 版本进行了合并，合并时间为 2019 年 11 月 20 日。

### 1.5.0 版本修复

1.5.0 版本修复源自 tomsun28 提交的 PR 代码，代码修复位置为 pathsMatch:125, PathMatchingFilter (org.apache.shiro.web.filter)，该修复方式是通过判断 requestURI 是否以`/`为结尾，如果以 / 结尾的话，则去掉尾部的`/`符号在与 URL 表达式进行比较。

也就是当 requestURI 为`/hello/1/`等以`/`为结尾的 URI 的时候，都会被清除最后的`/`号，再进行 URL 路径匹配。

![](https://blog.riskivy.com/wp-content/uploads/2020/03/84076cd34aeb2fb2b73492b3c82fc1f9.png)

### ≤1.5.1 版本绕过

观察 1.5.2 版本中新添加的[测试用例](https://github.com/apache/shiro/commit/3708d7907016bf2fa12691dff6ff0def1249b8ce)。

![](https://blog.riskivy.com/wp-content/uploads/2020/03/9f13c2d02422d4ee8eb4d0c4bd4d2616.png)

切换测试版本到 1.5.1 中，然后从中上面的测试用例提取 payload 进行绕过。

在 1.5.1 版本中，添加`/`还是会直接跳转到登录。

![](https://blog.riskivy.com/wp-content/uploads/2020/03/af64c500e37ecee5dd848c5ab5f56f00.png)

绕过 payload，`/fdsf;/../hello/1`，成功绕过。

![](https://blog.riskivy.com/wp-content/uploads/2020/03/b201d8bfe3260a3bb99444b0c784f975.png)

问题同样可以定位到 getChain 函数中对于 requestURI 的获取中，如下图所示，`this.getPathWithinApplication(request)`获取的 requestURI 为`/fdsf` ，而不是我们输入的`/fdsf;/../hello/1`，从而导致后面的 URI 路径模式匹配返回 False，从而再次绕过了 shiro 拦截器。

![](https://blog.riskivy.com/wp-content/uploads/2020/03/139365f33bf4ec5ad02f01f353fa20fa.png)

getPathWithinApplication 函数中会调用 WebUtils (org.apache.shiro.web.util) 中的 getRequestUri 函数获取 RequestUri。

```
public static String getRequestUri(HttpServletRequest request) {
        String uri = (String)request.getAttribute("javax.servlet.include.request\_uri");
        if (uri == null) {
            uri = request.getRequestURI();
        }

        return normalize(decodeAndCleanUriString(request, uri));
    }


```

RequestUri 函数中最终调用 decodeAndCleanUriString 函数对 URI 进行清洗。

```
private static String decodeAndCleanUriString(HttpServletRequest request, String uri) {
      uri = decodeRequestString(request, uri);
      int semicolonIndex = uri.indexOf(59);//获取;号的位置
      return semicolonIndex != -1 ? uri.substring(0, semicolonIndex) : uri;
  }


```

如果 URI 中存在`;`号的话，则会删除其后面的所有字符。`/fdsf;/../hello/1/`最终也就变成了`/fdsf`。

![](https://blog.riskivy.com/wp-content/uploads/2020/03/369381529cd8a99abe940e13ad47c044.png)

### 1.5.2 版本修复

再 1.5.2 版本中对其进行了[修复](https://github.com/apache/shiro/commit/3708d7907016bf2fa12691dff6ff0def1249b8ce#diff-98f7bc5c0391389e56531f8b3754081aR139)，获取 requestURI 的方式从`request.getRequestUri`直接获取的方式更改为获取 request 的 ContextPath，ServletPath，PathInfo，然后再重新拼接而成。

![](https://blog.riskivy.com/wp-content/uploads/2020/03/720bb5b61bde9275c4f2e196986e345c.png)

输入的`/fdsf;/../hello/1/`，将会被拼接为`//hello/1/1`再进行 URI 路径匹配，则无法绕过拦截器。

![](https://blog.riskivy.com/wp-content/uploads/2020/03/53308f65089df7cedf248a57c2dd39a8.png)

总结
--

在 web 容器中，Shiro 的拦截器是先与 spring(Servlet) 执行，两者拦截器对于 URI 模式匹配的差异，导致 Shiro 拦截器的绕过，而 Shiro 对其进行了两次修复，其一为删除 requestURI 后面的`/`号进行 URL 路径匹配，算是简单的修复了添加`/`号绕过的方式，而后在 1.5.2 版本中通过 requestURI 自主拼接的方式修复了`/fdsf;/../hello/1/`等使用了; 号方式的绕过。

而后又会有什么形式的绕过，或者又有什么其它容器导致的差异化绕过。则未可知。

修复方案
----

1\. 升级 1.5.2 版本及以上  
2\. 尽量避免使用`*`通配符作为动态路由拦截器的 URL 路径表达式。

参考链接
----

1.[https://github.com/apache/shiro/pull/127](https://github.com/apache/shiro/pull/127)  
2.[https://blog.51cto.com/luchunli/1835108](https://blog.51cto.com/luchunli/1835108)  
3.[https://issues.apache.org/jira/browse/SHIRO-682](https://issues.apache.org/jira/browse/SHIRO-682)  
4.[https://www.syshlang.com/96db3174/](https://www.syshlang.com/96db3174/)  
5.[http://shiro-user.582556.n2.nabble.com/Re-ANNOUNCE-CVE-2020-1957-Apache-Shiro-1-5-2-released-td7582136.html](http://shiro-user.582556.n2.nabble.com/Re-ANNOUNCE-CVE-2020-1957-Apache-Shiro-1-5-2-released-td7582136.html)

作者：斗象能力中心 TCC – tbag