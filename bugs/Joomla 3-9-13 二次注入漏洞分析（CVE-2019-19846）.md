> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/7Cg4D96ZpxgA_hV2ysZJzw)

**0x01 分析**

Joomla 3.9.13 CVE-2019-19846 是一个需要管理员权限的二次 SQL 注入漏洞，这里详细分享一下挖洞时的思路，漏洞触发点在 components/com_content/models/articles.php:L458  

```
$dateFiltering = $this->getState('filter.date_filtering', 'off');
$dateField     = $this->getState('filter.date_field', 'a.created');

switch ($dateFiltering)
{
    case 'range':
        ...
        $query->where(
            '(' . $dateField . ' >= ' . $startDateRange . ' AND ' . $dateField .
            ' <= ' . $endDateRange . ')'
        );
        break;
    ...
 }
```

可以看到这里的 dateField 从 getState('filter.date_field') 取值之后未经任何过滤就直接拼接到 where 语句中。通过在这个 model 的逆向查找，并没有找到 date_field 这个 state 初始化的地方。我们只能先通过构造入口，来看看使用这个 model 的控制器是否对 date_field 进行了初始化。

这个 model 属于前台的 com_content 组件，但是这个 model 的入口与同组件下的其他几个 model 不太一样。其他的 model 基本上都可以通过访问这个组件来访问，而 articles model 在本组件中却没有使用。

程序中有两个名为 articles 的 model，一个在 / components，一个在 / administrator/components 目录下。我在黑盒测试的时候构造了一个 url 如下：  

```
/index.php?option=com_content&view=articles&layout=modal&tmpl=component
```

这里程序中的控制器会根据 view 和 layout 的值，将请求直接跳到了 administrator 目录下的 articles 中了。但是根据`存在即合理，天生我材必有用`，/components 下面有个前台 articles 的 model，因此程序中一定会有调用这里的地方。最终找到了几处调用前台 article 的地方，只是有的跟正常调用的不太一样，这里是动态调用。写法大概有如下几种

```
$model = JModelLegacy::getInstance('Articles', 'ContentModel', array('ignore_request' => true));

也有动态调用model：
/libraries/src/MVC/Controller/BaseController.php:createModel($model, ...){
  ...
  JModelLegacy::getInstance($modelName, $classPrefix, $config);
  ...
}
```

通过访问

```
index.php/blog?252c5a5ef0e3df8493dbe18e7034957e=1
```

可以到达漏洞点，但是 state 我们控制不了，因为首先在 articles model 中没有对 date_field 做赋值处理，只能寄希望于调用这个 model 的地方能对 date_field 赋值。可是通过查看代码发现，当前的 index.php/blog 路由背后的 com_content 组件并没有对 date_field 进行初始化，因此这个组件只能放弃，看看其他的。

终于，在一个 module：mod_articles_popular 的 helper 类中找到了有设置 date_field 的地方，大概如下 / modules/mod_articles_popular/helper.php

```
function getList(&$params){
  $model = JModelLegacy::getInstance('Articles', 'ContentModel', array('ignore_request' => true)); //调用articles model
  ...
  $date_filtering = $params->get('date_filtering', 'off');
  if ($date_filtering !== 'off'){
    $model->setState('filter.date_filtering', $date_filtering);
    $model->setState('filter.date_field', $params->get('date_field', 'a.created'));
    ...
  }
  ...
}
```

可以看到这里通过 $params->get('date_field') 来进行赋值，这里的 param 是从 modules 表中取出的。通过逆向查找发现，/libraries/src/Helper/ModuleHelper.php:getModuleList() 方法会从 modules 表取出 module 的属性（包括 param），然后在 / libraries/src/Document/Renderer/Html/ModulesRenderer.php:render():L45 对 module 进行遍历并渲染：

```
foreach (ModuleHelper::getModules($position) as $mod){
    $moduleHtml = $renderer->render($mod, $params, $content);
    ...
}
```

到这里我们理一下思路，首先是那个 SQL 注入点，date_field，需要从 param 中获取值，而 param 又是从 module 在数据库中对应的 param 获取的。因此我们这里可以考虑一下二次注入。由于在获取 date_field 的值时使用了`$this->getState('filter.date_field','a.created');`，且默认值为 a.created，因此猜测这个字段在某个部分是可以修改的。

通过对漏洞点和此 module 附近的功能与逻辑进行部分了解之后，可以发现在首页的 module 编辑中，可以直接编辑 date_field 字段！因此我们只要点击保存后抓包修改一下 date_field 的内容即可将之写进 modules 表中！

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnSFN4X8x6fVwvAaBqFGyB6jC8wtdpJQz5PvSicSicibIgnxqMr0kOWlO11rTM9JGvvCJXhiawVp93JYkw/640?wx_fmt=png)

这里回到最开始的漏洞点

```
$dateFiltering = $this->getState('filter.date_filtering', 'off');
$dateField     = $this->getState('filter.date_field', 'a.created');

switch ($dateFiltering)
{
    case 'range':
        $startDateRange = $db->quote($this->getState('filter.start_date_range', $nullDate));
        $endDateRange   = $db->quote($this->getState('filter.end_date_range', $nullDate));
        $query->where(
            '(' . $dateField . ' >= ' . $startDateRange . ' AND ' . $dateField .
            ' <= ' . $endDateRange . ')'
        );//vuln 
        break;
    ....
```

可以看到这里还有个 dateFiltering 的限制。其实我们只要在刚刚的 module 设置中把 date_filtering 设置为 range 即可。

### **0x02 更好的注入**

可是目前为止这个漏洞还只是盲注而已。。回显它不香吗？并且之前拼接的 SQL 语句执行之后会报错

```
Unknown column 'a.hits' in 'order clause'
```

由于最后有个 order by 一个不可控的 column 名，并且我们不知道 a.hits 列名的表叫什么（每个 Joomla 系统的表前缀都默认是随机的），因此我们不能很好的 union 出数据。这里最简单的办法就是看看是否能控制 order by 的值，比如将之置为 1。查看代码发现这个 order by 的确是可以控制的，就在之前的漏洞点下面几行  

```
$query->order($this->getState('list.ordering', 'a.ordering') . ' ' . $this->getState('list.direction', 'ASC'));
```

```
$ordering = $params->get('article_ordering', 'a.ordering');

switch ($ordering){
    ...
    default:
        $articles->setState('list.ordering', $ordering);
        ...
}

$date_filtering = $params->get('date_filtering', 'off');
if ($date_filtering !== 'off'){
    $articles->setState('filter.date_filtering', $date_filtering);
    $articles->setState('filter.date_field', $params->get('date_field', 'a.created'));

    ...
```

这里依旧是通过 getState() 来进行取值。通过回看模块 mod_articles_popular 的赋值点，发现这里写死成 a.hits 了

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnSFN4X8x6fVwvAaBqFGyB6j8wK9pG3YVhSLsZny0Uundjm3RnVvhyCx9EP1uSMbW0Slm9ymcZR0NA/640?wx_fmt=png)

因此这个 module 就不太好用了，我们要考虑另一个 list.ordering 可控的 module，结果就发现了模块 mod_articles_category，满足我们的所有幻想：date_field 可控、date_filtering 可控、list.ordering 可控

```
/libraries/src/MVC/Controller/FormController.php

public function save(...) {
    ....
    $data  = $this->input->post->get('jform', array(), 'array');//获取用户传参
    ....
    $form = $model->getForm($data, false);
    ....
    $validData = $model->validate($form, $data);//校验
    ...
    if (!$model->save($validData)) {//保存
        ..error...
    }
    
    ...
    return true;
}
```

同理，登陆后在首页编辑模块，然后将相应的值改掉就好了。经过测试发现这里的 list.ordering 没有进行任何的过滤，因此可以算是一个单独的 order by 注入。不过这里我们的目标是只要将 order by 的列置为 1 即可，以便在 date_field 的位置进行 union 注入。

### **0x03 利用**

这里仅放出效果图，具体的 poc 就不公开了

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnSFN4X8x6fVwvAaBqFGyB6je9MQhh9QQqBvCXmo7cXuzLfGibS7H2O0KtPkV3JM4C0QOnWvL5SoHoQ/640?wx_fmt=png)  

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnSFN4X8x6fVwvAaBqFGyB6jlpfLiaMKibjIVKbicCm84k9yVgLzwyqVMUgJdsN9WKNvncbD827HWQJ2A/640?wx_fmt=png)

### **0x04 总结**

这个洞还是比较鸡肋的，1 是需要最高的 super user 权限，2 是由于有 token 校验无法进行 csrf，因此把这个漏洞限制成只能有 sa 账号才能进行利用。

### **0x05 补丁分析**

在打了补丁的 3.9.14 中，通过 diff 发现官方做的修复很简单，只是在 module 中存储时对字段进行了校验

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnSFN4X8x6fVwvAaBqFGyB6jANzvL71qtM0r3TnIAIf4NN4vzRicVl5vEqu0xwSbuGhTzgaEbSj893Q/640?wx_fmt=png)

也就是只加了个`validate="options"`。下面我们要跟进一下这个字段有何意义，在这之前我们要先搞懂这个 xml 文件是啥。

下图是利用链的第一部分：module 的目录结构

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnSFN4X8x6fVwvAaBqFGyB6j76zjuC8gFHJ91z8MTlnoicicQgVNTkicgkmib8lPMjDULUUzO7CKnjuSiaA/640?wx_fmt=png)

helper.php 是我们利用的文件，而这个 xml 配置文件主要是包含了当前 module 的一些基本信息，以及一些`参数`的信息，包括参数的描述、type、默认值、值范围等等，这是我们需要重点关注的。以我们的 poc 中的 date_filter 作为例子：

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnSFN4X8x6fVwvAaBqFGyB6jibuokR4M9WUHVEVQMtXf6L0AVK14qia4tG9udtDNGh0mP9Ofht9Fib7Kg/640?wx_fmt=png)

可以看到它的默认值是`a.title`，同时下面还有很多 option 标签，也就是说这个字段的值只能是 option 标签的值的其中一个。

但是说是这么说，Joomla 在这次补丁之前并没有进行校验，也就是前面说的`validate="options"`。

下面跟进源码走一下，下面的代码是保存 param 之前的逻辑  

```
/libraries/src/MVC/Model/FormModel.php

public function validate(...) {
    ...
    $data = $form->filter($data);
    $return = $form->validate($data, $group);

    ...
    return $data;
}
```

跟进这里的 validate，底层代码如下

```
/libraries/src/Form/Form.php

public function validate($data, $group = null)
{
  ...

  // Create an input registry object from the data to validate.
  $input = new Registry($data);

  // Get the fields for which to validate the data.
  $fields = $this->findFieldsByGroup($group);

  ...

  // Validate the fields.
  foreach ($fields as $field)//
  {
    $value = null;
    $name = (string) $field['name'];

    // Get the group names as strings for ancestor fields elements.
    $attrs = $field->xpath('ancestor::fields[@name]/@name');
    $groups = array_map('strval', $attrs ? $attrs : array());
    $group = implode('.', $groups);

    // Get the value from the input data.
    if ($group)
    {
      $value = $input->get($group . '.' . $name);
    }
    else
    {
      $value = $input->get($name);
    }

    // Validate the field.
    $valid = $this->validateField($field, $group, $value, $input);//

    // Check for an error.
    if ($valid instanceof \Exception)
    {
      $this->errors[] = $valid;
      $return         = false;
    }
  }
  return $return;
}
```

继续跟进 validate

```
protected function validateField(\SimpleXMLElement $element, $group = null, $value = null, Registry $input = null)
{
  ...

  // Get the field validation rule.
  if ($type = (string) $element['validate'])//根据xml中的每个field节点的"validate"属性做校验
  {
    // Load the JFormRule object for the field.
    $rule = $this->loadRuleType($type);//如果$type是options，则$rule为类"Joomla\\CMS\\Form\\Rule\\OptionsRule"的实例化

    ...

    // Run the field validation rule test.
    $valid = $rule->test($element, $value, $group, $input, $this);//

    // Check for an error in the validation test.
    if ($valid instanceof \Exception)
    {
      return $valid;
    }
  }
```

跟进 validateField

```
public function test(\SimpleXMLElement $element, $value, $group = null, Registry $input = null, Form $form = null)
{
  // Check if the field is required.
  $required = ((string) $element['required'] == 'true' || (string) $element['required'] == 'required');

  if (!$required && empty($value))
  {
    return true;
  }

  // Make an array of all available option values.
  $options = array();

  // Create the field
  $field = null;

  if ($form)
  {
    $field = $form->getField((string) $element->attributes()->name, $group);
  }

  // When the field exists, the real options are fetched.
  // This is needed for fields which do have dynamic options like from a database.
  if ($field && is_array($field->options))
  {
    foreach ($field->options as $opt)//取出所有option节点
    {
      $options[] = $opt->value;//取出field节点对应的option子节点，用于后面进行in_array()校验合法性
    }
  }
  else
  {
    foreach ($element->option as $opt)//取出所有option节点
    {
      $options[] = $opt->attributes()->value;//取出field节点对应的option子节点，用于后面进行in_array()校验合法性
    }
  }

  // There may be multiple values in the form of an array (if the element is checkboxes, for example).
  if (is_array($value))
  {
    // If all values are in the $options array, $diff will be empty and the options valid.
    $diff = array_diff($value, $options);//校验

    return empty($diff);
  }
  else
  {
    // In this case value must be a string
    return in_array((string) $value, $options);//校验
  }
}
```

这里获取`validate`属性的值之后，调用对应类的 test 方法。这里我们以本次的补丁为例`validate=options`，跟进 OptionsRule 的 test 方法

```
public function test(\SimpleXMLElement $element, $value, $group = null, Registry $input = null, Form $form = null)
{
  // Check if the field is required.
  $required = ((string) $element['required'] == 'true' || (string) $element['required'] == 'required');
  if (!$required && empty($value))
  {
    return true;
  }
  // Make an array of all available option values.
  $options = array();
  // Create the field
  $field = null;
  if ($form)
  {
    $field = $form->getField((string) $element->attributes()->name, $group);
  }
  // When the field exists, the real options are fetched.
  // This is needed for fields which do have dynamic options like from a database.
  if ($field && is_array($field->options))
  {
    foreach ($field->options as $opt)//取出所有option节点
    {
      $options[] = $opt->value;//取出field节点对应的option子节点，用于后面进行in_array()校验合法性
    }
  }
  else
  {
    foreach ($element->option as $opt)//取出所有option节点
    {
      $options[] = $opt->attributes()->value;//取出field节点对应的option子节点，用于后面进行in_array()校验合法性
    }
  }
  // There may be multiple values in the form of an array (if the element is checkboxes, for example).
  if (is_array($value))
  {
    // If all values are in the $options array, $diff will be empty and the options valid.
    $diff = array_diff($value, $options);//校验
    return empty($diff);
  }
  else
  {
    // In this case value must be a string
    return in_array((string) $value, $options);//校验
  }
}
```

原理比较简单，就是通过`in_array()和array_diff()`将用户输入值与 option 节点的值进行对比。