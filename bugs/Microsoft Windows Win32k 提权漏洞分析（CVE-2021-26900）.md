> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/EaTobgcCt1nAN_h-V5QBVw)

> Avscx@卫兵实验室
> -----------

分析日期
----

2021/05/25

漏洞复现证明截图
--------

![](https://mmbiz.qpic.cn/mmbiz_png/AvAjnOiazvnfhwzeiaH8mRHicdoRcib48gmIl5lwAqEHEx2dic5Mudp9gAcFsAm0kLrApnwM0icLwNytQf5ticGuslbuA/640?wx_fmt=png)

影响范围
----

```
Windows Server, version 20H2 (Server Core Installation)
Windows 10 Version 20H2 for ARM64-based Systems
Windows 10 Version 20H2 for 32-bit Systems
Windows 10 Version 20H2 for x64-based Systems
Windows Server, version 2004 (Server Core installation)
Windows 10 Version 2004 for x64-based Systems
Windows 10 Version 2004 for ARM64-based Systems
Windows 10 Version 2004 for 32-bit Systems
Windows Server, version 1909 (Server Core installation)
Windows 10 Version 1909 for ARM64-based Systems
Windows 10 Version 1909 for x64-based Systems
Windows 10 Version 1909 for 32-bit Systems

```

漏洞分析
----

###    背 景 资 料   

DirectComposition 组件是 Windows 内核模式图形组件，自 Windows 8 起引入，用于启用具有变换、效果和动画的位图合成，并支持不同来源的位图（GDI、DirectX 等），具有许多 syscall 和子功能。一个主要的系统调用是 NtDCompositionProcessChannelBatchBuffer 。该系统调用可以执行许多操作，包括创建资源，释放资源，设置资源属性等。要使用该系统调用，需要通过 NtDCompositionCreateChannel 系统调用创建一个通道。

###    基 础 知 识   

1.DirectComposition 自 Windows 8 后开始引入，基于 dwm(desktop windows manager) 工作。

2. 自 Win10 RS1 之后，其内核实现被改变，大量函数被重写，移除了大量的环三接口，并增加了一个 NtDCompositionProcessChannelBatchBuffer 函数，RS1 之前被移除大量环三接口通过这个函数进行分发。

3. 可以使用 NtDCompositionCreateChannel 创建一个类似于 Device Object 的句柄，并通过它创建 resource object(resource object 在用户层被称为视觉树中的基本对象，其包含了大量的类型)，其第三个参数返回一个 batch buffer 环三的映射地址。

4. 一个 batch buffer 与一个 channel 关联, 并由 NtDCompositionProcessChannelBatchBuffer 对其中的数据进行解析, NtDCompositionProcessChannelBatchBuffer 支持命令如下。

```
enum DCOMPOSITION_COMMAND_ID 
{ 
  ProcessCommandBufferIterator, 
  CreateResource, 
  OpenSharedResource, 
  ReleaseResource, 
  GetAnimationTime, 
  CapturePointer, 
  OpenSharedResourceHandle, 
  SetResourceCallbackId, 
  SetResourceIntegerProperty, 
  SetResourceFloatProperty, 
  SetResourceHandleProperty, 
  SetResourceHandleArrayProperty, 
  SetResourceBufferProperty, 
  SetResourceReferenceProperty, 
  SetResourceReferenceArrayProperty, 
  SetResourceAnimationProperty, 
  SetResourceDeletedNotificationTag, 
  AddVisualChild, 
  RedirectMouseToHwnd, 
  SetVisualInputSink, 
  RemoveVisualChild 
};

```

5. 对于任一 DirectComposition 漏洞，可由以下三个系统调用进行触发

```
NtDCompositionCreateChannel
NtDCompositionProcessChannelBatchBuffer
NtDCompositionCommitChannel

```

其中，NtDCompositionProcessChannelBatchBuffer 会将 batch buffer 中写入的多个 DirectComposition 命令发送给内核进行处理，与此同时，这些命令还会被序列化为另一种格式，由 NtDCompositionCommitChannel 通过 Local Procedure Call (LPC) 协议传递到 Desktop Window Manager (dwm.exe) 进程以渲染到屏幕。

Root Cause Analyze
------------------

参考 Zero Day Intiative 文章可知，此次漏洞为 CVE-2020-1381 的补丁绕过，漏洞点位于 DirectComposition::CInteractionTrackerBindingManagerMarshaler::SetBuf-ferProperty 函数，由 SetResourceBufferProperty 命令进行调用。

因此，该漏洞的触发需要用到以下三个命令。 

```
CreateResource
SetResourceBufferProperty
ReleaseResource

```

对应传递的结构体如下 

```
struct CREATE_RESOURCE
{
    DComProcessCommandId Command;
    ULONG hResource; //Resource ID (a unique number)
    ULONG ResourceType;
    ULONG bShare;
};

struct SET_BUFFER_PROPERTY
{
    DComProcessCommandId Command;
    ULONG hResource; 
    ULONG flag;
    ULONG BufferSize;
};

struct RELEASE_RESOURCE
{
    DComProcessCommandId Command;
    ULONG hResource; 
};

```

通过指定不同的 ResourceType 可以创建不同类型的资源，在 Win10_1909_x64 下 CInteractionTrackerMarshaler/CInteractionTrackerBindingManagerMarshaler 对应的 ResourceType 为 

```
if ( !v234 )   // v234 = ResourceType-0x4E-0xA
{
    v236 = (DirectComposition::CInteractionTrackerMarshaler *)((__int64 (__fastcall *)(size_t))Win32AllocPoolWithQuotaZInit)(0x1A0ui64);
    ······
    v14 = DirectComposition::CInteractionTrackerMarshaler::CInteractionTrackerMarshaler(v236);
    goto LABEL_26;
}
if ( v234 == 1 )
{
    v235 = (DirectComposition::CInteractionTrackerBindingManagerMarshaler *)((__int64 (__fastcall *)(size_t))Win32AllocPoolWithQuotaZInit)(0x60ui64);
    ······
    v14 = DirectComposition::CInteractionTrackerBindingManagerMarshaler::CInteractionTrackerBindingManagerMarshaler(v235);
    goto LABEL_26;
          }

//0x58 == CInteractionTrackerMarshaler 
//0x59 == CInteractionTrackerBindingManagerMarshaler

```

可抽象出相应的结构体如下 

```
struct CInteractionTrackerBindingManagerMarshaler 
{ 
  CInteractionTrackerMarshaler* Tracker1; 
  CInteractionTrackerMarshaler* Tracker2; 
  DWORD entry_id; 
  DWORD flag1; 
  BYTE  flag2; 
}; 

struct CInteractionTrackerMarshaler
{
  ······
  DWORD binding_obj;
};

```

因此，当我们使用 CreateResource 命令创建 TrackerBindingA 及 Tracker1 并通过 SetResourceBufferProperty 设置资源缓冲区属性后，TrackerBindingA 及 Tracker1 关系如图 

![](https://mmbiz.qpic.cn/mmbiz_png/AvAjnOiazvnfhwzeiaH8mRHicdoRcib48gmI9OzbWr6qc9q4ibbC78Wq4ibqlNa0rRTOaicQxdQbU960bAulkvqQjbTTA/640?wx_fmt=png)

其中，CInteractionTrackerBindingManagerMarshaler 对象会使用我们传递的 12 字节数据作为 SetResourceBufferProperty 命令的参数。传递参数为

```
resource1_id    //szBuff[0] = Tracker1;
resource2_id    //szBuff[1] = Tracker1;
new_entry_id    //szBuff[2] = 0x41414141;

```

存放于 SET_BUFFER_PROPERTY 结构体 + 0x10 位置

需要注意的是，当我们对 CInteractionTrackerMarshaler 对象进行释放时，若其存在和 CInteractionTrackerBindingManagerMarshaler 对象的绑定，则会调用 DirectComposition::CInteractionTrackerBindingManagerMarshaler::RemoveTrac-kerBindings 进行解绑，在该函数中，被释放对象所在的 entry_id 将被置为零，并最终通过 DirectComposition::CInteractionTrackerBindingManagerMarshaler::CleanUpListI-temsPendingDeletion 进行解除。

而该漏洞的成因恰恰是因为在对 CInteractionTrackerMarshaler 对象及 CInteractionTrackerBindingManagerMarshaler 对象进行绑定的时候没有判断其是否已存在绑定关系。

因此我们可以创建单个 CInteractionTrackerMarshaler 对象绑定到多个 CInteractionTrackerBindingManagerMarshaler 对象上，再对其进行释放，从而制造一个悬挂指针。

1.  Bind Tracker to the TrackerBindingB 
    

![](https://mmbiz.qpic.cn/mmbiz_png/AvAjnOiazvnfhwzeiaH8mRHicdoRcib48gmIhAKQZewboXGfFsRCuk4QdG5jjtCibGdUicho0MnTzqZCg6vupWRkWHbA/640?wx_fmt=png)

      2. Release Tracker Resource Object 

![](https://mmbiz.qpic.cn/mmbiz_png/AvAjnOiazvnfhwzeiaH8mRHicdoRcib48gmIia8ke2uD4YzsUx5djJshQbZYmzFIZOWgNIhN05zoj8nwud2QLDKUVog/640?wx_fmt=png)

最后通过 NtDCompositionCommitChannel 系统调用进行触发，在 DirectComposition::CInteractionTrackerBindingManagerMarshaler::EmitBoundT-rackerMarshalerUpdateCommands 被解引用，从而导致 UAF。  

对 CVE-2020-1381 的补丁进行分析  

![](https://mmbiz.qpic.cn/mmbiz_png/AvAjnOiazvnfhwzeiaH8mRHicdoRcib48gmIcb7boXmsEKwAcm1c1jG0NkQo1SNcAE8Z1QYfHkazUbicoRicZczpXiaiaA/640?wx_fmt=png)

可以看到主要增加了对 binding_obj 指针的判断，判断其是否已绑定某一 CInteractionTrackerBindingManagerMarshaler 对象，从而对该漏洞进行修补。

然而，该函数的代码逻辑依旧存在问题

```
NTSTATUS
 DirectComposition::CInteractionTrackerBindingManagerMarshaler::SetBufferProperty(DirectComposition::CInteractionTrackerBindingManagerMarshaler *binding, DirectComposition::CApplicationChannel *resinfo, unsigned int subcmd, void* databuffer, size_t datasize, bool *out) 
{ 
  // ... 
  // 1. Find tracker pair in tracker list 
  for (int i = 0; i < binding->tracker_list.numofentry; i++) 
  { 
    entry_size = binding->tracker_list.entrysize; // 0x20 by default 
    entry_ptr = (struct TrackerEntry *)(binding->tracker_list.ptr + entry_size * i); 
    entry_tracker1 = entry_ptr->Tracker1; 
    entry_tracker2 = entry_ptr->Tracker2; 
 
    tracker1_id = tracker1->resource_id; 
    tracker2_id = tracker2->resource_id; 
 
    if ( (entry_tracker1->resource_id == tracker1_id && entry_tracker2->resource_id == tracker2_id) || 
         (entry_tracker1->resource_id == tracker2_id && entry_tracker2->resource_id == tracker1_id) ) 
    { 
      // 1-1 If it exists, update entry_id 
      if ( entry_ptr->entry_id == new_entry_id ) 
        return 0; 
      // [1] Update entry_id 
      entry_ptr->entry_id = new_entry_id; 
      entry_ptr->flag2 = 1; 
 
      if ( !new_entry_id ) 
      { 
        // [2] if the new_entry_id is zero, remove relationship between CInteractionTrackerMarshaler and  
        // CInteractionTrackerBindingManagerMarshaler "if NECESSARY" 
        DirectComposition::CInteractionTrackerBindingManagerMarshaler::RemoveBindingManagerReferenceFromTrackerIfNecessary(binding, resinfo, tracker1_id, tracker2_id); 
      } 
      else 
      { 
        // Some routine 
      } 
      // ... 
      return 0; 
    } 
  } 
  // 1-2. Add New Entry 
  // ... 
}

```

从 Zero Day Intiative 文章中重命名的伪代码中我们可知，当我们将 entry_id 更新为零时，将会调用 DirectComposition::CInteractionTrackerBindingManagerMarshale-r::RemoveBindingManagerReferenceFromTrackerIfNecessary 解除和 CInteractionTrackerBindingManagerMarshaler 对象的绑定，但不会删除该 CInteractionTrackerMarshaler 对象。

```
void
DirectComposition::CInteractionTrackerBindingManagerMarshaler::RemoveBindingManagerReferenceFromTrackerIfNecessary(DirectComposition::CInteractionTrackerBindingManagerMarshaler *binding, DirectComposition::CApplicationChannel *resinfo, int resource1_id, int resource2_id) 
{ 
 
  if (resource1_id && resource1_id < resinfo->resourceid_max) 
    tracker1 = *( (resource1_id - 1) * resinfo->entry_size + resinfo->resource_list ); 
  else 
    tracker1 = NULL; 
 
  if(resource2_id && resource2_id < resinfo->resourceid_max) 
    tracker2 = *( (resource2_id - 1) * resinfo->entry_size + resinfo->resource_list ); 
  else 
    tracker2 = NULL; 
 
  tracker1_exist = false; 
  tracker2_exist = false; 
 
  // Check type of Resources 
  if ( tracker1 && tracker2 && tracker1->IsOfType(0x58) && tracker2->IsOfType(0x58) ) 
  { 
    for(int i = 0; i < binding->tracker_list.numofentry; i++) 
    { 
      entry_size = binding->tracker_list.entrysize; // 0x20 by default 
      entry_ptr = (struct TrackerEntry *)(binding->tracker_list.ptr + entry_size * i); 
      entry_tracker1 = entry_ptr->Tracker1; 
      entry_tracker2 = entry_ptr->Tracker2; 
 
      tracker1_id = tracker1->resource_id; 
      tracker2_id = tracker2->resource_id; 
 
      // Find the entry 
      if ( entry_ptr->entry_id ) { 
        if ( entry_tracker1->resource_id == tracker1_id || entry_tracker2->resource_id == tracker1_id ) 
          tracker1_exist = true; 
        if ( entry_tracker1->resource_id == tracker2_id || entry_tracker2->resource_id == tracker2_id ) 
          tracker2_exist = true; 
      } 
    } 
    // If there is no other object related with tracker1 or tracker2 
    // Remove the binding. 
    if ( !tracker1_exist ) 
      DirectComposition::CInteractionTrackerMarshaler::SetBindingManagerMarshaler(tracker1, resinfo, 0); 
    if ( !tracker2_exist ) 
      DirectComposition::CInteractionTrackerMarshaler::SetBindingManagerMarshaler(tracker2, resinfo, 0); 
  } 
}

```

因此，我们可以构造如下步骤来绕过该补丁。

1.Bind Tracker to the TrackerBindingA 

![](https://mmbiz.qpic.cn/mmbiz_png/AvAjnOiazvnfhwzeiaH8mRHicdoRcib48gmIckALvf6TgfvuusvbIryJWlsjxtVbFBAVWDBUmD6xbkC3pqsELncGBw/640?wx_fmt=png)

2.Unbind by setting tracker_id to 0 

![](https://mmbiz.qpic.cn/mmbiz_png/AvAjnOiazvnfhwzeiaH8mRHicdoRcib48gmIc2XdIQfFz3Nic1pX9Tvya1k4JXqREwPfTxJ2ShOd37RBOty1TtRV9Lw/640?wx_fmt=png)

3.Bind Tracker to the TrackerBindingB 

![](https://mmbiz.qpic.cn/mmbiz_png/AvAjnOiazvnfhwzeiaH8mRHicdoRcib48gmIfuXekiaxqicNolWClgaFKWvLQ7zmPhfjgjrHQPl1HyXg3fyVtSeVI8Yg/640?wx_fmt=png)

4.Activate the Entry by setting tracker_id to Non-ZERO 

![](https://mmbiz.qpic.cn/mmbiz_png/AvAjnOiazvnfhwzeiaH8mRHicdoRcib48gmI1yhL1cv6nc0cYzfhgrmfmYyiajm5RvtHry1KaJqMsickSjuh2IzicJYXQ/640?wx_fmt=png)

5.Release Tracker Resource Object 

![](https://mmbiz.qpic.cn/mmbiz_png/AvAjnOiazvnfhwzeiaH8mRHicdoRcib48gmIia8ke2uD4YzsUx5djJshQbZYmzFIZOWgNIhN05zoj8nwud2QLDKUVog/640?wx_fmt=png)

```
0: kd> bl
     0 e Disable Clear  ffffb598`64db2afd e 1 0001 (0001) win32kbase!DirectComposition::CApplicationChannel::CreateResource+0x49
     1 e Disable Clear  ffffb598`64f4d510 e 1 0001 (0001) win32kbase!DirectComposition::CInteractionTrackerBindingManagerMarshaler::SetBufferProperty
     3 e Disable Clear  ffffb598`64f4c0b0 e 1 0001 (0001) win32kbase!DirectComposition::CInteractionTrackerMarshaler::ReleaseAllReferences


[+] Create First TrackerBinding Resource Object
0: kd> g
Breakpoint 0 hit
win32kbase!DirectComposition::CApplicationChannel::CreateResource+0x49:
ffffb598`64db2afd e8daf3ffff      call    win32kbase!DirectComposition::CLinearObjectTableBase::InsertObject (ffffb598`64db1edc)

0: kd> r
rax=0000000000000000 rbx=0000000000000000 rcx=ffffb5b98602fc68
rdx=ffffb5b984c1b450 rsi=ffffb5b984c1b450 rdi=ffffb5b98602fc30
rip=ffffb59864db2afd rsp=ffffb08e12fb88f0 rbp=0000000000000059
 r8=0000000000000001  r9=0000000000000000 r10=ffffb5b380001000
r11=ffffb5b982f6fc30 r12=ffffb5b98602fc30 r13=0000000000000001
r14=0000000000000001 r15=ffffb5b98602fc00
iopl=0         nv up ei pl zr na po nc
cs=0010  ss=0018  ds=002b  es=002b  fs=0053  gs=002b             efl=00040246
win32kbase!DirectComposition::CApplicationChannel::CreateResource+0x49:
ffffb598`64db2afd e8daf3ffff      call    win32kbase!DirectComposition::CLinearObjectTableBase::InsertObject (ffffb598`64db1edc)

0: kd> p
win32kbase!DirectComposition::CApplicationChannel::CreateResource+0x4e:
ffffb598`64db2b02 8bd8            mov     ebx,eax

1: kd> dps ffffb5b984c1b450    # RDX
ffffb5b9`84c1b450  ffffb598`64f77070 win32kbase!DirectComposition::CInteractionTrackerBindingManagerMarshaler::`vftable'
ffffb5b9`84c1b458  00000000`00000000
ffffb5b9`84c1b460  00000001`00000000
ffffb5b9`84c1b468  00000000`00000001

```

```
[+] Create Second TrackerBinding Resource Object
1: kd> g
Breakpoint 0 hit
win32kbase!DirectComposition::CApplicationChannel::CreateResource+0x49:
ffffb598`64db2afd e8daf3ffff      call    win32kbase!DirectComposition::CLinearObjectTableBase::InsertObject (ffffb598`64db1edc)

1: kd> r
rax=0000000000000000 rbx=0000000000000000 rcx=ffffb5b98602fc68
rdx=ffffb5b984c1b1b0 rsi=ffffb5b984c1b1b0 rdi=ffffb5b98602fc30
rip=ffffb59864db2afd rsp=ffffb08e12fb88f0 rbp=0000000000000059
 r8=0000000000000002  r9=0000000000000000 r10=0000ffffb59864e5
r11=ffffb5b982f6fc38 r12=ffffb5b98602fc30 r13=0000000000000001
r14=0000000000000002 r15=ffffb5b98602fc00
iopl=0         nv up ei pl zr na po nc
cs=0010  ss=0018  ds=002b  es=002b  fs=0053  gs=002b             efl=00040246
win32kbase!DirectComposition::CApplicationChannel::CreateResource+0x49:
ffffb598`64db2afd e8daf3ffff      call    win32kbase!DirectComposition::CLinearObjectTableBase::InsertObject (ffffb598`64db1edc)

1: kd> p
win32kbase!DirectComposition::CApplicationChannel::CreateResource+0x4e:
ffffb598`64db2b02 8bd8            mov     ebx,eax

1: kd> dps ffffb5b984c1b1b0    # RDX
ffffb5b9`84c1b1b0  ffffb598`64f77070 win32kbase!DirectComposition::CInteractionTrackerBindingManagerMarshaler::`vftable'
ffffb5b9`84c1b1b8  ffffb5b9`84c1b450
ffffb5b9`84c1b1c0  00000001`00000000
ffffb5b9`84c1b1c8  00000000`00000002

```

```
[+] Create Tracker Resource Object
1: kd> g
Breakpoint 0 hit
win32kbase!DirectComposition::CApplicationChannel::CreateResource+0x49:
ffffb598`64db2afd e8daf3ffff      call    win32kbase!DirectComposition::CLinearObjectTableBase::InsertObject (ffffb598`64db1edc)

0: kd> r
rax=0000000000000000 rbx=0000000000000000 rcx=ffffb5b98602fc68
rdx=ffffb5b982fffc20 rsi=ffffb5b982fffc20 rdi=ffffb5b98602fc30
rip=ffffb59864db2afd rsp=ffffb08e12fb88f0 rbp=0000000000000058
 r8=0000000000000003  r9=0000000000000000 r10=0000ffffb59864e5
r11=ffffb5b982f6fc40 r12=ffffb5b98602fc30 r13=0000000000000001
r14=0000000000000003 r15=ffffb5b98602fc00
iopl=0         nv up ei pl zr na po nc
cs=0010  ss=0018  ds=002b  es=002b  fs=0053  gs=002b             efl=00040246
win32kbase!DirectComposition::CApplicationChannel::CreateResource+0x49:
ffffb598`64db2afd e8daf3ffff      call    win32kbase!DirectComposition::CLinearObjectTableBase::InsertObject (ffffb598`64db1edc)

0: kd> p
win32kbase!DirectComposition::CApplicationChannel::CreateResource+0x4e:
ffffb598`64db2b02 8bd8            mov     ebx,eax

0: kd> dps ffffb5b982fffc20    # RDX
ffffb5b9`82fffc20  ffffb598`64f76f78 win32kbase!DirectComposition::CInteractionTrackerMarshaler::`vftable'
ffffb5b9`82fffc28  ffffb5b9`84c1b1b0
ffffb5b9`82fffc30  00000001`1dffffc0
ffffb5b9`82fffc38  00000000`00000003

```

```
[+] Bind Tracker to the First TrackerBinding
0: kd> g
Breakpoint 1 hit
win32kbase!DirectComposition::CInteractionTrackerBindingManagerMarshaler::SetBufferProperty:
ffffb598`64f4d510 48895c2418      mov     qword ptr [rsp+18h],rbx

0: kd> g
Breakpoint 1 hit
win32kbase!DirectComposition::CInteractionTrackerBindingManagerMarshaler::SetBufferProperty:
ffffb598`64f4d510 48895c2418      mov     qword ptr [rsp+18h],rbx

0: kd> dps ffffb5b9`82fffc20+0x190        # tracker1->binding_obj
ffffb5b9`82fffdb0  ffffb5b9`84c1b450
ffffb5b9`82fffdb8  00000000`00000000

0: kd> dps poi(ffffb5b9`84c1b450+0x38)    # point to struct CInteractionTrackerBindingManagerMarshalerA
ffffb5b9`84d9f010  ffffb5b9`82fffc20
ffffb5b9`84d9f018  ffffb5b9`82fffc20
ffffb5b9`84d9f020  00000000`41414141
ffffb5b9`84d9f028  00000000`00000001

```

```
[+] Bind Tracker to the Second TrackerBinding
0: kd> g
Breakpoint 1 hit
win32kbase!DirectComposition::CInteractionTrackerBindingManagerMarshaler::SetBufferProperty:
ffffb598`64f4d510 48895c2418      mov     qword ptr [rsp+18h],rbx

1: kd> dps poi(ffffb5b9`84c1b1b0+0x38)    # point to struct CInteractionTrackerBindingManagerMarshalerB
ffffb5b9`806c2010  ffffb5b9`82fffc20
ffffb5b9`806c2018  ffffb5b9`82fffc20
ffffb5b9`806c2020  00000000`42424242
ffffb5b9`806c2028  00000000`00000001

1: kd> dps ffffb5b9`82fffc20+0x190
ffffb5b9`82fffdb0  ffffb5b9`84c1b1b0
ffffb5b9`82fffdb8  00000000`00000000

```

```
[+] Activate the Entry by setting tracker_id to Non-ZERO
1: kd> g
Breakpoint 3 hit
win32kbase!DirectComposition::CInteractionTrackerMarshaler::ReleaseAllReferences:
ffffb598`64f4c0b0 48895c2408      mov     qword ptr [rsp+8],rbx

0: kd> dps poi(ffffb5b9`84c1b450+0x38)    # point to struct CInteractionTrackerBindingManagerMarshalerA
ffffb5b9`84d9f010  ffffb5b9`82fffc20
ffffb5b9`84d9f018  ffffb5b9`82fffc20
ffffb5b9`84d9f020  00000000`41414141
ffffb5b9`84d9f028  00000000`00000001

```

```
[+] Release Tracker Resource Object
[+] Release the Second TrackerBinding Object
0: kd> gu
WARNING: Software breakpoints on session addresses can cause bugchecks.
Use hardware execution breakpoints (ba e) if possible.
win32kbase!DirectComposition::CApplicationChannel::ReleaseResource+0x124:
ffffb598`64db3ce4 90              nop

0: kd> dps poi(ffffb5b9`84c1b1b0+0x38)    # point to struct CInteractionTrackerBindingManagerMarshalerB
ffffb5b9`806c2010  00000000`00000000
ffffb5b9`806c2018  00000000`00000000
ffffb5b9`806c2020  00000000`00000000

0: kd> dps poi(ffffb5b9`84c1b450+0x38)    # point to struct CInteractionTrackerBindingManagerMarshalerA
ffffb5b9`84d9f010  ffffb5b9`82fffc20
ffffb5b9`84d9f018  ffffb5b9`82fffc20
ffffb5b9`84d9f020  00000000`41414141
ffffb5b9`84d9f028  00000000`00000001

0: kd> dps ffffb5b9`82fffc20+0x190        # tracker1->binding_obj Freed
ffffb5b9`82fffdb0  00000000`00000000
ffffb5b9`82fffdb8  00000000`00000000
ffffb5b9`82fffdc0  6f746547`231bd700

```

最终通过 NtDCompositionCommitChannel 系统调用触发 UAF。至此，CVE-2021-26900 的漏洞成因大致如上。  

验证视频
----

写在最后
----

由于 UAF 在用户态进程 dwm.exe 中触发，在使用 WindbG 进行双机调试的情况下不大方便在崩溃处断下，这里需要用到另一种方式，使用 WindbG 远程调试用户态进程，详细资料可参考 GReAT Ideas.Powered by SAS:Exploit Analysis for Beginners.

官方补丁
----

https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-26900

![](https://mmbiz.qpic.cn/mmbiz_png/AvAjnOiazvnf9lw493LJmpm51oUkLoMsXCmAU2UzEIY8pYWKVulWQPmTOMC1swUBCIFpLSDKHkn9VgXcWEZ99pg/640?wx_fmt=png)  

**人才招聘**

**二进制安全研究员**

**(Windows 内核方向)**

岗位职责：  

- 负责研究 Window 内核相关漏洞利用技术；

- 负责分析 Window 内核漏洞的原理及缓解措施；

任职要求：

- 2 年以上 windows 逆向工作经验。

- 熟悉 windows 底层架构、运行机制，熟悉汇编语言 C/C++ 语言，熟悉 win32/64 开发，并有相关开发经验；

- 熟悉 windows 驱动开发、熟悉 windows 平台内核架构；能熟练运用 Windows 平台下的软件调试方法。

- 熟练使用 ida、windbg 等调试软件工具调试分析漏洞。

- 有 CVE 编号、内核研究成果者优先；

- 具备良好的团队沟通、协作能力、良好的职业道德。

**二进制安全研究员**

**(Linux 内核方向)**  

岗位职责：

- 负责研究 Linux 内核相关漏洞利用技术；

- 负责分析 Linux 内核漏洞的原理及缓解措施；

任职要求：

- 2 年以上 Linux 逆向工作经验。

- 熟悉 Linux 底层架构、运行机制，熟悉汇编语言 C/C++ 语言，熟悉 x86/64 开发，并有相关开发经验；

- 熟悉 Linux 驱动开发、熟悉 Linux 平台内核架构；能熟练运用 Linux 平台下的软件调试方法。

- 熟练使用 ida、gdb、lldb 等调试软件工具调试分析漏洞。

- 有 CVE 编号、内核研究成果者优先；

- 具备良好的团队沟通、协作能力、良好的职业道德。

**二进制安全研究员**

**(系统应用方向)**  

岗位职责：  

- 负责安全技术研究，跟踪国内外最新的安全技术以及安全漏洞的追踪；

- 负责进行二进制漏洞挖掘，包括不限于浏览器、chakara 引擎、js 引擎、office、pdf 等等各种二进制类应用；

任职要求：

- 能主动关注国内外最新安全攻防技术，并在自己擅长和兴趣的领域能够进行深入的学习、研究；

- 熟练掌握 windbg、ida、gdb 等调试工具；

- 熟悉各类二进制安全漏洞原理（堆溢出、栈溢出、整数溢出、类型混淆等等）以及各种利用技术；

- 能够无障碍阅读英文技术文档；

- 具备良好的团队沟通、协作能力、良好的职业道德。

**Web 安全研究员**  

岗位职责：

- 跟踪最新安全技术动态，对高危安全漏洞进行快速分析和响应；

- 负责安全产品的线下、线上功能及流程的验收测试，保证项目进度和品质；

- 从事影响比较大的国内外大型的 cms、中间件、框架漏洞挖掘工作

任职要求：

- 深入了解漏洞原理，能够独立挖掘 / 分析包括但不限于 PHP/JAVA/.NET/ASP 等大中型应用漏洞，并编写 exp；

- 具备优秀的 JAVA 开发能力，能熟练挖掘 JAVA WEB 方面的漏洞，深入了解 tomcat,weblogic,jboss,resin 等中间件内部构造；

- 熟练使用至少一门开发语言，如：PHP、python、java；

- 有比较强的开发能力，熟悉 java web 的常见漏洞原理，有能力挖掘和分析 java web 方面的漏洞；

- 有重大漏洞发掘或高质量的 CVE、0day 挖掘能力的优先考虑；

**Web 安全研究员**

**(安全测试方向)**   

岗位职责：

- 安全攻防技术研究，最新 web 应用及中间件漏洞挖掘研究；

- 跟踪分析国内外的安全动态，对重大安全事件进行快速响应；

- 针对相关产品，进行全面详细的安全测试评估；

任职要求：

- 了解常见的网络协议 (TCP/IP,HTTP,FTP 等)；

- 熟练使用 Wireshark 等抓包工具，熟悉正则表达式；

- 掌握常见漏洞原理，有一定的漏洞分析能力；

- 具备 php、python、java 或其他相关语言编码能力；

- 对常见 waf 绕过有一定的基础经验；

- 具备一定的文档编写能力，具备良好的团队共同能力；

- 对安全有浓厚的兴趣，工作细致耐心。