> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [xz.aliyun.com](https://xz.aliyun.com/t/8694)

XStream 是一个基于 Java 库，可以将 Java 对象序列化为 XML，反之亦然。

2020 年，Xstream 有两个影响比较大的高危漏洞被爆出：CVE-2020-26217 远程代码执行漏洞与 CVE-2020-26259 任意文件删除漏洞。纵观两个漏洞，他们出现的原因与机制上极其相似，因此我们在这里放到一块来分析。

理解 poc
------

首先把 CVE-2020-26217 与 CVE-2020-26259 的 poc 放到一起比较下：

[![](https://xzfile.aliyuncs.com/media/upload/picture/20201222101608-a711bcea-43fb-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201222101608-a711bcea-43fb-1.png)

从上图两个漏洞 poc 的对比上来看：二者利用链前半部分都是一样的，只有中间 is 元素的 class 属性值不同：其中一个为 java.io.SequenceInputStream 而另一个为 com.sun.xml.internal.ws.util.ReadAllStream$FileStream。

因此，我们可以先从他们相同部分的调用链入手分析，等到了他们分歧之处，我们再分开来分析。在分析漏洞之前，我们需要搞明白 poc 中的元素以及其属性到底代表什么意思。

由于 poc 是个 xml 格式，我们一层层来剖析这个 xml。首先把 poc 元素折叠起来，看看 entry 元素中包含的元素内容，见下图：

[![](https://xzfile.aliyuncs.com/media/upload/picture/20201222101620-ae32e15c-43fb-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201222101620-ae32e15c-43fb-1.png)

entry 元素中包含了 jdk.nashorn.internal.objects.NativeString 与 string 两个元素

上图这样的结构代表什么意思呢？又是怎么生成的呢？

我们本地做了一个 demo，看一下下面的例子：

[![](https://xzfile.aliyuncs.com/media/upload/picture/20201222101630-b43b22ee-43fb-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201222101630-b43b22ee-43fb-1.png)

在这个 demo 中，HashMap 的 key 为一个 Person 对象，而 value 为 String 类型”test”

Xstream 将这个 map 输出为下图形式

[![](https://xzfile.aliyuncs.com/media/upload/picture/20201222101643-bbc2848a-43fb-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201222101643-bbc2848a-43fb-1.png)

让我们对比一下 poc 与我们测试 demo

[![](https://xzfile.aliyuncs.com/media/upload/picture/20201222101652-c1a4211a-43fb-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201222101652-c1a4211a-43fb-1.png)

从我们的 demo 与实际 poc 两个例子可以看出：在 Xstream 将 Map 生成 xml 格式数据时，会为每个 Entry 对象生成一个 <entry>…</entry > 元素，并将该 Entry 中的 key 与 value 作为其子元素顺次放置于其中第一个和第二个元素处。因此我们可以通过这个特点推断出，poc 中 jdk.nashorn.internal.objects.NativeString 与 string 两个元素其实就是该 Entry 的 key 与 value。此外，我们回头看一下我们的 demo

[![](https://xzfile.aliyuncs.com/media/upload/picture/20201222101701-c6e90da2-43fb-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201222101701-c6e90da2-43fb-1.png)

从上图可见：在生成 xml 时，我们为 Person 对象赋值的 name（“kumamon”）与 age（3）属性值成为了 Person 对象节点 (<person>…</person>) 的子元素(<name>…</name>、<age>…</age>)

因此可以推断，当一个 java 对象通过 Xstream 生成 xml 时，其结构应遵循如下结构：

[![](https://xzfile.aliyuncs.com/media/upload/picture/20201222101710-cc23fe9e-43fb-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201222101710-cc23fe9e-43fb-1.png)

回头看一下我们的 poc，我们再展开一级看看

[![](https://xzfile.aliyuncs.com/media/upload/picture/20201222101719-d17ac30a-43fb-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201222101719-d17ac30a-43fb-1.png)

通过上文的理解，上图 poc 可以理解为一个 map 集合，其中存在 key 为 jdk.nashorn.internal.objects.NativeString 对象、value 值为 test 的 Entry。而 jdk.nashorn.internal.objects.NativeString 对象又存在 flags、value 属性，它的 flags 属性值为 0、value 属性值为 com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data

在弄明白 poc 结构之后，我们来调试下 poc 的解析的过程

Xstream 程序在解析 xml 时遇到 Map 结构后，会新建了一个 map 并将 xml 中 key-value 对取出并 put 入其中，见下图

[![](https://xzfile.aliyuncs.com/media/upload/picture/20201222101729-d75f165e-43fb-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201222101729-d75f165e-43fb-1.png)

上图 key 值即为 poc 中 Entry 内 key 值 (NativeString 对象)，而 values 则为 Entry 中 value（test 字符串）

根据 map 的原理可知：map 在 put key 操作时需要获取 key 的 hash 值。因此程序调用了 jdk.nashorn.internal.objects.NativeString 的 hashCode 方法，见下图

[![](https://xzfile.aliyuncs.com/media/upload/picture/20201222101739-dd3e88de-43fb-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201222101739-dd3e88de-43fb-1.png)

从上图可见，程序调用了 getStringValue 方法，我们跟入这个方法，见下图：

[![](https://xzfile.aliyuncs.com/media/upload/picture/20201222101750-e4194d38-43fb-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201222101750-e4194d38-43fb-1.png)

在这个方法中，程序将判断 this.value 是否为 String 实例，并尝试调用 this.value.toString 方法

经过上文对 poc 的分析，此时的 this.value 其实就是 <jdk.nashorn.internal.objects.NativeString>

…</jdk.nashorn.internal.objects.NativeString> 元素中的 value 子元素值，攻击者可以通过 xml 中 NativeString 元素的 value 子元素控制。在官方给出的 poc 中，将 value 值构造为 com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data 类。见下图

[![](https://xzfile.aliyuncs.com/media/upload/picture/20201222101801-ea535fe0-43fb-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201222101801-ea535fe0-43fb-1.png)

因此，此时 this.value 为 com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data。程序调用 Base64Data 类的 toString 方法，见下图：

[![](https://xzfile.aliyuncs.com/media/upload/picture/20201222101809-ef7c00e4-43fb-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201222101809-ef7c00e4-43fb-1.png)

Base64Data 类中 toString 方法首先调用了其自身的 get 方法，跟入 get 方法中，见下图：

[![](https://xzfile.aliyuncs.com/media/upload/picture/20201222101819-f5394f82-43fb-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201222101819-f5394f82-43fb-1.png)

分析上图代码：this.dataHandler.getDataSource().getInputStream(); 将其拆分来看：

> 1.  首先程序执行 this.dataHandler.getDataSource()，即是获取 Base64Data 对象中 dataHandler 属性的 DataSource 值。Base64Data 的 dataHandler 属性值以及 dataHandler 的 dataSource 属性值都可以在 xml 中设置。poc 中将 dataSource 设置为：com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource。因此 this.dataHandler.getDataSource() 获取的值为：com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource
> 2.  随后程序执行 com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource 类的 getInputStream 方法，这将获取 com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSourc 的 is 属性值

CVE-2020-26217 与 CVE-2020-26259 两个 POC 中设置的 DataSource 的 is 属性值不同，这将导致两个漏洞进入了不同的调用链。我们先来看看 CVE-2020-26217

CVE-2020-26217
--------------

我们来看看 CVE-2020-26217 的 poc 中 DataSource 元素包含的 is 元素是什么

[![](https://xzfile.aliyuncs.com/media/upload/picture/20201222101830-fb813ee0-43fb-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201222101830-fb813ee0-43fb-1.png)

通过上图可见，poc 中构造的 is 值为 java.io.SequenceInputStream

随后，程序将 is 变量传入 readFrom 方法中，见下图

[![](https://xzfile.aliyuncs.com/media/upload/picture/20201222101838-0070b822-43fc-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201222101838-0070b822-43fc-1.png)

readFrom 方法实现如下：

[![](https://xzfile.aliyuncs.com/media/upload/picture/20201222101847-05a99430-43fc-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201222101847-05a99430-43fc-1.png)

此时的 is 变量为 java.io.SequenceInputStream，随后程序调用 java.io.SequenceInputStream 类的 read 方法

[![](https://xzfile.aliyuncs.com/media/upload/picture/20201222101856-0b809b1a-43fc-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201222101856-0b809b1a-43fc-1.png)

从上图可见，程序将调用 java.io.SequenceInputStream 类的 read 方法中的 nextStream 方法，跟入 nextStream 方法中，见下图：

[![](https://xzfile.aliyuncs.com/media/upload/picture/20201222101905-1083bc6e-43fc-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201222101905-1083bc6e-43fc-1.png)

从上图 110 行可见，程序将执行 in = (InputStream) e.nextElement();

而 e 的值，可以通过向 xml 中 SequenceInputStream 元素中的 e 元素值来控制。在 poc 中将这个 e 元素值设置为 javax.swing.MultiUIDefaults$MultiUIDefaultsEnumerator，见下图

[![](https://xzfile.aliyuncs.com/media/upload/picture/20201222101914-15eab5ae-43fc-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201222101914-15eab5ae-43fc-1.png)

因此，程序事实上调用的是 javax.swing.MultiUIDefaults$MultiUIDefaultsEnumerator 的 nextElement 方法。接下来进入位于 javax/swing/MultiUIDefaults.java 中的 nextElement 方法

[![](https://xzfile.aliyuncs.com/media/upload/picture/20201222101922-1ad15c12-43fc-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201222101922-1ad15c12-43fc-1.png)

可见，这次需要执行的是 iterator.next().getKey();

我们需要为 javax.swing.MultiUIDefaults$MultiUIDefaultsEnumerator 对象构造一个满足要求的 iterator 属性值。通过分析 poc 可知，poc 中选取了 javax.imageio.spi.FilterIterator 作为 iterator 属性值，见下图：

[![](https://xzfile.aliyuncs.com/media/upload/picture/20201222101931-201c4290-43fc-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201222101931-201c4290-43fc-1.png)

跟入位于 javax/imageio/spi/ServiceRegistry.java 的 javax.imageio.spi.FilterIterator 类的 next 方法，见下图：

[![](https://xzfile.aliyuncs.com/media/upload/picture/20201222101940-253c5184-43fc-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201222101940-253c5184-43fc-1.png)

在 javax.imageio.spi.FilterIterator 类的 next 方法中，执行 advance 方法。跟入 advance 方法

[![](https://xzfile.aliyuncs.com/media/upload/picture/20201222101948-2a59a82e-43fc-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201222101948-2a59a82e-43fc-1.png)

从上图可见，程序执行了 T elt = iter.next();  
此时的 iter 显然可以通过 xml 中 javax.imageio.spi.FilterIterator 元素中 iter 元素控制，我们看一下 poc 中构造的 iter 子节点，见下图

[![](https://xzfile.aliyuncs.com/media/upload/picture/20201222101958-300a5098-43fc-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201222101958-300a5098-43fc-1.png)

当 iter.next() 执行后，poc 中构造的 java.lang.ProcessBuilder 被返回并赋值给 elt，见下图

[![](https://xzfile.aliyuncs.com/media/upload/picture/20201222102006-34f78a58-43fc-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201222102006-34f78a58-43fc-1.png)

随后，程序执行 filter.filter(elt)

[![](https://xzfile.aliyuncs.com/media/upload/picture/20201222102015-3a6dfd32-43fc-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201222102015-3a6dfd32-43fc-1.png)

很显然，filter 值是可以通过 xml 中 javax.imageio.spi.FilterIterator 元素中 filter 元素控制的。看一下 poc

[![](https://xzfile.aliyuncs.com/media/upload/picture/20201222102025-404882b8-43fc-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201222102025-404882b8-43fc-1.png)

Filter 赋值为 javax.imageio.ImageIO$ContainsFilter 类

我们跟入 javax.imageio.ImageIO$ContainsFilter 类的 filter 方法中，位于 javax/imageio/ImageIO.java

[![](https://xzfile.aliyuncs.com/media/upload/picture/20201222102034-456e0808-43fc-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201222102034-456e0808-43fc-1.png)

可见在 javax.imageio.ImageIO$ContainsFilter 类的 filter 方法中，执行了 method.invoke(elt)。method 可以通过 xml 中 javax.imageio.ImageIO$ContainsFilter 元素包含的 method 元素控制，见 poc

[![](https://xzfile.aliyuncs.com/media/upload/picture/20201222102043-4ad23f94-43fc-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201222102043-4ad23f94-43fc-1.png)

此时 method 为 ProcessBuilder 类的 start 方法，而通过上文可知：elt 为构造好的 java.lang.ProcessBuilder 对象。在 method 与 elt 都可控的情况下，进行反射调用即可实现远程代码执行利用。

我们接下来看看 CVE-2020-26259 任意文件删除漏洞

CVE-2020-26259
--------------

首先分析下 CVE-2020-26259 的 poc

[![](https://xzfile.aliyuncs.com/media/upload/picture/20201222102054-516f3942-43fc-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201222102054-516f3942-43fc-1.png)

从 poc 中可以发现：CVE-2020-26259 的 poc 中 is 元素为 com.sun.xml.internal.ws.util.ReadAllStream$FileStream，这与上一个漏洞 poc 不一样。

值得注意的是，这次漏洞利用的不是 Base64Data 中 get 方法里的 baos.readFrom(is) 这个入口，而是位于它下面一行的 is.close() 这行代码。通过调试，程序在执行过 get 方法中 baos.readFrom(is) 后，紧接着执行 is.Close()，见下图：

[![](https://xzfile.aliyuncs.com/media/upload/picture/20201222102102-56a91cca-43fc-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201222102102-56a91cca-43fc-1.png)

此时的 is 是 com.sun.xml.internal.ws.util.ReadAllStream$FileStream，跟入 com.sun.xml.internal.ws.util.ReadAllStream$FileStream 中的 close 方法，见下图：

[![](https://xzfile.aliyuncs.com/media/upload/picture/20201222102111-5c093aec-43fc-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201222102111-5c093aec-43fc-1.png)

当 com.sun.xml.internal.ws.util.ReadAllStream$FileStream 对象的 tempFile 属性值不为空时，删除 tempFile 文件。

tempFile 是 com.sun.xml.internal.ws.util.ReadAllStream$FileStream 对象的属性值，因此可以直接在 poc 中 com.sun.xml.internal.ws.util.ReadAllStream$FileStream 元素内构造 tempFile 属性元素，通过 tempFile 属性元素控制要删除的文件，见下图 poc

[![](https://xzfile.aliyuncs.com/media/upload/picture/20201222102121-61805992-43fc-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20201222102121-61805992-43fc-1.png)

到此，一个任意文件删除漏洞产生了

总结
--

通过对这两个漏洞的分析不难发现，CVE-2020-26259 其实是 CVE-2020-26217 的一个思路上的延伸：在 is 可控时，既然 baos.readFrom(is) 可以利用，那么 is.close() 是否也能构造出一个利用链呢？从 CVE-2020-26259 答案上来看是可以的。  
从 CVE-2020-26259 也可以延伸出另一个问题：只要找到一个类，其中存在 close 方法且 close 方法中有可利用的地方，那么一条新的利用链就被挖掘出来了。