> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/-U9KSRliuNYLuRYnbmnFjw)

![](https://mmbiz.qpic.cn/mmbiz_jpg/Ok4fxxCpBb6LSx2iamplAVoRuaXDqia2aTwUGnwvd4Vau8lcTtNaIBSoaTia5Ih3QokOPmqP4CngO6MvNauojUmXg/640?wx_fmt=jpeg)

原理

### **（一）概述**

概述链接 1

概述链接 2  
（点击 “阅读原文” 查看链接）

接 CVE-2015-4852，

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb6LSx2iamplAVoRuaXDqia2aTc2vwfudjRF6UGwTq7WS6Eo1Zj6l5TicQgC998gHSh3AbGP8UtUxdywg/640?wx_fmt=png)

Oracle 使用黑名单进行了防护，如下，

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb6LSx2iamplAVoRuaXDqia2aTmh3iaYTlZQjOZqoVeITcXWfO51eht1eXj0CAlWcSx1WRskE0tR273mw/640?wx_fmt=png)

看一下 CVE-2015-4852 调试过程中记录的信息，

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb6LSx2iamplAVoRuaXDqia2aTJNuWicu1WH84MDqokcarZPThpAsp9CJa4AGA53cexhzlSsP74joXGHw/640?wx_fmt=png)

触发时的调用栈，

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb6LSx2iamplAVoRuaXDqia2aTwJueI0MIicTRiaWYiaicN929RVpGTkbmLnKf5lg76IXONhh9NZZRlxOpMA/640?wx_fmt=png)

结合上一次调试过程中记录的信息，我们可以看到，这个 fix 阻断了 CVE-2015-4852 的 exp 中在偏底层的位置对关键类的反序列化，可以说是打断了利用链。

但同时，我们也要注意到，对那几个关键类的反序列化的禁止仅存在于那三个列出的反序列化点。也就是说，如果能在别的反序列化点，通过适当的 readObject 对那几个关键类进行反序列化，也有可能能触发 RCE 之类的漏洞。这里和上一个漏洞类似，将反序列化点转移到了一个新类的内部。

实际上，CVE-2016-3510 和 CVE-2016-0638 的攻击都是基于对黑名单的绕过。

### **（二）CVE-2016-3510**

原理是将反序列化的对象封装进了 weblogic.corba.utils.MarshalledObject，然后再对 MarshalledObject 进行序列化。当字节流反序列化时 MarshalledObject 不在 WebLogic 黑名单里，可正常反序列化，在反序列化时 MarshalledObject 对象调用 readObject 时对 MarshalledObject 封装的序列化对象再次反序列化，这样就逃过了黑名单的检查。

MarshalledObject 比较符合需求，即在封装原链的基础上可以通过自身的反序列化来反序列化成员变量。

### **（三）原理**

**（一）工具分析**

结合着调试分析一下工具的逻辑与流程，

首先按照 CVE-2016-3510 的实际情况，将 TYPE 改为 marshall，

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb6LSx2iamplAVoRuaXDqia2aTs3SUQxONHnR2H1hWgicJibMic0JyT5wUUI9IEGficVXPRibS0stvtGFtDxw/640?wx_fmt=png)

debug，

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb6LSx2iamplAVoRuaXDqia2aTuQrW7P8mcUNprm0q4C1gCdqTHTHjSR3ePIbmSL11wux2Wsmw4wJFMQ/640?wx_fmt=png)

继续向前，可以看到此处的 handler 的类型是 AnnotationInvocationHandler，

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb6LSx2iamplAVoRuaXDqia2aT0Nq6L6iaEaJHibuzJvyyGZDMKvbg7If8lBrK11G7icHu8CYibZ6Ifcen8w/640?wx_fmt=png)

跟进此处的 selectBypass，

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb6LSx2iamplAVoRuaXDqia2aTrZ7y9EeCZ5ufXVgC1Tqgfn9jM20c0529dXXQg1YiaOSNDtPrsm2opAQ/640?wx_fmt=png)

可以看到，这里根据 TYPE 选择了 marshall 类型的包装，从这里我们可以猜测这个漏洞对于 CVE-2015-4852 的防护黑名单的绕过是基于额外封装的，黑名单限制了那三个反序列化点，不让它们对那几个关键类进行反序列化，于是又找了另一个包的类，进行了二次封装，通过反序列化这个 marshall 对象触发构造好的 AnnotationInvocationHandler。这一点在下面漏洞的调试中我们可以有一个比较直观的感受。

接下来进行构造 marshallObject，

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb6LSx2iamplAVoRuaXDqia2aTAq8dHxpF4sTrHvdEPpWoCS8Vaq8S5skoI3m7dzqmyIM25SjtxHibh2w/640?wx_fmt=png)

可以看到，这里的 marshallObject 中的成员变量 objBytes 即为 AnnotationInvocationHandler，

继续运行，进行反序列化，

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb6LSx2iamplAVoRuaXDqia2aTIrWQ7ibL5ksQ6pxFTic6XLfMuph8bd3wPA5fTLK24TC6nutJtQYLRJ5Q/640?wx_fmt=png)

可以看到这里反序列化封装的是 MarshallObject 类，其内部才是构造好的 AnnotationInvocationHandler，

继续，就该发包了，

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb6LSx2iamplAVoRuaXDqia2aTJsd8ZRXAr7Sc5MwWNKIzjJ9hm6UhiavYNRucJb47bAUoIfDFOibIXFOA/640?wx_fmt=png)

下面的内容在漏洞的调试环节展示。

**（二）原理**

Externalizable 接口 extends 了 Serializable 接口，而且在其基础上增加了两个方法：writeExternal() 和 readExternal()。这两个方法会在序列化和反序列化还原的过程中被自动调用，以便执行一些需要的操作。

结合上面所讲，原理部分主要是解释是怎么绕过黑名单（这里主要关注黑名单中 ServerChannelInputStream）的，重点解释在反序列化时 marshall 引发了什么后果。

weblogic.corba.utils.MarshalledObject 这个类没有实现 readObject 或者 readExternal 函数，所以在反序列化的时候采用 ObjectInputStream 的默认流程。但这个流程会调用辅助类 ObjectStreamClass 的 invokeReadResolve 函数，后者会调用 MarshalledObject 的 readResolve 函数，查看 readResolve 我们会发现，readResolve 中有 readObject 的调用，而其参数正来自其本身的 objBytes 变量，如下：

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb6LSx2iamplAVoRuaXDqia2aT8kf5zyBzRyI6ibSTia1oRrGu50WMT5nzuicgn9sNx3CBWPdVfHNWCicD4A/640?wx_fmt=png)

个人对这个漏洞的理解是，所以在构造 MarshalledObject 时把生成的恶意 payload Object 作为参数传给构造函数即可。装填好、封装好（甚至只用一个 Bytes 而不是别的需要触发的数据类型）的 MarshallObject 可以正常走原触发点，因为 MarshallObject 不在黑名单之中，这一点将在漏洞调试部分展示。

调试

### **（一）环境搭建**

与 CVE-2016-0638 相同，不再重复

### **（二）复现**

配好 Application，

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb6LSx2iamplAVoRuaXDqia2aTwCesIR80fIraAxc8bD8yRlCnNic34Yao2nmcWiaxAUBeqHEkNaQRp1pg/640?wx_fmt=png)

run 即可，

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb6LSx2iamplAVoRuaXDqia2aTPpjYrrTUvibhXBkSSyhM5j1dJlibG244JebZGSBvJCZOuU5zbYxvZzVQ/640?wx_fmt=png)

### **（三）调试**

断点下在 MarshallObject.class 的 readResolve，

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb6LSx2iamplAVoRuaXDqia2aTTQ1ia8iaWiatzPAv1WfRtNTpskdPiaSIfvFaia31v9EFKUWgHwK8kICqzag/640?wx_fmt=png)

结合调用栈，我们看看反序列化点上的情况，

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb6LSx2iamplAVoRuaXDqia2aThPZPria71yGwiac0JC1kl8EM03iaLEUNYRtQRxMcshcLwe2LpZPWRchGg/640?wx_fmt=png)

可以看到，其实是走了那几个反序列化点的，

向栈底方向翻看几个函数，

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb6LSx2iamplAVoRuaXDqia2aTyA87GibLjmUnus0a9T6EnP2IaIflAeV9QbmjIYdk9RbshYOEgeGcWqA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb6LSx2iamplAVoRuaXDqia2aTMafibM3dia0Mx9RMbcK9klommPnvfsN7wnyA6FpdAz8jaQRNDA1whkdA/640?wx_fmt=png)

最关键的是下面这个，

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb6LSx2iamplAVoRuaXDqia2aTUJaNIHVoOuaSTibLCcS3iagibibgzlHfClFuuQVTIz8XNibfe8SrN9VoyOg/640?wx_fmt=png)

个人认为，这里是整个调试过程中的一个关键点。作为 CVE-2015-4852 中黑名单做保护的一个点，ServerChannelInputStream 对一些关键类的反序列化做了限制，但此时 var1 是一个 MarshallObject（或曰是一个 Marshall 外壳加 AnnotationInvocationHandler 的内里），并不在黑名单所限制的那几个关键的类里面，所以下面仍然可以正常的进行反序列化。

继续向下调试，跟进 Marshall 的 readObject，尝试着跟了下，

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb6LSx2iamplAVoRuaXDqia2aTZUKMph5DEYuCWLJQd8zFr34QFniauIjiaJGwp7eIuXh8aXZhCXymyibxw/640?wx_fmt=png)

在其中就进入了 AnnotationInvocationHandler 的 invoke，

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb6LSx2iamplAVoRuaXDqia2aTr8CavL0b6ULRKIC6NiaU6eKyIGz9XXBbM3ctH0B0HMict4Wf9FjwoH7Q/640?wx_fmt=png)

此时查看调用栈，

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb6LSx2iamplAVoRuaXDqia2aTiaE0hA1MveE9c5ULUNAzHSmjNSJ21Fnh1GYVjVEn5eEydOiciah1yPT2g/640?wx_fmt=png)

里面多是些 java 内部的函数，没有再跟进了，

接下来也就可以正常触发了原反序列化链，

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb6LSx2iamplAVoRuaXDqia2aTSOaZuzox9k05ZtS88EQIlict7aJJKogygE2O1IqF7ccrap5xurB968w/640?wx_fmt=png)

接下来的过程就是 CVE-2015-4852 中的过程，不再重复。

收获与启示

CVE-2016-3510 和 CVE-2016-0638 都是基于对 CVE-2015-4852 的黑名单的绕过。这个黑名单的防御思路是在 InputStream 中设置了一个 Filter，检查 InputStream 中包含的类是否在其中。两者的思路有比较大的相似之处，即没有对原攻击链做太多的修改，只在黑名单里的反序列化点上做文章，合理的选择新的对象进行二次封装使反序列化点仍然可以触发。所以我认为，找这种漏洞的方法之一便是寻找一种类，这种类可以反序列化自身的成员变量。

通过这两个漏洞我们可以看到，黑名单防护是不那么靠谱的，尤其是像 weblogic 这样的复杂的一个程序，既有不在少数的引入库，又有比较复杂的自身结构。如果说 CVE-2015-4852 是有 Commons Collections 引发的，这 2016 的这两个主要是由 Weblogic 自身的问题引发的，只是之前没有被发现或提出而已。

这两个漏洞的原理和 CVE-2015-4852 差不多，在以后的学习生活中，我会尽可能的深入一点，多探究一点细节，加深自己对相关知识的理解。

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb6OLwHohYU7UjX5anusw3ZzxxUKM0Ert9iaakSvib40glppuwsWytjDfiaFx1T25gsIWL5c8c7kicamxw/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_gif/Ok4fxxCpBb5ZMeq0JBK8AOH3CVMApDrPvnibHjxDDT1mY2ic8ABv6zWUDq0VxcQ128rL7lxiaQrE1oTmjqInO89xA/640?wx_fmt=gif)  

------------------------------------------------------------------------------------------------------------------------------------------------

**戳 “阅读原文” 查看更多内容**