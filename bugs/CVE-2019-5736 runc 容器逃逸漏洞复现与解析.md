> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/4Ru3foCn3NFGwjpxIH8LSQ)

漏洞简介
----

CVE-2019-5736 是 2019 年 2 月 11 日在 oss-security 邮件列表披露的 runc 容器逃逸漏洞。在 Docker 18.09.2 之前的版本中使用了的 runc 版本小于 1.0-rc6，因此允许攻击者重写宿主机上的 runc 二进制文件，因此可以 root 的身份执行命令，导致获得宿主机的 root 权限。

影响范围
----

docker version <=18.09.2  
RunC version <=1.0-rc6

修复方案
----

###### runC github 修复链接：

https://github.com/opencontainers/runc/commit/0a8e4117e7f715d5fbeef398405813ce8e88558b

###### Docker 最新版本 18.09.2 中已修复了该漏洞，建议升级到最新版本。

https://github.com/docker/docker-ce/releases/tag/v18.09.2

###### Red Hat 平台修复方案详见以下链接：

https://access.redhat.com/zh_CN/security/vulnerabilities/3907161

###### AWS 平台修复方案详见以下链接：

https://aws.amazon.com/cn/security/security-bulletins/AWS-2019-002/

###### Kubernetes 修复方案详见以下链接：

https://kubernetes.io/blog/2019/02/11/runc-and-cve-2019-5736/

###### 阿里云修复方案详见以下链接：

https://help.aliyun.com/document_detail/107320.html

背景
--

### runC

在执行类似 docker exec 的命令时，底层实际上是容器运行时在操作。例如 runc，相应地，runc exec 命令会被执行。它的最终效果是在容器内部执行用户指定的程序。进一步讲，就是在容器的各种命名空间内，受到各种限制（如 cgroups）的情况下，启动一个进程。除此以外，这个操作与宿主机上执行一个程序没有区别。  
执行过程大体是这样的：runc 启动，加入到容器的命名空间，接着以自身为范本启动一个子进程，最后通过 exec 系统调用执行用户指定的二进制程序。

### PROCFS

/proc 是一个伪文件系统，这个伪文件系统让你可以和内核内部数据结构进行交互，与真正的文件系统不同的是它是存在于内存中而不是真正的硬盘上，linux 下有一个说法一切皆文件，所有在 linux 上运行的程序都在 / proc 下有一个自己的目录，目录名字为程序的 Pid 号，目录里面存储着许多关于进程的信息，列如进程状态 status，进程启动时的相关命令 cmdline，进程的内存映像 maps，进程包含的所有相关的文件描述符 fd 文件夹等等。

/proc/[PID]/fd/：这个目录下包含了进程打开的所有文件描述符。  
/proc/[PID]/exe：它是一种特殊的符号链接，指向进程自身对应的本地程序文件（例如我们执行 bash，/proc/[bash-PID]/exe 就指向 / bin/bash）

原理
--

设想这样一种情况：在 runc exec 加入到容器的命名空间之后，容器内进程已经能够通过内部 / proc 观察到它，此时如果打开 / proc/[runc-PID]/exe 并写入一些内容，就能够实现将宿主机上的 runc 二进制程序覆盖。下一次用户调用 runc 去执行命令时，实际执行的将是攻击者放置的指令。

复现
--

### 环境

#### 主机

![](https://mmbiz.qpic.cn/mmbiz_png/uxzyPCzbE3aFFBt2iaGFxuCXefYUYgURUt2LzG2RNuibqXNVZqTfDjkNkUuekZL8JyaFgEkJQQRs7c7r1fasNhicw/640?wx_fmt=png)

#### 容器

![](https://mmbiz.qpic.cn/mmbiz_png/uxzyPCzbE3aFFBt2iaGFxuCXefYUYgURUK8GYvfWibcu1lxsn7YAJZA0ZQFJg6djDMX2kLGvsgw7UKUZbgiasd7ibw/640?wx_fmt=png)

#### EXP

https://github.com/Frichetten/CVE-2019-5736-PoC  
略过 下载、修改 payload、编译过程  
payload：反弹 shell 目标 192.168.0.1 65534

1. 接收机器监听 65534  
![](https://mmbiz.qpic.cn/mmbiz_png/uxzyPCzbE3aFFBt2iaGFxuCXefYUYgURUWDUooiaEKspf5CDE3ibcGTq4zQEic1O47GIMfqNjh1GicKFUsXOEsYRBqg/640?wx_fmt=png)  
2. 容器内运行 exp  
![](https://mmbiz.qpic.cn/mmbiz_png/uxzyPCzbE3aFFBt2iaGFxuCXefYUYgURUNhUvYQaLd0eqkribvTP1ia0ib8HSXp6HaIogx8RsCJHGSzhhPvFjlrwGQ/640?wx_fmt=png)  
3. 模拟主机在此容器中执行命令  
![](https://mmbiz.qpic.cn/mmbiz_png/uxzyPCzbE3aFFBt2iaGFxuCXefYUYgURUW6sgQxhiaVXx12V5eibFQMwhp83Zk8pxjV7zyT07wzJRAb29PItQMo7g/640?wx_fmt=png)  
4. 此时接收机器收到反弹的 shell  
![](https://mmbiz.qpic.cn/mmbiz_png/uxzyPCzbE3aFFBt2iaGFxuCXefYUYgURUacmsMnPibVbE8LHl8czGfLgjtqHUsKPOAnXBzdwlV14MI1HfdoeBpoA/640?wx_fmt=png)

分析
--

### 利用后果

runC 二进制文件被修改  
![](https://mmbiz.qpic.cn/mmbiz_png/uxzyPCzbE3aFFBt2iaGFxuCXefYUYgURUe7VGqLuTnXX1WCScq73ecFDWuFk4M6SoJEmhT4MkLtQkNxhRZBicib7Q/640?wx_fmt=png)  
在恢复之前 每次调用 runc 均会执行 Payload

### 另一种获取 runC 文件描述符 的方式

#### execve()

execve() 是一个内核系统调用函数，execve() 和 fork()，clone() 不同，它不需要启动新的进程，它直接替换当前执行的文件为新的文件，为新的可执行文件分配新初始化的堆栈和数据段。替换可执行文件，意味着释放调用 execve() 文件的 IO, 但这个过程默认是不释放 / proc/pid/fd 中的打开的文件描述符。

#### 利用

在容器中监控（如 libseccomp ) 新启动的进程 获取 / proc/self/exe 并设法（如 __attribute__ ((constructor)) ）使其调用 execve() 传递 / proc/self/fd 中打开的文件描述符

下期预告
----

《CVE-2020-8554 Kubernetes 中间人攻击漏洞复现与解析》

![](https://mmbiz.qpic.cn/mmbiz_png/uxzyPCzbE3bW732RU7NAiaZc4JT6DxmZyUNeZGuxDkFCEEStghYzbBh4Va87vPYuw6llsvJzAmVg3I2f9icYTcKA/640?wx_fmt=png)