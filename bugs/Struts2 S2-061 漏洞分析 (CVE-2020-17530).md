> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/RD2HTMn-jFxDIs4-X95u6g)

Smi1e@卫兵实验室

漏洞描述
----

Struts2 会对某些标签属性 (比如 `id`，其他属性有待寻找) 的属性值进行二次表达式解析，因此当这些标签属性中使用了 `%{x}` 且 `x` 的值用户可控时，用户再传入一个 `%{payload}` 即可造成 OGNL 表达式执行。S2-061 是对 S2-059 沙盒进行的绕过。

影响范围
----

Struts 2.0.0 - Struts 2.5.25

漏洞分析
----

S2-061 和 S2-059 的 OGNL 表达执行触发方式一样，详情可见公众号之前的文章：[Struts2 S2-059 漏洞分析](https://mp.weixin.qq.com/s?__biz=MzUyMDEyNTkwNA==&mid=2247484472&idx=1&sn=35c122ea5f7dbbcc302f0a88cea70ac6&scene=21#wechat_redirect)。S2-059 的修复方式为只修复了沙盒绕过并没有修复 OGNL 表达式执行点，因为这个表达式执行触发条件过于苛刻，而 S2-061 再次绕过了 S2-059 的沙盒。

diff 一下沙盒，可以看到把很多中间件的包添加到了黑名单中。

![](https://mmbiz.qpic.cn/mmbiz_png/AvAjnOiazvndajx8rSkr2fqfQOR7TMkmN6Vbc9HWYpKh0Ic8flL3o7p3d7pDpeHiaiaYW0fYoVia8Rl3ibu0ricYIvrQ/640?wx_fmt=png)

已知的 OGNL 沙盒限制为:

*   无法 new 一个对象
    
*   无法调用黑名单类和包的方法、属性
    
*   无法使用反射
    
*   无法调用静态方法
    

另外，最新的 struts2 在 `ognl.OgnlRuntime#invokeMethod` 中 ban 掉了常用的 class，意味着即使绕过了沙盒依然不能直接调用这些类。

```
public static Object invokeMethod(Object target, Method method, Object[] argsArray) throws InvocationTargetException, IllegalAccessException {
        if (_useStricterInvocation) {
            Class methodDeclaringClass = method.getDeclaringClass();
            if (AO_SETACCESSIBLE_REF != null && AO_SETACCESSIBLE_REF.equals(method) || AO_SETACCESSIBLE_ARR_REF != null && AO_SETACCESSIBLE_ARR_REF.equals(method) || SYS_EXIT_REF != null && SYS_EXIT_REF.equals(method) || SYS_CONSOLE_REF != null && SYS_CONSOLE_REF.equals(method) || AccessibleObjectHandler.class.isAssignableFrom(methodDeclaringClass) || ClassResolver.class.isAssignableFrom(methodDeclaringClass) || MethodAccessor.class.isAssignableFrom(methodDeclaringClass) || MemberAccess.class.isAssignableFrom(methodDeclaringClass) || OgnlContext.class.isAssignableFrom(methodDeclaringClass) || Runtime.class.isAssignableFrom(methodDeclaringClass) || ClassLoader.class.isAssignableFrom(methodDeclaringClass) || ProcessBuilder.class.isAssignableFrom(methodDeclaringClass) || AccessibleObjectHandlerJDK9Plus.unsafeOrDescendant(methodDeclaringClass)) {
                throw new IllegalAccessException("Method [" + method + "] cannot be called from within OGNL invokeMethod() " + "under stricter invocation mode.");
            }
        }
```

再看一下 OGNL 沙盒未限制的操作为:

*   对象属性 `setter/getter(public)` 赋 / 取值，可以访问静态属性。
    
*   已实例类的方法调用 ( `OgnlContext` 中的对象)，不允许调用静态方法
    

可以看到目前我们只能在 `OgnlContext` 中寻找可利用的对象。

![](https://mmbiz.qpic.cn/mmbiz_png/AvAjnOiazvndajx8rSkr2fqfQOR7TMkmNNTkqE19PdXp52zUiaZFvK4aWIvf73picx8RlBX5iay5GGGIdho77r3yTA/640?wx_fmt=png)

看一下 `#application` 中的 `org.apache.tomcat.InstanceManager` ，他的键值为类 `org.apache.catalina.core.DefaultInstanceManager` 的实例化对象，该类为 tomcat 中的类，其他中间件还未分析，有兴趣可以自己找找看。

![](https://mmbiz.qpic.cn/mmbiz_png/AvAjnOiazvndajx8rSkr2fqfQOR7TMkmNnWmDCVbtIwpQ4ViayYTBwfJduAItZhqeP0ylHc9MRuWibeZYGMNsQjmg/640?wx_fmt=png)

他有一个 `newInstance` 方法，`className` 我们可控，最终可以实例化任意无参构造方法的类并返回。

![](https://mmbiz.qpic.cn/mmbiz_png/AvAjnOiazvndajx8rSkr2fqfQOR7TMkmNR24t7Il5hBCibfI5ibNic3tVqjRb6qzibbjKCpQAF7diaN1fgWzaFbh8pOg/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/AvAjnOiazvndajx8rSkr2fqfQOR7TMkmNlGicDzo0ZMic5IOKWpNjHRHBFSZSlyIoyRMZDiautWdyq6zVib0TECjx8Q/640?wx_fmt=png)

也就是说我们现在绕过了无法 new 一个对象的限制，不过这个对象必须存在 `public` 的无参构造方法。

ognl3.1.15 中， `OgnlContext` 又删掉了 `CONTEXT_CONTEEXT_KEY` 也就是 `context` 这个 key，禁止使用 `#context` 对 `OgnlContext` 进行访问。

![](https://mmbiz.qpic.cn/mmbiz_png/AvAjnOiazvndajx8rSkr2fqfQOR7TMkmNhK0Tc8ia8NgWSgeOfxmmBSTVGficsgGTT60sbxb83nOeibB69vdnoezvQ/640?wx_fmt=png)

而 S2-057 通过 `#attr` 、`#request` 等 map 对象中的 `struts.valueStack` 间接获取到了 `OgnlContext` ，但是补丁把包 `com.opensymphony.xwork2.ognl.` 加入到了黑名单中，不能调用 `OgnlValueStack` 的 `getContext` 方法了，因此这种方法也行不通了。

不过我们可以利用前文的实例化任意无参构造方法条件调用一些方法，间接的帮我们获取到 `OgnlContext` 。

看一下 `org.apache.commons.collections.BeanMap`

![](https://mmbiz.qpic.cn/mmbiz_png/AvAjnOiazvndajx8rSkr2fqfQOR7TMkmNfibkYD6nQoSOFnCIwPx58lYYTobwd2x7WPpA3t28Seiazm9GE7xeFI0w/640?wx_fmt=png)

跟进 `this.initialise()`，他会把我传入对象对应 class 当做 bean，提取 `get` 和 `set` 方法以及 `name` 赋值进 `readMethods` 和 `writeMethods` 。

![](https://mmbiz.qpic.cn/mmbiz_png/AvAjnOiazvndajx8rSkr2fqfQOR7TMkmNMp2jomhicZnBnb9GeGVZYeXIUTFyTA72nd2WszibEU8iaWUYUZbpWLR8w/640?wx_fmt=png)

看一下其 `get` 方法，根据我们传入的 `name` 调用 `readMethods` 中对应的 `getXxx` 方法

![](https://mmbiz.qpic.cn/mmbiz_png/AvAjnOiazvndajx8rSkr2fqfQOR7TMkmN1lLHDwlUBlD0cLL3T310YmDUbUEoIvNBqxWQicwIeg8mye6olB6OhOA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/AvAjnOiazvndajx8rSkr2fqfQOR7TMkmNbBu6eJkP3rR6exHqZp5fyrnUODaLZQG9IsqZNuWpFHG03j27cf7M4w/640?wx_fmt=png)

而 `com.opensymphony.xwork2.ognl.OgnlValueStack` 中存在 `getContext` 方法，因此我们可以拿到 `OgnlValueStack` 后，利用 `BeanMap` 间接获取到 `OgnlContext`。

![](https://mmbiz.qpic.cn/mmbiz_png/AvAjnOiazvndajx8rSkr2fqfQOR7TMkmNicJfEKwIQmd8XDd64SeAtjAicmxn63icmvDkILNKDfvwgmglZO0rj0LPw/640?wx_fmt=png)

同理我们可以获取到 `com.opensymphony.xwork2.ognl.SecurityMemberAccess` 对象

![](https://mmbiz.qpic.cn/mmbiz_png/AvAjnOiazvndajx8rSkr2fqfQOR7TMkmNvu8hBh0nVeTickdVC2kwqgq4S3oIRtbFYMtdELsiavo9diat8chIJkVHg/640?wx_fmt=png)

并利用 `put` 方法调用 `setExcludedClasses` 和 `setExcludedPackageNames` 覆盖掉黑名单。  

![](https://mmbiz.qpic.cn/mmbiz_png/AvAjnOiazvndajx8rSkr2fqfQOR7TMkmN0icR5fNibVp4AIrpEeibdrMibiayal8719SDpRLU3R02R2WuGibLs8tWQn9w/640?wx_fmt=png)

前面提到了最新的 struts2 即使绕过了沙盒依然不能直接调用常用的类来进行利用，但是我们清空了黑名单之后可以实例化任意黑名单中的类。

看下黑明单包中的类 `freemarker.template.utility.Execute`，存在无参构造方法 `Execute()` ，`exec` 方法可以直接执行命令。

![](https://mmbiz.qpic.cn/mmbiz_png/AvAjnOiazvndajx8rSkr2fqfQOR7TMkmNt2c5yIeW7icWIoKibz0zN2Go63VA3b4LtrGWk7LpD7zlYOSaYY0poLsw/640?wx_fmt=png)

漏洞证明
----

![](https://mmbiz.qpic.cn/mmbiz_png/AvAjnOiazvndajx8rSkr2fqfQOR7TMkmN3RYic651369LchAGpdZD5xp0cq7bic6RfEMicBk1Wekmsib3GboqHvfXbQ/640?wx_fmt=png)

**关于我们**

![](https://mmbiz.qpic.cn/mmbiz_png/AvAjnOiazvnf9lw493LJmpm51oUkLoMsXCmAU2UzEIY8pYWKVulWQPmTOMC1swUBCIFpLSDKHkn9VgXcWEZ99pg/640?wx_fmt=png)  

**人才招聘**

**二进制安全研究员 (Windows 内核方向)**

**工作地点：**

1. 杭州；

**岗位职责：**  

1、负责研究 Window 内核相关漏洞利用技术；

2、负责分析 Window 内核漏洞的原理及缓解措施；

  
**任职要求：**  

1、2 年以上 windows 逆向工作经验。

2、熟悉 windows 底层架构、运行机制，熟悉汇编语言 C/C++ 语言，熟悉 win32/64 开发，并有相关开发经验；

3、熟悉 windows 驱动开发、熟悉 windows 平台内核架构；能熟练运用 Windows 平台下的软件调试方法。

4、熟练使用 ida、windbg 等调试软件工具调试分析漏洞。

5、有 CVE 编号、内核研究成果者优先；

6、具备良好的团队沟通、协作能力、良好的职业道德。

**二进制安全研究员 (Linux 内核方向)**

**工作地点：**

1. 杭州；

**岗位职责：**  

1、负责研究 Linux 内核相关漏洞利用技术；

2、负责分析 Linux 内核漏洞的原理及缓解措施；

  
**任职要求：**  

1、2 年以上 Linux 逆向工作经验。

2、熟悉 Linux 底层架构、运行机制，熟悉汇编语言 C/C++ 语言，熟悉 x86/64 开发，并有相关开发经验；

3、熟悉 Linux 驱动开发、熟悉 Linux 平台内核架构；能熟练运用 Linux 平台下的软件调试方法。

4、熟练使用 ida、gdb、lldb 等调试软件工具调试分析漏洞。

5、有 CVE 编号、内核研究成果者优先；

6、具备良好的团队沟通、协作能力、良好的职业道德。

**二进制安全研究员 (系统应用方向)**

**工作地点：**

1. 杭州；

**岗位职责：**  

1、负责安全技术研究，跟踪国内外最新的安全技术以及安全漏洞的追踪；

2、负责进行二进制漏洞挖掘，包括不限于浏览器、chakara 引擎、js 引擎、office、pdf 等等各种二进制类应用；

  
**任职要求：**  

1、能主动关注国内外最新安全攻防技术，并在自己擅长和兴趣的领域能够进行深入的学习、研究；

2、熟练掌握 windbg、ida、gdb 等调试工具；

3、熟悉各类二进制安全漏洞原理（堆溢出、栈溢出、整数溢出、类型混淆等等）以及各种利用技术；

4、能够无障碍阅读英文技术文档；

5、具备良好的团队沟通、协作能力、良好的职业道德。

**Web 安全研究员**

**工作地点：**  

1. 杭州；

**岗位职责：**  

1、安全攻防技术研究，最新 web 应用及中间件 (tomcat、jetty、jboss 等等)、框架 (struts、spring、guice、shiro 等等) 组件 (freemarker、sitemesh 等等) 漏洞挖掘研究；

2、跟踪分析国内外的安全动态，对重大安全事件进行快速响应；

  
**任职要求：**  

1、了解常见的网络协议 (TCP/IP,HTTP,FTP 等)；

2、熟练使用 Wireshark 等抓包工具，熟悉正则表达式；

3、掌握常见漏洞原理，有一定的漏洞分析能力；

4、具备 php、python、java 或其他相关语言编码能力；

5、对常见 waf 绕过有一定的基础经验；

6、具备一定的文档编写能力，具备良好的团队共同能力；

7、对安全有浓厚的兴趣，工作细致耐心。

**感兴趣的小伙伴请联系 Nike，或将简历投送至下方邮箱。（请注明来源 “研究院公众号”，并附带求职岗位名称）**

**联系人：Nike  
邮箱：nike.zheng@dbappsecurity.com.cn**